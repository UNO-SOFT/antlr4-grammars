// Generated from Python2.g4 by ANTLR 4.7.

package python2 // Python2
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa


var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 88, 1022, 
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7, 
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13, 
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9, 
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23, 
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4, 
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34, 
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9, 
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44, 
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4, 
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55, 
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9, 
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65, 
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4, 
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76, 
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9, 
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86, 
	3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 5, 2, 178, 10, 2, 3, 3, 3, 3, 7, 3, 182, 
	10, 3, 12, 3, 14, 3, 185, 11, 3, 3, 3, 3, 3, 3, 4, 3, 4, 7, 4, 191, 10, 
	4, 12, 4, 14, 4, 194, 11, 4, 3, 4, 3, 4, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 
	202, 10, 5, 3, 5, 5, 5, 205, 10, 5, 3, 5, 3, 5, 3, 6, 6, 6, 210, 10, 6, 
	13, 6, 14, 6, 211, 3, 7, 3, 7, 3, 7, 5, 7, 217, 10, 7, 3, 8, 3, 8, 3, 8, 
	3, 8, 3, 8, 3, 8, 3, 9, 3, 9, 5, 9, 227, 10, 9, 3, 9, 3, 9, 3, 10, 3, 10, 
	3, 10, 5, 10, 234, 10, 10, 3, 10, 3, 10, 7, 10, 238, 10, 10, 12, 10, 14, 
	10, 241, 11, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 248, 10, 10, 
	3, 10, 3, 10, 5, 10, 252, 10, 10, 3, 10, 3, 10, 3, 10, 5, 10, 257, 10, 
	10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 263, 10, 10, 7, 10, 265, 10, 10, 
	12, 10, 14, 10, 268, 11, 10, 3, 10, 5, 10, 271, 10, 10, 5, 10, 273, 10, 
	10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 5, 11, 280, 10, 11, 3, 12, 3, 12, 
	3, 12, 7, 12, 285, 10, 12, 12, 12, 14, 12, 288, 11, 12, 3, 12, 5, 12, 291, 
	10, 12, 3, 13, 3, 13, 5, 13, 295, 10, 13, 3, 14, 3, 14, 3, 14, 7, 14, 300, 
	10, 14, 12, 14, 14, 14, 303, 11, 14, 3, 14, 5, 14, 306, 10, 14, 3, 14, 
	3, 14, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 5, 
	15, 319, 10, 15, 3, 16, 3, 16, 3, 16, 3, 16, 5, 16, 325, 10, 16, 3, 16, 
	3, 16, 3, 16, 5, 16, 330, 10, 16, 7, 16, 332, 10, 16, 12, 16, 14, 16, 335, 
	11, 16, 5, 16, 337, 10, 16, 3, 17, 3, 17, 3, 18, 3, 18, 3, 18, 3, 18, 3, 
	18, 7, 18, 346, 10, 18, 12, 18, 14, 18, 349, 11, 18, 3, 18, 5, 18, 352, 
	10, 18, 5, 18, 354, 10, 18, 3, 18, 3, 18, 3, 18, 3, 18, 6, 18, 360, 10, 
	18, 13, 18, 14, 18, 361, 3, 18, 5, 18, 365, 10, 18, 5, 18, 367, 10, 18, 
	5, 18, 369, 10, 18, 3, 19, 3, 19, 3, 19, 3, 20, 3, 20, 3, 21, 3, 21, 3, 
	21, 3, 21, 3, 21, 5, 21, 381, 10, 21, 3, 22, 3, 22, 3, 23, 3, 23, 3, 24, 
	3, 24, 5, 24, 389, 10, 24, 3, 25, 3, 25, 3, 26, 3, 26, 3, 26, 3, 26, 3, 
	26, 3, 26, 5, 26, 399, 10, 26, 5, 26, 401, 10, 26, 5, 26, 403, 10, 26, 
	3, 27, 3, 27, 5, 27, 407, 10, 27, 3, 28, 3, 28, 3, 28, 3, 29, 3, 29, 7, 
	29, 414, 10, 29, 12, 29, 14, 29, 417, 11, 29, 3, 29, 3, 29, 6, 29, 421, 
	10, 29, 13, 29, 14, 29, 422, 5, 29, 425, 10, 29, 3, 29, 3, 29, 3, 29, 3, 
	29, 3, 29, 3, 29, 3, 29, 5, 29, 434, 10, 29, 3, 30, 3, 30, 3, 30, 5, 30, 
	439, 10, 30, 3, 31, 3, 31, 3, 31, 5, 31, 444, 10, 31, 3, 32, 3, 32, 3, 
	32, 7, 32, 449, 10, 32, 12, 32, 14, 32, 452, 11, 32, 3, 32, 5, 32, 455, 
	10, 32, 3, 33, 3, 33, 3, 33, 7, 33, 460, 10, 33, 12, 33, 14, 33, 463, 11, 
	33, 3, 34, 3, 34, 3, 34, 7, 34, 468, 10, 34, 12, 34, 14, 34, 471, 11, 34, 
	3, 35, 3, 35, 3, 35, 3, 35, 7, 35, 477, 10, 35, 12, 35, 14, 35, 480, 11, 
	35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 5, 36, 488, 10, 36, 5, 36, 
	490, 10, 36, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 496, 10, 37, 3, 38, 3, 
	38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 5, 38, 506, 10, 38, 3, 39, 
	3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 7, 39, 517, 10, 
	39, 12, 39, 14, 39, 520, 11, 39, 3, 39, 3, 39, 3, 39, 5, 39, 525, 10, 39, 
	3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40, 534, 10, 40, 3, 
	41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 545, 
	10, 41, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 6, 42, 554, 10, 
	42, 13, 42, 14, 42, 555, 3, 42, 3, 42, 3, 42, 5, 42, 561, 10, 42, 3, 42, 
	3, 42, 3, 42, 5, 42, 566, 10, 42, 3, 42, 3, 42, 3, 42, 5, 42, 571, 10, 
	42, 3, 43, 3, 43, 3, 43, 3, 43, 7, 43, 577, 10, 43, 12, 43, 14, 43, 580, 
	11, 43, 3, 43, 3, 43, 3, 43, 3, 44, 3, 44, 3, 44, 5, 44, 588, 10, 44, 3, 
	45, 3, 45, 3, 45, 3, 45, 5, 45, 594, 10, 45, 5, 45, 596, 10, 45, 3, 46, 
	3, 46, 3, 46, 3, 46, 6, 46, 602, 10, 46, 13, 46, 14, 46, 603, 3, 46, 3, 
	46, 5, 46, 608, 10, 46, 3, 47, 3, 47, 3, 47, 6, 47, 613, 10, 47, 13, 47, 
	14, 47, 614, 3, 47, 5, 47, 618, 10, 47, 5, 47, 620, 10, 47, 3, 48, 3, 48, 
	5, 48, 624, 10, 48, 3, 49, 3, 49, 5, 49, 628, 10, 49, 3, 49, 3, 49, 3, 
	49, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 5, 50, 639, 10, 50, 3, 50, 
	5, 50, 642, 10, 50, 3, 51, 3, 51, 3, 51, 7, 51, 647, 10, 51, 12, 51, 14, 
	51, 650, 11, 51, 3, 52, 3, 52, 3, 52, 7, 52, 655, 10, 52, 12, 52, 14, 52, 
	658, 11, 52, 3, 53, 3, 53, 3, 53, 5, 53, 663, 10, 53, 3, 54, 3, 54, 3, 
	54, 3, 54, 7, 54, 669, 10, 54, 12, 54, 14, 54, 672, 11, 54, 3, 55, 3, 55, 
	3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 
	55, 5, 55, 687, 10, 55, 3, 56, 3, 56, 3, 56, 7, 56, 692, 10, 56, 12, 56, 
	14, 56, 695, 11, 56, 3, 57, 3, 57, 3, 57, 7, 57, 700, 10, 57, 12, 57, 14, 
	57, 703, 11, 57, 3, 58, 3, 58, 3, 58, 7, 58, 708, 10, 58, 12, 58, 14, 58, 
	711, 11, 58, 3, 59, 3, 59, 3, 59, 7, 59, 716, 10, 59, 12, 59, 14, 59, 719, 
	11, 59, 3, 60, 3, 60, 3, 60, 7, 60, 724, 10, 60, 12, 60, 14, 60, 727, 11, 
	60, 3, 61, 3, 61, 3, 61, 7, 61, 732, 10, 61, 12, 61, 14, 61, 735, 11, 61, 
	3, 62, 3, 62, 3, 62, 5, 62, 740, 10, 62, 3, 63, 3, 63, 7, 63, 744, 10, 
	63, 12, 63, 14, 63, 747, 11, 63, 3, 63, 3, 63, 5, 63, 751, 10, 63, 3, 64, 
	3, 64, 3, 64, 5, 64, 756, 10, 64, 3, 64, 3, 64, 3, 64, 5, 64, 761, 10, 
	64, 3, 64, 3, 64, 3, 64, 5, 64, 766, 10, 64, 3, 64, 3, 64, 3, 64, 3, 64, 
	3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 6, 64, 779, 10, 64, 13, 
	64, 14, 64, 780, 5, 64, 783, 10, 64, 3, 65, 3, 65, 3, 65, 3, 65, 7, 65, 
	789, 10, 65, 12, 65, 14, 65, 792, 11, 65, 3, 65, 5, 65, 795, 10, 65, 5, 
	65, 797, 10, 65, 3, 66, 3, 66, 3, 66, 3, 66, 7, 66, 803, 10, 66, 12, 66, 
	14, 66, 806, 11, 66, 3, 66, 5, 66, 809, 10, 66, 5, 66, 811, 10, 66, 3, 
	67, 3, 67, 5, 67, 815, 10, 67, 3, 67, 3, 67, 3, 67, 3, 68, 3, 68, 5, 68, 
	822, 10, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 5, 68, 831, 
	10, 68, 3, 69, 3, 69, 3, 69, 7, 69, 836, 10, 69, 12, 69, 14, 69, 839, 11, 
	69, 3, 69, 5, 69, 842, 10, 69, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 5, 70, 
	849, 10, 70, 3, 70, 3, 70, 5, 70, 853, 10, 70, 3, 70, 5, 70, 856, 10, 70, 
	5, 70, 858, 10, 70, 3, 71, 3, 71, 5, 71, 862, 10, 71, 3, 72, 3, 72, 3, 
	72, 7, 72, 867, 10, 72, 12, 72, 14, 72, 870, 11, 72, 3, 72, 5, 72, 873, 
	10, 72, 3, 73, 3, 73, 3, 73, 7, 73, 878, 10, 73, 12, 73, 14, 73, 881, 11, 
	73, 3, 73, 5, 73, 884, 10, 73, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 
	3, 74, 3, 74, 3, 74, 7, 74, 895, 10, 74, 12, 74, 14, 74, 898, 11, 74, 3, 
	74, 5, 74, 901, 10, 74, 5, 74, 903, 10, 74, 3, 74, 3, 74, 3, 74, 3, 74, 
	7, 74, 909, 10, 74, 12, 74, 14, 74, 912, 11, 74, 3, 74, 5, 74, 915, 10, 
	74, 5, 74, 917, 10, 74, 5, 74, 919, 10, 74, 3, 75, 3, 75, 3, 75, 3, 75, 
	5, 75, 925, 10, 75, 3, 75, 5, 75, 928, 10, 75, 3, 75, 3, 75, 3, 75, 3, 
	76, 3, 76, 3, 76, 7, 76, 936, 10, 76, 12, 76, 14, 76, 939, 11, 76, 3, 76, 
	3, 76, 5, 76, 943, 10, 76, 3, 76, 3, 76, 3, 76, 3, 76, 7, 76, 949, 10, 
	76, 12, 76, 14, 76, 952, 11, 76, 3, 76, 3, 76, 3, 76, 5, 76, 957, 10, 76, 
	3, 76, 3, 76, 5, 76, 961, 10, 76, 3, 77, 3, 77, 5, 77, 965, 10, 77, 3, 
	77, 3, 77, 3, 77, 3, 77, 5, 77, 971, 10, 77, 3, 78, 3, 78, 5, 78, 975, 
	10, 78, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 5, 79, 982, 10, 79, 3, 80, 3, 
	80, 3, 80, 5, 80, 987, 10, 80, 3, 81, 3, 81, 5, 81, 991, 10, 81, 3, 82, 
	3, 82, 3, 82, 3, 82, 3, 82, 5, 82, 998, 10, 82, 3, 83, 3, 83, 3, 83, 5, 
	83, 1003, 10, 83, 3, 84, 3, 84, 3, 84, 7, 84, 1008, 10, 84, 12, 84, 14, 
	84, 1011, 11, 84, 3, 85, 3, 85, 3, 86, 3, 86, 5, 86, 1017, 10, 86, 3, 86, 
	5, 86, 1020, 10, 86, 3, 86, 2, 2, 87, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 
	22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 
	58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 
	94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 
	124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 
	154, 156, 158, 160, 162, 164, 166, 168, 170, 2, 8, 3, 2, 11, 22, 4, 2, 
	7, 7, 33, 33, 4, 2, 23, 23, 62, 62, 3, 2, 63, 64, 4, 2, 8, 8, 65, 67, 4, 
	2, 63, 64, 68, 68, 2, 1115, 2, 177, 3, 2, 2, 2, 4, 183, 3, 2, 2, 2, 6, 
	188, 3, 2, 2, 2, 8, 197, 3, 2, 2, 2, 10, 209, 3, 2, 2, 2, 12, 213, 3, 2, 
	2, 2, 14, 218, 3, 2, 2, 2, 16, 224, 3, 2, 2, 2, 18, 272, 3, 2, 2, 2, 20, 
	279, 3, 2, 2, 2, 22, 281, 3, 2, 2, 2, 24, 294, 3, 2, 2, 2, 26, 296, 3, 
	2, 2, 2, 28, 318, 3, 2, 2, 2, 30, 320, 3, 2, 2, 2, 32, 338, 3, 2, 2, 2, 
	34, 340, 3, 2, 2, 2, 36, 370, 3, 2, 2, 2, 38, 373, 3, 2, 2, 2, 40, 380, 
	3, 2, 2, 2, 42, 382, 3, 2, 2, 2, 44, 384, 3, 2, 2, 2, 46, 386, 3, 2, 2, 
	2, 48, 390, 3, 2, 2, 2, 50, 392, 3, 2, 2, 2, 52, 406, 3, 2, 2, 2, 54, 408, 
	3, 2, 2, 2, 56, 411, 3, 2, 2, 2, 58, 435, 3, 2, 2, 2, 60, 440, 3, 2, 2, 
	2, 62, 445, 3, 2, 2, 2, 64, 456, 3, 2, 2, 2, 66, 464, 3, 2, 2, 2, 68, 472, 
	3, 2, 2, 2, 70, 481, 3, 2, 2, 2, 72, 491, 3, 2, 2, 2, 74, 505, 3, 2, 2, 
	2, 76, 507, 3, 2, 2, 2, 78, 526, 3, 2, 2, 2, 80, 535, 3, 2, 2, 2, 82, 546, 
	3, 2, 2, 2, 84, 572, 3, 2, 2, 2, 86, 584, 3, 2, 2, 2, 88, 589, 3, 2, 2, 
	2, 90, 607, 3, 2, 2, 2, 92, 609, 3, 2, 2, 2, 94, 623, 3, 2, 2, 2, 96, 625, 
	3, 2, 2, 2, 98, 641, 3, 2, 2, 2, 100, 643, 3, 2, 2, 2, 102, 651, 3, 2, 
	2, 2, 104, 662, 3, 2, 2, 2, 106, 664, 3, 2, 2, 2, 108, 686, 3, 2, 2, 2, 
	110, 688, 3, 2, 2, 2, 112, 696, 3, 2, 2, 2, 114, 704, 3, 2, 2, 2, 116, 
	712, 3, 2, 2, 2, 118, 720, 3, 2, 2, 2, 120, 728, 3, 2, 2, 2, 122, 739, 
	3, 2, 2, 2, 124, 741, 3, 2, 2, 2, 126, 782, 3, 2, 2, 2, 128, 784, 3, 2, 
	2, 2, 130, 798, 3, 2, 2, 2, 132, 812, 3, 2, 2, 2, 134, 830, 3, 2, 2, 2, 
	136, 832, 3, 2, 2, 2, 138, 857, 3, 2, 2, 2, 140, 859, 3, 2, 2, 2, 142, 
	863, 3, 2, 2, 2, 144, 874, 3, 2, 2, 2, 146, 918, 3, 2, 2, 2, 148, 920, 
	3, 2, 2, 2, 150, 937, 3, 2, 2, 2, 152, 970, 3, 2, 2, 2, 154, 974, 3, 2, 
	2, 2, 156, 976, 3, 2, 2, 2, 158, 983, 3, 2, 2, 2, 160, 990, 3, 2, 2, 2, 
	162, 992, 3, 2, 2, 2, 164, 999, 3, 2, 2, 2, 166, 1004, 3, 2, 2, 2, 168, 
	1012, 3, 2, 2, 2, 170, 1014, 3, 2, 2, 2, 172, 178, 7, 87, 2, 2, 173, 178, 
	5, 26, 14, 2, 174, 175, 5, 74, 38, 2, 175, 176, 7, 87, 2, 2, 176, 178, 
	3, 2, 2, 2, 177, 172, 3, 2, 2, 2, 177, 173, 3, 2, 2, 2, 177, 174, 3, 2, 
	2, 2, 178, 3, 3, 2, 2, 2, 179, 182, 7, 87, 2, 2, 180, 182, 5, 24, 13, 2, 
	181, 179, 3, 2, 2, 2, 181, 180, 3, 2, 2, 2, 182, 185, 3, 2, 2, 2, 183, 
	181, 3, 2, 2, 2, 183, 184, 3, 2, 2, 2, 184, 186, 3, 2, 2, 2, 185, 183, 
	3, 2, 2, 2, 186, 187, 7, 88, 2, 2, 187, 5, 3, 2, 2, 2, 188, 192, 5, 144, 
	73, 2, 189, 191, 7, 87, 2, 2, 190, 189, 3, 2, 2, 2, 191, 194, 3, 2, 2, 
	2, 192, 190, 3, 2, 2, 2, 192, 193, 3, 2, 2, 2, 193, 195, 3, 2, 2, 2, 194, 
	192, 3, 2, 2, 2, 195, 196, 7, 88, 2, 2, 196, 7, 3, 2, 2, 2, 197, 198, 7, 
	3, 2, 2, 198, 204, 5, 66, 34, 2, 199, 201, 7, 78, 2, 2, 200, 202, 5, 150, 
	76, 2, 201, 200, 3, 2, 2, 2, 201, 202, 3, 2, 2, 2, 202, 203, 3, 2, 2, 2, 
	203, 205, 7, 79, 2, 2, 204, 199, 3, 2, 2, 2, 204, 205, 3, 2, 2, 2, 205, 
	206, 3, 2, 2, 2, 206, 207, 7, 87, 2, 2, 207, 9, 3, 2, 2, 2, 208, 210, 5, 
	8, 5, 2, 209, 208, 3, 2, 2, 2, 210, 211, 3, 2, 2, 2, 211, 209, 3, 2, 2, 
	2, 211, 212, 3, 2, 2, 2, 212, 11, 3, 2, 2, 2, 213, 216, 5, 10, 6, 2, 214, 
	217, 5, 148, 75, 2, 215, 217, 5, 14, 8, 2, 216, 214, 3, 2, 2, 2, 216, 215, 
	3, 2, 2, 2, 217, 13, 3, 2, 2, 2, 218, 219, 7, 4, 2, 2, 219, 220, 7, 72, 
	2, 2, 220, 221, 5, 16, 9, 2, 221, 222, 7, 5, 2, 2, 222, 223, 5, 90, 46, 
	2, 223, 15, 3, 2, 2, 2, 224, 226, 7, 78, 2, 2, 225, 227, 5, 18, 10, 2, 
	226, 225, 3, 2, 2, 2, 226, 227, 3, 2, 2, 2, 227, 228, 3, 2, 2, 2, 228, 
	229, 7, 79, 2, 2, 229, 17, 3, 2, 2, 2, 230, 233, 5, 20, 11, 2, 231, 232, 
	7, 6, 2, 2, 232, 234, 5, 98, 50, 2, 233, 231, 3, 2, 2, 2, 233, 234, 3, 
	2, 2, 2, 234, 235, 3, 2, 2, 2, 235, 236, 7, 7, 2, 2, 236, 238, 3, 2, 2, 
	2, 237, 230, 3, 2, 2, 2, 238, 241, 3, 2, 2, 2, 239, 237, 3, 2, 2, 2, 239, 
	240, 3, 2, 2, 2, 240, 251, 3, 2, 2, 2, 241, 239, 3, 2, 2, 2, 242, 243, 
	7, 8, 2, 2, 243, 247, 7, 72, 2, 2, 244, 245, 7, 7, 2, 2, 245, 246, 7, 9, 
	2, 2, 246, 248, 7, 72, 2, 2, 247, 244, 3, 2, 2, 2, 247, 248, 3, 2, 2, 2, 
	248, 252, 3, 2, 2, 2, 249, 250, 7, 9, 2, 2, 250, 252, 7, 72, 2, 2, 251, 
	242, 3, 2, 2, 2, 251, 249, 3, 2, 2, 2, 252, 273, 3, 2, 2, 2, 253, 256, 
	5, 20, 11, 2, 254, 255, 7, 6, 2, 2, 255, 257, 5, 98, 50, 2, 256, 254, 3, 
	2, 2, 2, 256, 257, 3, 2, 2, 2, 257, 266, 3, 2, 2, 2, 258, 259, 7, 7, 2, 
	2, 259, 262, 5, 20, 11, 2, 260, 261, 7, 6, 2, 2, 261, 263, 5, 98, 50, 2, 
	262, 260, 3, 2, 2, 2, 262, 263, 3, 2, 2, 2, 263, 265, 3, 2, 2, 2, 264, 
	258, 3, 2, 2, 2, 265, 268, 3, 2, 2, 2, 266, 264, 3, 2, 2, 2, 266, 267, 
	3, 2, 2, 2, 267, 270, 3, 2, 2, 2, 268, 266, 3, 2, 2, 2, 269, 271, 7, 7, 
	2, 2, 270, 269, 3, 2, 2, 2, 270, 271, 3, 2, 2, 2, 271, 273, 3, 2, 2, 2, 
	272, 239, 3, 2, 2, 2, 272, 253, 3, 2, 2, 2, 273, 19, 3, 2, 2, 2, 274, 280, 
	7, 72, 2, 2, 275, 276, 7, 78, 2, 2, 276, 277, 5, 22, 12, 2, 277, 278, 7, 
	79, 2, 2, 278, 280, 3, 2, 2, 2, 279, 274, 3, 2, 2, 2, 279, 275, 3, 2, 2, 
	2, 280, 21, 3, 2, 2, 2, 281, 286, 5, 20, 11, 2, 282, 283, 7, 7, 2, 2, 283, 
	285, 5, 20, 11, 2, 284, 282, 3, 2, 2, 2, 285, 288, 3, 2, 2, 2, 286, 284, 
	3, 2, 2, 2, 286, 287, 3, 2, 2, 2, 287, 290, 3, 2, 2, 2, 288, 286, 3, 2, 
	2, 2, 289, 291, 7, 7, 2, 2, 290, 289, 3, 2, 2, 2, 290, 291, 3, 2, 2, 2, 
	291, 23, 3, 2, 2, 2, 292, 295, 5, 26, 14, 2, 293, 295, 5, 74, 38, 2, 294, 
	292, 3, 2, 2, 2, 294, 293, 3, 2, 2, 2, 295, 25, 3, 2, 2, 2, 296, 301, 5, 
	28, 15, 2, 297, 298, 7, 10, 2, 2, 298, 300, 5, 28, 15, 2, 299, 297, 3, 
	2, 2, 2, 300, 303, 3, 2, 2, 2, 301, 299, 3, 2, 2, 2, 301, 302, 3, 2, 2, 
	2, 302, 305, 3, 2, 2, 2, 303, 301, 3, 2, 2, 2, 304, 306, 7, 10, 2, 2, 305, 
	304, 3, 2, 2, 2, 305, 306, 3, 2, 2, 2, 306, 307, 3, 2, 2, 2, 307, 308, 
	7, 87, 2, 2, 308, 27, 3, 2, 2, 2, 309, 319, 5, 30, 16, 2, 310, 319, 5, 
	34, 18, 2, 311, 319, 5, 36, 19, 2, 312, 319, 5, 38, 20, 2, 313, 319, 5, 
	40, 21, 2, 314, 319, 5, 52, 27, 2, 315, 319, 5, 68, 35, 2, 316, 319, 5, 
	70, 36, 2, 317, 319, 5, 72, 37, 2, 318, 309, 3, 2, 2, 2, 318, 310, 3, 2, 
	2, 2, 318, 311, 3, 2, 2, 2, 318, 312, 3, 2, 2, 2, 318, 313, 3, 2, 2, 2, 
	318, 314, 3, 2, 2, 2, 318, 315, 3, 2, 2, 2, 318, 316, 3, 2, 2, 2, 318, 
	317, 3, 2, 2, 2, 319, 29, 3, 2, 2, 2, 320, 336, 5, 144, 73, 2, 321, 324, 
	5, 32, 17, 2, 322, 325, 5, 170, 86, 2, 323, 325, 5, 144, 73, 2, 324, 322, 
	3, 2, 2, 2, 324, 323, 3, 2, 2, 2, 325, 337, 3, 2, 2, 2, 326, 329, 7, 6, 
	2, 2, 327, 330, 5, 170, 86, 2, 328, 330, 5, 144, 73, 2, 329, 327, 3, 2, 
	2, 2, 329, 328, 3, 2, 2, 2, 330, 332, 3, 2, 2, 2, 331, 326, 3, 2, 2, 2, 
	332, 335, 3, 2, 2, 2, 333, 331, 3, 2, 2, 2, 333, 334, 3, 2, 2, 2, 334, 
	337, 3, 2, 2, 2, 335, 333, 3, 2, 2, 2, 336, 321, 3, 2, 2, 2, 336, 333, 
	3, 2, 2, 2, 337, 31, 3, 2, 2, 2, 338, 339, 9, 2, 2, 2, 339, 33, 3, 2, 2, 
	2, 340, 341, 6, 18, 2, 2, 341, 368, 7, 72, 2, 2, 342, 347, 5, 98, 50, 2, 
	343, 344, 7, 7, 2, 2, 344, 346, 5, 98, 50, 2, 345, 343, 3, 2, 2, 2, 346, 
	349, 3, 2, 2, 2, 347, 345, 3, 2, 2, 2, 347, 348, 3, 2, 2, 2, 348, 351, 
	3, 2, 2, 2, 349, 347, 3, 2, 2, 2, 350, 352, 7, 7, 2, 2, 351, 350, 3, 2, 
	2, 2, 351, 352, 3, 2, 2, 2, 352, 354, 3, 2, 2, 2, 353, 342, 3, 2, 2, 2, 
	353, 354, 3, 2, 2, 2, 354, 369, 3, 2, 2, 2, 355, 356, 7, 23, 2, 2, 356, 
	366, 5, 98, 50, 2, 357, 358, 7, 7, 2, 2, 358, 360, 5, 98, 50, 2, 359, 357, 
	3, 2, 2, 2, 360, 361, 3, 2, 2, 2, 361, 359, 3, 2, 2, 2, 361, 362, 3, 2, 
	2, 2, 362, 364, 3, 2, 2, 2, 363, 365, 7, 7, 2, 2, 364, 363, 3, 2, 2, 2, 
	364, 365, 3, 2, 2, 2, 365, 367, 3, 2, 2, 2, 366, 359, 3, 2, 2, 2, 366, 
	367, 3, 2, 2, 2, 367, 369, 3, 2, 2, 2, 368, 353, 3, 2, 2, 2, 368, 355, 
	3, 2, 2, 2, 369, 35, 3, 2, 2, 2, 370, 371, 7, 24, 2, 2, 371, 372, 5, 142, 
	72, 2, 372, 37, 3, 2, 2, 2, 373, 374, 7, 25, 2, 2, 374, 39, 3, 2, 2, 2, 
	375, 381, 5, 42, 22, 2, 376, 381, 5, 44, 23, 2, 377, 381, 5, 46, 24, 2, 
	378, 381, 5, 50, 26, 2, 379, 381, 5, 48, 25, 2, 380, 375, 3, 2, 2, 2, 380, 
	376, 3, 2, 2, 2, 380, 377, 3, 2, 2, 2, 380, 378, 3, 2, 2, 2, 380, 379, 
	3, 2, 2, 2, 381, 41, 3, 2, 2, 2, 382, 383, 7, 26, 2, 2, 383, 43, 3, 2, 
	2, 2, 384, 385, 7, 27, 2, 2, 385, 45, 3, 2, 2, 2, 386, 388, 7, 28, 2, 2, 
	387, 389, 5, 144, 73, 2, 388, 387, 3, 2, 2, 2, 388, 389, 3, 2, 2, 2, 389, 
	47, 3, 2, 2, 2, 390, 391, 5, 170, 86, 2, 391, 49, 3, 2, 2, 2, 392, 402, 
	7, 29, 2, 2, 393, 400, 5, 98, 50, 2, 394, 395, 7, 7, 2, 2, 395, 398, 5, 
	98, 50, 2, 396, 397, 7, 7, 2, 2, 397, 399, 5, 98, 50, 2, 398, 396, 3, 2, 
	2, 2, 398, 399, 3, 2, 2, 2, 399, 401, 3, 2, 2, 2, 400, 394, 3, 2, 2, 2, 
	400, 401, 3, 2, 2, 2, 401, 403, 3, 2, 2, 2, 402, 393, 3, 2, 2, 2, 402, 
	403, 3, 2, 2, 2, 403, 51, 3, 2, 2, 2, 404, 407, 5, 54, 28, 2, 405, 407, 
	5, 56, 29, 2, 406, 404, 3, 2, 2, 2, 406, 405, 3, 2, 2, 2, 407, 53, 3, 2, 
	2, 2, 408, 409, 7, 30, 2, 2, 409, 410, 5, 64, 33, 2, 410, 55, 3, 2, 2, 
	2, 411, 424, 7, 31, 2, 2, 412, 414, 7, 32, 2, 2, 413, 412, 3, 2, 2, 2, 
	414, 417, 3, 2, 2, 2, 415, 413, 3, 2, 2, 2, 415, 416, 3, 2, 2, 2, 416, 
	418, 3, 2, 2, 2, 417, 415, 3, 2, 2, 2, 418, 425, 5, 66, 34, 2, 419, 421, 
	7, 32, 2, 2, 420, 419, 3, 2, 2, 2, 421, 422, 3, 2, 2, 2, 422, 420, 3, 2, 
	2, 2, 422, 423, 3, 2, 2, 2, 423, 425, 3, 2, 2, 2, 424, 415, 3, 2, 2, 2, 
	424, 420, 3, 2, 2, 2, 425, 426, 3, 2, 2, 2, 426, 433, 7, 30, 2, 2, 427, 
	434, 7, 8, 2, 2, 428, 429, 7, 78, 2, 2, 429, 430, 5, 62, 32, 2, 430, 431, 
	7, 79, 2, 2, 431, 434, 3, 2, 2, 2, 432, 434, 5, 62, 32, 2, 433, 427, 3, 
	2, 2, 2, 433, 428, 3, 2, 2, 2, 433, 432, 3, 2, 2, 2, 434, 57, 3, 2, 2, 
	2, 435, 438, 7, 72, 2, 2, 436, 437, 7, 33, 2, 2, 437, 439, 7, 72, 2, 2, 
	438, 436, 3, 2, 2, 2, 438, 439, 3, 2, 2, 2, 439, 59, 3, 2, 2, 2, 440, 443, 
	5, 66, 34, 2, 441, 442, 7, 33, 2, 2, 442, 444, 7, 72, 2, 2, 443, 441, 3, 
	2, 2, 2, 443, 444, 3, 2, 2, 2, 444, 61, 3, 2, 2, 2, 445, 450, 5, 58, 30, 
	2, 446, 447, 7, 7, 2, 2, 447, 449, 5, 58, 30, 2, 448, 446, 3, 2, 2, 2, 
	449, 452, 3, 2, 2, 2, 450, 448, 3, 2, 2, 2, 450, 451, 3, 2, 2, 2, 451, 
	454, 3, 2, 2, 2, 452, 450, 3, 2, 2, 2, 453, 455, 7, 7, 2, 2, 454, 453, 
	3, 2, 2, 2, 454, 455, 3, 2, 2, 2, 455, 63, 3, 2, 2, 2, 456, 461, 5, 60, 
	31, 2, 457, 458, 7, 7, 2, 2, 458, 460, 5, 60, 31, 2, 459, 457, 3, 2, 2, 
	2, 460, 463, 3, 2, 2, 2, 461, 459, 3, 2, 2, 2, 461, 462, 3, 2, 2, 2, 462, 
	65, 3, 2, 2, 2, 463, 461, 3, 2, 2, 2, 464, 469, 7, 72, 2, 2, 465, 466, 
	7, 32, 2, 2, 466, 468, 7, 72, 2, 2, 467, 465, 3, 2, 2, 2, 468, 471, 3, 
	2, 2, 2, 469, 467, 3, 2, 2, 2, 469, 470, 3, 2, 2, 2, 470, 67, 3, 2, 2, 
	2, 471, 469, 3, 2, 2, 2, 472, 473, 7, 34, 2, 2, 473, 478, 7, 72, 2, 2, 
	474, 475, 7, 7, 2, 2, 475, 477, 7, 72, 2, 2, 476, 474, 3, 2, 2, 2, 477, 
	480, 3, 2, 2, 2, 478, 476, 3, 2, 2, 2, 478, 479, 3, 2, 2, 2, 479, 69, 3, 
	2, 2, 2, 480, 478, 3, 2, 2, 2, 481, 482, 7, 35, 2, 2, 482, 489, 5, 110, 
	56, 2, 483, 484, 7, 36, 2, 2, 484, 487, 5, 98, 50, 2, 485, 486, 7, 7, 2, 
	2, 486, 488, 5, 98, 50, 2, 487, 485, 3, 2, 2, 2, 487, 488, 3, 2, 2, 2, 
	488, 490, 3, 2, 2, 2, 489, 483, 3, 2, 2, 2, 489, 490, 3, 2, 2, 2, 490, 
	71, 3, 2, 2, 2, 491, 492, 7, 37, 2, 2, 492, 495, 5, 98, 50, 2, 493, 494, 
	7, 7, 2, 2, 494, 496, 5, 98, 50, 2, 495, 493, 3, 2, 2, 2, 495, 496, 3, 
	2, 2, 2, 496, 73, 3, 2, 2, 2, 497, 506, 5, 76, 39, 2, 498, 506, 5, 78, 
	40, 2, 499, 506, 5, 80, 41, 2, 500, 506, 5, 82, 42, 2, 501, 506, 5, 84, 
	43, 2, 502, 506, 5, 14, 8, 2, 503, 506, 5, 148, 75, 2, 504, 506, 5, 12, 
	7, 2, 505, 497, 3, 2, 2, 2, 505, 498, 3, 2, 2, 2, 505, 499, 3, 2, 2, 2, 
	505, 500, 3, 2, 2, 2, 505, 501, 3, 2, 2, 2, 505, 502, 3, 2, 2, 2, 505, 
	503, 3, 2, 2, 2, 505, 504, 3, 2, 2, 2, 506, 75, 3, 2, 2, 2, 507, 508, 7, 
	38, 2, 2, 508, 509, 5, 98, 50, 2, 509, 510, 7, 5, 2, 2, 510, 518, 5, 90, 
	46, 2, 511, 512, 7, 39, 2, 2, 512, 513, 5, 98, 50, 2, 513, 514, 7, 5, 2, 
	2, 514, 515, 5, 90, 46, 2, 515, 517, 3, 2, 2, 2, 516, 511, 3, 2, 2, 2, 
	517, 520, 3, 2, 2, 2, 518, 516, 3, 2, 2, 2, 518, 519, 3, 2, 2, 2, 519, 
	524, 3, 2, 2, 2, 520, 518, 3, 2, 2, 2, 521, 522, 7, 40, 2, 2, 522, 523, 
	7, 5, 2, 2, 523, 525, 5, 90, 46, 2, 524, 521, 3, 2, 2, 2, 524, 525, 3, 
	2, 2, 2, 525, 77, 3, 2, 2, 2, 526, 527, 7, 41, 2, 2, 527, 528, 5, 98, 50, 
	2, 528, 529, 7, 5, 2, 2, 529, 533, 5, 90, 46, 2, 530, 531, 7, 40, 2, 2, 
	531, 532, 7, 5, 2, 2, 532, 534, 5, 90, 46, 2, 533, 530, 3, 2, 2, 2, 533, 
	534, 3, 2, 2, 2, 534, 79, 3, 2, 2, 2, 535, 536, 7, 42, 2, 2, 536, 537, 
	5, 142, 72, 2, 537, 538, 7, 36, 2, 2, 538, 539, 5, 144, 73, 2, 539, 540, 
	7, 5, 2, 2, 540, 544, 5, 90, 46, 2, 541, 542, 7, 40, 2, 2, 542, 543, 7, 
	5, 2, 2, 543, 545, 5, 90, 46, 2, 544, 541, 3, 2, 2, 2, 544, 545, 3, 2, 
	2, 2, 545, 81, 3, 2, 2, 2, 546, 547, 7, 43, 2, 2, 547, 548, 7, 5, 2, 2, 
	548, 570, 5, 90, 46, 2, 549, 550, 5, 88, 45, 2, 550, 551, 7, 5, 2, 2, 551, 
	552, 5, 90, 46, 2, 552, 554, 3, 2, 2, 2, 553, 549, 3, 2, 2, 2, 554, 555, 
	3, 2, 2, 2, 555, 553, 3, 2, 2, 2, 555, 556, 3, 2, 2, 2, 556, 560, 3, 2, 
	2, 2, 557, 558, 7, 40, 2, 2, 558, 559, 7, 5, 2, 2, 559, 561, 5, 90, 46, 
	2, 560, 557, 3, 2, 2, 2, 560, 561, 3, 2, 2, 2, 561, 565, 3, 2, 2, 2, 562, 
	563, 7, 44, 2, 2, 563, 564, 7, 5, 2, 2, 564, 566, 5, 90, 46, 2, 565, 562, 
	3, 2, 2, 2, 565, 566, 3, 2, 2, 2, 566, 571, 3, 2, 2, 2, 567, 568, 7, 44, 
	2, 2, 568, 569, 7, 5, 2, 2, 569, 571, 5, 90, 46, 2, 570, 553, 3, 2, 2, 
	2, 570, 567, 3, 2, 2, 2, 571, 83, 3, 2, 2, 2, 572, 573, 7, 45, 2, 2, 573, 
	578, 5, 86, 44, 2, 574, 575, 7, 7, 2, 2, 575, 577, 5, 86, 44, 2, 576, 574, 
	3, 2, 2, 2, 577, 580, 3, 2, 2, 2, 578, 576, 3, 2, 2, 2, 578, 579, 3, 2, 
	2, 2, 579, 581, 3, 2, 2, 2, 580, 578, 3, 2, 2, 2, 581, 582, 7, 5, 2, 2, 
	582, 583, 5, 90, 46, 2, 583, 85, 3, 2, 2, 2, 584, 587, 5, 98, 50, 2, 585, 
	586, 7, 33, 2, 2, 586, 588, 5, 110, 56, 2, 587, 585, 3, 2, 2, 2, 587, 588, 
	3, 2, 2, 2, 588, 87, 3, 2, 2, 2, 589, 595, 7, 46, 2, 2, 590, 593, 5, 98, 
	50, 2, 591, 592, 9, 3, 2, 2, 592, 594, 5, 98, 50, 2, 593, 591, 3, 2, 2, 
	2, 593, 594, 3, 2, 2, 2, 594, 596, 3, 2, 2, 2, 595, 590, 3, 2, 2, 2, 595, 
	596, 3, 2, 2, 2, 596, 89, 3, 2, 2, 2, 597, 608, 5, 26, 14, 2, 598, 599, 
	7, 87, 2, 2, 599, 601, 7, 85, 2, 2, 600, 602, 5, 24, 13, 2, 601, 600, 3, 
	2, 2, 2, 602, 603, 3, 2, 2, 2, 603, 601, 3, 2, 2, 2, 603, 604, 3, 2, 2, 
	2, 604, 605, 3, 2, 2, 2, 605, 606, 7, 86, 2, 2, 606, 608, 3, 2, 2, 2, 607, 
	597, 3, 2, 2, 2, 607, 598, 3, 2, 2, 2, 608, 91, 3, 2, 2, 2, 609, 619, 5, 
	94, 48, 2, 610, 611, 7, 7, 2, 2, 611, 613, 5, 94, 48, 2, 612, 610, 3, 2, 
	2, 2, 613, 614, 3, 2, 2, 2, 614, 612, 3, 2, 2, 2, 614, 615, 3, 2, 2, 2, 
	615, 617, 3, 2, 2, 2, 616, 618, 7, 7, 2, 2, 617, 616, 3, 2, 2, 2, 617, 
	618, 3, 2, 2, 2, 618, 620, 3, 2, 2, 2, 619, 612, 3, 2, 2, 2, 619, 620, 
	3, 2, 2, 2, 620, 93, 3, 2, 2, 2, 621, 624, 5, 100, 51, 2, 622, 624, 5, 
	96, 49, 2, 623, 621, 3, 2, 2, 2, 623, 622, 3, 2, 2, 2, 624, 95, 3, 2, 2, 
	2, 625, 627, 7, 47, 2, 2, 626, 628, 5, 18, 10, 2, 627, 626, 3, 2, 2, 2, 
	627, 628, 3, 2, 2, 2, 628, 629, 3, 2, 2, 2, 629, 630, 7, 5, 2, 2, 630, 
	631, 5, 94, 48, 2, 631, 97, 3, 2, 2, 2, 632, 638, 5, 100, 51, 2, 633, 634, 
	7, 38, 2, 2, 634, 635, 5, 100, 51, 2, 635, 636, 7, 40, 2, 2, 636, 637, 
	5, 98, 50, 2, 637, 639, 3, 2, 2, 2, 638, 633, 3, 2, 2, 2, 638, 639, 3, 
	2, 2, 2, 639, 642, 3, 2, 2, 2, 640, 642, 5, 132, 67, 2, 641, 632, 3, 2, 
	2, 2, 641, 640, 3, 2, 2, 2, 642, 99, 3, 2, 2, 2, 643, 648, 5, 102, 52, 
	2, 644, 645, 7, 48, 2, 2, 645, 647, 5, 102, 52, 2, 646, 644, 3, 2, 2, 2, 
	647, 650, 3, 2, 2, 2, 648, 646, 3, 2, 2, 2, 648, 649, 3, 2, 2, 2, 649, 
	101, 3, 2, 2, 2, 650, 648, 3, 2, 2, 2, 651, 656, 5, 104, 53, 2, 652, 653, 
	7, 49, 2, 2, 653, 655, 5, 104, 53, 2, 654, 652, 3, 2, 2, 2, 655, 658, 3, 
	2, 2, 2, 656, 654, 3, 2, 2, 2, 656, 657, 3, 2, 2, 2, 657, 103, 3, 2, 2, 
	2, 658, 656, 3, 2, 2, 2, 659, 660, 7, 50, 2, 2, 660, 663, 5, 104, 53, 2, 
	661, 663, 5, 106, 54, 2, 662, 659, 3, 2, 2, 2, 662, 661, 3, 2, 2, 2, 663, 
	105, 3, 2, 2, 2, 664, 670, 5, 110, 56, 2, 665, 666, 5, 108, 55, 2, 666, 
	667, 5, 110, 56, 2, 667, 669, 3, 2, 2, 2, 668, 665, 3, 2, 2, 2, 669, 672, 
	3, 2, 2, 2, 670, 668, 3, 2, 2, 2, 670, 671, 3, 2, 2, 2, 671, 107, 3, 2, 
	2, 2, 672, 670, 3, 2, 2, 2, 673, 687, 7, 51, 2, 2, 674, 687, 7, 52, 2, 
	2, 675, 687, 7, 53, 2, 2, 676, 687, 7, 54, 2, 2, 677, 687, 7, 55, 2, 2, 
	678, 687, 7, 56, 2, 2, 679, 687, 7, 57, 2, 2, 680, 687, 7, 36, 2, 2, 681, 
	682, 7, 50, 2, 2, 682, 687, 7, 36, 2, 2, 683, 687, 7, 58, 2, 2, 684, 685, 
	7, 58, 2, 2, 685, 687, 7, 50, 2, 2, 686, 673, 3, 2, 2, 2, 686, 674, 3, 
	2, 2, 2, 686, 675, 3, 2, 2, 2, 686, 676, 3, 2, 2, 2, 686, 677, 3, 2, 2, 
	2, 686, 678, 3, 2, 2, 2, 686, 679, 3, 2, 2, 2, 686, 680, 3, 2, 2, 2, 686, 
	681, 3, 2, 2, 2, 686, 683, 3, 2, 2, 2, 686, 684, 3, 2, 2, 2, 687, 109, 
	3, 2, 2, 2, 688, 693, 5, 112, 57, 2, 689, 690, 7, 59, 2, 2, 690, 692, 5, 
	112, 57, 2, 691, 689, 3, 2, 2, 2, 692, 695, 3, 2, 2, 2, 693, 691, 3, 2, 
	2, 2, 693, 694, 3, 2, 2, 2, 694, 111, 3, 2, 2, 2, 695, 693, 3, 2, 2, 2, 
	696, 701, 5, 114, 58, 2, 697, 698, 7, 60, 2, 2, 698, 700, 5, 114, 58, 2, 
	699, 697, 3, 2, 2, 2, 700, 703, 3, 2, 2, 2, 701, 699, 3, 2, 2, 2, 701, 
	702, 3, 2, 2, 2, 702, 113, 3, 2, 2, 2, 703, 701, 3, 2, 2, 2, 704, 709, 
	5, 116, 59, 2, 705, 706, 7, 61, 2, 2, 706, 708, 5, 116, 59, 2, 707, 705, 
	3, 2, 2, 2, 708, 711, 3, 2, 2, 2, 709, 707, 3, 2, 2, 2, 709, 710, 3, 2, 
	2, 2, 710, 115, 3, 2, 2, 2, 711, 709, 3, 2, 2, 2, 712, 717, 5, 118, 60, 
	2, 713, 714, 9, 4, 2, 2, 714, 716, 5, 118, 60, 2, 715, 713, 3, 2, 2, 2, 
	716, 719, 3, 2, 2, 2, 717, 715, 3, 2, 2, 2, 717, 718, 3, 2, 2, 2, 718, 
	117, 3, 2, 2, 2, 719, 717, 3, 2, 2, 2, 720, 725, 5, 120, 61, 2, 721, 722, 
	9, 5, 2, 2, 722, 724, 5, 120, 61, 2, 723, 721, 3, 2, 2, 2, 724, 727, 3, 
	2, 2, 2, 725, 723, 3, 2, 2, 2, 725, 726, 3, 2, 2, 2, 726, 119, 3, 2, 2, 
	2, 727, 725, 3, 2, 2, 2, 728, 733, 5, 122, 62, 2, 729, 730, 9, 6, 2, 2, 
	730, 732, 5, 122, 62, 2, 731, 729, 3, 2, 2, 2, 732, 735, 3, 2, 2, 2, 733, 
	731, 3, 2, 2, 2, 733, 734, 3, 2, 2, 2, 734, 121, 3, 2, 2, 2, 735, 733, 
	3, 2, 2, 2, 736, 737, 9, 7, 2, 2, 737, 740, 5, 122, 62, 2, 738, 740, 5, 
	124, 63, 2, 739, 736, 3, 2, 2, 2, 739, 738, 3, 2, 2, 2, 740, 123, 3, 2, 
	2, 2, 741, 745, 5, 126, 64, 2, 742, 744, 5, 134, 68, 2, 743, 742, 3, 2, 
	2, 2, 744, 747, 3, 2, 2, 2, 745, 743, 3, 2, 2, 2, 745, 746, 3, 2, 2, 2, 
	746, 750, 3, 2, 2, 2, 747, 745, 3, 2, 2, 2, 748, 749, 7, 9, 2, 2, 749, 
	751, 5, 122, 62, 2, 750, 748, 3, 2, 2, 2, 750, 751, 3, 2, 2, 2, 751, 125, 
	3, 2, 2, 2, 752, 755, 7, 78, 2, 2, 753, 756, 5, 170, 86, 2, 754, 756, 5, 
	130, 66, 2, 755, 753, 3, 2, 2, 2, 755, 754, 3, 2, 2, 2, 755, 756, 3, 2, 
	2, 2, 756, 757, 3, 2, 2, 2, 757, 783, 7, 79, 2, 2, 758, 760, 7, 82, 2, 
	2, 759, 761, 5, 128, 65, 2, 760, 759, 3, 2, 2, 2, 760, 761, 3, 2, 2, 2, 
	761, 762, 3, 2, 2, 2, 762, 783, 7, 83, 2, 2, 763, 765, 7, 80, 2, 2, 764, 
	766, 5, 146, 74, 2, 765, 764, 3, 2, 2, 2, 765, 766, 3, 2, 2, 2, 766, 767, 
	3, 2, 2, 2, 767, 783, 7, 81, 2, 2, 768, 769, 7, 69, 2, 2, 769, 770, 5, 
	166, 84, 2, 770, 771, 7, 69, 2, 2, 771, 783, 3, 2, 2, 2, 772, 773, 7, 32, 
	2, 2, 773, 774, 7, 32, 2, 2, 774, 783, 7, 32, 2, 2, 775, 783, 7, 72, 2, 
	2, 776, 783, 7, 73, 2, 2, 777, 779, 7, 74, 2, 2, 778, 777, 3, 2, 2, 2, 
	779, 780, 3, 2, 2, 2, 780, 778, 3, 2, 2, 2, 780, 781, 3, 2, 2, 2, 781, 
	783, 3, 2, 2, 2, 782, 752, 3, 2, 2, 2, 782, 758, 3, 2, 2, 2, 782, 763, 
	3, 2, 2, 2, 782, 768, 3, 2, 2, 2, 782, 772, 3, 2, 2, 2, 782, 775, 3, 2, 
	2, 2, 782, 776, 3, 2, 2, 2, 782, 778, 3, 2, 2, 2, 783, 127, 3, 2, 2, 2, 
	784, 796, 5, 98, 50, 2, 785, 797, 5, 156, 79, 2, 786, 787, 7, 7, 2, 2, 
	787, 789, 5, 98, 50, 2, 788, 786, 3, 2, 2, 2, 789, 792, 3, 2, 2, 2, 790, 
	788, 3, 2, 2, 2, 790, 791, 3, 2, 2, 2, 791, 794, 3, 2, 2, 2, 792, 790, 
	3, 2, 2, 2, 793, 795, 7, 7, 2, 2, 794, 793, 3, 2, 2, 2, 794, 795, 3, 2, 
	2, 2, 795, 797, 3, 2, 2, 2, 796, 785, 3, 2, 2, 2, 796, 790, 3, 2, 2, 2, 
	797, 129, 3, 2, 2, 2, 798, 810, 5, 98, 50, 2, 799, 811, 5, 162, 82, 2, 
	800, 801, 7, 7, 2, 2, 801, 803, 5, 98, 50, 2, 802, 800, 3, 2, 2, 2, 803, 
	806, 3, 2, 2, 2, 804, 802, 3, 2, 2, 2, 804, 805, 3, 2, 2, 2, 805, 808, 
	3, 2, 2, 2, 806, 804, 3, 2, 2, 2, 807, 809, 7, 7, 2, 2, 808, 807, 3, 2, 
	2, 2, 808, 809, 3, 2, 2, 2, 809, 811, 3, 2, 2, 2, 810, 799, 3, 2, 2, 2, 
	810, 804, 3, 2, 2, 2, 811, 131, 3, 2, 2, 2, 812, 814, 7, 47, 2, 2, 813, 
	815, 5, 18, 10, 2, 814, 813, 3, 2, 2, 2, 814, 815, 3, 2, 2, 2, 815, 816, 
	3, 2, 2, 2, 816, 817, 7, 5, 2, 2, 817, 818, 5, 98, 50, 2, 818, 133, 3, 
	2, 2, 2, 819, 821, 7, 78, 2, 2, 820, 822, 5, 150, 76, 2, 821, 820, 3, 2, 
	2, 2, 821, 822, 3, 2, 2, 2, 822, 823, 3, 2, 2, 2, 823, 831, 7, 79, 2, 2, 
	824, 825, 7, 82, 2, 2, 825, 826, 5, 136, 69, 2, 826, 827, 7, 83, 2, 2, 
	827, 831, 3, 2, 2, 2, 828, 829, 7, 32, 2, 2, 829, 831, 7, 72, 2, 2, 830, 
	819, 3, 2, 2, 2, 830, 824, 3, 2, 2, 2, 830, 828, 3, 2, 2, 2, 831, 135, 
	3, 2, 2, 2, 832, 837, 5, 138, 70, 2, 833, 834, 7, 7, 2, 2, 834, 836, 5, 
	138, 70, 2, 835, 833, 3, 2, 2, 2, 836, 839, 3, 2, 2, 2, 837, 835, 3, 2, 
	2, 2, 837, 838, 3, 2, 2, 2, 838, 841, 3, 2, 2, 2, 839, 837, 3, 2, 2, 2, 
	840, 842, 7, 7, 2, 2, 841, 840, 3, 2, 2, 2, 841, 842, 3, 2, 2, 2, 842, 
	137, 3, 2, 2, 2, 843, 844, 7, 32, 2, 2, 844, 845, 7, 32, 2, 2, 845, 858, 
	7, 32, 2, 2, 846, 858, 5, 98, 50, 2, 847, 849, 5, 98, 50, 2, 848, 847, 
	3, 2, 2, 2, 848, 849, 3, 2, 2, 2, 849, 850, 3, 2, 2, 2, 850, 852, 7, 5, 
	2, 2, 851, 853, 5, 98, 50, 2, 852, 851, 3, 2, 2, 2, 852, 853, 3, 2, 2, 
	2, 853, 855, 3, 2, 2, 2, 854, 856, 5, 140, 71, 2, 855, 854, 3, 2, 2, 2, 
	855, 856, 3, 2, 2, 2, 856, 858, 3, 2, 2, 2, 857, 843, 3, 2, 2, 2, 857, 
	846, 3, 2, 2, 2, 857, 848, 3, 2, 2, 2, 858, 139, 3, 2, 2, 2, 859, 861, 
	7, 5, 2, 2, 860, 862, 5, 98, 50, 2, 861, 860, 3, 2, 2, 2, 861, 862, 3, 
	2, 2, 2, 862, 141, 3, 2, 2, 2, 863, 868, 5, 110, 56, 2, 864, 865, 7, 7, 
	2, 2, 865, 867, 5, 110, 56, 2, 866, 864, 3, 2, 2, 2, 867, 870, 3, 2, 2, 
	2, 868, 866, 3, 2, 2, 2, 868, 869, 3, 2, 2, 2, 869, 872, 3, 2, 2, 2, 870, 
	868, 3, 2, 2, 2, 871, 873, 7, 7, 2, 2, 872, 871, 3, 2, 2, 2, 872, 873, 
	3, 2, 2, 2, 873, 143, 3, 2, 2, 2, 874, 879, 5, 98, 50, 2, 875, 876, 7, 
	7, 2, 2, 876, 878, 5, 98, 50, 2, 877, 875, 3, 2, 2, 2, 878, 881, 3, 2, 
	2, 2, 879, 877, 3, 2, 2, 2, 879, 880, 3, 2, 2, 2, 880, 883, 3, 2, 2, 2, 
	881, 879, 3, 2, 2, 2, 882, 884, 7, 7, 2, 2, 883, 882, 3, 2, 2, 2, 883, 
	884, 3, 2, 2, 2, 884, 145, 3, 2, 2, 2, 885, 886, 5, 98, 50, 2, 886, 887, 
	7, 5, 2, 2, 887, 902, 5, 98, 50, 2, 888, 903, 5, 162, 82, 2, 889, 890, 
	7, 7, 2, 2, 890, 891, 5, 98, 50, 2, 891, 892, 7, 5, 2, 2, 892, 893, 5, 
	98, 50, 2, 893, 895, 3, 2, 2, 2, 894, 889, 3, 2, 2, 2, 895, 898, 3, 2, 
	2, 2, 896, 894, 3, 2, 2, 2, 896, 897, 3, 2, 2, 2, 897, 900, 3, 2, 2, 2, 
	898, 896, 3, 2, 2, 2, 899, 901, 7, 7, 2, 2, 900, 899, 3, 2, 2, 2, 900, 
	901, 3, 2, 2, 2, 901, 903, 3, 2, 2, 2, 902, 888, 3, 2, 2, 2, 902, 896, 
	3, 2, 2, 2, 903, 919, 3, 2, 2, 2, 904, 916, 5, 98, 50, 2, 905, 917, 5, 
	162, 82, 2, 906, 907, 7, 7, 2, 2, 907, 909, 5, 98, 50, 2, 908, 906, 3, 
	2, 2, 2, 909, 912, 3, 2, 2, 2, 910, 908, 3, 2, 2, 2, 910, 911, 3, 2, 2, 
	2, 911, 914, 3, 2, 2, 2, 912, 910, 3, 2, 2, 2, 913, 915, 7, 7, 2, 2, 914, 
	913, 3, 2, 2, 2, 914, 915, 3, 2, 2, 2, 915, 917, 3, 2, 2, 2, 916, 905, 
	3, 2, 2, 2, 916, 910, 3, 2, 2, 2, 917, 919, 3, 2, 2, 2, 918, 885, 3, 2, 
	2, 2, 918, 904, 3, 2, 2, 2, 919, 147, 3, 2, 2, 2, 920, 921, 7, 70, 2, 2, 
	921, 927, 7, 72, 2, 2, 922, 924, 7, 78, 2, 2, 923, 925, 5, 144, 73, 2, 
	924, 923, 3, 2, 2, 2, 924, 925, 3, 2, 2, 2, 925, 926, 3, 2, 2, 2, 926, 
	928, 7, 79, 2, 2, 927, 922, 3, 2, 2, 2, 927, 928, 3, 2, 2, 2, 928, 929, 
	3, 2, 2, 2, 929, 930, 7, 5, 2, 2, 930, 931, 5, 90, 46, 2, 931, 149, 3, 
	2, 2, 2, 932, 933, 5, 152, 77, 2, 933, 934, 7, 7, 2, 2, 934, 936, 3, 2, 
	2, 2, 935, 932, 3, 2, 2, 2, 936, 939, 3, 2, 2, 2, 937, 935, 3, 2, 2, 2, 
	937, 938, 3, 2, 2, 2, 938, 960, 3, 2, 2, 2, 939, 937, 3, 2, 2, 2, 940, 
	942, 5, 152, 77, 2, 941, 943, 7, 7, 2, 2, 942, 941, 3, 2, 2, 2, 942, 943, 
	3, 2, 2, 2, 943, 961, 3, 2, 2, 2, 944, 945, 7, 8, 2, 2, 945, 950, 5, 98, 
	50, 2, 946, 947, 7, 7, 2, 2, 947, 949, 5, 152, 77, 2, 948, 946, 3, 2, 2, 
	2, 949, 952, 3, 2, 2, 2, 950, 948, 3, 2, 2, 2, 950, 951, 3, 2, 2, 2, 951, 
	956, 3, 2, 2, 2, 952, 950, 3, 2, 2, 2, 953, 954, 7, 7, 2, 2, 954, 955, 
	7, 9, 2, 2, 955, 957, 5, 98, 50, 2, 956, 953, 3, 2, 2, 2, 956, 957, 3, 
	2, 2, 2, 957, 961, 3, 2, 2, 2, 958, 959, 7, 9, 2, 2, 959, 961, 5, 98, 50, 
	2, 960, 940, 3, 2, 2, 2, 960, 944, 3, 2, 2, 2, 960, 958, 3, 2, 2, 2, 961, 
	151, 3, 2, 2, 2, 962, 964, 5, 98, 50, 2, 963, 965, 5, 162, 82, 2, 964, 
	963, 3, 2, 2, 2, 964, 965, 3, 2, 2, 2, 965, 971, 3, 2, 2, 2, 966, 967, 
	5, 98, 50, 2, 967, 968, 7, 6, 2, 2, 968, 969, 5, 98, 50, 2, 969, 971, 3, 
	2, 2, 2, 970, 962, 3, 2, 2, 2, 970, 966, 3, 2, 2, 2, 971, 153, 3, 2, 2, 
	2, 972, 975, 5, 156, 79, 2, 973, 975, 5, 158, 80, 2, 974, 972, 3, 2, 2, 
	2, 974, 973, 3, 2, 2, 2, 975, 155, 3, 2, 2, 2, 976, 977, 7, 42, 2, 2, 977, 
	978, 5, 142, 72, 2, 978, 979, 7, 36, 2, 2, 979, 981, 5, 92, 47, 2, 980, 
	982, 5, 154, 78, 2, 981, 980, 3, 2, 2, 2, 981, 982, 3, 2, 2, 2, 982, 157, 
	3, 2, 2, 2, 983, 984, 7, 38, 2, 2, 984, 986, 5, 94, 48, 2, 985, 987, 5, 
	154, 78, 2, 986, 985, 3, 2, 2, 2, 986, 987, 3, 2, 2, 2, 987, 159, 3, 2, 
	2, 2, 988, 991, 5, 162, 82, 2, 989, 991, 5, 164, 83, 2, 990, 988, 3, 2, 
	2, 2, 990, 989, 3, 2, 2, 2, 991, 161, 3, 2, 2, 2, 992, 993, 7, 42, 2, 2, 
	993, 994, 5, 142, 72, 2, 994, 995, 7, 36, 2, 2, 995, 997, 5, 100, 51, 2, 
	996, 998, 5, 160, 81, 2, 997, 996, 3, 2, 2, 2, 997, 998, 3, 2, 2, 2, 998, 
	163, 3, 2, 2, 2, 999, 1000, 7, 38, 2, 2, 1000, 1002, 5, 94, 48, 2, 1001, 
	1003, 5, 160, 81, 2, 1002, 1001, 3, 2, 2, 2, 1002, 1003, 3, 2, 2, 2, 1003, 
	165, 3, 2, 2, 2, 1004, 1009, 5, 98, 50, 2, 1005, 1006, 7, 7, 2, 2, 1006, 
	1008, 5, 98, 50, 2, 1007, 1005, 3, 2, 2, 2, 1008, 1011, 3, 2, 2, 2, 1009, 
	1007, 3, 2, 2, 2, 1009, 1010, 3, 2, 2, 2, 1010, 167, 3, 2, 2, 2, 1011, 
	1009, 3, 2, 2, 2, 1012, 1013, 7, 72, 2, 2, 1013, 169, 3, 2, 2, 2, 1014, 
	1016, 7, 71, 2, 2, 1015, 1017, 7, 31, 2, 2, 1016, 1015, 3, 2, 2, 2, 1016, 
	1017, 3, 2, 2, 2, 1017, 1019, 3, 2, 2, 2, 1018, 1020, 5, 144, 73, 2, 1019, 
	1018, 3, 2, 2, 2, 1019, 1020, 3, 2, 2, 2, 1020, 171, 3, 2, 2, 2, 144, 177, 
	181, 183, 192, 201, 204, 211, 216, 226, 233, 239, 247, 251, 256, 262, 266, 
	270, 272, 279, 286, 290, 294, 301, 305, 318, 324, 329, 333, 336, 347, 351, 
	353, 361, 364, 366, 368, 380, 388, 398, 400, 402, 406, 415, 422, 424, 433, 
	438, 443, 450, 454, 461, 469, 478, 487, 489, 495, 505, 518, 524, 533, 544, 
	555, 560, 565, 570, 578, 587, 593, 595, 603, 607, 614, 617, 619, 623, 627, 
	638, 641, 648, 656, 662, 670, 686, 693, 701, 709, 717, 725, 733, 739, 745, 
	750, 755, 760, 765, 780, 782, 790, 794, 796, 804, 808, 810, 814, 821, 830, 
	837, 841, 848, 852, 855, 857, 861, 868, 872, 879, 883, 896, 900, 902, 910, 
	914, 916, 918, 924, 927, 937, 942, 950, 956, 960, 964, 970, 974, 981, 986, 
	990, 997, 1002, 1009, 1016, 1019,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'@'", "'def'", "':'", "'='", "','", "'*'", "'**'", "';'", "'+='", 
	"'-='", "'*='", "'/='", "'%='", "'&='", "'|='", "'^='", "'<<='", "'>>='", 
	"'**='", "'//='", "'>>'", "'del'", "'pass'", "'break'", "'continue'", "'return'", 
	"'raise'", "'import'", "'from'", "'.'", "'as'", "'global'", "'exec'", "'in'", 
	"'assert'", "'if'", "'elif'", "'else'", "'while'", "'for'", "'try'", "'finally'", 
	"'with'", "'except'", "'lambda'", "'or'", "'and'", "'not'", "'<'", "'>'", 
	"'=='", "'>='", "'<='", "'<>'", "'!='", "'is'", "'|'", "'^'", "'&'", "'<<'", 
	"'+'", "'-'", "'/'", "'%'", "'//'", "'~'", "'`'", "'class'", "'yield'", 
	"", "", "", "", "", "", "'('", "')'", "'{'", "'}'", "'['", "']'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "NAME", 
	"NUMBER", "STRING", "LINENDING", "WHITESPACE", "COMMENT", "OPEN_PAREN", 
	"CLOSE_PAREN", "OPEN_BRACE", "CLOSE_BRACE", "OPEN_BRACKET", "CLOSE_BRACKET", 
	"UNKNOWN", "INDENT", "DEDENT", "NEWLINE", "ENDMARKER",
}

var ruleNames = []string{
	"single_input", "file_input", "eval_input", "decorator", "decorators", 
	"decorated", "funcdef", "parameters", "varargslist", "fpdef", "fplist", 
	"stmt", "simple_stmt", "small_stmt", "expr_stmt", "augassign", "print_stmt", 
	"del_stmt", "pass_stmt", "flow_stmt", "break_stmt", "continue_stmt", "return_stmt", 
	"yield_stmt", "raise_stmt", "import_stmt", "import_name", "import_from", 
	"import_as_name", "dotted_as_name", "import_as_names", "dotted_as_names", 
	"dotted_name", "global_stmt", "exec_stmt", "assert_stmt", "compound_stmt", 
	"if_stmt", "while_stmt", "for_stmt", "try_stmt", "with_stmt", "with_item", 
	"except_clause", "suite", "testlist_safe", "old_test", "old_lambdef", "test", 
	"or_test", "and_test", "not_test", "comparison", "comp_op", "expr", "xor_expr", 
	"and_expr", "shift_expr", "arith_expr", "term", "factor", "power", "atom", 
	"listmaker", "testlist_comp", "lambdef", "trailer", "subscriptlist", "subscript", 
	"sliceop", "exprlist", "testlist", "dictorsetmaker", "classdef", "arglist", 
	"argument", "list_iter", "list_for", "list_if", "comp_iter", "comp_for", 
	"comp_if", "testlist1", "encoding_decl", "yield_expr",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type Python2Parser struct {
	*antlr.BaseParser
}

func NewPython2Parser(input antlr.TokenStream) *Python2Parser {
	this := new(Python2Parser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Python2.g4"

	return this
}

// Python2Parser tokens.
const (
	Python2ParserEOF = antlr.TokenEOF
	Python2ParserT__0 = 1
	Python2ParserT__1 = 2
	Python2ParserT__2 = 3
	Python2ParserT__3 = 4
	Python2ParserT__4 = 5
	Python2ParserT__5 = 6
	Python2ParserT__6 = 7
	Python2ParserT__7 = 8
	Python2ParserT__8 = 9
	Python2ParserT__9 = 10
	Python2ParserT__10 = 11
	Python2ParserT__11 = 12
	Python2ParserT__12 = 13
	Python2ParserT__13 = 14
	Python2ParserT__14 = 15
	Python2ParserT__15 = 16
	Python2ParserT__16 = 17
	Python2ParserT__17 = 18
	Python2ParserT__18 = 19
	Python2ParserT__19 = 20
	Python2ParserT__20 = 21
	Python2ParserT__21 = 22
	Python2ParserT__22 = 23
	Python2ParserT__23 = 24
	Python2ParserT__24 = 25
	Python2ParserT__25 = 26
	Python2ParserT__26 = 27
	Python2ParserT__27 = 28
	Python2ParserT__28 = 29
	Python2ParserT__29 = 30
	Python2ParserT__30 = 31
	Python2ParserT__31 = 32
	Python2ParserT__32 = 33
	Python2ParserT__33 = 34
	Python2ParserT__34 = 35
	Python2ParserT__35 = 36
	Python2ParserT__36 = 37
	Python2ParserT__37 = 38
	Python2ParserT__38 = 39
	Python2ParserT__39 = 40
	Python2ParserT__40 = 41
	Python2ParserT__41 = 42
	Python2ParserT__42 = 43
	Python2ParserT__43 = 44
	Python2ParserT__44 = 45
	Python2ParserT__45 = 46
	Python2ParserT__46 = 47
	Python2ParserT__47 = 48
	Python2ParserT__48 = 49
	Python2ParserT__49 = 50
	Python2ParserT__50 = 51
	Python2ParserT__51 = 52
	Python2ParserT__52 = 53
	Python2ParserT__53 = 54
	Python2ParserT__54 = 55
	Python2ParserT__55 = 56
	Python2ParserT__56 = 57
	Python2ParserT__57 = 58
	Python2ParserT__58 = 59
	Python2ParserT__59 = 60
	Python2ParserT__60 = 61
	Python2ParserT__61 = 62
	Python2ParserT__62 = 63
	Python2ParserT__63 = 64
	Python2ParserT__64 = 65
	Python2ParserT__65 = 66
	Python2ParserT__66 = 67
	Python2ParserT__67 = 68
	Python2ParserT__68 = 69
	Python2ParserNAME = 70
	Python2ParserNUMBER = 71
	Python2ParserSTRING = 72
	Python2ParserLINENDING = 73
	Python2ParserWHITESPACE = 74
	Python2ParserCOMMENT = 75
	Python2ParserOPEN_PAREN = 76
	Python2ParserCLOSE_PAREN = 77
	Python2ParserOPEN_BRACE = 78
	Python2ParserCLOSE_BRACE = 79
	Python2ParserOPEN_BRACKET = 80
	Python2ParserCLOSE_BRACKET = 81
	Python2ParserUNKNOWN = 82
	Python2ParserINDENT = 83
	Python2ParserDEDENT = 84
	Python2ParserNEWLINE = 85
	Python2ParserENDMARKER = 86
)

// Python2Parser rules.
const (
	Python2ParserRULE_single_input = 0
	Python2ParserRULE_file_input = 1
	Python2ParserRULE_eval_input = 2
	Python2ParserRULE_decorator = 3
	Python2ParserRULE_decorators = 4
	Python2ParserRULE_decorated = 5
	Python2ParserRULE_funcdef = 6
	Python2ParserRULE_parameters = 7
	Python2ParserRULE_varargslist = 8
	Python2ParserRULE_fpdef = 9
	Python2ParserRULE_fplist = 10
	Python2ParserRULE_stmt = 11
	Python2ParserRULE_simple_stmt = 12
	Python2ParserRULE_small_stmt = 13
	Python2ParserRULE_expr_stmt = 14
	Python2ParserRULE_augassign = 15
	Python2ParserRULE_print_stmt = 16
	Python2ParserRULE_del_stmt = 17
	Python2ParserRULE_pass_stmt = 18
	Python2ParserRULE_flow_stmt = 19
	Python2ParserRULE_break_stmt = 20
	Python2ParserRULE_continue_stmt = 21
	Python2ParserRULE_return_stmt = 22
	Python2ParserRULE_yield_stmt = 23
	Python2ParserRULE_raise_stmt = 24
	Python2ParserRULE_import_stmt = 25
	Python2ParserRULE_import_name = 26
	Python2ParserRULE_import_from = 27
	Python2ParserRULE_import_as_name = 28
	Python2ParserRULE_dotted_as_name = 29
	Python2ParserRULE_import_as_names = 30
	Python2ParserRULE_dotted_as_names = 31
	Python2ParserRULE_dotted_name = 32
	Python2ParserRULE_global_stmt = 33
	Python2ParserRULE_exec_stmt = 34
	Python2ParserRULE_assert_stmt = 35
	Python2ParserRULE_compound_stmt = 36
	Python2ParserRULE_if_stmt = 37
	Python2ParserRULE_while_stmt = 38
	Python2ParserRULE_for_stmt = 39
	Python2ParserRULE_try_stmt = 40
	Python2ParserRULE_with_stmt = 41
	Python2ParserRULE_with_item = 42
	Python2ParserRULE_except_clause = 43
	Python2ParserRULE_suite = 44
	Python2ParserRULE_testlist_safe = 45
	Python2ParserRULE_old_test = 46
	Python2ParserRULE_old_lambdef = 47
	Python2ParserRULE_test = 48
	Python2ParserRULE_or_test = 49
	Python2ParserRULE_and_test = 50
	Python2ParserRULE_not_test = 51
	Python2ParserRULE_comparison = 52
	Python2ParserRULE_comp_op = 53
	Python2ParserRULE_expr = 54
	Python2ParserRULE_xor_expr = 55
	Python2ParserRULE_and_expr = 56
	Python2ParserRULE_shift_expr = 57
	Python2ParserRULE_arith_expr = 58
	Python2ParserRULE_term = 59
	Python2ParserRULE_factor = 60
	Python2ParserRULE_power = 61
	Python2ParserRULE_atom = 62
	Python2ParserRULE_listmaker = 63
	Python2ParserRULE_testlist_comp = 64
	Python2ParserRULE_lambdef = 65
	Python2ParserRULE_trailer = 66
	Python2ParserRULE_subscriptlist = 67
	Python2ParserRULE_subscript = 68
	Python2ParserRULE_sliceop = 69
	Python2ParserRULE_exprlist = 70
	Python2ParserRULE_testlist = 71
	Python2ParserRULE_dictorsetmaker = 72
	Python2ParserRULE_classdef = 73
	Python2ParserRULE_arglist = 74
	Python2ParserRULE_argument = 75
	Python2ParserRULE_list_iter = 76
	Python2ParserRULE_list_for = 77
	Python2ParserRULE_list_if = 78
	Python2ParserRULE_comp_iter = 79
	Python2ParserRULE_comp_for = 80
	Python2ParserRULE_comp_if = 81
	Python2ParserRULE_testlist1 = 82
	Python2ParserRULE_encoding_decl = 83
	Python2ParserRULE_yield_expr = 84
)

// ISingle_inputContext is an interface to support dynamic dispatch.
type ISingle_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingle_inputContext differentiates from other interfaces.
	IsSingle_inputContext()
}

type Single_inputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_inputContext() *Single_inputContext {
	var p = new(Single_inputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_single_input
	return p
}

func (*Single_inputContext) IsSingle_inputContext() {}

func NewSingle_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_inputContext {
	var p = new(Single_inputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_single_input

	return p
}

func (s *Single_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_inputContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python2ParserNEWLINE, 0)
}

func (s *Single_inputContext) Simple_stmt() ISimple_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *Single_inputContext) Compound_stmt() ICompound_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_stmtContext)
}

func (s *Single_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Single_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterSingle_input(s)
	}
}

func (s *Single_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitSingle_input(s)
	}
}

func (s *Single_inputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitSingle_input(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Single_input() (localctx ISingle_inputContext) {
	localctx = NewSingle_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, Python2ParserRULE_single_input)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(175)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(170)
			p.Match(Python2ParserNEWLINE)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(171)
			p.Simple_stmt()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(172)
			p.Compound_stmt()
		}
		{
			p.SetState(173)
			p.Match(Python2ParserNEWLINE)
		}

	}


	return localctx
}


// IFile_inputContext is an interface to support dynamic dispatch.
type IFile_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_inputContext differentiates from other interfaces.
	IsFile_inputContext()
}

type File_inputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_inputContext() *File_inputContext {
	var p = new(File_inputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_file_input
	return p
}

func (*File_inputContext) IsFile_inputContext() {}

func NewFile_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_inputContext {
	var p = new(File_inputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_file_input

	return p
}

func (s *File_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *File_inputContext) ENDMARKER() antlr.TerminalNode {
	return s.GetToken(Python2ParserENDMARKER, 0)
}

func (s *File_inputContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Python2ParserNEWLINE)
}

func (s *File_inputContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Python2ParserNEWLINE, i)
}

func (s *File_inputContext) AllStmt() []IStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStmtContext)(nil)).Elem())
	var tst = make([]IStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStmtContext)
		}
	}

	return tst
}

func (s *File_inputContext) Stmt(i int) IStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *File_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *File_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterFile_input(s)
	}
}

func (s *File_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitFile_input(s)
	}
}

func (s *File_inputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitFile_input(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) File_input() (localctx IFile_inputContext) {
	localctx = NewFile_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, Python2ParserRULE_file_input)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(181)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(179)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(177)
					p.Match(Python2ParserNEWLINE)
				}


			case 2:
				{
					p.SetState(178)
					p.Stmt()
				}

			}

		}
		p.SetState(183)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())
	}
	{
		p.SetState(184)
		p.Match(Python2ParserENDMARKER)
	}



	return localctx
}


// IEval_inputContext is an interface to support dynamic dispatch.
type IEval_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEval_inputContext differentiates from other interfaces.
	IsEval_inputContext()
}

type Eval_inputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEval_inputContext() *Eval_inputContext {
	var p = new(Eval_inputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_eval_input
	return p
}

func (*Eval_inputContext) IsEval_inputContext() {}

func NewEval_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Eval_inputContext {
	var p = new(Eval_inputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_eval_input

	return p
}

func (s *Eval_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *Eval_inputContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Eval_inputContext) ENDMARKER() antlr.TerminalNode {
	return s.GetToken(Python2ParserENDMARKER, 0)
}

func (s *Eval_inputContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Python2ParserNEWLINE)
}

func (s *Eval_inputContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Python2ParserNEWLINE, i)
}

func (s *Eval_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Eval_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Eval_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterEval_input(s)
	}
}

func (s *Eval_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitEval_input(s)
	}
}

func (s *Eval_inputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitEval_input(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Eval_input() (localctx IEval_inputContext) {
	localctx = NewEval_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, Python2ParserRULE_eval_input)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(186)
		p.Testlist()
	}
	p.SetState(190)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python2ParserNEWLINE {
		{
			p.SetState(187)
			p.Match(Python2ParserNEWLINE)
		}


		p.SetState(192)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(193)
		p.Match(Python2ParserENDMARKER)
	}



	return localctx
}


// IDecoratorContext is an interface to support dynamic dispatch.
type IDecoratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecoratorContext differentiates from other interfaces.
	IsDecoratorContext()
}

type DecoratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorContext() *DecoratorContext {
	var p = new(DecoratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_decorator
	return p
}

func (*DecoratorContext) IsDecoratorContext() {}

func NewDecoratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorContext {
	var p = new(DecoratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_decorator

	return p
}

func (s *DecoratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorContext) Dotted_name() IDotted_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *DecoratorContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python2ParserNEWLINE, 0)
}

func (s *DecoratorContext) Arglist() IArglistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArglistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *DecoratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DecoratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterDecorator(s)
	}
}

func (s *DecoratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitDecorator(s)
	}
}

func (s *DecoratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitDecorator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Decorator() (localctx IDecoratorContext) {
	localctx = NewDecoratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, Python2ParserRULE_decorator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(195)
		p.Match(Python2ParserT__0)
	}
	{
		p.SetState(196)
		p.Dotted_name()
	}
	p.SetState(202)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserOPEN_PAREN {
		{
			p.SetState(197)
			p.Match(Python2ParserOPEN_PAREN)
		}
		p.SetState(199)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python2ParserT__5) | (1 << Python2ParserT__6) | (1 << Python2ParserT__29))) != 0) || ((((_la - 45)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 45))) & ((1 << (Python2ParserT__44 - 45)) | (1 << (Python2ParserT__47 - 45)) | (1 << (Python2ParserT__60 - 45)) | (1 << (Python2ParserT__61 - 45)) | (1 << (Python2ParserT__65 - 45)) | (1 << (Python2ParserT__66 - 45)) | (1 << (Python2ParserNAME - 45)) | (1 << (Python2ParserNUMBER - 45)) | (1 << (Python2ParserSTRING - 45)) | (1 << (Python2ParserOPEN_PAREN - 45)))) != 0) || _la == Python2ParserOPEN_BRACE || _la == Python2ParserOPEN_BRACKET {
			{
				p.SetState(198)
				p.Arglist()
			}

		}
		{
			p.SetState(201)
			p.Match(Python2ParserCLOSE_PAREN)
		}

	}
	{
		p.SetState(204)
		p.Match(Python2ParserNEWLINE)
	}



	return localctx
}


// IDecoratorsContext is an interface to support dynamic dispatch.
type IDecoratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecoratorsContext differentiates from other interfaces.
	IsDecoratorsContext()
}

type DecoratorsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorsContext() *DecoratorsContext {
	var p = new(DecoratorsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_decorators
	return p
}

func (*DecoratorsContext) IsDecoratorsContext() {}

func NewDecoratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorsContext {
	var p = new(DecoratorsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_decorators

	return p
}

func (s *DecoratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorsContext) AllDecorator() []IDecoratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDecoratorContext)(nil)).Elem())
	var tst = make([]IDecoratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDecoratorContext)
		}
	}

	return tst
}

func (s *DecoratorsContext) Decorator(i int) IDecoratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecoratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDecoratorContext)
}

func (s *DecoratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DecoratorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterDecorators(s)
	}
}

func (s *DecoratorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitDecorators(s)
	}
}

func (s *DecoratorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitDecorators(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Decorators() (localctx IDecoratorsContext) {
	localctx = NewDecoratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, Python2ParserRULE_decorators)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(207)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == Python2ParserT__0 {
		{
			p.SetState(206)
			p.Decorator()
		}


		p.SetState(209)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IDecoratedContext is an interface to support dynamic dispatch.
type IDecoratedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecoratedContext differentiates from other interfaces.
	IsDecoratedContext()
}

type DecoratedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratedContext() *DecoratedContext {
	var p = new(DecoratedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_decorated
	return p
}

func (*DecoratedContext) IsDecoratedContext() {}

func NewDecoratedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratedContext {
	var p = new(DecoratedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_decorated

	return p
}

func (s *DecoratedContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratedContext) Decorators() IDecoratorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecoratorsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecoratorsContext)
}

func (s *DecoratedContext) Classdef() IClassdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassdefContext)
}

func (s *DecoratedContext) Funcdef() IFuncdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *DecoratedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DecoratedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterDecorated(s)
	}
}

func (s *DecoratedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitDecorated(s)
	}
}

func (s *DecoratedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitDecorated(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Decorated() (localctx IDecoratedContext) {
	localctx = NewDecoratedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, Python2ParserRULE_decorated)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(211)
		p.Decorators()
	}
	p.SetState(214)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserT__67:
		{
			p.SetState(212)
			p.Classdef()
		}


	case Python2ParserT__1:
		{
			p.SetState(213)
			p.Funcdef()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IFuncdefContext is an interface to support dynamic dispatch.
type IFuncdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFuncdefContext differentiates from other interfaces.
	IsFuncdefContext()
}

type FuncdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncdefContext() *FuncdefContext {
	var p = new(FuncdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_funcdef
	return p
}

func (*FuncdefContext) IsFuncdefContext() {}

func NewFuncdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncdefContext {
	var p = new(FuncdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_funcdef

	return p
}

func (s *FuncdefContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python2ParserNAME, 0)
}

func (s *FuncdefContext) Parameters() IParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FuncdefContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *FuncdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FuncdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterFuncdef(s)
	}
}

func (s *FuncdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitFuncdef(s)
	}
}

func (s *FuncdefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitFuncdef(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Funcdef() (localctx IFuncdefContext) {
	localctx = NewFuncdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, Python2ParserRULE_funcdef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(216)
		p.Match(Python2ParserT__1)
	}
	{
		p.SetState(217)
		p.Match(Python2ParserNAME)
	}
	{
		p.SetState(218)
		p.Parameters()
	}
	{
		p.SetState(219)
		p.Match(Python2ParserT__2)
	}
	{
		p.SetState(220)
		p.Suite()
	}



	return localctx
}


// IParametersContext is an interface to support dynamic dispatch.
type IParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParametersContext differentiates from other interfaces.
	IsParametersContext()
}

type ParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersContext() *ParametersContext {
	var p = new(ParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_parameters
	return p
}

func (*ParametersContext) IsParametersContext() {}

func NewParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersContext {
	var p = new(ParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_parameters

	return p
}

func (s *ParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersContext) Varargslist() IVarargslistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarargslistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarargslistContext)
}

func (s *ParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterParameters(s)
	}
}

func (s *ParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitParameters(s)
	}
}

func (s *ParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitParameters(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Parameters() (localctx IParametersContext) {
	localctx = NewParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, Python2ParserRULE_parameters)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(222)
		p.Match(Python2ParserOPEN_PAREN)
	}
	p.SetState(224)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__5 || _la == Python2ParserT__6 || _la == Python2ParserNAME || _la == Python2ParserOPEN_PAREN {
		{
			p.SetState(223)
			p.Varargslist()
		}

	}
	{
		p.SetState(226)
		p.Match(Python2ParserCLOSE_PAREN)
	}



	return localctx
}


// IVarargslistContext is an interface to support dynamic dispatch.
type IVarargslistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarargslistContext differentiates from other interfaces.
	IsVarargslistContext()
}

type VarargslistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarargslistContext() *VarargslistContext {
	var p = new(VarargslistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_varargslist
	return p
}

func (*VarargslistContext) IsVarargslistContext() {}

func NewVarargslistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarargslistContext {
	var p = new(VarargslistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_varargslist

	return p
}

func (s *VarargslistContext) GetParser() antlr.Parser { return s.parser }

func (s *VarargslistContext) AllFpdef() []IFpdefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFpdefContext)(nil)).Elem())
	var tst = make([]IFpdefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFpdefContext)
		}
	}

	return tst
}

func (s *VarargslistContext) Fpdef(i int) IFpdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFpdefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFpdefContext)
}

func (s *VarargslistContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(Python2ParserNAME)
}

func (s *VarargslistContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(Python2ParserNAME, i)
}

func (s *VarargslistContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *VarargslistContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *VarargslistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarargslistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VarargslistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterVarargslist(s)
	}
}

func (s *VarargslistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitVarargslist(s)
	}
}

func (s *VarargslistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitVarargslist(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Varargslist() (localctx IVarargslistContext) {
	localctx = NewVarargslistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, Python2ParserRULE_varargslist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(270)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.SetState(237)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == Python2ParserNAME || _la == Python2ParserOPEN_PAREN {
			{
				p.SetState(228)
				p.Fpdef()
			}
			p.SetState(231)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == Python2ParserT__3 {
				{
					p.SetState(229)
					p.Match(Python2ParserT__3)
				}
				{
					p.SetState(230)
					p.Test()
				}

			}
			{
				p.SetState(233)
				p.Match(Python2ParserT__4)
			}


			p.SetState(239)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(249)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python2ParserT__5:
			{
				p.SetState(240)
				p.Match(Python2ParserT__5)
			}
			{
				p.SetState(241)
				p.Match(Python2ParserNAME)
			}
			p.SetState(245)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == Python2ParserT__4 {
				{
					p.SetState(242)
					p.Match(Python2ParserT__4)
				}
				{
					p.SetState(243)
					p.Match(Python2ParserT__6)
				}
				{
					p.SetState(244)
					p.Match(Python2ParserNAME)
				}

			}


		case Python2ParserT__6:
			{
				p.SetState(247)
				p.Match(Python2ParserT__6)
			}
			{
				p.SetState(248)
				p.Match(Python2ParserNAME)
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}


	case 2:
		{
			p.SetState(251)
			p.Fpdef()
		}
		p.SetState(254)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python2ParserT__3 {
			{
				p.SetState(252)
				p.Match(Python2ParserT__3)
			}
			{
				p.SetState(253)
				p.Test()
			}

		}
		p.SetState(264)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(256)
					p.Match(Python2ParserT__4)
				}
				{
					p.SetState(257)
					p.Fpdef()
				}
				p.SetState(260)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == Python2ParserT__3 {
					{
						p.SetState(258)
						p.Match(Python2ParserT__3)
					}
					{
						p.SetState(259)
						p.Test()
					}

				}


			}
			p.SetState(266)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext())
		}
		p.SetState(268)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python2ParserT__4 {
			{
				p.SetState(267)
				p.Match(Python2ParserT__4)
			}

		}

	}



	return localctx
}


// IFpdefContext is an interface to support dynamic dispatch.
type IFpdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFpdefContext differentiates from other interfaces.
	IsFpdefContext()
}

type FpdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFpdefContext() *FpdefContext {
	var p = new(FpdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_fpdef
	return p
}

func (*FpdefContext) IsFpdefContext() {}

func NewFpdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FpdefContext {
	var p = new(FpdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_fpdef

	return p
}

func (s *FpdefContext) GetParser() antlr.Parser { return s.parser }

func (s *FpdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python2ParserNAME, 0)
}

func (s *FpdefContext) Fplist() IFplistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFplistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFplistContext)
}

func (s *FpdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FpdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FpdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterFpdef(s)
	}
}

func (s *FpdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitFpdef(s)
	}
}

func (s *FpdefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitFpdef(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Fpdef() (localctx IFpdefContext) {
	localctx = NewFpdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, Python2ParserRULE_fpdef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(277)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(272)
			p.Match(Python2ParserNAME)
		}


	case Python2ParserOPEN_PAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(273)
			p.Match(Python2ParserOPEN_PAREN)
		}
		{
			p.SetState(274)
			p.Fplist()
		}
		{
			p.SetState(275)
			p.Match(Python2ParserCLOSE_PAREN)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IFplistContext is an interface to support dynamic dispatch.
type IFplistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFplistContext differentiates from other interfaces.
	IsFplistContext()
}

type FplistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFplistContext() *FplistContext {
	var p = new(FplistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_fplist
	return p
}

func (*FplistContext) IsFplistContext() {}

func NewFplistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FplistContext {
	var p = new(FplistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_fplist

	return p
}

func (s *FplistContext) GetParser() antlr.Parser { return s.parser }

func (s *FplistContext) AllFpdef() []IFpdefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFpdefContext)(nil)).Elem())
	var tst = make([]IFpdefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFpdefContext)
		}
	}

	return tst
}

func (s *FplistContext) Fpdef(i int) IFpdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFpdefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFpdefContext)
}

func (s *FplistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FplistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FplistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterFplist(s)
	}
}

func (s *FplistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitFplist(s)
	}
}

func (s *FplistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitFplist(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Fplist() (localctx IFplistContext) {
	localctx = NewFplistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, Python2ParserRULE_fplist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(279)
		p.Fpdef()
	}
	p.SetState(284)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(280)
				p.Match(Python2ParserT__4)
			}
			{
				p.SetState(281)
				p.Fpdef()
			}


		}
		p.SetState(286)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())
	}
	p.SetState(288)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__4 {
		{
			p.SetState(287)
			p.Match(Python2ParserT__4)
		}

	}



	return localctx
}


// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_stmt
	return p
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) Simple_stmt() ISimple_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *StmtContext) Compound_stmt() ICompound_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_stmtContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitStmt(s)
	}
}

func (s *StmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, Python2ParserRULE_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(292)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(290)
			p.Simple_stmt()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(291)
			p.Compound_stmt()
		}

	}


	return localctx
}


// ISimple_stmtContext is an interface to support dynamic dispatch.
type ISimple_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_stmtContext differentiates from other interfaces.
	IsSimple_stmtContext()
}

type Simple_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_stmtContext() *Simple_stmtContext {
	var p = new(Simple_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_simple_stmt
	return p
}

func (*Simple_stmtContext) IsSimple_stmtContext() {}

func NewSimple_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_stmtContext {
	var p = new(Simple_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_simple_stmt

	return p
}

func (s *Simple_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_stmtContext) AllSmall_stmt() []ISmall_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISmall_stmtContext)(nil)).Elem())
	var tst = make([]ISmall_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISmall_stmtContext)
		}
	}

	return tst
}

func (s *Simple_stmtContext) Small_stmt(i int) ISmall_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISmall_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISmall_stmtContext)
}

func (s *Simple_stmtContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python2ParserNEWLINE, 0)
}

func (s *Simple_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Simple_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterSimple_stmt(s)
	}
}

func (s *Simple_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitSimple_stmt(s)
	}
}

func (s *Simple_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitSimple_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Simple_stmt() (localctx ISimple_stmtContext) {
	localctx = NewSimple_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, Python2ParserRULE_simple_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(294)
		p.Small_stmt()
	}
	p.SetState(299)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(295)
				p.Match(Python2ParserT__7)
			}
			{
				p.SetState(296)
				p.Small_stmt()
			}


		}
		p.SetState(301)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())
	}
	p.SetState(303)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__7 {
		{
			p.SetState(302)
			p.Match(Python2ParserT__7)
		}

	}
	{
		p.SetState(305)
		p.Match(Python2ParserNEWLINE)
	}



	return localctx
}


// ISmall_stmtContext is an interface to support dynamic dispatch.
type ISmall_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSmall_stmtContext differentiates from other interfaces.
	IsSmall_stmtContext()
}

type Small_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySmall_stmtContext() *Small_stmtContext {
	var p = new(Small_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_small_stmt
	return p
}

func (*Small_stmtContext) IsSmall_stmtContext() {}

func NewSmall_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Small_stmtContext {
	var p = new(Small_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_small_stmt

	return p
}

func (s *Small_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Small_stmtContext) Expr_stmt() IExpr_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_stmtContext)
}

func (s *Small_stmtContext) Print_stmt() IPrint_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrint_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrint_stmtContext)
}

func (s *Small_stmtContext) Del_stmt() IDel_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDel_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDel_stmtContext)
}

func (s *Small_stmtContext) Pass_stmt() IPass_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_stmtContext)
}

func (s *Small_stmtContext) Flow_stmt() IFlow_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_stmtContext)
}

func (s *Small_stmtContext) Import_stmt() IImport_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_stmtContext)
}

func (s *Small_stmtContext) Global_stmt() IGlobal_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobal_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobal_stmtContext)
}

func (s *Small_stmtContext) Exec_stmt() IExec_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExec_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExec_stmtContext)
}

func (s *Small_stmtContext) Assert_stmt() IAssert_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssert_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssert_stmtContext)
}

func (s *Small_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Small_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Small_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterSmall_stmt(s)
	}
}

func (s *Small_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitSmall_stmt(s)
	}
}

func (s *Small_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitSmall_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Small_stmt() (localctx ISmall_stmtContext) {
	localctx = NewSmall_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, Python2ParserRULE_small_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(316)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(307)
			p.Expr_stmt()
		}


	case 2:
		{
			p.SetState(308)
			p.Print_stmt()
		}


	case 3:
		{
			p.SetState(309)
			p.Del_stmt()
		}


	case 4:
		{
			p.SetState(310)
			p.Pass_stmt()
		}


	case 5:
		{
			p.SetState(311)
			p.Flow_stmt()
		}


	case 6:
		{
			p.SetState(312)
			p.Import_stmt()
		}


	case 7:
		{
			p.SetState(313)
			p.Global_stmt()
		}


	case 8:
		{
			p.SetState(314)
			p.Exec_stmt()
		}


	case 9:
		{
			p.SetState(315)
			p.Assert_stmt()
		}

	}



	return localctx
}


// IExpr_stmtContext is an interface to support dynamic dispatch.
type IExpr_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_stmtContext differentiates from other interfaces.
	IsExpr_stmtContext()
}

type Expr_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_stmtContext() *Expr_stmtContext {
	var p = new(Expr_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_expr_stmt
	return p
}

func (*Expr_stmtContext) IsExpr_stmtContext() {}

func NewExpr_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_stmtContext {
	var p = new(Expr_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_expr_stmt

	return p
}

func (s *Expr_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_stmtContext) AllTestlist() []ITestlistContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestlistContext)(nil)).Elem())
	var tst = make([]ITestlistContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestlistContext)
		}
	}

	return tst
}

func (s *Expr_stmtContext) Testlist(i int) ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Expr_stmtContext) Augassign() IAugassignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAugassignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAugassignContext)
}

func (s *Expr_stmtContext) AllYield_expr() []IYield_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IYield_exprContext)(nil)).Elem())
	var tst = make([]IYield_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IYield_exprContext)
		}
	}

	return tst
}

func (s *Expr_stmtContext) Yield_expr(i int) IYield_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *Expr_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitExpr_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Expr_stmt() (localctx IExpr_stmtContext) {
	localctx = NewExpr_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, Python2ParserRULE_expr_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(318)
		p.Testlist()
	}
	p.SetState(334)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserT__8, Python2ParserT__9, Python2ParserT__10, Python2ParserT__11, Python2ParserT__12, Python2ParserT__13, Python2ParserT__14, Python2ParserT__15, Python2ParserT__16, Python2ParserT__17, Python2ParserT__18, Python2ParserT__19:
		{
			p.SetState(319)
			p.Augassign()
		}
		p.SetState(322)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python2ParserT__68:
			{
				p.SetState(320)
				p.Yield_expr()
			}


		case Python2ParserT__29, Python2ParserT__44, Python2ParserT__47, Python2ParserT__60, Python2ParserT__61, Python2ParserT__65, Python2ParserT__66, Python2ParserNAME, Python2ParserNUMBER, Python2ParserSTRING, Python2ParserOPEN_PAREN, Python2ParserOPEN_BRACE, Python2ParserOPEN_BRACKET:
			{
				p.SetState(321)
				p.Testlist()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}


	case Python2ParserT__3, Python2ParserT__7, Python2ParserNEWLINE:
		p.SetState(331)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == Python2ParserT__3 {
			{
				p.SetState(324)
				p.Match(Python2ParserT__3)
			}
			p.SetState(327)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Python2ParserT__68:
				{
					p.SetState(325)
					p.Yield_expr()
				}


			case Python2ParserT__29, Python2ParserT__44, Python2ParserT__47, Python2ParserT__60, Python2ParserT__61, Python2ParserT__65, Python2ParserT__66, Python2ParserNAME, Python2ParserNUMBER, Python2ParserSTRING, Python2ParserOPEN_PAREN, Python2ParserOPEN_BRACE, Python2ParserOPEN_BRACKET:
				{
					p.SetState(326)
					p.Testlist()
				}



			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}


			p.SetState(333)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IAugassignContext is an interface to support dynamic dispatch.
type IAugassignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAugassignContext differentiates from other interfaces.
	IsAugassignContext()
}

type AugassignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAugassignContext() *AugassignContext {
	var p = new(AugassignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_augassign
	return p
}

func (*AugassignContext) IsAugassignContext() {}

func NewAugassignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AugassignContext {
	var p = new(AugassignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_augassign

	return p
}

func (s *AugassignContext) GetParser() antlr.Parser { return s.parser }
func (s *AugassignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AugassignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AugassignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterAugassign(s)
	}
}

func (s *AugassignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitAugassign(s)
	}
}

func (s *AugassignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitAugassign(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Augassign() (localctx IAugassignContext) {
	localctx = NewAugassignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, Python2ParserRULE_augassign)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(336)
	_la = p.GetTokenStream().LA(1)

	if !((((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python2ParserT__8) | (1 << Python2ParserT__9) | (1 << Python2ParserT__10) | (1 << Python2ParserT__11) | (1 << Python2ParserT__12) | (1 << Python2ParserT__13) | (1 << Python2ParserT__14) | (1 << Python2ParserT__15) | (1 << Python2ParserT__16) | (1 << Python2ParserT__17) | (1 << Python2ParserT__18) | (1 << Python2ParserT__19))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}



	return localctx
}


// IPrint_stmtContext is an interface to support dynamic dispatch.
type IPrint_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrint_stmtContext differentiates from other interfaces.
	IsPrint_stmtContext()
}

type Print_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrint_stmtContext() *Print_stmtContext {
	var p = new(Print_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_print_stmt
	return p
}

func (*Print_stmtContext) IsPrint_stmtContext() {}

func NewPrint_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Print_stmtContext {
	var p = new(Print_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_print_stmt

	return p
}

func (s *Print_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Print_stmtContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python2ParserNAME, 0)
}

func (s *Print_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Print_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Print_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Print_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Print_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterPrint_stmt(s)
	}
}

func (s *Print_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitPrint_stmt(s)
	}
}

func (s *Print_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitPrint_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Print_stmt() (localctx IPrint_stmtContext) {
	localctx = NewPrint_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, Python2ParserRULE_print_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(338)

	if !(self._input.LT(1).text=='print') {
		panic(antlr.NewFailedPredicateException(p, "self._input.LT(1).text=='print'", ""))
	}
	{
		p.SetState(339)
		p.Match(Python2ParserNAME)
	}
	p.SetState(366)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserT__7, Python2ParserT__29, Python2ParserT__44, Python2ParserT__47, Python2ParserT__60, Python2ParserT__61, Python2ParserT__65, Python2ParserT__66, Python2ParserNAME, Python2ParserNUMBER, Python2ParserSTRING, Python2ParserOPEN_PAREN, Python2ParserOPEN_BRACE, Python2ParserOPEN_BRACKET, Python2ParserNEWLINE:
		p.SetState(351)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 30)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 30))) & ((1 << (Python2ParserT__29 - 30)) | (1 << (Python2ParserT__44 - 30)) | (1 << (Python2ParserT__47 - 30)) | (1 << (Python2ParserT__60 - 30)))) != 0) || ((((_la - 62)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 62))) & ((1 << (Python2ParserT__61 - 62)) | (1 << (Python2ParserT__65 - 62)) | (1 << (Python2ParserT__66 - 62)) | (1 << (Python2ParserNAME - 62)) | (1 << (Python2ParserNUMBER - 62)) | (1 << (Python2ParserSTRING - 62)) | (1 << (Python2ParserOPEN_PAREN - 62)) | (1 << (Python2ParserOPEN_BRACE - 62)) | (1 << (Python2ParserOPEN_BRACKET - 62)))) != 0) {
			{
				p.SetState(340)
				p.Test()
			}
			p.SetState(345)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(341)
						p.Match(Python2ParserT__4)
					}
					{
						p.SetState(342)
						p.Test()
					}


				}
				p.SetState(347)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())
			}
			p.SetState(349)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == Python2ParserT__4 {
				{
					p.SetState(348)
					p.Match(Python2ParserT__4)
				}

			}

		}


	case Python2ParserT__20:
		{
			p.SetState(353)
			p.Match(Python2ParserT__20)
		}
		{
			p.SetState(354)
			p.Test()
		}
		p.SetState(364)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python2ParserT__4 {
			p.SetState(357)
			p.GetErrorHandler().Sync(p)
			_alt = 1
			for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				switch _alt {
				case 1:
						{
							p.SetState(355)
							p.Match(Python2ParserT__4)
						}
						{
							p.SetState(356)
							p.Test()
						}




				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

				p.SetState(359)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext())
			}
			p.SetState(362)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == Python2ParserT__4 {
				{
					p.SetState(361)
					p.Match(Python2ParserT__4)
				}

			}

		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IDel_stmtContext is an interface to support dynamic dispatch.
type IDel_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDel_stmtContext differentiates from other interfaces.
	IsDel_stmtContext()
}

type Del_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDel_stmtContext() *Del_stmtContext {
	var p = new(Del_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_del_stmt
	return p
}

func (*Del_stmtContext) IsDel_stmtContext() {}

func NewDel_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Del_stmtContext {
	var p = new(Del_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_del_stmt

	return p
}

func (s *Del_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Del_stmtContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *Del_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Del_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Del_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterDel_stmt(s)
	}
}

func (s *Del_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitDel_stmt(s)
	}
}

func (s *Del_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitDel_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Del_stmt() (localctx IDel_stmtContext) {
	localctx = NewDel_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, Python2ParserRULE_del_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(368)
		p.Match(Python2ParserT__21)
	}
	{
		p.SetState(369)
		p.Exprlist()
	}



	return localctx
}


// IPass_stmtContext is an interface to support dynamic dispatch.
type IPass_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_stmtContext differentiates from other interfaces.
	IsPass_stmtContext()
}

type Pass_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_stmtContext() *Pass_stmtContext {
	var p = new(Pass_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_pass_stmt
	return p
}

func (*Pass_stmtContext) IsPass_stmtContext() {}

func NewPass_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_stmtContext {
	var p = new(Pass_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_pass_stmt

	return p
}

func (s *Pass_stmtContext) GetParser() antlr.Parser { return s.parser }
func (s *Pass_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Pass_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterPass_stmt(s)
	}
}

func (s *Pass_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitPass_stmt(s)
	}
}

func (s *Pass_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitPass_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Pass_stmt() (localctx IPass_stmtContext) {
	localctx = NewPass_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, Python2ParserRULE_pass_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(371)
		p.Match(Python2ParserT__22)
	}



	return localctx
}


// IFlow_stmtContext is an interface to support dynamic dispatch.
type IFlow_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_stmtContext differentiates from other interfaces.
	IsFlow_stmtContext()
}

type Flow_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_stmtContext() *Flow_stmtContext {
	var p = new(Flow_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_flow_stmt
	return p
}

func (*Flow_stmtContext) IsFlow_stmtContext() {}

func NewFlow_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_stmtContext {
	var p = new(Flow_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_flow_stmt

	return p
}

func (s *Flow_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Flow_stmtContext) Break_stmt() IBreak_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreak_stmtContext)
}

func (s *Flow_stmtContext) Continue_stmt() IContinue_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinue_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinue_stmtContext)
}

func (s *Flow_stmtContext) Return_stmt() IReturn_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturn_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturn_stmtContext)
}

func (s *Flow_stmtContext) Raise_stmt() IRaise_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRaise_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRaise_stmtContext)
}

func (s *Flow_stmtContext) Yield_stmt() IYield_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_stmtContext)
}

func (s *Flow_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Flow_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterFlow_stmt(s)
	}
}

func (s *Flow_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitFlow_stmt(s)
	}
}

func (s *Flow_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitFlow_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Flow_stmt() (localctx IFlow_stmtContext) {
	localctx = NewFlow_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, Python2ParserRULE_flow_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(378)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserT__23:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(373)
			p.Break_stmt()
		}


	case Python2ParserT__24:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(374)
			p.Continue_stmt()
		}


	case Python2ParserT__25:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(375)
			p.Return_stmt()
		}


	case Python2ParserT__26:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(376)
			p.Raise_stmt()
		}


	case Python2ParserT__68:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(377)
			p.Yield_stmt()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IBreak_stmtContext is an interface to support dynamic dispatch.
type IBreak_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreak_stmtContext differentiates from other interfaces.
	IsBreak_stmtContext()
}

type Break_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_stmtContext() *Break_stmtContext {
	var p = new(Break_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_break_stmt
	return p
}

func (*Break_stmtContext) IsBreak_stmtContext() {}

func NewBreak_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_stmtContext {
	var p = new(Break_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_break_stmt

	return p
}

func (s *Break_stmtContext) GetParser() antlr.Parser { return s.parser }
func (s *Break_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Break_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterBreak_stmt(s)
	}
}

func (s *Break_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitBreak_stmt(s)
	}
}

func (s *Break_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitBreak_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Break_stmt() (localctx IBreak_stmtContext) {
	localctx = NewBreak_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, Python2ParserRULE_break_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(380)
		p.Match(Python2ParserT__23)
	}



	return localctx
}


// IContinue_stmtContext is an interface to support dynamic dispatch.
type IContinue_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinue_stmtContext differentiates from other interfaces.
	IsContinue_stmtContext()
}

type Continue_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinue_stmtContext() *Continue_stmtContext {
	var p = new(Continue_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_continue_stmt
	return p
}

func (*Continue_stmtContext) IsContinue_stmtContext() {}

func NewContinue_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Continue_stmtContext {
	var p = new(Continue_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_continue_stmt

	return p
}

func (s *Continue_stmtContext) GetParser() antlr.Parser { return s.parser }
func (s *Continue_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Continue_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Continue_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterContinue_stmt(s)
	}
}

func (s *Continue_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitContinue_stmt(s)
	}
}

func (s *Continue_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitContinue_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Continue_stmt() (localctx IContinue_stmtContext) {
	localctx = NewContinue_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, Python2ParserRULE_continue_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(382)
		p.Match(Python2ParserT__24)
	}



	return localctx
}


// IReturn_stmtContext is an interface to support dynamic dispatch.
type IReturn_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturn_stmtContext differentiates from other interfaces.
	IsReturn_stmtContext()
}

type Return_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_stmtContext() *Return_stmtContext {
	var p = new(Return_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_return_stmt
	return p
}

func (*Return_stmtContext) IsReturn_stmtContext() {}

func NewReturn_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_stmtContext {
	var p = new(Return_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_return_stmt

	return p
}

func (s *Return_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_stmtContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Return_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Return_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterReturn_stmt(s)
	}
}

func (s *Return_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitReturn_stmt(s)
	}
}

func (s *Return_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitReturn_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Return_stmt() (localctx IReturn_stmtContext) {
	localctx = NewReturn_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, Python2ParserRULE_return_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(384)
		p.Match(Python2ParserT__25)
	}
	p.SetState(386)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 30)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 30))) & ((1 << (Python2ParserT__29 - 30)) | (1 << (Python2ParserT__44 - 30)) | (1 << (Python2ParserT__47 - 30)) | (1 << (Python2ParserT__60 - 30)))) != 0) || ((((_la - 62)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 62))) & ((1 << (Python2ParserT__61 - 62)) | (1 << (Python2ParserT__65 - 62)) | (1 << (Python2ParserT__66 - 62)) | (1 << (Python2ParserNAME - 62)) | (1 << (Python2ParserNUMBER - 62)) | (1 << (Python2ParserSTRING - 62)) | (1 << (Python2ParserOPEN_PAREN - 62)) | (1 << (Python2ParserOPEN_BRACE - 62)) | (1 << (Python2ParserOPEN_BRACKET - 62)))) != 0) {
		{
			p.SetState(385)
			p.Testlist()
		}

	}



	return localctx
}


// IYield_stmtContext is an interface to support dynamic dispatch.
type IYield_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYield_stmtContext differentiates from other interfaces.
	IsYield_stmtContext()
}

type Yield_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_stmtContext() *Yield_stmtContext {
	var p = new(Yield_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_yield_stmt
	return p
}

func (*Yield_stmtContext) IsYield_stmtContext() {}

func NewYield_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_stmtContext {
	var p = new(Yield_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_yield_stmt

	return p
}

func (s *Yield_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_stmtContext) Yield_expr() IYield_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *Yield_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Yield_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterYield_stmt(s)
	}
}

func (s *Yield_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitYield_stmt(s)
	}
}

func (s *Yield_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitYield_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Yield_stmt() (localctx IYield_stmtContext) {
	localctx = NewYield_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, Python2ParserRULE_yield_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(388)
		p.Yield_expr()
	}



	return localctx
}


// IRaise_stmtContext is an interface to support dynamic dispatch.
type IRaise_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRaise_stmtContext differentiates from other interfaces.
	IsRaise_stmtContext()
}

type Raise_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaise_stmtContext() *Raise_stmtContext {
	var p = new(Raise_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_raise_stmt
	return p
}

func (*Raise_stmtContext) IsRaise_stmtContext() {}

func NewRaise_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Raise_stmtContext {
	var p = new(Raise_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_raise_stmt

	return p
}

func (s *Raise_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Raise_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Raise_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Raise_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raise_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Raise_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterRaise_stmt(s)
	}
}

func (s *Raise_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitRaise_stmt(s)
	}
}

func (s *Raise_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitRaise_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Raise_stmt() (localctx IRaise_stmtContext) {
	localctx = NewRaise_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, Python2ParserRULE_raise_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(390)
		p.Match(Python2ParserT__26)
	}
	p.SetState(400)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 30)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 30))) & ((1 << (Python2ParserT__29 - 30)) | (1 << (Python2ParserT__44 - 30)) | (1 << (Python2ParserT__47 - 30)) | (1 << (Python2ParserT__60 - 30)))) != 0) || ((((_la - 62)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 62))) & ((1 << (Python2ParserT__61 - 62)) | (1 << (Python2ParserT__65 - 62)) | (1 << (Python2ParserT__66 - 62)) | (1 << (Python2ParserNAME - 62)) | (1 << (Python2ParserNUMBER - 62)) | (1 << (Python2ParserSTRING - 62)) | (1 << (Python2ParserOPEN_PAREN - 62)) | (1 << (Python2ParserOPEN_BRACE - 62)) | (1 << (Python2ParserOPEN_BRACKET - 62)))) != 0) {
		{
			p.SetState(391)
			p.Test()
		}
		p.SetState(398)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python2ParserT__4 {
			{
				p.SetState(392)
				p.Match(Python2ParserT__4)
			}
			{
				p.SetState(393)
				p.Test()
			}
			p.SetState(396)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == Python2ParserT__4 {
				{
					p.SetState(394)
					p.Match(Python2ParserT__4)
				}
				{
					p.SetState(395)
					p.Test()
				}

			}

		}

	}



	return localctx
}


// IImport_stmtContext is an interface to support dynamic dispatch.
type IImport_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_stmtContext differentiates from other interfaces.
	IsImport_stmtContext()
}

type Import_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_stmtContext() *Import_stmtContext {
	var p = new(Import_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_import_stmt
	return p
}

func (*Import_stmtContext) IsImport_stmtContext() {}

func NewImport_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_stmtContext {
	var p = new(Import_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_import_stmt

	return p
}

func (s *Import_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_stmtContext) Import_name() IImport_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_nameContext)
}

func (s *Import_stmtContext) Import_from() IImport_fromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_fromContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_fromContext)
}

func (s *Import_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Import_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterImport_stmt(s)
	}
}

func (s *Import_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitImport_stmt(s)
	}
}

func (s *Import_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitImport_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Import_stmt() (localctx IImport_stmtContext) {
	localctx = NewImport_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, Python2ParserRULE_import_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(404)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserT__27:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(402)
			p.Import_name()
		}


	case Python2ParserT__28:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(403)
			p.Import_from()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IImport_nameContext is an interface to support dynamic dispatch.
type IImport_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_nameContext differentiates from other interfaces.
	IsImport_nameContext()
}

type Import_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_nameContext() *Import_nameContext {
	var p = new(Import_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_import_name
	return p
}

func (*Import_nameContext) IsImport_nameContext() {}

func NewImport_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_nameContext {
	var p = new(Import_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_import_name

	return p
}

func (s *Import_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_nameContext) Dotted_as_names() IDotted_as_namesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_as_namesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_as_namesContext)
}

func (s *Import_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Import_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterImport_name(s)
	}
}

func (s *Import_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitImport_name(s)
	}
}

func (s *Import_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitImport_name(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Import_name() (localctx IImport_nameContext) {
	localctx = NewImport_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, Python2ParserRULE_import_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(406)
		p.Match(Python2ParserT__27)
	}
	{
		p.SetState(407)
		p.Dotted_as_names()
	}



	return localctx
}


// IImport_fromContext is an interface to support dynamic dispatch.
type IImport_fromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_fromContext differentiates from other interfaces.
	IsImport_fromContext()
}

type Import_fromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_fromContext() *Import_fromContext {
	var p = new(Import_fromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_import_from
	return p
}

func (*Import_fromContext) IsImport_fromContext() {}

func NewImport_fromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_fromContext {
	var p = new(Import_fromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_import_from

	return p
}

func (s *Import_fromContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_fromContext) Dotted_name() IDotted_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *Import_fromContext) Import_as_names() IImport_as_namesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_as_namesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_as_namesContext)
}

func (s *Import_fromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_fromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Import_fromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterImport_from(s)
	}
}

func (s *Import_fromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitImport_from(s)
	}
}

func (s *Import_fromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitImport_from(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Import_from() (localctx IImport_fromContext) {
	localctx = NewImport_fromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, Python2ParserRULE_import_from)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(409)
		p.Match(Python2ParserT__28)
	}
	p.SetState(422)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.SetState(413)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == Python2ParserT__29 {
			{
				p.SetState(410)
				p.Match(Python2ParserT__29)
			}


			p.SetState(415)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(416)
			p.Dotted_name()
		}


	case 2:
		p.SetState(418)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == Python2ParserT__29 {
			{
				p.SetState(417)
				p.Match(Python2ParserT__29)
			}


			p.SetState(420)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(424)
		p.Match(Python2ParserT__27)
	}
	p.SetState(431)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserT__5:
		{
			p.SetState(425)
			p.Match(Python2ParserT__5)
		}


	case Python2ParserOPEN_PAREN:
		{
			p.SetState(426)
			p.Match(Python2ParserOPEN_PAREN)
		}
		{
			p.SetState(427)
			p.Import_as_names()
		}
		{
			p.SetState(428)
			p.Match(Python2ParserCLOSE_PAREN)
		}


	case Python2ParserNAME:
		{
			p.SetState(430)
			p.Import_as_names()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}




	return localctx
}


// IImport_as_nameContext is an interface to support dynamic dispatch.
type IImport_as_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_as_nameContext differentiates from other interfaces.
	IsImport_as_nameContext()
}

type Import_as_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_as_nameContext() *Import_as_nameContext {
	var p = new(Import_as_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_import_as_name
	return p
}

func (*Import_as_nameContext) IsImport_as_nameContext() {}

func NewImport_as_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_as_nameContext {
	var p = new(Import_as_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_import_as_name

	return p
}

func (s *Import_as_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_as_nameContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(Python2ParserNAME)
}

func (s *Import_as_nameContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(Python2ParserNAME, i)
}

func (s *Import_as_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_as_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Import_as_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterImport_as_name(s)
	}
}

func (s *Import_as_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitImport_as_name(s)
	}
}

func (s *Import_as_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitImport_as_name(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Import_as_name() (localctx IImport_as_nameContext) {
	localctx = NewImport_as_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, Python2ParserRULE_import_as_name)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(433)
		p.Match(Python2ParserNAME)
	}
	p.SetState(436)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__30 {
		{
			p.SetState(434)
			p.Match(Python2ParserT__30)
		}
		{
			p.SetState(435)
			p.Match(Python2ParserNAME)
		}

	}



	return localctx
}


// IDotted_as_nameContext is an interface to support dynamic dispatch.
type IDotted_as_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotted_as_nameContext differentiates from other interfaces.
	IsDotted_as_nameContext()
}

type Dotted_as_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_as_nameContext() *Dotted_as_nameContext {
	var p = new(Dotted_as_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_dotted_as_name
	return p
}

func (*Dotted_as_nameContext) IsDotted_as_nameContext() {}

func NewDotted_as_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_as_nameContext {
	var p = new(Dotted_as_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_dotted_as_name

	return p
}

func (s *Dotted_as_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_as_nameContext) Dotted_name() IDotted_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *Dotted_as_nameContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python2ParserNAME, 0)
}

func (s *Dotted_as_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_as_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dotted_as_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterDotted_as_name(s)
	}
}

func (s *Dotted_as_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitDotted_as_name(s)
	}
}

func (s *Dotted_as_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitDotted_as_name(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Dotted_as_name() (localctx IDotted_as_nameContext) {
	localctx = NewDotted_as_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, Python2ParserRULE_dotted_as_name)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(438)
		p.Dotted_name()
	}
	p.SetState(441)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__30 {
		{
			p.SetState(439)
			p.Match(Python2ParserT__30)
		}
		{
			p.SetState(440)
			p.Match(Python2ParserNAME)
		}

	}



	return localctx
}


// IImport_as_namesContext is an interface to support dynamic dispatch.
type IImport_as_namesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_as_namesContext differentiates from other interfaces.
	IsImport_as_namesContext()
}

type Import_as_namesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_as_namesContext() *Import_as_namesContext {
	var p = new(Import_as_namesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_import_as_names
	return p
}

func (*Import_as_namesContext) IsImport_as_namesContext() {}

func NewImport_as_namesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_as_namesContext {
	var p = new(Import_as_namesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_import_as_names

	return p
}

func (s *Import_as_namesContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_as_namesContext) AllImport_as_name() []IImport_as_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImport_as_nameContext)(nil)).Elem())
	var tst = make([]IImport_as_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImport_as_nameContext)
		}
	}

	return tst
}

func (s *Import_as_namesContext) Import_as_name(i int) IImport_as_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_as_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImport_as_nameContext)
}

func (s *Import_as_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_as_namesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Import_as_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterImport_as_names(s)
	}
}

func (s *Import_as_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitImport_as_names(s)
	}
}

func (s *Import_as_namesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitImport_as_names(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Import_as_names() (localctx IImport_as_namesContext) {
	localctx = NewImport_as_namesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, Python2ParserRULE_import_as_names)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(443)
		p.Import_as_name()
	}
	p.SetState(448)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(444)
				p.Match(Python2ParserT__4)
			}
			{
				p.SetState(445)
				p.Import_as_name()
			}


		}
		p.SetState(450)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())
	}
	p.SetState(452)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__4 {
		{
			p.SetState(451)
			p.Match(Python2ParserT__4)
		}

	}



	return localctx
}


// IDotted_as_namesContext is an interface to support dynamic dispatch.
type IDotted_as_namesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotted_as_namesContext differentiates from other interfaces.
	IsDotted_as_namesContext()
}

type Dotted_as_namesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_as_namesContext() *Dotted_as_namesContext {
	var p = new(Dotted_as_namesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_dotted_as_names
	return p
}

func (*Dotted_as_namesContext) IsDotted_as_namesContext() {}

func NewDotted_as_namesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_as_namesContext {
	var p = new(Dotted_as_namesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_dotted_as_names

	return p
}

func (s *Dotted_as_namesContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_as_namesContext) AllDotted_as_name() []IDotted_as_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDotted_as_nameContext)(nil)).Elem())
	var tst = make([]IDotted_as_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDotted_as_nameContext)
		}
	}

	return tst
}

func (s *Dotted_as_namesContext) Dotted_as_name(i int) IDotted_as_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_as_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDotted_as_nameContext)
}

func (s *Dotted_as_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_as_namesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dotted_as_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterDotted_as_names(s)
	}
}

func (s *Dotted_as_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitDotted_as_names(s)
	}
}

func (s *Dotted_as_namesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitDotted_as_names(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Dotted_as_names() (localctx IDotted_as_namesContext) {
	localctx = NewDotted_as_namesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, Python2ParserRULE_dotted_as_names)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(454)
		p.Dotted_as_name()
	}
	p.SetState(459)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python2ParserT__4 {
		{
			p.SetState(455)
			p.Match(Python2ParserT__4)
		}
		{
			p.SetState(456)
			p.Dotted_as_name()
		}


		p.SetState(461)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IDotted_nameContext is an interface to support dynamic dispatch.
type IDotted_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotted_nameContext differentiates from other interfaces.
	IsDotted_nameContext()
}

type Dotted_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_nameContext() *Dotted_nameContext {
	var p = new(Dotted_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_dotted_name
	return p
}

func (*Dotted_nameContext) IsDotted_nameContext() {}

func NewDotted_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_nameContext {
	var p = new(Dotted_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_dotted_name

	return p
}

func (s *Dotted_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_nameContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(Python2ParserNAME)
}

func (s *Dotted_nameContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(Python2ParserNAME, i)
}

func (s *Dotted_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dotted_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterDotted_name(s)
	}
}

func (s *Dotted_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitDotted_name(s)
	}
}

func (s *Dotted_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitDotted_name(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Dotted_name() (localctx IDotted_nameContext) {
	localctx = NewDotted_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, Python2ParserRULE_dotted_name)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(462)
		p.Match(Python2ParserNAME)
	}
	p.SetState(467)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python2ParserT__29 {
		{
			p.SetState(463)
			p.Match(Python2ParserT__29)
		}
		{
			p.SetState(464)
			p.Match(Python2ParserNAME)
		}


		p.SetState(469)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IGlobal_stmtContext is an interface to support dynamic dispatch.
type IGlobal_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobal_stmtContext differentiates from other interfaces.
	IsGlobal_stmtContext()
}

type Global_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobal_stmtContext() *Global_stmtContext {
	var p = new(Global_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_global_stmt
	return p
}

func (*Global_stmtContext) IsGlobal_stmtContext() {}

func NewGlobal_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_stmtContext {
	var p = new(Global_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_global_stmt

	return p
}

func (s *Global_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_stmtContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(Python2ParserNAME)
}

func (s *Global_stmtContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(Python2ParserNAME, i)
}

func (s *Global_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Global_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterGlobal_stmt(s)
	}
}

func (s *Global_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitGlobal_stmt(s)
	}
}

func (s *Global_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitGlobal_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Global_stmt() (localctx IGlobal_stmtContext) {
	localctx = NewGlobal_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, Python2ParserRULE_global_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(470)
		p.Match(Python2ParserT__31)
	}
	{
		p.SetState(471)
		p.Match(Python2ParserNAME)
	}
	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python2ParserT__4 {
		{
			p.SetState(472)
			p.Match(Python2ParserT__4)
		}
		{
			p.SetState(473)
			p.Match(Python2ParserNAME)
		}


		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IExec_stmtContext is an interface to support dynamic dispatch.
type IExec_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExec_stmtContext differentiates from other interfaces.
	IsExec_stmtContext()
}

type Exec_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExec_stmtContext() *Exec_stmtContext {
	var p = new(Exec_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_exec_stmt
	return p
}

func (*Exec_stmtContext) IsExec_stmtContext() {}

func NewExec_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exec_stmtContext {
	var p = new(Exec_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_exec_stmt

	return p
}

func (s *Exec_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Exec_stmtContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Exec_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Exec_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Exec_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exec_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Exec_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterExec_stmt(s)
	}
}

func (s *Exec_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitExec_stmt(s)
	}
}

func (s *Exec_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitExec_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Exec_stmt() (localctx IExec_stmtContext) {
	localctx = NewExec_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, Python2ParserRULE_exec_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(479)
		p.Match(Python2ParserT__32)
	}
	{
		p.SetState(480)
		p.Expr()
	}
	p.SetState(487)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__33 {
		{
			p.SetState(481)
			p.Match(Python2ParserT__33)
		}
		{
			p.SetState(482)
			p.Test()
		}
		p.SetState(485)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python2ParserT__4 {
			{
				p.SetState(483)
				p.Match(Python2ParserT__4)
			}
			{
				p.SetState(484)
				p.Test()
			}

		}

	}



	return localctx
}


// IAssert_stmtContext is an interface to support dynamic dispatch.
type IAssert_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssert_stmtContext differentiates from other interfaces.
	IsAssert_stmtContext()
}

type Assert_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssert_stmtContext() *Assert_stmtContext {
	var p = new(Assert_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_assert_stmt
	return p
}

func (*Assert_stmtContext) IsAssert_stmtContext() {}

func NewAssert_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assert_stmtContext {
	var p = new(Assert_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_assert_stmt

	return p
}

func (s *Assert_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Assert_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Assert_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Assert_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assert_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Assert_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterAssert_stmt(s)
	}
}

func (s *Assert_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitAssert_stmt(s)
	}
}

func (s *Assert_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitAssert_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Assert_stmt() (localctx IAssert_stmtContext) {
	localctx = NewAssert_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, Python2ParserRULE_assert_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(489)
		p.Match(Python2ParserT__34)
	}
	{
		p.SetState(490)
		p.Test()
	}
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__4 {
		{
			p.SetState(491)
			p.Match(Python2ParserT__4)
		}
		{
			p.SetState(492)
			p.Test()
		}

	}



	return localctx
}


// ICompound_stmtContext is an interface to support dynamic dispatch.
type ICompound_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompound_stmtContext differentiates from other interfaces.
	IsCompound_stmtContext()
}

type Compound_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_stmtContext() *Compound_stmtContext {
	var p = new(Compound_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_compound_stmt
	return p
}

func (*Compound_stmtContext) IsCompound_stmtContext() {}

func NewCompound_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_stmtContext {
	var p = new(Compound_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_compound_stmt

	return p
}

func (s *Compound_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_stmtContext) If_stmt() IIf_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_stmtContext)
}

func (s *Compound_stmtContext) While_stmt() IWhile_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhile_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhile_stmtContext)
}

func (s *Compound_stmtContext) For_stmt() IFor_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_stmtContext)
}

func (s *Compound_stmtContext) Try_stmt() ITry_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITry_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITry_stmtContext)
}

func (s *Compound_stmtContext) With_stmt() IWith_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWith_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWith_stmtContext)
}

func (s *Compound_stmtContext) Funcdef() IFuncdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *Compound_stmtContext) Classdef() IClassdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassdefContext)
}

func (s *Compound_stmtContext) Decorated() IDecoratedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecoratedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecoratedContext)
}

func (s *Compound_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Compound_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterCompound_stmt(s)
	}
}

func (s *Compound_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitCompound_stmt(s)
	}
}

func (s *Compound_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitCompound_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Compound_stmt() (localctx ICompound_stmtContext) {
	localctx = NewCompound_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, Python2ParserRULE_compound_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(503)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserT__35:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(495)
			p.If_stmt()
		}


	case Python2ParserT__38:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(496)
			p.While_stmt()
		}


	case Python2ParserT__39:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(497)
			p.For_stmt()
		}


	case Python2ParserT__40:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(498)
			p.Try_stmt()
		}


	case Python2ParserT__42:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(499)
			p.With_stmt()
		}


	case Python2ParserT__1:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(500)
			p.Funcdef()
		}


	case Python2ParserT__67:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(501)
			p.Classdef()
		}


	case Python2ParserT__0:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(502)
			p.Decorated()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IIf_stmtContext is an interface to support dynamic dispatch.
type IIf_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_stmtContext differentiates from other interfaces.
	IsIf_stmtContext()
}

type If_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_stmtContext() *If_stmtContext {
	var p = new(If_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_if_stmt
	return p
}

func (*If_stmtContext) IsIf_stmtContext() {}

func NewIf_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_stmtContext {
	var p = new(If_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_if_stmt

	return p
}

func (s *If_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *If_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *If_stmtContext) AllSuite() []ISuiteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuiteContext)(nil)).Elem())
	var tst = make([]ISuiteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuiteContext)
		}
	}

	return tst
}

func (s *If_stmtContext) Suite(i int) ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitIf_stmt(s)
	}
}

func (s *If_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitIf_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) If_stmt() (localctx IIf_stmtContext) {
	localctx = NewIf_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, Python2ParserRULE_if_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(505)
		p.Match(Python2ParserT__35)
	}
	{
		p.SetState(506)
		p.Test()
	}
	{
		p.SetState(507)
		p.Match(Python2ParserT__2)
	}
	{
		p.SetState(508)
		p.Suite()
	}
	p.SetState(516)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(509)
				p.Match(Python2ParserT__36)
			}
			{
				p.SetState(510)
				p.Test()
			}
			{
				p.SetState(511)
				p.Match(Python2ParserT__2)
			}
			{
				p.SetState(512)
				p.Suite()
			}


		}
		p.SetState(518)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext())
	}
	p.SetState(522)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(519)
			p.Match(Python2ParserT__37)
		}
		{
			p.SetState(520)
			p.Match(Python2ParserT__2)
		}
		{
			p.SetState(521)
			p.Suite()
		}


	}



	return localctx
}


// IWhile_stmtContext is an interface to support dynamic dispatch.
type IWhile_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhile_stmtContext differentiates from other interfaces.
	IsWhile_stmtContext()
}

type While_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhile_stmtContext() *While_stmtContext {
	var p = new(While_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_while_stmt
	return p
}

func (*While_stmtContext) IsWhile_stmtContext() {}

func NewWhile_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *While_stmtContext {
	var p = new(While_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_while_stmt

	return p
}

func (s *While_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *While_stmtContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *While_stmtContext) AllSuite() []ISuiteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuiteContext)(nil)).Elem())
	var tst = make([]ISuiteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuiteContext)
		}
	}

	return tst
}

func (s *While_stmtContext) Suite(i int) ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *While_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *While_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterWhile_stmt(s)
	}
}

func (s *While_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitWhile_stmt(s)
	}
}

func (s *While_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitWhile_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) While_stmt() (localctx IWhile_stmtContext) {
	localctx = NewWhile_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, Python2ParserRULE_while_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(524)
		p.Match(Python2ParserT__38)
	}
	{
		p.SetState(525)
		p.Test()
	}
	{
		p.SetState(526)
		p.Match(Python2ParserT__2)
	}
	{
		p.SetState(527)
		p.Suite()
	}
	p.SetState(531)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(528)
			p.Match(Python2ParserT__37)
		}
		{
			p.SetState(529)
			p.Match(Python2ParserT__2)
		}
		{
			p.SetState(530)
			p.Suite()
		}


	}



	return localctx
}


// IFor_stmtContext is an interface to support dynamic dispatch.
type IFor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_stmtContext differentiates from other interfaces.
	IsFor_stmtContext()
}

type For_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_stmtContext() *For_stmtContext {
	var p = new(For_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_for_stmt
	return p
}

func (*For_stmtContext) IsFor_stmtContext() {}

func NewFor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_stmtContext {
	var p = new(For_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_for_stmt

	return p
}

func (s *For_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_stmtContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *For_stmtContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *For_stmtContext) AllSuite() []ISuiteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuiteContext)(nil)).Elem())
	var tst = make([]ISuiteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuiteContext)
		}
	}

	return tst
}

func (s *For_stmtContext) Suite(i int) ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *For_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *For_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterFor_stmt(s)
	}
}

func (s *For_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitFor_stmt(s)
	}
}

func (s *For_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitFor_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) For_stmt() (localctx IFor_stmtContext) {
	localctx = NewFor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, Python2ParserRULE_for_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(533)
		p.Match(Python2ParserT__39)
	}
	{
		p.SetState(534)
		p.Exprlist()
	}
	{
		p.SetState(535)
		p.Match(Python2ParserT__33)
	}
	{
		p.SetState(536)
		p.Testlist()
	}
	{
		p.SetState(537)
		p.Match(Python2ParserT__2)
	}
	{
		p.SetState(538)
		p.Suite()
	}
	p.SetState(542)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(539)
			p.Match(Python2ParserT__37)
		}
		{
			p.SetState(540)
			p.Match(Python2ParserT__2)
		}
		{
			p.SetState(541)
			p.Suite()
		}


	}



	return localctx
}


// ITry_stmtContext is an interface to support dynamic dispatch.
type ITry_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTry_stmtContext differentiates from other interfaces.
	IsTry_stmtContext()
}

type Try_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTry_stmtContext() *Try_stmtContext {
	var p = new(Try_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_try_stmt
	return p
}

func (*Try_stmtContext) IsTry_stmtContext() {}

func NewTry_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Try_stmtContext {
	var p = new(Try_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_try_stmt

	return p
}

func (s *Try_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Try_stmtContext) AllSuite() []ISuiteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuiteContext)(nil)).Elem())
	var tst = make([]ISuiteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuiteContext)
		}
	}

	return tst
}

func (s *Try_stmtContext) Suite(i int) ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *Try_stmtContext) AllExcept_clause() []IExcept_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExcept_clauseContext)(nil)).Elem())
	var tst = make([]IExcept_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExcept_clauseContext)
		}
	}

	return tst
}

func (s *Try_stmtContext) Except_clause(i int) IExcept_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExcept_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExcept_clauseContext)
}

func (s *Try_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Try_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Try_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterTry_stmt(s)
	}
}

func (s *Try_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitTry_stmt(s)
	}
}

func (s *Try_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitTry_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Try_stmt() (localctx ITry_stmtContext) {
	localctx = NewTry_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, Python2ParserRULE_try_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(544)
		p.Match(Python2ParserT__40)
	}
	{
		p.SetState(545)
		p.Match(Python2ParserT__2)
	}
	{
		p.SetState(546)
		p.Suite()
	}
	p.SetState(568)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserT__43:
		p.SetState(551)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					{
						p.SetState(547)
						p.Except_clause()
					}
					{
						p.SetState(548)
						p.Match(Python2ParserT__2)
					}
					{
						p.SetState(549)
						p.Suite()
					}




			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(553)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext())
		}
		p.SetState(558)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(555)
				p.Match(Python2ParserT__37)
			}
			{
				p.SetState(556)
				p.Match(Python2ParserT__2)
			}
			{
				p.SetState(557)
				p.Suite()
			}


		}
		p.SetState(563)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(560)
				p.Match(Python2ParserT__41)
			}
			{
				p.SetState(561)
				p.Match(Python2ParserT__2)
			}
			{
				p.SetState(562)
				p.Suite()
			}


		}


	case Python2ParserT__41:
		{
			p.SetState(565)
			p.Match(Python2ParserT__41)
		}
		{
			p.SetState(566)
			p.Match(Python2ParserT__2)
		}
		{
			p.SetState(567)
			p.Suite()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}




	return localctx
}


// IWith_stmtContext is an interface to support dynamic dispatch.
type IWith_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWith_stmtContext differentiates from other interfaces.
	IsWith_stmtContext()
}

type With_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_stmtContext() *With_stmtContext {
	var p = new(With_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_with_stmt
	return p
}

func (*With_stmtContext) IsWith_stmtContext() {}

func NewWith_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_stmtContext {
	var p = new(With_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_with_stmt

	return p
}

func (s *With_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *With_stmtContext) AllWith_item() []IWith_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWith_itemContext)(nil)).Elem())
	var tst = make([]IWith_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWith_itemContext)
		}
	}

	return tst
}

func (s *With_stmtContext) With_item(i int) IWith_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWith_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWith_itemContext)
}

func (s *With_stmtContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *With_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterWith_stmt(s)
	}
}

func (s *With_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitWith_stmt(s)
	}
}

func (s *With_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitWith_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) With_stmt() (localctx IWith_stmtContext) {
	localctx = NewWith_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, Python2ParserRULE_with_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(570)
		p.Match(Python2ParserT__42)
	}
	{
		p.SetState(571)
		p.With_item()
	}
	p.SetState(576)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python2ParserT__4 {
		{
			p.SetState(572)
			p.Match(Python2ParserT__4)
		}
		{
			p.SetState(573)
			p.With_item()
		}


		p.SetState(578)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(579)
		p.Match(Python2ParserT__2)
	}
	{
		p.SetState(580)
		p.Suite()
	}



	return localctx
}


// IWith_itemContext is an interface to support dynamic dispatch.
type IWith_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWith_itemContext differentiates from other interfaces.
	IsWith_itemContext()
}

type With_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_itemContext() *With_itemContext {
	var p = new(With_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_with_item
	return p
}

func (*With_itemContext) IsWith_itemContext() {}

func NewWith_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_itemContext {
	var p = new(With_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_with_item

	return p
}

func (s *With_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *With_itemContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *With_itemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *With_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterWith_item(s)
	}
}

func (s *With_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitWith_item(s)
	}
}

func (s *With_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitWith_item(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) With_item() (localctx IWith_itemContext) {
	localctx = NewWith_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, Python2ParserRULE_with_item)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(582)
		p.Test()
	}
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__30 {
		{
			p.SetState(583)
			p.Match(Python2ParserT__30)
		}
		{
			p.SetState(584)
			p.Expr()
		}

	}



	return localctx
}


// IExcept_clauseContext is an interface to support dynamic dispatch.
type IExcept_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExcept_clauseContext differentiates from other interfaces.
	IsExcept_clauseContext()
}

type Except_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExcept_clauseContext() *Except_clauseContext {
	var p = new(Except_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_except_clause
	return p
}

func (*Except_clauseContext) IsExcept_clauseContext() {}

func NewExcept_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Except_clauseContext {
	var p = new(Except_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_except_clause

	return p
}

func (s *Except_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Except_clauseContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Except_clauseContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Except_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Except_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Except_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterExcept_clause(s)
	}
}

func (s *Except_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitExcept_clause(s)
	}
}

func (s *Except_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitExcept_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Except_clause() (localctx IExcept_clauseContext) {
	localctx = NewExcept_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, Python2ParserRULE_except_clause)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(587)
		p.Match(Python2ParserT__43)
	}
	p.SetState(593)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 30)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 30))) & ((1 << (Python2ParserT__29 - 30)) | (1 << (Python2ParserT__44 - 30)) | (1 << (Python2ParserT__47 - 30)) | (1 << (Python2ParserT__60 - 30)))) != 0) || ((((_la - 62)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 62))) & ((1 << (Python2ParserT__61 - 62)) | (1 << (Python2ParserT__65 - 62)) | (1 << (Python2ParserT__66 - 62)) | (1 << (Python2ParserNAME - 62)) | (1 << (Python2ParserNUMBER - 62)) | (1 << (Python2ParserSTRING - 62)) | (1 << (Python2ParserOPEN_PAREN - 62)) | (1 << (Python2ParserOPEN_BRACE - 62)) | (1 << (Python2ParserOPEN_BRACKET - 62)))) != 0) {
		{
			p.SetState(588)
			p.Test()
		}
		p.SetState(591)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python2ParserT__4 || _la == Python2ParserT__30 {
			p.SetState(589)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Python2ParserT__4 || _la == Python2ParserT__30) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
			    p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
			{
				p.SetState(590)
				p.Test()
			}

		}

	}



	return localctx
}


// ISuiteContext is an interface to support dynamic dispatch.
type ISuiteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuiteContext differentiates from other interfaces.
	IsSuiteContext()
}

type SuiteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuiteContext() *SuiteContext {
	var p = new(SuiteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_suite
	return p
}

func (*SuiteContext) IsSuiteContext() {}

func NewSuiteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuiteContext {
	var p = new(SuiteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_suite

	return p
}

func (s *SuiteContext) GetParser() antlr.Parser { return s.parser }

func (s *SuiteContext) Simple_stmt() ISimple_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *SuiteContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python2ParserNEWLINE, 0)
}

func (s *SuiteContext) INDENT() antlr.TerminalNode {
	return s.GetToken(Python2ParserINDENT, 0)
}

func (s *SuiteContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(Python2ParserDEDENT, 0)
}

func (s *SuiteContext) AllStmt() []IStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStmtContext)(nil)).Elem())
	var tst = make([]IStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStmtContext)
		}
	}

	return tst
}

func (s *SuiteContext) Stmt(i int) IStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *SuiteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuiteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SuiteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterSuite(s)
	}
}

func (s *SuiteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitSuite(s)
	}
}

func (s *SuiteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitSuite(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Suite() (localctx ISuiteContext) {
	localctx = NewSuiteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, Python2ParserRULE_suite)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(605)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(595)
			p.Simple_stmt()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(596)
			p.Match(Python2ParserNEWLINE)
		}
		{
			p.SetState(597)
			p.Match(Python2ParserINDENT)
		}
		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					{
						p.SetState(598)
						p.Stmt()
					}




			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(601)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())
		}
		{
			p.SetState(603)
			p.Match(Python2ParserDEDENT)
		}

	}


	return localctx
}


// ITestlist_safeContext is an interface to support dynamic dispatch.
type ITestlist_safeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestlist_safeContext differentiates from other interfaces.
	IsTestlist_safeContext()
}

type Testlist_safeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlist_safeContext() *Testlist_safeContext {
	var p = new(Testlist_safeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_testlist_safe
	return p
}

func (*Testlist_safeContext) IsTestlist_safeContext() {}

func NewTestlist_safeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Testlist_safeContext {
	var p = new(Testlist_safeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_testlist_safe

	return p
}

func (s *Testlist_safeContext) GetParser() antlr.Parser { return s.parser }

func (s *Testlist_safeContext) AllOld_test() []IOld_testContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOld_testContext)(nil)).Elem())
	var tst = make([]IOld_testContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOld_testContext)
		}
	}

	return tst
}

func (s *Testlist_safeContext) Old_test(i int) IOld_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOld_testContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOld_testContext)
}

func (s *Testlist_safeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Testlist_safeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Testlist_safeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterTestlist_safe(s)
	}
}

func (s *Testlist_safeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitTestlist_safe(s)
	}
}

func (s *Testlist_safeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitTestlist_safe(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Testlist_safe() (localctx ITestlist_safeContext) {
	localctx = NewTestlist_safeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, Python2ParserRULE_testlist_safe)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		p.Old_test()
	}
	p.SetState(617)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__4 {
		p.SetState(610)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					{
						p.SetState(608)
						p.Match(Python2ParserT__4)
					}
					{
						p.SetState(609)
						p.Old_test()
					}




			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(612)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext())
		}
		p.SetState(615)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python2ParserT__4 {
			{
				p.SetState(614)
				p.Match(Python2ParserT__4)
			}

		}

	}



	return localctx
}


// IOld_testContext is an interface to support dynamic dispatch.
type IOld_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOld_testContext differentiates from other interfaces.
	IsOld_testContext()
}

type Old_testContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOld_testContext() *Old_testContext {
	var p = new(Old_testContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_old_test
	return p
}

func (*Old_testContext) IsOld_testContext() {}

func NewOld_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Old_testContext {
	var p = new(Old_testContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_old_test

	return p
}

func (s *Old_testContext) GetParser() antlr.Parser { return s.parser }

func (s *Old_testContext) Or_test() IOr_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_testContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *Old_testContext) Old_lambdef() IOld_lambdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOld_lambdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOld_lambdefContext)
}

func (s *Old_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Old_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Old_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterOld_test(s)
	}
}

func (s *Old_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitOld_test(s)
	}
}

func (s *Old_testContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitOld_test(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Old_test() (localctx IOld_testContext) {
	localctx = NewOld_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, Python2ParserRULE_old_test)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(621)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserT__29, Python2ParserT__47, Python2ParserT__60, Python2ParserT__61, Python2ParserT__65, Python2ParserT__66, Python2ParserNAME, Python2ParserNUMBER, Python2ParserSTRING, Python2ParserOPEN_PAREN, Python2ParserOPEN_BRACE, Python2ParserOPEN_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(619)
			p.Or_test()
		}


	case Python2ParserT__44:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(620)
			p.Old_lambdef()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IOld_lambdefContext is an interface to support dynamic dispatch.
type IOld_lambdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOld_lambdefContext differentiates from other interfaces.
	IsOld_lambdefContext()
}

type Old_lambdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOld_lambdefContext() *Old_lambdefContext {
	var p = new(Old_lambdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_old_lambdef
	return p
}

func (*Old_lambdefContext) IsOld_lambdefContext() {}

func NewOld_lambdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Old_lambdefContext {
	var p = new(Old_lambdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_old_lambdef

	return p
}

func (s *Old_lambdefContext) GetParser() antlr.Parser { return s.parser }

func (s *Old_lambdefContext) Old_test() IOld_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOld_testContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOld_testContext)
}

func (s *Old_lambdefContext) Varargslist() IVarargslistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarargslistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarargslistContext)
}

func (s *Old_lambdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Old_lambdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Old_lambdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterOld_lambdef(s)
	}
}

func (s *Old_lambdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitOld_lambdef(s)
	}
}

func (s *Old_lambdefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitOld_lambdef(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Old_lambdef() (localctx IOld_lambdefContext) {
	localctx = NewOld_lambdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, Python2ParserRULE_old_lambdef)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(623)
		p.Match(Python2ParserT__44)
	}
	p.SetState(625)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__5 || _la == Python2ParserT__6 || _la == Python2ParserNAME || _la == Python2ParserOPEN_PAREN {
		{
			p.SetState(624)
			p.Varargslist()
		}

	}
	{
		p.SetState(627)
		p.Match(Python2ParserT__2)
	}
	{
		p.SetState(628)
		p.Old_test()
	}



	return localctx
}


// ITestContext is an interface to support dynamic dispatch.
type ITestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestContext differentiates from other interfaces.
	IsTestContext()
}

type TestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestContext() *TestContext {
	var p = new(TestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_test
	return p
}

func (*TestContext) IsTestContext() {}

func NewTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestContext {
	var p = new(TestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_test

	return p
}

func (s *TestContext) GetParser() antlr.Parser { return s.parser }

func (s *TestContext) AllOr_test() []IOr_testContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOr_testContext)(nil)).Elem())
	var tst = make([]IOr_testContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOr_testContext)
		}
	}

	return tst
}

func (s *TestContext) Or_test(i int) IOr_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_testContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *TestContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TestContext) Lambdef() ILambdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdefContext)
}

func (s *TestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterTest(s)
	}
}

func (s *TestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitTest(s)
	}
}

func (s *TestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitTest(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Test() (localctx ITestContext) {
	localctx = NewTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, Python2ParserRULE_test)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(639)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserT__29, Python2ParserT__47, Python2ParserT__60, Python2ParserT__61, Python2ParserT__65, Python2ParserT__66, Python2ParserNAME, Python2ParserNUMBER, Python2ParserSTRING, Python2ParserOPEN_PAREN, Python2ParserOPEN_BRACE, Python2ParserOPEN_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(630)
			p.Or_test()
		}
		p.SetState(636)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python2ParserT__35 {
			{
				p.SetState(631)
				p.Match(Python2ParserT__35)
			}
			{
				p.SetState(632)
				p.Or_test()
			}
			{
				p.SetState(633)
				p.Match(Python2ParserT__37)
			}
			{
				p.SetState(634)
				p.Test()
			}

		}


	case Python2ParserT__44:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(638)
			p.Lambdef()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IOr_testContext is an interface to support dynamic dispatch.
type IOr_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOr_testContext differentiates from other interfaces.
	IsOr_testContext()
}

type Or_testContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOr_testContext() *Or_testContext {
	var p = new(Or_testContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_or_test
	return p
}

func (*Or_testContext) IsOr_testContext() {}

func NewOr_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Or_testContext {
	var p = new(Or_testContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_or_test

	return p
}

func (s *Or_testContext) GetParser() antlr.Parser { return s.parser }

func (s *Or_testContext) AllAnd_test() []IAnd_testContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnd_testContext)(nil)).Elem())
	var tst = make([]IAnd_testContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnd_testContext)
		}
	}

	return tst
}

func (s *Or_testContext) And_test(i int) IAnd_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_testContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnd_testContext)
}

func (s *Or_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Or_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Or_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterOr_test(s)
	}
}

func (s *Or_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitOr_test(s)
	}
}

func (s *Or_testContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitOr_test(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Or_test() (localctx IOr_testContext) {
	localctx = NewOr_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, Python2ParserRULE_or_test)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(641)
		p.And_test()
	}
	p.SetState(646)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python2ParserT__45 {
		{
			p.SetState(642)
			p.Match(Python2ParserT__45)
		}
		{
			p.SetState(643)
			p.And_test()
		}


		p.SetState(648)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAnd_testContext is an interface to support dynamic dispatch.
type IAnd_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnd_testContext differentiates from other interfaces.
	IsAnd_testContext()
}

type And_testContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_testContext() *And_testContext {
	var p = new(And_testContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_and_test
	return p
}

func (*And_testContext) IsAnd_testContext() {}

func NewAnd_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_testContext {
	var p = new(And_testContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_and_test

	return p
}

func (s *And_testContext) GetParser() antlr.Parser { return s.parser }

func (s *And_testContext) AllNot_test() []INot_testContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INot_testContext)(nil)).Elem())
	var tst = make([]INot_testContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INot_testContext)
		}
	}

	return tst
}

func (s *And_testContext) Not_test(i int) INot_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INot_testContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INot_testContext)
}

func (s *And_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *And_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterAnd_test(s)
	}
}

func (s *And_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitAnd_test(s)
	}
}

func (s *And_testContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitAnd_test(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) And_test() (localctx IAnd_testContext) {
	localctx = NewAnd_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, Python2ParserRULE_and_test)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(649)
		p.Not_test()
	}
	p.SetState(654)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python2ParserT__46 {
		{
			p.SetState(650)
			p.Match(Python2ParserT__46)
		}
		{
			p.SetState(651)
			p.Not_test()
		}


		p.SetState(656)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// INot_testContext is an interface to support dynamic dispatch.
type INot_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNot_testContext differentiates from other interfaces.
	IsNot_testContext()
}

type Not_testContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNot_testContext() *Not_testContext {
	var p = new(Not_testContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_not_test
	return p
}

func (*Not_testContext) IsNot_testContext() {}

func NewNot_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Not_testContext {
	var p = new(Not_testContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_not_test

	return p
}

func (s *Not_testContext) GetParser() antlr.Parser { return s.parser }

func (s *Not_testContext) Not_test() INot_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INot_testContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INot_testContext)
}

func (s *Not_testContext) Comparison() IComparisonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *Not_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Not_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Not_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterNot_test(s)
	}
}

func (s *Not_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitNot_test(s)
	}
}

func (s *Not_testContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitNot_test(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Not_test() (localctx INot_testContext) {
	localctx = NewNot_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, Python2ParserRULE_not_test)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(660)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserT__47:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(657)
			p.Match(Python2ParserT__47)
		}
		{
			p.SetState(658)
			p.Not_test()
		}


	case Python2ParserT__29, Python2ParserT__60, Python2ParserT__61, Python2ParserT__65, Python2ParserT__66, Python2ParserNAME, Python2ParserNUMBER, Python2ParserSTRING, Python2ParserOPEN_PAREN, Python2ParserOPEN_BRACE, Python2ParserOPEN_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(659)
			p.Comparison()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IComparisonContext is an interface to support dynamic dispatch.
type IComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonContext differentiates from other interfaces.
	IsComparisonContext()
}

type ComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonContext() *ComparisonContext {
	var p = new(ComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_comparison
	return p
}

func (*ComparisonContext) IsComparisonContext() {}

func NewComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonContext {
	var p = new(ComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_comparison

	return p
}

func (s *ComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ComparisonContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ComparisonContext) AllComp_op() []IComp_opContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComp_opContext)(nil)).Elem())
	var tst = make([]IComp_opContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComp_opContext)
		}
	}

	return tst
}

func (s *ComparisonContext) Comp_op(i int) IComp_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_opContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComp_opContext)
}

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitComparison(s)
	}
}

func (s *ComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitComparison(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Comparison() (localctx IComparisonContext) {
	localctx = NewComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, Python2ParserRULE_comparison)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(662)
		p.Expr()
	}
	p.SetState(668)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ((((_la - 34)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 34))) & ((1 << (Python2ParserT__33 - 34)) | (1 << (Python2ParserT__47 - 34)) | (1 << (Python2ParserT__48 - 34)) | (1 << (Python2ParserT__49 - 34)) | (1 << (Python2ParserT__50 - 34)) | (1 << (Python2ParserT__51 - 34)) | (1 << (Python2ParserT__52 - 34)) | (1 << (Python2ParserT__53 - 34)) | (1 << (Python2ParserT__54 - 34)) | (1 << (Python2ParserT__55 - 34)))) != 0) {
		{
			p.SetState(663)
			p.Comp_op()
		}
		{
			p.SetState(664)
			p.Expr()
		}


		p.SetState(670)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IComp_opContext is an interface to support dynamic dispatch.
type IComp_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_opContext differentiates from other interfaces.
	IsComp_opContext()
}

type Comp_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_opContext() *Comp_opContext {
	var p = new(Comp_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_comp_op
	return p
}

func (*Comp_opContext) IsComp_opContext() {}

func NewComp_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_opContext {
	var p = new(Comp_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_comp_op

	return p
}

func (s *Comp_opContext) GetParser() antlr.Parser { return s.parser }
func (s *Comp_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Comp_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterComp_op(s)
	}
}

func (s *Comp_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitComp_op(s)
	}
}

func (s *Comp_opContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitComp_op(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Comp_op() (localctx IComp_opContext) {
	localctx = NewComp_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, Python2ParserRULE_comp_op)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(684)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(671)
			p.Match(Python2ParserT__48)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(672)
			p.Match(Python2ParserT__49)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(673)
			p.Match(Python2ParserT__50)
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(674)
			p.Match(Python2ParserT__51)
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(675)
			p.Match(Python2ParserT__52)
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(676)
			p.Match(Python2ParserT__53)
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(677)
			p.Match(Python2ParserT__54)
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(678)
			p.Match(Python2ParserT__33)
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(679)
			p.Match(Python2ParserT__47)
		}
		{
			p.SetState(680)
			p.Match(Python2ParserT__33)
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(681)
			p.Match(Python2ParserT__55)
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(682)
			p.Match(Python2ParserT__55)
		}
		{
			p.SetState(683)
			p.Match(Python2ParserT__47)
		}

	}


	return localctx
}


// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AllXor_expr() []IXor_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IXor_exprContext)(nil)).Elem())
	var tst = make([]IXor_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IXor_exprContext)
		}
	}

	return tst
}

func (s *ExprContext) Xor_expr(i int) IXor_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXor_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IXor_exprContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitExpr(s)
	}
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, Python2ParserRULE_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(686)
		p.Xor_expr()
	}
	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python2ParserT__56 {
		{
			p.SetState(687)
			p.Match(Python2ParserT__56)
		}
		{
			p.SetState(688)
			p.Xor_expr()
		}


		p.SetState(693)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IXor_exprContext is an interface to support dynamic dispatch.
type IXor_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXor_exprContext differentiates from other interfaces.
	IsXor_exprContext()
}

type Xor_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXor_exprContext() *Xor_exprContext {
	var p = new(Xor_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_xor_expr
	return p
}

func (*Xor_exprContext) IsXor_exprContext() {}

func NewXor_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xor_exprContext {
	var p = new(Xor_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_xor_expr

	return p
}

func (s *Xor_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Xor_exprContext) AllAnd_expr() []IAnd_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnd_exprContext)(nil)).Elem())
	var tst = make([]IAnd_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnd_exprContext)
		}
	}

	return tst
}

func (s *Xor_exprContext) And_expr(i int) IAnd_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnd_exprContext)
}

func (s *Xor_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xor_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Xor_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterXor_expr(s)
	}
}

func (s *Xor_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitXor_expr(s)
	}
}

func (s *Xor_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitXor_expr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Xor_expr() (localctx IXor_exprContext) {
	localctx = NewXor_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, Python2ParserRULE_xor_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(694)
		p.And_expr()
	}
	p.SetState(699)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python2ParserT__57 {
		{
			p.SetState(695)
			p.Match(Python2ParserT__57)
		}
		{
			p.SetState(696)
			p.And_expr()
		}


		p.SetState(701)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAnd_exprContext is an interface to support dynamic dispatch.
type IAnd_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnd_exprContext differentiates from other interfaces.
	IsAnd_exprContext()
}

type And_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_exprContext() *And_exprContext {
	var p = new(And_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_and_expr
	return p
}

func (*And_exprContext) IsAnd_exprContext() {}

func NewAnd_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_exprContext {
	var p = new(And_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_and_expr

	return p
}

func (s *And_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *And_exprContext) AllShift_expr() []IShift_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IShift_exprContext)(nil)).Elem())
	var tst = make([]IShift_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IShift_exprContext)
		}
	}

	return tst
}

func (s *And_exprContext) Shift_expr(i int) IShift_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IShift_exprContext)
}

func (s *And_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *And_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterAnd_expr(s)
	}
}

func (s *And_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitAnd_expr(s)
	}
}

func (s *And_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitAnd_expr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) And_expr() (localctx IAnd_exprContext) {
	localctx = NewAnd_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, Python2ParserRULE_and_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Shift_expr()
	}
	p.SetState(707)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python2ParserT__58 {
		{
			p.SetState(703)
			p.Match(Python2ParserT__58)
		}
		{
			p.SetState(704)
			p.Shift_expr()
		}


		p.SetState(709)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IShift_exprContext is an interface to support dynamic dispatch.
type IShift_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShift_exprContext differentiates from other interfaces.
	IsShift_exprContext()
}

type Shift_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_exprContext() *Shift_exprContext {
	var p = new(Shift_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_shift_expr
	return p
}

func (*Shift_exprContext) IsShift_exprContext() {}

func NewShift_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_exprContext {
	var p = new(Shift_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_shift_expr

	return p
}

func (s *Shift_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_exprContext) AllArith_expr() []IArith_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArith_exprContext)(nil)).Elem())
	var tst = make([]IArith_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArith_exprContext)
		}
	}

	return tst
}

func (s *Shift_exprContext) Arith_expr(i int) IArith_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArith_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArith_exprContext)
}

func (s *Shift_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Shift_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterShift_expr(s)
	}
}

func (s *Shift_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitShift_expr(s)
	}
}

func (s *Shift_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitShift_expr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Shift_expr() (localctx IShift_exprContext) {
	localctx = NewShift_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, Python2ParserRULE_shift_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(710)
		p.Arith_expr()
	}
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python2ParserT__20 || _la == Python2ParserT__59 {
		p.SetState(711)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Python2ParserT__20 || _la == Python2ParserT__59) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
		    p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(712)
			p.Arith_expr()
		}


		p.SetState(717)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IArith_exprContext is an interface to support dynamic dispatch.
type IArith_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArith_exprContext differentiates from other interfaces.
	IsArith_exprContext()
}

type Arith_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArith_exprContext() *Arith_exprContext {
	var p = new(Arith_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_arith_expr
	return p
}

func (*Arith_exprContext) IsArith_exprContext() {}

func NewArith_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arith_exprContext {
	var p = new(Arith_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_arith_expr

	return p
}

func (s *Arith_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Arith_exprContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *Arith_exprContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Arith_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arith_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Arith_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterArith_expr(s)
	}
}

func (s *Arith_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitArith_expr(s)
	}
}

func (s *Arith_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitArith_expr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Arith_expr() (localctx IArith_exprContext) {
	localctx = NewArith_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, Python2ParserRULE_arith_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(718)
		p.Term()
	}
	p.SetState(723)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python2ParserT__60 || _la == Python2ParserT__61 {
		p.SetState(719)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Python2ParserT__60 || _la == Python2ParserT__61) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
		    p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(720)
			p.Term()
		}


		p.SetState(725)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) AllFactor() []IFactorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFactorContext)(nil)).Elem())
	var tst = make([]IFactorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFactorContext)
		}
	}

	return tst
}

func (s *TermContext) Factor(i int) IFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitTerm(s)
	}
}

func (s *TermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitTerm(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, Python2ParserRULE_term)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(726)
		p.Factor()
	}
	p.SetState(731)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python2ParserT__5 || ((((_la - 63)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 63))) & ((1 << (Python2ParserT__62 - 63)) | (1 << (Python2ParserT__63 - 63)) | (1 << (Python2ParserT__64 - 63)))) != 0) {
		p.SetState(727)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Python2ParserT__5 || ((((_la - 63)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 63))) & ((1 << (Python2ParserT__62 - 63)) | (1 << (Python2ParserT__63 - 63)) | (1 << (Python2ParserT__64 - 63)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
		    p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(728)
			p.Factor()
		}


		p.SetState(733)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IFactorContext is an interface to support dynamic dispatch.
type IFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFactorContext differentiates from other interfaces.
	IsFactorContext()
}

type FactorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactorContext() *FactorContext {
	var p = new(FactorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_factor
	return p
}

func (*FactorContext) IsFactorContext() {}

func NewFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FactorContext {
	var p = new(FactorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_factor

	return p
}

func (s *FactorContext) GetParser() antlr.Parser { return s.parser }

func (s *FactorContext) Factor() IFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *FactorContext) Power() IPowerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowerContext)
}

func (s *FactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterFactor(s)
	}
}

func (s *FactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitFactor(s)
	}
}

func (s *FactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitFactor(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Factor() (localctx IFactorContext) {
	localctx = NewFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, Python2ParserRULE_factor)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(737)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserT__60, Python2ParserT__61, Python2ParserT__65:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(734)
		_la = p.GetTokenStream().LA(1)

		if !(((((_la - 61)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 61))) & ((1 << (Python2ParserT__60 - 61)) | (1 << (Python2ParserT__61 - 61)) | (1 << (Python2ParserT__65 - 61)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
		    p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(735)
			p.Factor()
		}


	case Python2ParserT__29, Python2ParserT__66, Python2ParserNAME, Python2ParserNUMBER, Python2ParserSTRING, Python2ParserOPEN_PAREN, Python2ParserOPEN_BRACE, Python2ParserOPEN_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(736)
			p.Power()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IPowerContext is an interface to support dynamic dispatch.
type IPowerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerContext differentiates from other interfaces.
	IsPowerContext()
}

type PowerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerContext() *PowerContext {
	var p = new(PowerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_power
	return p
}

func (*PowerContext) IsPowerContext() {}

func NewPowerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerContext {
	var p = new(PowerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_power

	return p
}

func (s *PowerContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *PowerContext) AllTrailer() []ITrailerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITrailerContext)(nil)).Elem())
	var tst = make([]ITrailerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITrailerContext)
		}
	}

	return tst
}

func (s *PowerContext) Trailer(i int) ITrailerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrailerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITrailerContext)
}

func (s *PowerContext) Factor() IFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *PowerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PowerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterPower(s)
	}
}

func (s *PowerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitPower(s)
	}
}

func (s *PowerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitPower(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Power() (localctx IPowerContext) {
	localctx = NewPowerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, Python2ParserRULE_power)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		p.Atom()
	}
	p.SetState(743)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python2ParserT__29 || _la == Python2ParserOPEN_PAREN || _la == Python2ParserOPEN_BRACKET {
		{
			p.SetState(740)
			p.Trailer()
		}


		p.SetState(745)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(748)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__6 {
		{
			p.SetState(746)
			p.Match(Python2ParserT__6)
		}
		{
			p.SetState(747)
			p.Factor()
		}

	}



	return localctx
}


// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) Testlist1() ITestlist1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlist1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlist1Context)
}

func (s *AtomContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python2ParserNAME, 0)
}

func (s *AtomContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Python2ParserNUMBER, 0)
}

func (s *AtomContext) Yield_expr() IYield_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *AtomContext) Testlist_comp() ITestlist_compContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlist_compContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlist_compContext)
}

func (s *AtomContext) Listmaker() IListmakerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListmakerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListmakerContext)
}

func (s *AtomContext) Dictorsetmaker() IDictorsetmakerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictorsetmakerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictorsetmakerContext)
}

func (s *AtomContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(Python2ParserSTRING)
}

func (s *AtomContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(Python2ParserSTRING, i)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitAtom(s)
	}
}

func (s *AtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitAtom(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, Python2ParserRULE_atom)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(780)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserOPEN_PAREN:
		{
			p.SetState(750)
			p.Match(Python2ParserOPEN_PAREN)
		}
		p.SetState(753)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python2ParserT__68:
			{
				p.SetState(751)
				p.Yield_expr()
			}


		case Python2ParserT__29, Python2ParserT__44, Python2ParserT__47, Python2ParserT__60, Python2ParserT__61, Python2ParserT__65, Python2ParserT__66, Python2ParserNAME, Python2ParserNUMBER, Python2ParserSTRING, Python2ParserOPEN_PAREN, Python2ParserOPEN_BRACE, Python2ParserOPEN_BRACKET:
			{
				p.SetState(752)
				p.Testlist_comp()
			}


		case Python2ParserCLOSE_PAREN:



		default:
		}
		{
			p.SetState(755)
			p.Match(Python2ParserCLOSE_PAREN)
		}


	case Python2ParserOPEN_BRACKET:
		{
			p.SetState(756)
			p.Match(Python2ParserOPEN_BRACKET)
		}
		p.SetState(758)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 30)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 30))) & ((1 << (Python2ParserT__29 - 30)) | (1 << (Python2ParserT__44 - 30)) | (1 << (Python2ParserT__47 - 30)) | (1 << (Python2ParserT__60 - 30)))) != 0) || ((((_la - 62)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 62))) & ((1 << (Python2ParserT__61 - 62)) | (1 << (Python2ParserT__65 - 62)) | (1 << (Python2ParserT__66 - 62)) | (1 << (Python2ParserNAME - 62)) | (1 << (Python2ParserNUMBER - 62)) | (1 << (Python2ParserSTRING - 62)) | (1 << (Python2ParserOPEN_PAREN - 62)) | (1 << (Python2ParserOPEN_BRACE - 62)) | (1 << (Python2ParserOPEN_BRACKET - 62)))) != 0) {
			{
				p.SetState(757)
				p.Listmaker()
			}

		}
		{
			p.SetState(760)
			p.Match(Python2ParserCLOSE_BRACKET)
		}


	case Python2ParserOPEN_BRACE:
		{
			p.SetState(761)
			p.Match(Python2ParserOPEN_BRACE)
		}
		p.SetState(763)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 30)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 30))) & ((1 << (Python2ParserT__29 - 30)) | (1 << (Python2ParserT__44 - 30)) | (1 << (Python2ParserT__47 - 30)) | (1 << (Python2ParserT__60 - 30)))) != 0) || ((((_la - 62)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 62))) & ((1 << (Python2ParserT__61 - 62)) | (1 << (Python2ParserT__65 - 62)) | (1 << (Python2ParserT__66 - 62)) | (1 << (Python2ParserNAME - 62)) | (1 << (Python2ParserNUMBER - 62)) | (1 << (Python2ParserSTRING - 62)) | (1 << (Python2ParserOPEN_PAREN - 62)) | (1 << (Python2ParserOPEN_BRACE - 62)) | (1 << (Python2ParserOPEN_BRACKET - 62)))) != 0) {
			{
				p.SetState(762)
				p.Dictorsetmaker()
			}

		}
		{
			p.SetState(765)
			p.Match(Python2ParserCLOSE_BRACE)
		}


	case Python2ParserT__66:
		{
			p.SetState(766)
			p.Match(Python2ParserT__66)
		}
		{
			p.SetState(767)
			p.Testlist1()
		}
		{
			p.SetState(768)
			p.Match(Python2ParserT__66)
		}


	case Python2ParserT__29:
		{
			p.SetState(770)
			p.Match(Python2ParserT__29)
		}
		{
			p.SetState(771)
			p.Match(Python2ParserT__29)
		}
		{
			p.SetState(772)
			p.Match(Python2ParserT__29)
		}


	case Python2ParserNAME:
		{
			p.SetState(773)
			p.Match(Python2ParserNAME)
		}


	case Python2ParserNUMBER:
		{
			p.SetState(774)
			p.Match(Python2ParserNUMBER)
		}


	case Python2ParserSTRING:
		p.SetState(776)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == Python2ParserSTRING {
			{
				p.SetState(775)
				p.Match(Python2ParserSTRING)
			}


			p.SetState(778)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IListmakerContext is an interface to support dynamic dispatch.
type IListmakerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsListmakerContext differentiates from other interfaces.
	IsListmakerContext()
}

type ListmakerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListmakerContext() *ListmakerContext {
	var p = new(ListmakerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_listmaker
	return p
}

func (*ListmakerContext) IsListmakerContext() {}

func NewListmakerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListmakerContext {
	var p = new(ListmakerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_listmaker

	return p
}

func (s *ListmakerContext) GetParser() antlr.Parser { return s.parser }

func (s *ListmakerContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *ListmakerContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *ListmakerContext) List_for() IList_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_forContext)
}

func (s *ListmakerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListmakerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ListmakerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterListmaker(s)
	}
}

func (s *ListmakerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitListmaker(s)
	}
}

func (s *ListmakerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitListmaker(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Listmaker() (localctx IListmakerContext) {
	localctx = NewListmakerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, Python2ParserRULE_listmaker)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(782)
		p.Test()
	}
	p.SetState(794)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserT__39:
		{
			p.SetState(783)
			p.List_for()
		}


	case Python2ParserT__4, Python2ParserCLOSE_BRACKET:
		p.SetState(788)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(784)
					p.Match(Python2ParserT__4)
				}
				{
					p.SetState(785)
					p.Test()
				}


			}
			p.SetState(790)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())
		}
		p.SetState(792)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python2ParserT__4 {
			{
				p.SetState(791)
				p.Match(Python2ParserT__4)
			}

		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// ITestlist_compContext is an interface to support dynamic dispatch.
type ITestlist_compContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestlist_compContext differentiates from other interfaces.
	IsTestlist_compContext()
}

type Testlist_compContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlist_compContext() *Testlist_compContext {
	var p = new(Testlist_compContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_testlist_comp
	return p
}

func (*Testlist_compContext) IsTestlist_compContext() {}

func NewTestlist_compContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Testlist_compContext {
	var p = new(Testlist_compContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_testlist_comp

	return p
}

func (s *Testlist_compContext) GetParser() antlr.Parser { return s.parser }

func (s *Testlist_compContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Testlist_compContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Testlist_compContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *Testlist_compContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Testlist_compContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Testlist_compContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterTestlist_comp(s)
	}
}

func (s *Testlist_compContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitTestlist_comp(s)
	}
}

func (s *Testlist_compContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitTestlist_comp(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Testlist_comp() (localctx ITestlist_compContext) {
	localctx = NewTestlist_compContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, Python2ParserRULE_testlist_comp)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(796)
		p.Test()
	}
	p.SetState(808)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserT__39:
		{
			p.SetState(797)
			p.Comp_for()
		}


	case Python2ParserT__4, Python2ParserCLOSE_PAREN:
		p.SetState(802)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(798)
					p.Match(Python2ParserT__4)
				}
				{
					p.SetState(799)
					p.Test()
				}


			}
			p.SetState(804)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext())
		}
		p.SetState(806)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python2ParserT__4 {
			{
				p.SetState(805)
				p.Match(Python2ParserT__4)
			}

		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// ILambdefContext is an interface to support dynamic dispatch.
type ILambdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdefContext differentiates from other interfaces.
	IsLambdefContext()
}

type LambdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdefContext() *LambdefContext {
	var p = new(LambdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_lambdef
	return p
}

func (*LambdefContext) IsLambdefContext() {}

func NewLambdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdefContext {
	var p = new(LambdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_lambdef

	return p
}

func (s *LambdefContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdefContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *LambdefContext) Varargslist() IVarargslistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarargslistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarargslistContext)
}

func (s *LambdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LambdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterLambdef(s)
	}
}

func (s *LambdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitLambdef(s)
	}
}

func (s *LambdefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitLambdef(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Lambdef() (localctx ILambdefContext) {
	localctx = NewLambdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, Python2ParserRULE_lambdef)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(810)
		p.Match(Python2ParserT__44)
	}
	p.SetState(812)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__5 || _la == Python2ParserT__6 || _la == Python2ParserNAME || _la == Python2ParserOPEN_PAREN {
		{
			p.SetState(811)
			p.Varargslist()
		}

	}
	{
		p.SetState(814)
		p.Match(Python2ParserT__2)
	}
	{
		p.SetState(815)
		p.Test()
	}



	return localctx
}


// ITrailerContext is an interface to support dynamic dispatch.
type ITrailerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrailerContext differentiates from other interfaces.
	IsTrailerContext()
}

type TrailerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrailerContext() *TrailerContext {
	var p = new(TrailerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_trailer
	return p
}

func (*TrailerContext) IsTrailerContext() {}

func NewTrailerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrailerContext {
	var p = new(TrailerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_trailer

	return p
}

func (s *TrailerContext) GetParser() antlr.Parser { return s.parser }

func (s *TrailerContext) Arglist() IArglistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArglistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *TrailerContext) Subscriptlist() ISubscriptlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubscriptlistContext)
}

func (s *TrailerContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python2ParserNAME, 0)
}

func (s *TrailerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrailerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TrailerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterTrailer(s)
	}
}

func (s *TrailerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitTrailer(s)
	}
}

func (s *TrailerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitTrailer(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Trailer() (localctx ITrailerContext) {
	localctx = NewTrailerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, Python2ParserRULE_trailer)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(828)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserOPEN_PAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(817)
			p.Match(Python2ParserOPEN_PAREN)
		}
		p.SetState(819)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << Python2ParserT__5) | (1 << Python2ParserT__6) | (1 << Python2ParserT__29))) != 0) || ((((_la - 45)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 45))) & ((1 << (Python2ParserT__44 - 45)) | (1 << (Python2ParserT__47 - 45)) | (1 << (Python2ParserT__60 - 45)) | (1 << (Python2ParserT__61 - 45)) | (1 << (Python2ParserT__65 - 45)) | (1 << (Python2ParserT__66 - 45)) | (1 << (Python2ParserNAME - 45)) | (1 << (Python2ParserNUMBER - 45)) | (1 << (Python2ParserSTRING - 45)) | (1 << (Python2ParserOPEN_PAREN - 45)))) != 0) || _la == Python2ParserOPEN_BRACE || _la == Python2ParserOPEN_BRACKET {
			{
				p.SetState(818)
				p.Arglist()
			}

		}
		{
			p.SetState(821)
			p.Match(Python2ParserCLOSE_PAREN)
		}


	case Python2ParserOPEN_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(822)
			p.Match(Python2ParserOPEN_BRACKET)
		}
		{
			p.SetState(823)
			p.Subscriptlist()
		}
		{
			p.SetState(824)
			p.Match(Python2ParserCLOSE_BRACKET)
		}


	case Python2ParserT__29:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(826)
			p.Match(Python2ParserT__29)
		}
		{
			p.SetState(827)
			p.Match(Python2ParserNAME)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ISubscriptlistContext is an interface to support dynamic dispatch.
type ISubscriptlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscriptlistContext differentiates from other interfaces.
	IsSubscriptlistContext()
}

type SubscriptlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptlistContext() *SubscriptlistContext {
	var p = new(SubscriptlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_subscriptlist
	return p
}

func (*SubscriptlistContext) IsSubscriptlistContext() {}

func NewSubscriptlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptlistContext {
	var p = new(SubscriptlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_subscriptlist

	return p
}

func (s *SubscriptlistContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptlistContext) AllSubscript() []ISubscriptContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscriptContext)(nil)).Elem())
	var tst = make([]ISubscriptContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscriptContext)
		}
	}

	return tst
}

func (s *SubscriptlistContext) Subscript(i int) ISubscriptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscriptContext)
}

func (s *SubscriptlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SubscriptlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterSubscriptlist(s)
	}
}

func (s *SubscriptlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitSubscriptlist(s)
	}
}

func (s *SubscriptlistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitSubscriptlist(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Subscriptlist() (localctx ISubscriptlistContext) {
	localctx = NewSubscriptlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, Python2ParserRULE_subscriptlist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(830)
		p.Subscript()
	}
	p.SetState(835)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(831)
				p.Match(Python2ParserT__4)
			}
			{
				p.SetState(832)
				p.Subscript()
			}


		}
		p.SetState(837)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext())
	}
	p.SetState(839)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__4 {
		{
			p.SetState(838)
			p.Match(Python2ParserT__4)
		}

	}



	return localctx
}


// ISubscriptContext is an interface to support dynamic dispatch.
type ISubscriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscriptContext differentiates from other interfaces.
	IsSubscriptContext()
}

type SubscriptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptContext() *SubscriptContext {
	var p = new(SubscriptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_subscript
	return p
}

func (*SubscriptContext) IsSubscriptContext() {}

func NewSubscriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptContext {
	var p = new(SubscriptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_subscript

	return p
}

func (s *SubscriptContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *SubscriptContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *SubscriptContext) Sliceop() ISliceopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISliceopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISliceopContext)
}

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitSubscript(s)
	}
}

func (s *SubscriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitSubscript(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Subscript() (localctx ISubscriptContext) {
	localctx = NewSubscriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, Python2ParserRULE_subscript)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(841)
			p.Match(Python2ParserT__29)
		}
		{
			p.SetState(842)
			p.Match(Python2ParserT__29)
		}
		{
			p.SetState(843)
			p.Match(Python2ParserT__29)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(844)
			p.Test()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(846)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 30)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 30))) & ((1 << (Python2ParserT__29 - 30)) | (1 << (Python2ParserT__44 - 30)) | (1 << (Python2ParserT__47 - 30)) | (1 << (Python2ParserT__60 - 30)))) != 0) || ((((_la - 62)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 62))) & ((1 << (Python2ParserT__61 - 62)) | (1 << (Python2ParserT__65 - 62)) | (1 << (Python2ParserT__66 - 62)) | (1 << (Python2ParserNAME - 62)) | (1 << (Python2ParserNUMBER - 62)) | (1 << (Python2ParserSTRING - 62)) | (1 << (Python2ParserOPEN_PAREN - 62)) | (1 << (Python2ParserOPEN_BRACE - 62)) | (1 << (Python2ParserOPEN_BRACKET - 62)))) != 0) {
			{
				p.SetState(845)
				p.Test()
			}

		}
		{
			p.SetState(848)
			p.Match(Python2ParserT__2)
		}
		p.SetState(850)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 30)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 30))) & ((1 << (Python2ParserT__29 - 30)) | (1 << (Python2ParserT__44 - 30)) | (1 << (Python2ParserT__47 - 30)) | (1 << (Python2ParserT__60 - 30)))) != 0) || ((((_la - 62)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 62))) & ((1 << (Python2ParserT__61 - 62)) | (1 << (Python2ParserT__65 - 62)) | (1 << (Python2ParserT__66 - 62)) | (1 << (Python2ParserNAME - 62)) | (1 << (Python2ParserNUMBER - 62)) | (1 << (Python2ParserSTRING - 62)) | (1 << (Python2ParserOPEN_PAREN - 62)) | (1 << (Python2ParserOPEN_BRACE - 62)) | (1 << (Python2ParserOPEN_BRACKET - 62)))) != 0) {
			{
				p.SetState(849)
				p.Test()
			}

		}
		p.SetState(853)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python2ParserT__2 {
			{
				p.SetState(852)
				p.Sliceop()
			}

		}

	}


	return localctx
}


// ISliceopContext is an interface to support dynamic dispatch.
type ISliceopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSliceopContext differentiates from other interfaces.
	IsSliceopContext()
}

type SliceopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySliceopContext() *SliceopContext {
	var p = new(SliceopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_sliceop
	return p
}

func (*SliceopContext) IsSliceopContext() {}

func NewSliceopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SliceopContext {
	var p = new(SliceopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_sliceop

	return p
}

func (s *SliceopContext) GetParser() antlr.Parser { return s.parser }

func (s *SliceopContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *SliceopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SliceopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SliceopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterSliceop(s)
	}
}

func (s *SliceopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitSliceop(s)
	}
}

func (s *SliceopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitSliceop(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Sliceop() (localctx ISliceopContext) {
	localctx = NewSliceopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, Python2ParserRULE_sliceop)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(857)
		p.Match(Python2ParserT__2)
	}
	p.SetState(859)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 30)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 30))) & ((1 << (Python2ParserT__29 - 30)) | (1 << (Python2ParserT__44 - 30)) | (1 << (Python2ParserT__47 - 30)) | (1 << (Python2ParserT__60 - 30)))) != 0) || ((((_la - 62)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 62))) & ((1 << (Python2ParserT__61 - 62)) | (1 << (Python2ParserT__65 - 62)) | (1 << (Python2ParserT__66 - 62)) | (1 << (Python2ParserNAME - 62)) | (1 << (Python2ParserNUMBER - 62)) | (1 << (Python2ParserSTRING - 62)) | (1 << (Python2ParserOPEN_PAREN - 62)) | (1 << (Python2ParserOPEN_BRACE - 62)) | (1 << (Python2ParserOPEN_BRACKET - 62)))) != 0) {
		{
			p.SetState(858)
			p.Test()
		}

	}



	return localctx
}


// IExprlistContext is an interface to support dynamic dispatch.
type IExprlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprlistContext differentiates from other interfaces.
	IsExprlistContext()
}

type ExprlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprlistContext() *ExprlistContext {
	var p = new(ExprlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_exprlist
	return p
}

func (*ExprlistContext) IsExprlistContext() {}

func NewExprlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprlistContext {
	var p = new(ExprlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_exprlist

	return p
}

func (s *ExprlistContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprlistContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprlistContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExprlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterExprlist(s)
	}
}

func (s *ExprlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitExprlist(s)
	}
}

func (s *ExprlistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitExprlist(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Exprlist() (localctx IExprlistContext) {
	localctx = NewExprlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, Python2ParserRULE_exprlist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(861)
		p.Expr()
	}
	p.SetState(866)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(862)
				p.Match(Python2ParserT__4)
			}
			{
				p.SetState(863)
				p.Expr()
			}


		}
		p.SetState(868)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext())
	}
	p.SetState(870)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__4 {
		{
			p.SetState(869)
			p.Match(Python2ParserT__4)
		}

	}



	return localctx
}


// ITestlistContext is an interface to support dynamic dispatch.
type ITestlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestlistContext differentiates from other interfaces.
	IsTestlistContext()
}

type TestlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlistContext() *TestlistContext {
	var p = new(TestlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_testlist
	return p
}

func (*TestlistContext) IsTestlistContext() {}

func NewTestlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestlistContext {
	var p = new(TestlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_testlist

	return p
}

func (s *TestlistContext) GetParser() antlr.Parser { return s.parser }

func (s *TestlistContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *TestlistContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TestlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TestlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterTestlist(s)
	}
}

func (s *TestlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitTestlist(s)
	}
}

func (s *TestlistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitTestlist(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Testlist() (localctx ITestlistContext) {
	localctx = NewTestlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, Python2ParserRULE_testlist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(872)
		p.Test()
	}
	p.SetState(877)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(873)
				p.Match(Python2ParserT__4)
			}
			{
				p.SetState(874)
				p.Test()
			}


		}
		p.SetState(879)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext())
	}
	p.SetState(881)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__4 {
		{
			p.SetState(880)
			p.Match(Python2ParserT__4)
		}

	}



	return localctx
}


// IDictorsetmakerContext is an interface to support dynamic dispatch.
type IDictorsetmakerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictorsetmakerContext differentiates from other interfaces.
	IsDictorsetmakerContext()
}

type DictorsetmakerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictorsetmakerContext() *DictorsetmakerContext {
	var p = new(DictorsetmakerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_dictorsetmaker
	return p
}

func (*DictorsetmakerContext) IsDictorsetmakerContext() {}

func NewDictorsetmakerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictorsetmakerContext {
	var p = new(DictorsetmakerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_dictorsetmaker

	return p
}

func (s *DictorsetmakerContext) GetParser() antlr.Parser { return s.parser }

func (s *DictorsetmakerContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *DictorsetmakerContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *DictorsetmakerContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *DictorsetmakerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictorsetmakerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DictorsetmakerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterDictorsetmaker(s)
	}
}

func (s *DictorsetmakerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitDictorsetmaker(s)
	}
}

func (s *DictorsetmakerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitDictorsetmaker(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Dictorsetmaker() (localctx IDictorsetmakerContext) {
	localctx = NewDictorsetmakerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, Python2ParserRULE_dictorsetmaker)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(916)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(883)
			p.Test()
		}
		{
			p.SetState(884)
			p.Match(Python2ParserT__2)
		}
		{
			p.SetState(885)
			p.Test()
		}
		p.SetState(900)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python2ParserT__39:
			{
				p.SetState(886)
				p.Comp_for()
			}


		case Python2ParserT__4, Python2ParserCLOSE_BRACE:
			p.SetState(894)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(887)
						p.Match(Python2ParserT__4)
					}
					{
						p.SetState(888)
						p.Test()
					}
					{
						p.SetState(889)
						p.Match(Python2ParserT__2)
					}
					{
						p.SetState(890)
						p.Test()
					}


				}
				p.SetState(896)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())
			}
			p.SetState(898)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == Python2ParserT__4 {
				{
					p.SetState(897)
					p.Match(Python2ParserT__4)
				}

			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}



	case 2:
		{
			p.SetState(902)
			p.Test()
		}
		p.SetState(914)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python2ParserT__39:
			{
				p.SetState(903)
				p.Comp_for()
			}


		case Python2ParserT__4, Python2ParserCLOSE_BRACE:
			p.SetState(908)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(904)
						p.Match(Python2ParserT__4)
					}
					{
						p.SetState(905)
						p.Test()
					}


				}
				p.SetState(910)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext())
			}
			p.SetState(912)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == Python2ParserT__4 {
				{
					p.SetState(911)
					p.Match(Python2ParserT__4)
				}

			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}


	}



	return localctx
}


// IClassdefContext is an interface to support dynamic dispatch.
type IClassdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassdefContext differentiates from other interfaces.
	IsClassdefContext()
}

type ClassdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassdefContext() *ClassdefContext {
	var p = new(ClassdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_classdef
	return p
}

func (*ClassdefContext) IsClassdefContext() {}

func NewClassdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassdefContext {
	var p = new(ClassdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_classdef

	return p
}

func (s *ClassdefContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python2ParserNAME, 0)
}

func (s *ClassdefContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *ClassdefContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *ClassdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ClassdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterClassdef(s)
	}
}

func (s *ClassdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitClassdef(s)
	}
}

func (s *ClassdefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitClassdef(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Classdef() (localctx IClassdefContext) {
	localctx = NewClassdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, Python2ParserRULE_classdef)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(918)
		p.Match(Python2ParserT__67)
	}
	{
		p.SetState(919)
		p.Match(Python2ParserNAME)
	}
	p.SetState(925)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserOPEN_PAREN {
		{
			p.SetState(920)
			p.Match(Python2ParserOPEN_PAREN)
		}
		p.SetState(922)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 30)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 30))) & ((1 << (Python2ParserT__29 - 30)) | (1 << (Python2ParserT__44 - 30)) | (1 << (Python2ParserT__47 - 30)) | (1 << (Python2ParserT__60 - 30)))) != 0) || ((((_la - 62)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 62))) & ((1 << (Python2ParserT__61 - 62)) | (1 << (Python2ParserT__65 - 62)) | (1 << (Python2ParserT__66 - 62)) | (1 << (Python2ParserNAME - 62)) | (1 << (Python2ParserNUMBER - 62)) | (1 << (Python2ParserSTRING - 62)) | (1 << (Python2ParserOPEN_PAREN - 62)) | (1 << (Python2ParserOPEN_BRACE - 62)) | (1 << (Python2ParserOPEN_BRACKET - 62)))) != 0) {
			{
				p.SetState(921)
				p.Testlist()
			}

		}
		{
			p.SetState(924)
			p.Match(Python2ParserCLOSE_PAREN)
		}

	}
	{
		p.SetState(927)
		p.Match(Python2ParserT__2)
	}
	{
		p.SetState(928)
		p.Suite()
	}



	return localctx
}


// IArglistContext is an interface to support dynamic dispatch.
type IArglistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArglistContext differentiates from other interfaces.
	IsArglistContext()
}

type ArglistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArglistContext() *ArglistContext {
	var p = new(ArglistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_arglist
	return p
}

func (*ArglistContext) IsArglistContext() {}

func NewArglistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArglistContext {
	var p = new(ArglistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_arglist

	return p
}

func (s *ArglistContext) GetParser() antlr.Parser { return s.parser }

func (s *ArglistContext) AllArgument() []IArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentContext)(nil)).Elem())
	var tst = make([]IArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentContext)
		}
	}

	return tst
}

func (s *ArglistContext) Argument(i int) IArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArglistContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *ArglistContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *ArglistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArglistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArglistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterArglist(s)
	}
}

func (s *ArglistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitArglist(s)
	}
}

func (s *ArglistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitArglist(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Arglist() (localctx IArglistContext) {
	localctx = NewArglistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, Python2ParserRULE_arglist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(935)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(930)
				p.Argument()
			}
			{
				p.SetState(931)
				p.Match(Python2ParserT__4)
			}


		}
		p.SetState(937)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext())
	}
	p.SetState(958)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserT__29, Python2ParserT__44, Python2ParserT__47, Python2ParserT__60, Python2ParserT__61, Python2ParserT__65, Python2ParserT__66, Python2ParserNAME, Python2ParserNUMBER, Python2ParserSTRING, Python2ParserOPEN_PAREN, Python2ParserOPEN_BRACE, Python2ParserOPEN_BRACKET:
		{
			p.SetState(938)
			p.Argument()
		}
		p.SetState(940)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python2ParserT__4 {
			{
				p.SetState(939)
				p.Match(Python2ParserT__4)
			}

		}


	case Python2ParserT__5:
		{
			p.SetState(942)
			p.Match(Python2ParserT__5)
		}
		{
			p.SetState(943)
			p.Test()
		}
		p.SetState(948)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(944)
					p.Match(Python2ParserT__4)
				}
				{
					p.SetState(945)
					p.Argument()
				}


			}
			p.SetState(950)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext())
		}
		p.SetState(954)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python2ParserT__4 {
			{
				p.SetState(951)
				p.Match(Python2ParserT__4)
			}
			{
				p.SetState(952)
				p.Match(Python2ParserT__6)
			}
			{
				p.SetState(953)
				p.Test()
			}

		}


	case Python2ParserT__6:
		{
			p.SetState(956)
			p.Match(Python2ParserT__6)
		}
		{
			p.SetState(957)
			p.Test()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_argument
	return p
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *ArgumentContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *ArgumentContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitArgument(s)
	}
}

func (s *ArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitArgument(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, Python2ParserRULE_argument)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(968)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(960)
			p.Test()
		}
		p.SetState(962)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == Python2ParserT__39 {
			{
				p.SetState(961)
				p.Comp_for()
			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(964)
			p.Test()
		}
		{
			p.SetState(965)
			p.Match(Python2ParserT__3)
		}
		{
			p.SetState(966)
			p.Test()
		}

	}


	return localctx
}


// IList_iterContext is an interface to support dynamic dispatch.
type IList_iterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_iterContext differentiates from other interfaces.
	IsList_iterContext()
}

type List_iterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_iterContext() *List_iterContext {
	var p = new(List_iterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_list_iter
	return p
}

func (*List_iterContext) IsList_iterContext() {}

func NewList_iterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_iterContext {
	var p = new(List_iterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_list_iter

	return p
}

func (s *List_iterContext) GetParser() antlr.Parser { return s.parser }

func (s *List_iterContext) List_for() IList_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_forContext)
}

func (s *List_iterContext) List_if() IList_ifContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_ifContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_ifContext)
}

func (s *List_iterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_iterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *List_iterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterList_iter(s)
	}
}

func (s *List_iterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitList_iter(s)
	}
}

func (s *List_iterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitList_iter(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) List_iter() (localctx IList_iterContext) {
	localctx = NewList_iterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, Python2ParserRULE_list_iter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(972)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserT__39:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(970)
			p.List_for()
		}


	case Python2ParserT__35:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(971)
			p.List_if()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IList_forContext is an interface to support dynamic dispatch.
type IList_forContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_forContext differentiates from other interfaces.
	IsList_forContext()
}

type List_forContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_forContext() *List_forContext {
	var p = new(List_forContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_list_for
	return p
}

func (*List_forContext) IsList_forContext() {}

func NewList_forContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_forContext {
	var p = new(List_forContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_list_for

	return p
}

func (s *List_forContext) GetParser() antlr.Parser { return s.parser }

func (s *List_forContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *List_forContext) Testlist_safe() ITestlist_safeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlist_safeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlist_safeContext)
}

func (s *List_forContext) List_iter() IList_iterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_iterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_iterContext)
}

func (s *List_forContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_forContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *List_forContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterList_for(s)
	}
}

func (s *List_forContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitList_for(s)
	}
}

func (s *List_forContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitList_for(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) List_for() (localctx IList_forContext) {
	localctx = NewList_forContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, Python2ParserRULE_list_for)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(974)
		p.Match(Python2ParserT__39)
	}
	{
		p.SetState(975)
		p.Exprlist()
	}
	{
		p.SetState(976)
		p.Match(Python2ParserT__33)
	}
	{
		p.SetState(977)
		p.Testlist_safe()
	}
	p.SetState(979)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__35 || _la == Python2ParserT__39 {
		{
			p.SetState(978)
			p.List_iter()
		}

	}



	return localctx
}


// IList_ifContext is an interface to support dynamic dispatch.
type IList_ifContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_ifContext differentiates from other interfaces.
	IsList_ifContext()
}

type List_ifContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_ifContext() *List_ifContext {
	var p = new(List_ifContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_list_if
	return p
}

func (*List_ifContext) IsList_ifContext() {}

func NewList_ifContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_ifContext {
	var p = new(List_ifContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_list_if

	return p
}

func (s *List_ifContext) GetParser() antlr.Parser { return s.parser }

func (s *List_ifContext) Old_test() IOld_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOld_testContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOld_testContext)
}

func (s *List_ifContext) List_iter() IList_iterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_iterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_iterContext)
}

func (s *List_ifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_ifContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *List_ifContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterList_if(s)
	}
}

func (s *List_ifContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitList_if(s)
	}
}

func (s *List_ifContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitList_if(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) List_if() (localctx IList_ifContext) {
	localctx = NewList_ifContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, Python2ParserRULE_list_if)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(981)
		p.Match(Python2ParserT__35)
	}
	{
		p.SetState(982)
		p.Old_test()
	}
	p.SetState(984)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__35 || _la == Python2ParserT__39 {
		{
			p.SetState(983)
			p.List_iter()
		}

	}



	return localctx
}


// IComp_iterContext is an interface to support dynamic dispatch.
type IComp_iterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_iterContext differentiates from other interfaces.
	IsComp_iterContext()
}

type Comp_iterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_iterContext() *Comp_iterContext {
	var p = new(Comp_iterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_comp_iter
	return p
}

func (*Comp_iterContext) IsComp_iterContext() {}

func NewComp_iterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_iterContext {
	var p = new(Comp_iterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_comp_iter

	return p
}

func (s *Comp_iterContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_iterContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *Comp_iterContext) Comp_if() IComp_ifContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_ifContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_ifContext)
}

func (s *Comp_iterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_iterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Comp_iterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterComp_iter(s)
	}
}

func (s *Comp_iterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitComp_iter(s)
	}
}

func (s *Comp_iterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitComp_iter(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Comp_iter() (localctx IComp_iterContext) {
	localctx = NewComp_iterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, Python2ParserRULE_comp_iter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(988)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python2ParserT__39:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(986)
			p.Comp_for()
		}


	case Python2ParserT__35:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(987)
			p.Comp_if()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IComp_forContext is an interface to support dynamic dispatch.
type IComp_forContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_forContext differentiates from other interfaces.
	IsComp_forContext()
}

type Comp_forContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_forContext() *Comp_forContext {
	var p = new(Comp_forContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_comp_for
	return p
}

func (*Comp_forContext) IsComp_forContext() {}

func NewComp_forContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_forContext {
	var p = new(Comp_forContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_comp_for

	return p
}

func (s *Comp_forContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_forContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *Comp_forContext) Or_test() IOr_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_testContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *Comp_forContext) Comp_iter() IComp_iterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_iterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_iterContext)
}

func (s *Comp_forContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_forContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Comp_forContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterComp_for(s)
	}
}

func (s *Comp_forContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitComp_for(s)
	}
}

func (s *Comp_forContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitComp_for(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Comp_for() (localctx IComp_forContext) {
	localctx = NewComp_forContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, Python2ParserRULE_comp_for)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(990)
		p.Match(Python2ParserT__39)
	}
	{
		p.SetState(991)
		p.Exprlist()
	}
	{
		p.SetState(992)
		p.Match(Python2ParserT__33)
	}
	{
		p.SetState(993)
		p.Or_test()
	}
	p.SetState(995)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__35 || _la == Python2ParserT__39 {
		{
			p.SetState(994)
			p.Comp_iter()
		}

	}



	return localctx
}


// IComp_ifContext is an interface to support dynamic dispatch.
type IComp_ifContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_ifContext differentiates from other interfaces.
	IsComp_ifContext()
}

type Comp_ifContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_ifContext() *Comp_ifContext {
	var p = new(Comp_ifContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_comp_if
	return p
}

func (*Comp_ifContext) IsComp_ifContext() {}

func NewComp_ifContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_ifContext {
	var p = new(Comp_ifContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_comp_if

	return p
}

func (s *Comp_ifContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_ifContext) Old_test() IOld_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOld_testContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOld_testContext)
}

func (s *Comp_ifContext) Comp_iter() IComp_iterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_iterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_iterContext)
}

func (s *Comp_ifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_ifContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Comp_ifContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterComp_if(s)
	}
}

func (s *Comp_ifContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitComp_if(s)
	}
}

func (s *Comp_ifContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitComp_if(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Comp_if() (localctx IComp_ifContext) {
	localctx = NewComp_ifContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, Python2ParserRULE_comp_if)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(997)
		p.Match(Python2ParserT__35)
	}
	{
		p.SetState(998)
		p.Old_test()
	}
	p.SetState(1000)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__35 || _la == Python2ParserT__39 {
		{
			p.SetState(999)
			p.Comp_iter()
		}

	}



	return localctx
}


// ITestlist1Context is an interface to support dynamic dispatch.
type ITestlist1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestlist1Context differentiates from other interfaces.
	IsTestlist1Context()
}

type Testlist1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlist1Context() *Testlist1Context {
	var p = new(Testlist1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_testlist1
	return p
}

func (*Testlist1Context) IsTestlist1Context() {}

func NewTestlist1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Testlist1Context {
	var p = new(Testlist1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_testlist1

	return p
}

func (s *Testlist1Context) GetParser() antlr.Parser { return s.parser }

func (s *Testlist1Context) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Testlist1Context) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Testlist1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Testlist1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Testlist1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterTestlist1(s)
	}
}

func (s *Testlist1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitTestlist1(s)
	}
}

func (s *Testlist1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitTestlist1(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Testlist1() (localctx ITestlist1Context) {
	localctx = NewTestlist1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, Python2ParserRULE_testlist1)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1002)
		p.Test()
	}
	p.SetState(1007)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == Python2ParserT__4 {
		{
			p.SetState(1003)
			p.Match(Python2ParserT__4)
		}
		{
			p.SetState(1004)
			p.Test()
		}


		p.SetState(1009)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IEncoding_declContext is an interface to support dynamic dispatch.
type IEncoding_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEncoding_declContext differentiates from other interfaces.
	IsEncoding_declContext()
}

type Encoding_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncoding_declContext() *Encoding_declContext {
	var p = new(Encoding_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_encoding_decl
	return p
}

func (*Encoding_declContext) IsEncoding_declContext() {}

func NewEncoding_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Encoding_declContext {
	var p = new(Encoding_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_encoding_decl

	return p
}

func (s *Encoding_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Encoding_declContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python2ParserNAME, 0)
}

func (s *Encoding_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Encoding_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Encoding_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterEncoding_decl(s)
	}
}

func (s *Encoding_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitEncoding_decl(s)
	}
}

func (s *Encoding_declContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitEncoding_decl(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Encoding_decl() (localctx IEncoding_declContext) {
	localctx = NewEncoding_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, Python2ParserRULE_encoding_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1010)
		p.Match(Python2ParserNAME)
	}



	return localctx
}


// IYield_exprContext is an interface to support dynamic dispatch.
type IYield_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYield_exprContext differentiates from other interfaces.
	IsYield_exprContext()
}

type Yield_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_exprContext() *Yield_exprContext {
	var p = new(Yield_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python2ParserRULE_yield_expr
	return p
}

func (*Yield_exprContext) IsYield_exprContext() {}

func NewYield_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_exprContext {
	var p = new(Yield_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python2ParserRULE_yield_expr

	return p
}

func (s *Yield_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_exprContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Yield_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Yield_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.EnterYield_expr(s)
	}
}

func (s *Yield_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python2Listener); ok {
		listenerT.ExitYield_expr(s)
	}
}

func (s *Yield_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python2Visitor:
		return t.VisitYield_expr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *Python2Parser) Yield_expr() (localctx IYield_exprContext) {
	localctx = NewYield_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, Python2ParserRULE_yield_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1012)
		p.Match(Python2ParserT__68)
	}
	p.SetState(1014)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == Python2ParserT__28 {
		{
			p.SetState(1013)
			p.Match(Python2ParserT__28)
		}

	}
	p.SetState(1017)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 30)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 30))) & ((1 << (Python2ParserT__29 - 30)) | (1 << (Python2ParserT__44 - 30)) | (1 << (Python2ParserT__47 - 30)) | (1 << (Python2ParserT__60 - 30)))) != 0) || ((((_la - 62)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 62))) & ((1 << (Python2ParserT__61 - 62)) | (1 << (Python2ParserT__65 - 62)) | (1 << (Python2ParserT__66 - 62)) | (1 << (Python2ParserNAME - 62)) | (1 << (Python2ParserNUMBER - 62)) | (1 << (Python2ParserSTRING - 62)) | (1 << (Python2ParserOPEN_PAREN - 62)) | (1 << (Python2ParserOPEN_BRACE - 62)) | (1 << (Python2ParserOPEN_BRACKET - 62)))) != 0) {
		{
			p.SetState(1016)
			p.Testlist()
		}

	}



	return localctx
}


func (p *Python2Parser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 16:
			var t *Print_stmtContext = nil
			if localctx != nil { t = localctx.(*Print_stmtContext) }
			return p.Print_stmt_Sempred(t, predIndex)


	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *Python2Parser) Print_stmt_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
			return self._input.LT(1).text=='print'

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

