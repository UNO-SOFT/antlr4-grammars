// Package arithmetic_test contains tests for the arithmetic grammar.
// The tests should be run with the -timeout flag, to ensure the parser doesn't
// get stuck.
//
// Do not edit this file, it is generated by maketest.go
//
package arithmetic_test

import (
	"bramp.net/antlr4test-go/arithmetic"
	"github.com/antlr/antlr4/runtime/Go/antlr"
	"path/filepath"
	"testing"
)

const MAX_TOKENS = 1000000

var examples = []string{
	"grammars-v4/arithmetic/examples/number1.txt",
	"grammars-v4/arithmetic/examples/number2.txt",
	"grammars-v4/arithmetic/examples/number3.txt",
	"grammars-v4/arithmetic/examples/number4.txt",
	"grammars-v4/arithmetic/examples/number5.txt",
	"grammars-v4/arithmetic/examples/number6.txt",
	"grammars-v4/arithmetic/examples/paren1.txt",
	"grammars-v4/arithmetic/examples/pow1.txt",
	"grammars-v4/arithmetic/examples/precedence1.txt",
	"grammars-v4/arithmetic/examples/precedence1.txt.tree",
	"grammars-v4/arithmetic/examples/precedence2.txt",
	"grammars-v4/arithmetic/examples/precedence2.txt.tree",
	"grammars-v4/arithmetic/examples/precedence3.txt",
	"grammars-v4/arithmetic/examples/precedence3.txt.tree",
	"grammars-v4/arithmetic/examples/pythagoras.txt",
	"grammars-v4/arithmetic/examples/pythagoras2.txt",
	"grammars-v4/arithmetic/examples/pythagoras2.txt.tree",
	"grammars-v4/arithmetic/examples/quadratic.txt",
	"grammars-v4/arithmetic/examples/simple.txt",
	"grammars-v4/arithmetic/examples/simple2.txt",
	"grammars-v4/arithmetic/examples/unary.txt",
}

func newCharStream(filename string) (antlr.CharStream, error) {
	var input antlr.CharStream
	input, err := antlr.NewFileStream(filepath.Join("..", filename))
	if err != nil {
		return nil, err
	}

	return input, nil
}

// TODO Add an Example func

func TestarithmeticLexer(t *testing.T) {
	for _, file := range examples {
		input, err := newCharStream(file)
		if err != nil {
			t.Errorf("Failed to open example file: %s", err)
		}

		// Create the Lexer
		lexer := arithmetic.NewarithmeticLexer(input)

		// Try and read all tokens
		i := 0
		for ; i < MAX_TOKENS; i++ {
			t := lexer.NextToken()
			if t.GetTokenType() == antlr.TokenEOF {
				break
			}
		}

		// If we read too many tokens, then perhaps there is a problem with the lexer.
		if i == MAX_TOKENS {
			t.Errorf("NewarithmeticLexer(%q) read %d tokens without finding EOF", file, i)
		}
	}
}

func TestarithmeticParser(t *testing.T) {
	for _, file := range examples {
		input, err := newCharStream(file)
		if err != nil {
			t.Errorf("Failed to open example file: %s", err)
		}

		// Create the Lexer
		lexer := arithmetic.NewarithmeticLexer(input)
		stream := antlr.NewCommonTokenStream(lexer, antlr.TokenDefaultChannel)

		// Create the Parser
		p := arithmetic.NewarithmeticParser(stream)
		p.BuildParseTrees = true
		p.AddErrorListener(antlr.NewDiagnosticErrorListener(true)) // TODO Change this
		p.AddErrorListener(antlr.NewConsoleErrorListener())

		// Finally test
		p.Equation()

		// TODO Check for errors
	}
}
