// Generated from Cobol85.g4 by ANTLR 4.7.

package cobol85 // Cobol85
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 571, 6261,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 4, 176, 9, 176, 4, 177, 9, 177, 4, 178, 9, 178,
	4, 179, 9, 179, 4, 180, 9, 180, 4, 181, 9, 181, 4, 182, 9, 182, 4, 183,
	9, 183, 4, 184, 9, 184, 4, 185, 9, 185, 4, 186, 9, 186, 4, 187, 9, 187,
	4, 188, 9, 188, 4, 189, 9, 189, 4, 190, 9, 190, 4, 191, 9, 191, 4, 192,
	9, 192, 4, 193, 9, 193, 4, 194, 9, 194, 4, 195, 9, 195, 4, 196, 9, 196,
	4, 197, 9, 197, 4, 198, 9, 198, 4, 199, 9, 199, 4, 200, 9, 200, 4, 201,
	9, 201, 4, 202, 9, 202, 4, 203, 9, 203, 4, 204, 9, 204, 4, 205, 9, 205,
	4, 206, 9, 206, 4, 207, 9, 207, 4, 208, 9, 208, 4, 209, 9, 209, 4, 210,
	9, 210, 4, 211, 9, 211, 4, 212, 9, 212, 4, 213, 9, 213, 4, 214, 9, 214,
	4, 215, 9, 215, 4, 216, 9, 216, 4, 217, 9, 217, 4, 218, 9, 218, 4, 219,
	9, 219, 4, 220, 9, 220, 4, 221, 9, 221, 4, 222, 9, 222, 4, 223, 9, 223,
	4, 224, 9, 224, 4, 225, 9, 225, 4, 226, 9, 226, 4, 227, 9, 227, 4, 228,
	9, 228, 4, 229, 9, 229, 4, 230, 9, 230, 4, 231, 9, 231, 4, 232, 9, 232,
	4, 233, 9, 233, 4, 234, 9, 234, 4, 235, 9, 235, 4, 236, 9, 236, 4, 237,
	9, 237, 4, 238, 9, 238, 4, 239, 9, 239, 4, 240, 9, 240, 4, 241, 9, 241,
	4, 242, 9, 242, 4, 243, 9, 243, 4, 244, 9, 244, 4, 245, 9, 245, 4, 246,
	9, 246, 4, 247, 9, 247, 4, 248, 9, 248, 4, 249, 9, 249, 4, 250, 9, 250,
	4, 251, 9, 251, 4, 252, 9, 252, 4, 253, 9, 253, 4, 254, 9, 254, 4, 255,
	9, 255, 4, 256, 9, 256, 4, 257, 9, 257, 4, 258, 9, 258, 4, 259, 9, 259,
	4, 260, 9, 260, 4, 261, 9, 261, 4, 262, 9, 262, 4, 263, 9, 263, 4, 264,
	9, 264, 4, 265, 9, 265, 4, 266, 9, 266, 4, 267, 9, 267, 4, 268, 9, 268,
	4, 269, 9, 269, 4, 270, 9, 270, 4, 271, 9, 271, 4, 272, 9, 272, 4, 273,
	9, 273, 4, 274, 9, 274, 4, 275, 9, 275, 4, 276, 9, 276, 4, 277, 9, 277,
	4, 278, 9, 278, 4, 279, 9, 279, 4, 280, 9, 280, 4, 281, 9, 281, 4, 282,
	9, 282, 4, 283, 9, 283, 4, 284, 9, 284, 4, 285, 9, 285, 4, 286, 9, 286,
	4, 287, 9, 287, 4, 288, 9, 288, 4, 289, 9, 289, 4, 290, 9, 290, 4, 291,
	9, 291, 4, 292, 9, 292, 4, 293, 9, 293, 4, 294, 9, 294, 4, 295, 9, 295,
	4, 296, 9, 296, 4, 297, 9, 297, 4, 298, 9, 298, 4, 299, 9, 299, 4, 300,
	9, 300, 4, 301, 9, 301, 4, 302, 9, 302, 4, 303, 9, 303, 4, 304, 9, 304,
	4, 305, 9, 305, 4, 306, 9, 306, 4, 307, 9, 307, 4, 308, 9, 308, 4, 309,
	9, 309, 4, 310, 9, 310, 4, 311, 9, 311, 4, 312, 9, 312, 4, 313, 9, 313,
	4, 314, 9, 314, 4, 315, 9, 315, 4, 316, 9, 316, 4, 317, 9, 317, 4, 318,
	9, 318, 4, 319, 9, 319, 4, 320, 9, 320, 4, 321, 9, 321, 4, 322, 9, 322,
	4, 323, 9, 323, 4, 324, 9, 324, 4, 325, 9, 325, 4, 326, 9, 326, 4, 327,
	9, 327, 4, 328, 9, 328, 4, 329, 9, 329, 4, 330, 9, 330, 4, 331, 9, 331,
	4, 332, 9, 332, 4, 333, 9, 333, 4, 334, 9, 334, 4, 335, 9, 335, 4, 336,
	9, 336, 4, 337, 9, 337, 4, 338, 9, 338, 4, 339, 9, 339, 4, 340, 9, 340,
	4, 341, 9, 341, 4, 342, 9, 342, 4, 343, 9, 343, 4, 344, 9, 344, 4, 345,
	9, 345, 4, 346, 9, 346, 4, 347, 9, 347, 4, 348, 9, 348, 4, 349, 9, 349,
	4, 350, 9, 350, 4, 351, 9, 351, 4, 352, 9, 352, 4, 353, 9, 353, 4, 354,
	9, 354, 4, 355, 9, 355, 4, 356, 9, 356, 4, 357, 9, 357, 4, 358, 9, 358,
	4, 359, 9, 359, 4, 360, 9, 360, 4, 361, 9, 361, 4, 362, 9, 362, 4, 363,
	9, 363, 4, 364, 9, 364, 4, 365, 9, 365, 4, 366, 9, 366, 4, 367, 9, 367,
	4, 368, 9, 368, 4, 369, 9, 369, 4, 370, 9, 370, 4, 371, 9, 371, 4, 372,
	9, 372, 4, 373, 9, 373, 4, 374, 9, 374, 4, 375, 9, 375, 4, 376, 9, 376,
	4, 377, 9, 377, 4, 378, 9, 378, 4, 379, 9, 379, 4, 380, 9, 380, 4, 381,
	9, 381, 4, 382, 9, 382, 4, 383, 9, 383, 4, 384, 9, 384, 4, 385, 9, 385,
	4, 386, 9, 386, 4, 387, 9, 387, 4, 388, 9, 388, 4, 389, 9, 389, 4, 390,
	9, 390, 4, 391, 9, 391, 4, 392, 9, 392, 4, 393, 9, 393, 4, 394, 9, 394,
	4, 395, 9, 395, 4, 396, 9, 396, 4, 397, 9, 397, 4, 398, 9, 398, 4, 399,
	9, 399, 4, 400, 9, 400, 4, 401, 9, 401, 4, 402, 9, 402, 4, 403, 9, 403,
	4, 404, 9, 404, 4, 405, 9, 405, 4, 406, 9, 406, 4, 407, 9, 407, 4, 408,
	9, 408, 4, 409, 9, 409, 4, 410, 9, 410, 4, 411, 9, 411, 4, 412, 9, 412,
	4, 413, 9, 413, 4, 414, 9, 414, 4, 415, 9, 415, 4, 416, 9, 416, 4, 417,
	9, 417, 4, 418, 9, 418, 4, 419, 9, 419, 4, 420, 9, 420, 4, 421, 9, 421,
	4, 422, 9, 422, 4, 423, 9, 423, 4, 424, 9, 424, 4, 425, 9, 425, 4, 426,
	9, 426, 4, 427, 9, 427, 4, 428, 9, 428, 4, 429, 9, 429, 4, 430, 9, 430,
	4, 431, 9, 431, 4, 432, 9, 432, 4, 433, 9, 433, 4, 434, 9, 434, 4, 435,
	9, 435, 4, 436, 9, 436, 4, 437, 9, 437, 4, 438, 9, 438, 4, 439, 9, 439,
	4, 440, 9, 440, 4, 441, 9, 441, 4, 442, 9, 442, 4, 443, 9, 443, 4, 444,
	9, 444, 4, 445, 9, 445, 4, 446, 9, 446, 4, 447, 9, 447, 4, 448, 9, 448,
	4, 449, 9, 449, 4, 450, 9, 450, 4, 451, 9, 451, 4, 452, 9, 452, 4, 453,
	9, 453, 4, 454, 9, 454, 4, 455, 9, 455, 4, 456, 9, 456, 4, 457, 9, 457,
	4, 458, 9, 458, 4, 459, 9, 459, 4, 460, 9, 460, 4, 461, 9, 461, 4, 462,
	9, 462, 4, 463, 9, 463, 4, 464, 9, 464, 4, 465, 9, 465, 4, 466, 9, 466,
	4, 467, 9, 467, 4, 468, 9, 468, 4, 469, 9, 469, 4, 470, 9, 470, 4, 471,
	9, 471, 4, 472, 9, 472, 4, 473, 9, 473, 4, 474, 9, 474, 4, 475, 9, 475,
	4, 476, 9, 476, 4, 477, 9, 477, 4, 478, 9, 478, 4, 479, 9, 479, 4, 480,
	9, 480, 4, 481, 9, 481, 4, 482, 9, 482, 4, 483, 9, 483, 4, 484, 9, 484,
	4, 485, 9, 485, 4, 486, 9, 486, 4, 487, 9, 487, 4, 488, 9, 488, 4, 489,
	9, 489, 4, 490, 9, 490, 4, 491, 9, 491, 4, 492, 9, 492, 4, 493, 9, 493,
	4, 494, 9, 494, 4, 495, 9, 495, 4, 496, 9, 496, 4, 497, 9, 497, 4, 498,
	9, 498, 4, 499, 9, 499, 4, 500, 9, 500, 4, 501, 9, 501, 4, 502, 9, 502,
	4, 503, 9, 503, 4, 504, 9, 504, 4, 505, 9, 505, 4, 506, 9, 506, 4, 507,
	9, 507, 4, 508, 9, 508, 4, 509, 9, 509, 4, 510, 9, 510, 4, 511, 9, 511,
	4, 512, 9, 512, 4, 513, 9, 513, 4, 514, 9, 514, 4, 515, 9, 515, 4, 516,
	9, 516, 4, 517, 9, 517, 4, 518, 9, 518, 4, 519, 9, 519, 4, 520, 9, 520,
	4, 521, 9, 521, 4, 522, 9, 522, 4, 523, 9, 523, 4, 524, 9, 524, 4, 525,
	9, 525, 4, 526, 9, 526, 4, 527, 9, 527, 4, 528, 9, 528, 4, 529, 9, 529,
	4, 530, 9, 530, 4, 531, 9, 531, 4, 532, 9, 532, 4, 533, 9, 533, 4, 534,
	9, 534, 4, 535, 9, 535, 4, 536, 9, 536, 4, 537, 9, 537, 4, 538, 9, 538,
	4, 539, 9, 539, 4, 540, 9, 540, 4, 541, 9, 541, 4, 542, 9, 542, 4, 543,
	9, 543, 4, 544, 9, 544, 4, 545, 9, 545, 4, 546, 9, 546, 4, 547, 9, 547,
	4, 548, 9, 548, 4, 549, 9, 549, 4, 550, 9, 550, 4, 551, 9, 551, 4, 552,
	9, 552, 4, 553, 9, 553, 4, 554, 9, 554, 4, 555, 9, 555, 4, 556, 9, 556,
	4, 557, 9, 557, 4, 558, 9, 558, 4, 559, 9, 559, 4, 560, 9, 560, 4, 561,
	9, 561, 4, 562, 9, 562, 4, 563, 9, 563, 4, 564, 9, 564, 4, 565, 9, 565,
	4, 566, 9, 566, 4, 567, 9, 567, 4, 568, 9, 568, 4, 569, 9, 569, 4, 570,
	9, 570, 4, 571, 9, 571, 4, 572, 9, 572, 4, 573, 9, 573, 4, 574, 9, 574,
	4, 575, 9, 575, 4, 576, 9, 576, 4, 577, 9, 577, 4, 578, 9, 578, 4, 579,
	9, 579, 4, 580, 9, 580, 4, 581, 9, 581, 4, 582, 9, 582, 4, 583, 9, 583,
	4, 584, 9, 584, 4, 585, 9, 585, 4, 586, 9, 586, 4, 587, 9, 587, 4, 588,
	9, 588, 4, 589, 9, 589, 4, 590, 9, 590, 4, 591, 9, 591, 4, 592, 9, 592,
	3, 2, 3, 2, 3, 2, 3, 3, 6, 3, 1189, 10, 3, 13, 3, 14, 3, 1190, 3, 4, 5,
	4, 1194, 10, 4, 3, 4, 3, 4, 5, 4, 1198, 10, 4, 3, 4, 5, 4, 1201, 10, 4,
	3, 4, 5, 4, 1204, 10, 4, 3, 4, 7, 4, 1207, 10, 4, 12, 4, 14, 4, 1210, 11,
	4, 3, 4, 5, 4, 1213, 10, 4, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 6, 3, 6, 6,
	6, 1222, 10, 6, 13, 6, 14, 6, 1223, 6, 6, 1226, 10, 6, 13, 6, 14, 6, 1227,
	3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7,
	3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 6, 7, 1251, 10, 7,
	13, 7, 14, 7, 1252, 3, 7, 3, 7, 5, 7, 1257, 10, 7, 3, 8, 3, 8, 3, 9, 3,
	9, 3, 9, 3, 9, 3, 9, 7, 9, 1266, 10, 9, 12, 9, 14, 9, 1269, 11, 9, 3, 10,
	3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 1277, 10, 10, 3, 11, 3, 11, 3,
	11, 3, 11, 5, 11, 1283, 10, 11, 3, 11, 3, 11, 5, 11, 1287, 10, 11, 5, 11,
	1289, 10, 11, 3, 11, 3, 11, 3, 12, 3, 12, 3, 12, 5, 12, 1296, 10, 12, 3,
	13, 3, 13, 3, 13, 5, 13, 1301, 10, 13, 3, 14, 3, 14, 3, 14, 5, 14, 1306,
	10, 14, 3, 15, 3, 15, 3, 15, 5, 15, 1311, 10, 15, 3, 16, 3, 16, 3, 16,
	5, 16, 1316, 10, 16, 3, 17, 3, 17, 3, 17, 5, 17, 1321, 10, 17, 3, 18, 3,
	18, 3, 18, 3, 18, 7, 18, 1327, 10, 18, 12, 18, 14, 18, 1330, 11, 18, 3,
	19, 3, 19, 3, 19, 5, 19, 1335, 10, 19, 3, 20, 3, 20, 3, 20, 3, 20, 7, 20,
	1341, 10, 20, 12, 20, 14, 20, 1344, 11, 20, 3, 21, 3, 21, 5, 21, 1348,
	10, 21, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 1354, 10, 22, 3, 22, 3, 22,
	5, 22, 1358, 10, 22, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 3, 23, 7, 23, 1366,
	10, 23, 12, 23, 14, 23, 1369, 11, 23, 3, 23, 3, 23, 3, 24, 3, 24, 3, 24,
	3, 24, 3, 24, 5, 24, 1378, 10, 24, 3, 25, 3, 25, 5, 25, 1382, 10, 25, 3,
	25, 3, 25, 5, 25, 1386, 10, 25, 3, 25, 5, 25, 1389, 10, 25, 3, 26, 3, 26,
	5, 26, 1393, 10, 26, 3, 26, 5, 26, 1396, 10, 26, 3, 26, 3, 26, 5, 26, 1400,
	10, 26, 3, 26, 5, 26, 1403, 10, 26, 3, 27, 5, 27, 1406, 10, 27, 3, 27,
	5, 27, 1409, 10, 27, 3, 27, 3, 27, 5, 27, 1413, 10, 27, 3, 27, 6, 27, 1416,
	10, 27, 13, 27, 14, 27, 1417, 3, 27, 5, 27, 1421, 10, 27, 3, 27, 5, 27,
	1424, 10, 27, 3, 28, 5, 28, 1427, 10, 28, 3, 28, 3, 28, 5, 28, 1431, 10,
	28, 3, 28, 3, 28, 3, 29, 5, 29, 1436, 10, 29, 3, 29, 3, 29, 5, 29, 1440,
	10, 29, 3, 29, 3, 29, 3, 30, 3, 30, 5, 30, 1446, 10, 30, 3, 30, 3, 30,
	3, 31, 3, 31, 3, 31, 3, 31, 3, 32, 3, 32, 3, 32, 6, 32, 1457, 10, 32, 13,
	32, 14, 32, 1458, 3, 32, 3, 32, 5, 32, 1463, 10, 32, 3, 33, 3, 33, 3, 33,
	3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 1476, 10,
	33, 3, 34, 3, 34, 5, 34, 1480, 10, 34, 3, 35, 3, 35, 3, 35, 3, 35, 5, 35,
	1486, 10, 35, 3, 35, 5, 35, 1489, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3,
	35, 3, 35, 3, 35, 6, 35, 1498, 10, 35, 13, 35, 14, 35, 1499, 5, 35, 1502,
	10, 35, 3, 36, 3, 36, 3, 36, 6, 36, 1507, 10, 36, 13, 36, 14, 36, 1508,
	5, 36, 1511, 10, 36, 3, 37, 3, 37, 3, 37, 3, 38, 3, 38, 6, 38, 1518, 10,
	38, 13, 38, 14, 38, 1519, 3, 39, 3, 39, 3, 39, 5, 39, 1525, 10, 39, 3,
	39, 3, 39, 5, 39, 1529, 10, 39, 3, 39, 3, 39, 3, 39, 5, 39, 1534, 10, 39,
	3, 40, 3, 40, 3, 40, 5, 40, 1539, 10, 40, 3, 40, 3, 40, 3, 41, 3, 41, 3,
	41, 5, 41, 1546, 10, 41, 3, 41, 5, 41, 1549, 10, 41, 3, 41, 5, 41, 1552,
	10, 41, 3, 41, 6, 41, 1555, 10, 41, 13, 41, 14, 41, 1556, 3, 42, 3, 42,
	3, 42, 5, 42, 1562, 10, 42, 3, 43, 3, 43, 5, 43, 1566, 10, 43, 3, 44, 3,
	44, 5, 44, 1570, 10, 44, 3, 45, 3, 45, 5, 45, 1574, 10, 45, 3, 45, 5, 45,
	1577, 10, 45, 3, 45, 3, 45, 5, 45, 1581, 10, 45, 3, 45, 3, 45, 3, 45, 5,
	45, 1586, 10, 45, 3, 46, 3, 46, 5, 46, 1590, 10, 46, 3, 46, 3, 46, 3, 47,
	3, 47, 5, 47, 1596, 10, 47, 3, 47, 3, 47, 5, 47, 1600, 10, 47, 5, 47, 1602,
	10, 47, 3, 47, 5, 47, 1605, 10, 47, 3, 47, 3, 47, 5, 47, 1609, 10, 47,
	3, 48, 3, 48, 3, 48, 5, 48, 1614, 10, 48, 5, 48, 1616, 10, 48, 3, 48, 3,
	48, 3, 48, 5, 48, 1621, 10, 48, 5, 48, 1623, 10, 48, 3, 49, 3, 49, 5, 49,
	1627, 10, 49, 3, 49, 3, 49, 5, 49, 1631, 10, 49, 3, 49, 5, 49, 1634, 10,
	49, 3, 50, 3, 50, 5, 50, 1638, 10, 50, 3, 50, 5, 50, 1641, 10, 50, 3, 50,
	3, 50, 3, 50, 5, 50, 1646, 10, 50, 3, 50, 5, 50, 1649, 10, 50, 3, 50, 5,
	50, 1652, 10, 50, 3, 50, 3, 50, 5, 50, 1656, 10, 50, 3, 50, 5, 50, 1659,
	10, 50, 3, 50, 3, 50, 3, 50, 5, 50, 1664, 10, 50, 3, 50, 5, 50, 1667, 10,
	50, 3, 50, 5, 50, 1670, 10, 50, 5, 50, 1672, 10, 50, 3, 51, 3, 51, 5, 51,
	1676, 10, 51, 3, 51, 3, 51, 3, 52, 3, 52, 5, 52, 1682, 10, 52, 3, 52, 5,
	52, 1685, 10, 52, 3, 52, 5, 52, 1688, 10, 52, 3, 52, 3, 52, 5, 52, 1692,
	10, 52, 3, 53, 3, 53, 5, 53, 1696, 10, 53, 3, 53, 5, 53, 1699, 10, 53,
	3, 53, 5, 53, 1702, 10, 53, 3, 53, 6, 53, 1705, 10, 53, 13, 53, 14, 53,
	1706, 3, 53, 3, 53, 5, 53, 1711, 10, 53, 3, 54, 6, 54, 1714, 10, 54, 13,
	54, 14, 54, 1715, 3, 54, 5, 54, 1719, 10, 54, 3, 54, 6, 54, 1722, 10, 54,
	13, 54, 14, 54, 1723, 3, 55, 3, 55, 3, 55, 3, 55, 7, 55, 1730, 10, 55,
	12, 55, 14, 55, 1733, 11, 55, 3, 56, 3, 56, 5, 56, 1737, 10, 56, 3, 57,
	3, 57, 5, 57, 1741, 10, 57, 3, 57, 7, 57, 1744, 10, 57, 12, 57, 14, 57,
	1747, 11, 57, 3, 57, 3, 57, 3, 58, 3, 58, 7, 58, 1753, 10, 58, 12, 58,
	14, 58, 1756, 11, 58, 3, 59, 3, 59, 5, 59, 1760, 10, 59, 3, 59, 3, 59,
	3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3,
	60, 5, 60, 1775, 10, 60, 3, 61, 3, 61, 5, 61, 1779, 10, 61, 3, 61, 3, 61,
	3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 5, 61, 1790, 10, 61, 3,
	62, 3, 62, 3, 62, 5, 62, 1795, 10, 62, 3, 62, 5, 62, 1798, 10, 62, 3, 62,
	5, 62, 1801, 10, 62, 3, 63, 3, 63, 5, 63, 1805, 10, 63, 5, 63, 1807, 10,
	63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 5, 63, 1814, 10, 63, 3, 63, 3, 63,
	3, 64, 3, 64, 5, 64, 1820, 10, 64, 3, 64, 5, 64, 1823, 10, 64, 3, 64, 3,
	64, 5, 64, 1827, 10, 64, 3, 65, 3, 65, 3, 65, 5, 65, 1832, 10, 65, 3, 65,
	3, 65, 3, 65, 5, 65, 1837, 10, 65, 3, 66, 3, 66, 5, 66, 1841, 10, 66, 3,
	66, 5, 66, 1844, 10, 66, 3, 66, 3, 66, 3, 67, 3, 67, 5, 67, 1850, 10, 67,
	3, 67, 5, 67, 1853, 10, 67, 3, 67, 3, 67, 5, 67, 1857, 10, 67, 3, 67, 5,
	67, 1860, 10, 67, 3, 67, 5, 67, 1863, 10, 67, 3, 68, 3, 68, 3, 68, 5, 68,
	1868, 10, 68, 3, 68, 5, 68, 1871, 10, 68, 3, 68, 3, 68, 5, 68, 1875, 10,
	68, 3, 68, 5, 68, 1878, 10, 68, 3, 68, 5, 68, 1881, 10, 68, 3, 69, 3, 69,
	5, 69, 1885, 10, 69, 3, 69, 3, 69, 3, 70, 5, 70, 1890, 10, 70, 3, 70, 3,
	70, 5, 70, 1894, 10, 70, 3, 70, 3, 70, 5, 70, 1898, 10, 70, 3, 71, 3, 71,
	5, 71, 1902, 10, 71, 3, 71, 5, 71, 1905, 10, 71, 3, 71, 3, 71, 3, 72, 3,
	72, 3, 72, 3, 72, 3, 72, 5, 72, 1914, 10, 72, 3, 72, 7, 72, 1917, 10, 72,
	12, 72, 14, 72, 1920, 11, 72, 3, 72, 5, 72, 1923, 10, 72, 3, 73, 3, 73,
	3, 73, 3, 73, 5, 73, 1929, 10, 73, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 1935,
	10, 74, 5, 74, 1937, 10, 74, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 1943, 10,
	74, 3, 75, 3, 75, 3, 75, 3, 76, 5, 76, 1949, 10, 76, 3, 76, 5, 76, 1952,
	10, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 77, 3, 77, 5, 77, 1960, 10, 77,
	3, 78, 3, 78, 5, 78, 1964, 10, 78, 3, 78, 5, 78, 1967, 10, 78, 3, 78, 5,
	78, 1970, 10, 78, 3, 78, 6, 78, 1973, 10, 78, 13, 78, 14, 78, 1974, 3,
	79, 3, 79, 3, 79, 5, 79, 1980, 10, 79, 3, 79, 5, 79, 1983, 10, 79, 3, 79,
	6, 79, 1986, 10, 79, 13, 79, 14, 79, 1987, 3, 80, 3, 80, 3, 80, 5, 80,
	1993, 10, 80, 3, 81, 3, 81, 3, 81, 5, 81, 1998, 10, 81, 3, 81, 3, 81, 3,
	82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 83, 5, 83, 2008, 10, 83, 3, 83, 5, 83,
	2011, 10, 83, 3, 83, 5, 83, 2014, 10, 83, 3, 83, 5, 83, 2017, 10, 83, 3,
	83, 5, 83, 2020, 10, 83, 3, 83, 5, 83, 2023, 10, 83, 3, 83, 5, 83, 2026,
	10, 83, 3, 83, 5, 83, 2029, 10, 83, 3, 83, 5, 83, 2032, 10, 83, 3, 84,
	3, 84, 3, 84, 3, 84, 7, 84, 2038, 10, 84, 12, 84, 14, 84, 2041, 11, 84,
	3, 85, 3, 85, 3, 85, 5, 85, 2046, 10, 85, 3, 85, 7, 85, 2049, 10, 85, 12,
	85, 14, 85, 2052, 11, 85, 3, 85, 3, 85, 7, 85, 2056, 10, 85, 12, 85, 14,
	85, 2059, 11, 85, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86,
	3, 86, 3, 86, 3, 86, 5, 86, 2072, 10, 86, 3, 87, 5, 87, 2075, 10, 87, 3,
	87, 3, 87, 3, 88, 5, 88, 2080, 10, 88, 3, 88, 3, 88, 3, 89, 3, 89, 5, 89,
	2086, 10, 89, 3, 89, 3, 89, 5, 89, 2090, 10, 89, 3, 89, 5, 89, 2093, 10,
	89, 3, 90, 3, 90, 3, 90, 3, 91, 3, 91, 3, 91, 3, 91, 5, 91, 2102, 10, 91,
	3, 92, 5, 92, 2105, 10, 92, 3, 92, 3, 92, 5, 92, 2109, 10, 92, 3, 93, 5,
	93, 2112, 10, 93, 3, 93, 3, 93, 5, 93, 2116, 10, 93, 3, 93, 5, 93, 2119,
	10, 93, 3, 93, 5, 93, 2122, 10, 93, 3, 93, 3, 93, 5, 93, 2126, 10, 93,
	3, 93, 5, 93, 2129, 10, 93, 5, 93, 2131, 10, 93, 3, 93, 3, 93, 5, 93, 2135,
	10, 93, 3, 93, 5, 93, 2138, 10, 93, 3, 94, 5, 94, 2141, 10, 94, 3, 94,
	3, 94, 3, 94, 5, 94, 2146, 10, 94, 3, 95, 3, 95, 3, 95, 3, 96, 3, 96, 3,
	96, 5, 96, 2154, 10, 96, 3, 96, 3, 96, 5, 96, 2158, 10, 96, 5, 96, 2160,
	10, 96, 3, 96, 3, 96, 3, 96, 6, 96, 2165, 10, 96, 13, 96, 14, 96, 2166,
	5, 96, 2169, 10, 96, 3, 97, 3, 97, 3, 97, 6, 97, 2174, 10, 97, 13, 97,
	14, 97, 2175, 3, 98, 3, 98, 5, 98, 2180, 10, 98, 3, 98, 3, 98, 5, 98, 2184,
	10, 98, 3, 99, 3, 99, 3, 99, 5, 99, 2189, 10, 99, 3, 99, 3, 99, 5, 99,
	2193, 10, 99, 5, 99, 2195, 10, 99, 3, 99, 6, 99, 2198, 10, 99, 13, 99,
	14, 99, 2199, 3, 100, 3, 100, 5, 100, 2204, 10, 100, 3, 100, 3, 100, 5,
	100, 2208, 10, 100, 3, 100, 5, 100, 2211, 10, 100, 3, 100, 7, 100, 2214,
	10, 100, 12, 100, 14, 100, 2217, 11, 100, 3, 101, 3, 101, 3, 101, 5, 101,
	2222, 10, 101, 3, 102, 5, 102, 2225, 10, 102, 3, 102, 3, 102, 5, 102, 2229,
	10, 102, 3, 102, 3, 102, 5, 102, 2233, 10, 102, 3, 103, 5, 103, 2236, 10,
	103, 3, 103, 5, 103, 2239, 10, 103, 3, 103, 3, 103, 3, 103, 5, 103, 2244,
	10, 103, 3, 104, 5, 104, 2247, 10, 104, 3, 104, 5, 104, 2250, 10, 104,
	3, 104, 3, 104, 3, 104, 5, 104, 2255, 10, 104, 3, 105, 3, 105, 5, 105,
	2259, 10, 105, 3, 105, 5, 105, 2262, 10, 105, 3, 105, 3, 105, 3, 106, 3,
	106, 3, 107, 3, 107, 5, 107, 2270, 10, 107, 3, 107, 3, 107, 3, 108, 3,
	108, 5, 108, 2276, 10, 108, 3, 108, 3, 108, 5, 108, 2280, 10, 108, 5, 108,
	2282, 10, 108, 3, 108, 6, 108, 2285, 10, 108, 13, 108, 14, 108, 2286, 3,
	109, 3, 109, 3, 109, 3, 109, 7, 109, 2293, 10, 109, 12, 109, 14, 109, 2296,
	11, 109, 3, 110, 3, 110, 3, 110, 3, 110, 3, 110, 3, 111, 3, 111, 3, 111,
	3, 111, 7, 111, 2307, 10, 111, 12, 111, 14, 111, 2310, 11, 111, 3, 112,
	3, 112, 3, 112, 3, 112, 7, 112, 2316, 10, 112, 12, 112, 14, 112, 2319,
	11, 112, 3, 113, 3, 113, 3, 113, 3, 113, 3, 113, 7, 113, 2326, 10, 113,
	12, 113, 14, 113, 2329, 11, 113, 3, 114, 3, 114, 3, 114, 5, 114, 2334,
	10, 114, 3, 115, 3, 115, 3, 115, 5, 115, 2339, 10, 115, 3, 115, 5, 115,
	2342, 10, 115, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115,
	3, 115, 3, 115, 3, 115, 5, 115, 2354, 10, 115, 3, 115, 7, 115, 2357, 10,
	115, 12, 115, 14, 115, 2360, 11, 115, 3, 115, 3, 115, 3, 116, 3, 116, 3,
	116, 5, 116, 2367, 10, 116, 3, 116, 3, 116, 3, 116, 3, 116, 3, 116, 3,
	116, 3, 116, 7, 116, 2376, 10, 116, 12, 116, 14, 116, 2379, 11, 116, 3,
	116, 3, 116, 3, 117, 3, 117, 3, 117, 5, 117, 2386, 10, 117, 3, 117, 3,
	117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 5, 117, 2396, 10,
	117, 3, 117, 7, 117, 2399, 10, 117, 12, 117, 14, 117, 2402, 11, 117, 3,
	117, 3, 117, 3, 118, 3, 118, 3, 118, 5, 118, 2409, 10, 118, 3, 118, 3,
	118, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 6,
	119, 2421, 10, 119, 13, 119, 14, 119, 2422, 5, 119, 2425, 10, 119, 3, 120,
	3, 120, 3, 120, 5, 120, 2430, 10, 120, 3, 120, 3, 120, 3, 121, 3, 121,
	3, 121, 5, 121, 2437, 10, 121, 3, 121, 3, 121, 3, 122, 5, 122, 2442, 10,
	122, 3, 122, 3, 122, 5, 122, 2446, 10, 122, 3, 122, 3, 122, 3, 123, 3,
	123, 3, 123, 5, 123, 2453, 10, 123, 3, 123, 3, 123, 3, 124, 3, 124, 3,
	124, 5, 124, 2460, 10, 124, 3, 124, 3, 124, 3, 125, 3, 125, 3, 125, 5,
	125, 2467, 10, 125, 3, 125, 3, 125, 3, 126, 5, 126, 2472, 10, 126, 3, 126,
	3, 126, 5, 126, 2476, 10, 126, 3, 126, 3, 126, 3, 127, 5, 127, 2481, 10,
	127, 3, 127, 3, 127, 5, 127, 2485, 10, 127, 3, 127, 3, 127, 3, 128, 5,
	128, 2490, 10, 128, 3, 128, 3, 128, 5, 128, 2494, 10, 128, 3, 128, 3, 128,
	3, 129, 5, 129, 2499, 10, 129, 3, 129, 3, 129, 5, 129, 2503, 10, 129, 3,
	129, 3, 129, 3, 130, 5, 130, 2508, 10, 130, 3, 130, 3, 130, 5, 130, 2512,
	10, 130, 3, 130, 3, 130, 3, 131, 3, 131, 3, 131, 5, 131, 2519, 10, 131,
	3, 131, 3, 131, 3, 132, 3, 132, 3, 132, 3, 132, 3, 132, 3, 132, 3, 132,
	5, 132, 2530, 10, 132, 3, 132, 7, 132, 2533, 10, 132, 12, 132, 14, 132,
	2536, 11, 132, 3, 133, 3, 133, 3, 133, 3, 133, 7, 133, 2542, 10, 133, 12,
	133, 14, 133, 2545, 11, 133, 3, 134, 3, 134, 3, 134, 5, 134, 2550, 10,
	134, 3, 134, 3, 134, 3, 134, 3, 134, 3, 134, 3, 134, 3, 134, 3, 134, 3,
	134, 3, 134, 3, 134, 3, 134, 3, 134, 3, 134, 3, 134, 3, 134, 3, 134, 3,
	134, 5, 134, 2570, 10, 134, 3, 134, 3, 134, 3, 134, 3, 134, 3, 134, 3,
	134, 3, 134, 3, 134, 3, 134, 3, 134, 7, 134, 2582, 10, 134, 12, 134, 14,
	134, 2585, 11, 134, 3, 134, 3, 134, 3, 135, 3, 135, 3, 135, 3, 136, 3,
	136, 3, 137, 3, 137, 3, 138, 3, 138, 3, 138, 3, 139, 3, 139, 3, 140, 3,
	140, 3, 141, 3, 141, 3, 142, 3, 142, 3, 143, 3, 143, 5, 143, 2609, 10,
	143, 3, 143, 3, 143, 5, 143, 2613, 10, 143, 3, 144, 3, 144, 5, 144, 2617,
	10, 144, 3, 144, 5, 144, 2620, 10, 144, 3, 144, 5, 144, 2623, 10, 144,
	3, 144, 3, 144, 5, 144, 2627, 10, 144, 3, 145, 3, 145, 5, 145, 2631, 10,
	145, 3, 145, 5, 145, 2634, 10, 145, 3, 145, 5, 145, 2637, 10, 145, 3, 145,
	3, 145, 5, 145, 2641, 10, 145, 3, 146, 3, 146, 5, 146, 2645, 10, 146, 3,
	146, 3, 146, 5, 146, 2649, 10, 146, 3, 147, 3, 147, 5, 147, 2653, 10, 147,
	3, 147, 3, 147, 5, 147, 2657, 10, 147, 3, 148, 3, 148, 5, 148, 2661, 10,
	148, 3, 148, 3, 148, 3, 149, 3, 149, 5, 149, 2667, 10, 149, 3, 149, 3,
	149, 3, 150, 3, 150, 5, 150, 2673, 10, 150, 3, 150, 3, 150, 3, 151, 3,
	151, 3, 151, 5, 151, 2680, 10, 151, 3, 151, 5, 151, 2683, 10, 151, 3, 152,
	3, 152, 3, 152, 3, 153, 3, 153, 3, 153, 3, 154, 3, 154, 5, 154, 2693, 10,
	154, 3, 154, 3, 154, 3, 155, 3, 155, 5, 155, 2699, 10, 155, 3, 155, 3,
	155, 3, 156, 3, 156, 5, 156, 2705, 10, 156, 3, 157, 3, 157, 5, 157, 2709,
	10, 157, 5, 157, 2711, 10, 157, 3, 157, 3, 157, 3, 157, 5, 157, 2716, 10,
	157, 5, 157, 2718, 10, 157, 3, 158, 3, 158, 3, 159, 3, 159, 3, 160, 3,
	160, 3, 161, 3, 161, 5, 161, 2728, 10, 161, 3, 161, 5, 161, 2731, 10, 161,
	3, 161, 3, 161, 5, 161, 2735, 10, 161, 3, 161, 5, 161, 2738, 10, 161, 3,
	162, 3, 162, 3, 162, 5, 162, 2743, 10, 162, 3, 163, 3, 163, 3, 164, 3,
	164, 3, 165, 3, 165, 3, 165, 3, 165, 7, 165, 2753, 10, 165, 12, 165, 14,
	165, 2756, 11, 165, 3, 166, 3, 166, 6, 166, 2760, 10, 166, 13, 166, 14,
	166, 2761, 3, 167, 3, 167, 3, 167, 5, 167, 2767, 10, 167, 3, 167, 3, 167,
	5, 167, 2771, 10, 167, 3, 167, 5, 167, 2774, 10, 167, 3, 167, 5, 167, 2777,
	10, 167, 3, 167, 5, 167, 2780, 10, 167, 5, 167, 2782, 10, 167, 3, 167,
	3, 167, 3, 168, 5, 168, 2787, 10, 168, 3, 168, 3, 168, 3, 169, 3, 169,
	3, 169, 5, 169, 2794, 10, 169, 3, 169, 3, 169, 5, 169, 2798, 10, 169, 5,
	169, 2800, 10, 169, 3, 169, 3, 169, 5, 169, 2804, 10, 169, 3, 170, 3, 170,
	3, 170, 3, 171, 3, 171, 3, 171, 3, 171, 3, 172, 3, 172, 3, 172, 3, 172,
	3, 173, 3, 173, 3, 173, 3, 174, 3, 174, 3, 174, 5, 174, 2823, 10, 174,
	3, 175, 3, 175, 3, 175, 5, 175, 2828, 10, 175, 3, 175, 5, 175, 2831, 10,
	175, 3, 175, 3, 175, 5, 175, 2835, 10, 175, 3, 175, 3, 175, 3, 176, 3,
	176, 5, 176, 2841, 10, 176, 3, 176, 5, 176, 2844, 10, 176, 3, 176, 3, 176,
	3, 176, 3, 177, 3, 177, 5, 177, 2851, 10, 177, 3, 177, 3, 177, 3, 177,
	3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 5, 177,
	2864, 10, 177, 3, 177, 7, 177, 2867, 10, 177, 12, 177, 14, 177, 2870, 11,
	177, 3, 177, 3, 177, 3, 178, 3, 178, 5, 178, 2876, 10, 178, 3, 178, 3,
	178, 3, 179, 3, 179, 5, 179, 2882, 10, 179, 3, 179, 5, 179, 2885, 10, 179,
	3, 179, 3, 179, 3, 180, 3, 180, 5, 180, 2891, 10, 180, 3, 181, 3, 181,
	5, 181, 2895, 10, 181, 3, 182, 5, 182, 2898, 10, 182, 3, 182, 5, 182, 2901,
	10, 182, 3, 182, 5, 182, 2904, 10, 182, 3, 182, 3, 182, 5, 182, 2908, 10,
	182, 3, 183, 3, 183, 5, 183, 2912, 10, 183, 3, 183, 3, 183, 5, 183, 2916,
	10, 183, 3, 184, 3, 184, 3, 184, 3, 185, 3, 185, 3, 185, 5, 185, 2924,
	10, 185, 3, 185, 3, 185, 3, 185, 5, 185, 2929, 10, 185, 3, 186, 3, 186,
	3, 186, 3, 187, 3, 187, 3, 187, 3, 188, 3, 188, 5, 188, 2939, 10, 188,
	3, 188, 3, 188, 3, 189, 3, 189, 5, 189, 2945, 10, 189, 3, 189, 3, 189,
	5, 189, 2949, 10, 189, 3, 190, 3, 190, 5, 190, 2953, 10, 190, 3, 190, 3,
	190, 3, 190, 5, 190, 2958, 10, 190, 3, 191, 3, 191, 5, 191, 2962, 10, 191,
	3, 191, 3, 191, 3, 192, 3, 192, 3, 192, 5, 192, 2969, 10, 192, 3, 192,
	7, 192, 2972, 10, 192, 12, 192, 14, 192, 2975, 11, 192, 3, 192, 3, 192,
	3, 192, 5, 192, 2980, 10, 192, 3, 192, 7, 192, 2983, 10, 192, 12, 192,
	14, 192, 2986, 11, 192, 5, 192, 2988, 10, 192, 3, 193, 3, 193, 5, 193,
	2992, 10, 193, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193,
	5, 193, 3001, 10, 193, 3, 194, 3, 194, 3, 194, 5, 194, 3006, 10, 194, 3,
	195, 3, 195, 3, 195, 5, 195, 3011, 10, 195, 3, 196, 3, 196, 3, 196, 5,
	196, 3016, 10, 196, 3, 196, 3, 196, 5, 196, 3020, 10, 196, 3, 197, 3, 197,
	3, 198, 3, 198, 3, 198, 5, 198, 3027, 10, 198, 3, 198, 3, 198, 5, 198,
	3031, 10, 198, 3, 199, 3, 199, 5, 199, 3035, 10, 199, 5, 199, 3037, 10,
	199, 3, 199, 3, 199, 3, 200, 3, 200, 3, 200, 5, 200, 3044, 10, 200, 3,
	201, 3, 201, 3, 201, 5, 201, 3049, 10, 201, 3, 202, 3, 202, 5, 202, 3053,
	10, 202, 3, 202, 3, 202, 3, 203, 3, 203, 3, 203, 3, 203, 7, 203, 3061,
	10, 203, 12, 203, 14, 203, 3064, 11, 203, 3, 204, 3, 204, 5, 204, 3068,
	10, 204, 3, 205, 3, 205, 3, 205, 3, 205, 5, 205, 3074, 10, 205, 3, 205,
	5, 205, 3077, 10, 205, 3, 206, 3, 206, 3, 206, 3, 206, 5, 206, 3083, 10,
	206, 3, 206, 5, 206, 3086, 10, 206, 3, 206, 3, 206, 7, 206, 3090, 10, 206,
	12, 206, 14, 206, 3093, 11, 206, 3, 207, 3, 207, 3, 207, 5, 207, 3098,
	10, 207, 3, 207, 5, 207, 3101, 10, 207, 3, 208, 3, 208, 5, 208, 3105, 10,
	208, 3, 208, 3, 208, 5, 208, 3109, 10, 208, 3, 208, 5, 208, 3112, 10, 208,
	3, 208, 5, 208, 3115, 10, 208, 3, 208, 5, 208, 3118, 10, 208, 3, 209, 3,
	209, 3, 209, 3, 209, 3, 210, 3, 210, 5, 210, 3126, 10, 210, 3, 210, 3,
	210, 3, 211, 3, 211, 5, 211, 3132, 10, 211, 3, 211, 3, 211, 3, 212, 3,
	212, 3, 212, 5, 212, 3139, 10, 212, 3, 213, 3, 213, 3, 213, 5, 213, 3144,
	10, 213, 3, 213, 5, 213, 3147, 10, 213, 3, 213, 5, 213, 3150, 10, 213,
	3, 213, 5, 213, 3153, 10, 213, 3, 214, 3, 214, 3, 214, 3, 215, 3, 215,
	3, 215, 3, 216, 3, 216, 6, 216, 3163, 10, 216, 13, 216, 14, 216, 3164,
	3, 217, 3, 217, 5, 217, 3169, 10, 217, 3, 218, 3, 218, 6, 218, 3173, 10,
	218, 13, 218, 14, 218, 3174, 3, 219, 3, 219, 5, 219, 3179, 10, 219, 3,
	220, 5, 220, 3182, 10, 220, 3, 220, 3, 220, 3, 221, 5, 221, 3187, 10, 221,
	3, 221, 3, 221, 3, 222, 3, 222, 3, 222, 3, 222, 5, 222, 3195, 10, 222,
	3, 223, 3, 223, 3, 223, 5, 223, 3200, 10, 223, 3, 223, 5, 223, 3203, 10,
	223, 3, 223, 5, 223, 3206, 10, 223, 3, 223, 5, 223, 3209, 10, 223, 3, 223,
	5, 223, 3212, 10, 223, 3, 223, 5, 223, 3215, 10, 223, 3, 223, 5, 223, 3218,
	10, 223, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223,
	3, 223, 3, 223, 3, 223, 3, 223, 7, 223, 3232, 10, 223, 12, 223, 14, 223,
	3235, 11, 223, 3, 223, 5, 223, 3238, 10, 223, 3, 223, 5, 223, 3241, 10,
	223, 3, 223, 5, 223, 3244, 10, 223, 3, 223, 3, 223, 3, 224, 3, 224, 3,
	224, 3, 224, 3, 224, 3, 225, 3, 225, 3, 225, 3, 225, 3, 225, 3, 226, 6,
	226, 3259, 10, 226, 13, 226, 14, 226, 3260, 3, 226, 3, 226, 3, 227, 3,
	227, 3, 228, 3, 228, 5, 228, 3269, 10, 228, 3, 228, 3, 228, 3, 229, 3,
	229, 3, 230, 5, 230, 3276, 10, 230, 3, 230, 3, 230, 3, 230, 5, 230, 3281,
	10, 230, 3, 231, 5, 231, 3284, 10, 231, 3, 231, 3, 231, 3, 232, 3, 232,
	3, 233, 3, 233, 5, 233, 3292, 10, 233, 3, 234, 3, 234, 3, 234, 5, 234,
	3297, 10, 234, 3, 234, 5, 234, 3300, 10, 234, 3, 234, 3, 234, 5, 234, 3304,
	10, 234, 3, 234, 5, 234, 3307, 10, 234, 3, 234, 7, 234, 3310, 10, 234,
	12, 234, 14, 234, 3313, 11, 234, 3, 234, 3, 234, 5, 234, 3317, 10, 234,
	3, 234, 5, 234, 3320, 10, 234, 3, 234, 6, 234, 3323, 10, 234, 13, 234,
	14, 234, 3324, 5, 234, 3327, 10, 234, 3, 235, 3, 235, 3, 235, 3, 236, 3,
	236, 5, 236, 3334, 10, 236, 3, 236, 5, 236, 3337, 10, 236, 3, 236, 6, 236,
	3340, 10, 236, 13, 236, 14, 236, 3341, 3, 237, 3, 237, 5, 237, 3346, 10,
	237, 3, 237, 3, 237, 3, 238, 6, 238, 3351, 10, 238, 13, 238, 14, 238, 3352,
	3, 238, 5, 238, 3356, 10, 238, 6, 238, 3358, 10, 238, 13, 238, 14, 238,
	3359, 3, 239, 3, 239, 3, 239, 3, 239, 3, 239, 3, 239, 3, 239, 3, 239, 3,
	239, 3, 239, 3, 239, 3, 239, 3, 239, 3, 239, 3, 239, 3, 239, 3, 239, 5,
	239, 3379, 10, 239, 3, 240, 3, 240, 3, 241, 3, 241, 3, 241, 3, 241, 3,
	242, 5, 242, 3388, 10, 242, 3, 242, 5, 242, 3391, 10, 242, 3, 242, 3, 242,
	3, 243, 3, 243, 3, 243, 3, 244, 3, 244, 3, 244, 3, 245, 3, 245, 3, 245,
	3, 245, 5, 245, 3405, 10, 245, 3, 246, 3, 246, 5, 246, 3409, 10, 246, 5,
	246, 3411, 10, 246, 3, 246, 3, 246, 3, 246, 5, 246, 3416, 10, 246, 5, 246,
	3418, 10, 246, 3, 247, 3, 247, 5, 247, 3422, 10, 247, 3, 248, 5, 248, 3425,
	10, 248, 3, 248, 3, 248, 3, 249, 3, 249, 5, 249, 3431, 10, 249, 3, 249,
	3, 249, 3, 250, 5, 250, 3436, 10, 250, 3, 250, 3, 250, 3, 251, 3, 251,
	5, 251, 3442, 10, 251, 5, 251, 3444, 10, 251, 3, 251, 3, 251, 5, 251, 3448,
	10, 251, 3, 251, 3, 251, 3, 251, 3, 251, 3, 251, 3, 251, 3, 251, 3, 251,
	3, 251, 3, 251, 3, 251, 3, 251, 3, 251, 3, 251, 3, 251, 3, 251, 3, 251,
	3, 251, 3, 251, 3, 251, 3, 251, 3, 251, 3, 251, 3, 251, 3, 251, 3, 251,
	3, 251, 3, 251, 3, 251, 5, 251, 3479, 10, 251, 3, 252, 3, 252, 3, 252,
	5, 252, 3484, 10, 252, 3, 252, 3, 252, 5, 252, 3488, 10, 252, 3, 253, 3,
	253, 5, 253, 3492, 10, 253, 3, 253, 3, 253, 5, 253, 3496, 10, 253, 5, 253,
	3498, 10, 253, 3, 253, 6, 253, 3501, 10, 253, 13, 253, 14, 253, 3502, 3,
	254, 3, 254, 5, 254, 3507, 10, 254, 3, 255, 3, 255, 5, 255, 3511, 10, 255,
	3, 256, 3, 256, 3, 256, 3, 257, 5, 257, 3517, 10, 257, 3, 257, 3, 257,
	3, 257, 3, 258, 3, 258, 3, 258, 5, 258, 3525, 10, 258, 3, 258, 5, 258,
	3528, 10, 258, 3, 258, 3, 258, 5, 258, 3532, 10, 258, 3, 258, 3, 258, 3,
	259, 3, 259, 3, 259, 3, 259, 3, 259, 3, 259, 3, 259, 6, 259, 3543, 10,
	259, 13, 259, 14, 259, 3544, 3, 260, 3, 260, 3, 260, 3, 261, 3, 261, 3,
	261, 6, 261, 3553, 10, 261, 13, 261, 14, 261, 3554, 3, 261, 3, 261, 3,
	261, 3, 261, 3, 262, 3, 262, 3, 262, 3, 262, 3, 262, 3, 262, 3, 263, 3,
	263, 3, 263, 5, 263, 3570, 10, 263, 3, 264, 3, 264, 7, 264, 3574, 10, 264,
	12, 264, 14, 264, 3577, 11, 264, 3, 265, 3, 265, 3, 265, 3, 265, 3, 266,
	7, 266, 3584, 10, 266, 12, 266, 14, 266, 3587, 11, 266, 3, 266, 7, 266,
	3590, 10, 266, 12, 266, 14, 266, 3593, 11, 266, 3, 267, 3, 267, 3, 267,
	3, 267, 7, 267, 3599, 10, 267, 12, 267, 14, 267, 3602, 11, 267, 5, 267,
	3604, 10, 267, 3, 268, 7, 268, 3607, 10, 268, 12, 268, 14, 268, 3610, 11,
	268, 3, 268, 3, 268, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3,
	269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3,
	269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3,
	269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3,
	269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3,
	269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 5, 269, 3663, 10,
	269, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 5, 270, 3671, 10,
	270, 3, 271, 3, 271, 3, 271, 5, 271, 3676, 10, 271, 3, 271, 3, 271, 5,
	271, 3680, 10, 271, 3, 271, 3, 271, 3, 271, 3, 271, 3, 271, 5, 271, 3687,
	10, 271, 3, 271, 3, 271, 3, 271, 3, 271, 5, 271, 3693, 10, 271, 3, 272,
	3, 272, 3, 272, 3, 273, 3, 273, 3, 273, 3, 273, 3, 274, 5, 274, 3703, 10,
	274, 3, 274, 3, 274, 3, 275, 3, 275, 3, 275, 3, 275, 5, 275, 3711, 10,
	275, 3, 275, 5, 275, 3714, 10, 275, 3, 275, 5, 275, 3717, 10, 275, 3, 275,
	5, 275, 3720, 10, 275, 3, 276, 6, 276, 3723, 10, 276, 13, 276, 14, 276,
	3724, 3, 276, 3, 276, 6, 276, 3729, 10, 276, 13, 276, 14, 276, 3730, 3,
	277, 6, 277, 3734, 10, 277, 13, 277, 14, 277, 3735, 3, 277, 3, 277, 6,
	277, 3740, 10, 277, 13, 277, 14, 277, 3741, 5, 277, 3744, 10, 277, 3, 277,
	3, 277, 6, 277, 3748, 10, 277, 13, 277, 14, 277, 3749, 3, 278, 3, 278,
	3, 278, 3, 278, 3, 278, 3, 279, 3, 279, 5, 279, 3759, 10, 279, 3, 280,
	3, 280, 5, 280, 3763, 10, 280, 3, 281, 3, 281, 5, 281, 3767, 10, 281, 3,
	282, 3, 282, 5, 282, 3771, 10, 282, 3, 282, 3, 282, 3, 283, 3, 283, 6,
	283, 3777, 10, 283, 13, 283, 14, 283, 3778, 3, 284, 3, 284, 3, 284, 3,
	284, 5, 284, 3785, 10, 284, 3, 284, 3, 284, 3, 285, 3, 285, 3, 285, 5,
	285, 3792, 10, 285, 3, 285, 5, 285, 3795, 10, 285, 3, 285, 5, 285, 3798,
	10, 285, 3, 285, 5, 285, 3801, 10, 285, 3, 285, 5, 285, 3804, 10, 285,
	3, 285, 5, 285, 3807, 10, 285, 3, 285, 5, 285, 3810, 10, 285, 3, 286, 3,
	286, 6, 286, 3814, 10, 286, 13, 286, 14, 286, 3815, 3, 287, 3, 287, 3,
	287, 5, 287, 3821, 10, 287, 3, 288, 5, 288, 3824, 10, 288, 3, 288, 5, 288,
	3827, 10, 288, 3, 288, 6, 288, 3830, 10, 288, 13, 288, 14, 288, 3831, 3,
	289, 3, 289, 3, 289, 3, 289, 5, 289, 3838, 10, 289, 3, 289, 3, 289, 5,
	289, 3842, 10, 289, 3, 290, 5, 290, 3845, 10, 290, 3, 290, 3, 290, 6, 290,
	3849, 10, 290, 13, 290, 14, 290, 3850, 3, 291, 3, 291, 5, 291, 3855, 10,
	291, 3, 292, 5, 292, 3858, 10, 292, 3, 292, 3, 292, 6, 292, 3862, 10, 292,
	13, 292, 14, 292, 3863, 3, 293, 3, 293, 3, 293, 3, 293, 5, 293, 3870, 10,
	293, 3, 293, 3, 293, 5, 293, 3874, 10, 293, 3, 294, 3, 294, 3, 294, 3,
	295, 3, 295, 6, 295, 3881, 10, 295, 13, 295, 14, 295, 3882, 3, 296, 3,
	296, 3, 296, 3, 296, 3, 296, 5, 296, 3890, 10, 296, 3, 297, 3, 297, 6,
	297, 3894, 10, 297, 13, 297, 14, 297, 3895, 3, 298, 3, 298, 3, 298, 3,
	298, 5, 298, 3902, 10, 298, 3, 299, 3, 299, 5, 299, 3906, 10, 299, 3, 299,
	5, 299, 3909, 10, 299, 3, 299, 5, 299, 3912, 10, 299, 3, 299, 3, 299, 3,
	299, 5, 299, 3917, 10, 299, 5, 299, 3919, 10, 299, 3, 300, 5, 300, 3922,
	10, 300, 3, 300, 3, 300, 3, 300, 5, 300, 3927, 10, 300, 3, 301, 5, 301,
	3930, 10, 301, 3, 301, 3, 301, 3, 301, 3, 301, 5, 301, 3936, 10, 301, 3,
	301, 3, 301, 6, 301, 3940, 10, 301, 13, 301, 14, 301, 3941, 5, 301, 3944,
	10, 301, 3, 302, 3, 302, 3, 302, 5, 302, 3949, 10, 302, 3, 303, 3, 303,
	5, 303, 3953, 10, 303, 3, 303, 3, 303, 3, 304, 3, 304, 3, 304, 5, 304,
	3960, 10, 304, 3, 305, 3, 305, 5, 305, 3964, 10, 305, 3, 305, 3, 305, 5,
	305, 3968, 10, 305, 3, 306, 3, 306, 6, 306, 3972, 10, 306, 13, 306, 14,
	306, 3973, 3, 306, 3, 306, 3, 306, 5, 306, 3979, 10, 306, 3, 306, 5, 306,
	3982, 10, 306, 3, 306, 5, 306, 3985, 10, 306, 3, 307, 3, 307, 5, 307, 3989,
	10, 307, 3, 308, 3, 308, 3, 309, 3, 309, 3, 309, 5, 309, 3996, 10, 309,
	3, 309, 5, 309, 3999, 10, 309, 3, 309, 5, 309, 4002, 10, 309, 3, 309, 5,
	309, 4005, 10, 309, 3, 310, 3, 310, 3, 310, 5, 310, 4010, 10, 310, 3, 310,
	3, 310, 3, 310, 5, 310, 4015, 10, 310, 3, 310, 3, 310, 5, 310, 4019, 10,
	310, 3, 310, 3, 310, 3, 310, 5, 310, 4024, 10, 310, 3, 311, 3, 311, 6,
	311, 4028, 10, 311, 13, 311, 14, 311, 4029, 3, 311, 5, 311, 4033, 10, 311,
	3, 311, 5, 311, 4036, 10, 311, 3, 311, 5, 311, 4039, 10, 311, 3, 312, 3,
	312, 5, 312, 4043, 10, 312, 3, 313, 3, 313, 3, 313, 5, 313, 4048, 10, 313,
	3, 314, 3, 314, 3, 314, 5, 314, 4053, 10, 314, 3, 315, 5, 315, 4056, 10,
	315, 3, 315, 3, 315, 3, 315, 3, 316, 3, 316, 3, 316, 5, 316, 4064, 10,
	316, 3, 316, 3, 316, 3, 316, 5, 316, 4069, 10, 316, 3, 316, 5, 316, 4072,
	10, 316, 3, 316, 5, 316, 4075, 10, 316, 3, 316, 5, 316, 4078, 10, 316,
	3, 316, 5, 316, 4081, 10, 316, 3, 317, 3, 317, 3, 317, 5, 317, 4086, 10,
	317, 3, 317, 5, 317, 4089, 10, 317, 3, 318, 3, 318, 6, 318, 4093, 10, 318,
	13, 318, 14, 318, 4094, 3, 319, 3, 319, 3, 319, 5, 319, 4100, 10, 319,
	3, 319, 5, 319, 4103, 10, 319, 3, 320, 3, 320, 6, 320, 4107, 10, 320, 13,
	320, 14, 320, 4108, 3, 321, 3, 321, 5, 321, 4113, 10, 321, 3, 322, 3, 322,
	3, 322, 3, 323, 3, 323, 3, 323, 5, 323, 4121, 10, 323, 3, 323, 3, 323,
	3, 323, 5, 323, 4126, 10, 323, 3, 323, 3, 323, 5, 323, 4130, 10, 323, 3,
	323, 3, 323, 3, 323, 5, 323, 4135, 10, 323, 3, 324, 3, 324, 3, 324, 3,
	324, 6, 324, 4141, 10, 324, 13, 324, 14, 324, 4142, 5, 324, 4145, 10, 324,
	3, 325, 3, 325, 3, 325, 7, 325, 4150, 10, 325, 12, 325, 14, 325, 4153,
	11, 325, 3, 325, 6, 325, 4156, 10, 325, 13, 325, 14, 325, 4157, 3, 325,
	5, 325, 4161, 10, 325, 3, 325, 5, 325, 4164, 10, 325, 3, 326, 3, 326, 3,
	326, 3, 326, 5, 326, 4170, 10, 326, 3, 327, 3, 327, 3, 327, 3, 328, 6,
	328, 4176, 10, 328, 13, 328, 14, 328, 4177, 3, 328, 7, 328, 4181, 10, 328,
	12, 328, 14, 328, 4184, 11, 328, 3, 329, 3, 329, 3, 329, 7, 329, 4189,
	10, 329, 12, 329, 14, 329, 4192, 11, 329, 3, 330, 3, 330, 5, 330, 4196,
	10, 330, 3, 330, 3, 330, 5, 330, 4200, 10, 330, 3, 330, 3, 330, 5, 330,
	4204, 10, 330, 3, 331, 3, 331, 3, 331, 3, 332, 3, 332, 3, 332, 3, 333,
	3, 333, 3, 333, 7, 333, 4215, 10, 333, 12, 333, 14, 333, 4218, 11, 333,
	3, 334, 3, 334, 3, 334, 5, 334, 4223, 10, 334, 3, 335, 6, 335, 4226, 10,
	335, 13, 335, 14, 335, 4227, 3, 336, 6, 336, 4231, 10, 336, 13, 336, 14,
	336, 4232, 3, 337, 6, 337, 4236, 10, 337, 13, 337, 14, 337, 4237, 3, 338,
	3, 338, 5, 338, 4242, 10, 338, 3, 338, 5, 338, 4245, 10, 338, 3, 338, 6,
	338, 4248, 10, 338, 13, 338, 14, 338, 4249, 3, 339, 3, 339, 5, 339, 4254,
	10, 339, 3, 340, 3, 340, 5, 340, 4258, 10, 340, 3, 341, 3, 341, 3, 341,
	3, 342, 3, 342, 3, 343, 3, 343, 5, 343, 4267, 10, 343, 3, 343, 3, 343,
	5, 343, 4271, 10, 343, 3, 344, 3, 344, 3, 345, 3, 345, 6, 345, 4277, 10,
	345, 13, 345, 14, 345, 4278, 3, 345, 3, 345, 5, 345, 4283, 10, 345, 3,
	345, 5, 345, 4286, 10, 345, 5, 345, 4288, 10, 345, 3, 346, 3, 346, 3, 346,
	3, 346, 5, 346, 4294, 10, 346, 3, 346, 5, 346, 4297, 10, 346, 3, 347, 5,
	347, 4300, 10, 347, 3, 347, 3, 347, 3, 347, 7, 347, 4305, 10, 347, 12,
	347, 14, 347, 4308, 11, 347, 5, 347, 4310, 10, 347, 3, 348, 3, 348, 3,
	348, 3, 348, 7, 348, 4316, 10, 348, 12, 348, 14, 348, 4319, 11, 348, 5,
	348, 4321, 10, 348, 3, 349, 3, 349, 6, 349, 4325, 10, 349, 13, 349, 14,
	349, 4326, 3, 349, 5, 349, 4330, 10, 349, 3, 350, 3, 350, 6, 350, 4334,
	10, 350, 13, 350, 14, 350, 4335, 3, 351, 3, 351, 5, 351, 4340, 10, 351,
	3, 351, 3, 351, 3, 351, 5, 351, 4345, 10, 351, 3, 352, 3, 352, 6, 352,
	4349, 10, 352, 13, 352, 14, 352, 4350, 3, 353, 3, 353, 3, 353, 3, 353,
	3, 353, 3, 353, 5, 353, 4359, 10, 353, 3, 354, 3, 354, 6, 354, 4363, 10,
	354, 13, 354, 14, 354, 4364, 3, 355, 3, 355, 3, 355, 6, 355, 4370, 10,
	355, 13, 355, 14, 355, 4371, 3, 356, 3, 356, 6, 356, 4376, 10, 356, 13,
	356, 14, 356, 4377, 3, 356, 6, 356, 4381, 10, 356, 13, 356, 14, 356, 4382,
	3, 357, 3, 357, 3, 357, 5, 357, 4388, 10, 357, 3, 357, 3, 357, 7, 357,
	4392, 10, 357, 12, 357, 14, 357, 4395, 11, 357, 3, 358, 3, 358, 3, 358,
	3, 358, 6, 358, 4401, 10, 358, 13, 358, 14, 358, 4402, 3, 359, 3, 359,
	7, 359, 4407, 10, 359, 12, 359, 14, 359, 4410, 11, 359, 3, 360, 3, 360,
	3, 360, 7, 360, 4415, 10, 360, 12, 360, 14, 360, 4418, 11, 360, 3, 361,
	3, 361, 6, 361, 4422, 10, 361, 13, 361, 14, 361, 4423, 3, 362, 3, 362,
	6, 362, 4428, 10, 362, 13, 362, 14, 362, 4429, 3, 363, 3, 363, 5, 363,
	4434, 10, 363, 3, 363, 7, 363, 4437, 10, 363, 12, 363, 14, 363, 4440, 11,
	363, 3, 364, 3, 364, 5, 364, 4444, 10, 364, 3, 364, 3, 364, 7, 364, 4448,
	10, 364, 12, 364, 14, 364, 4451, 11, 364, 3, 365, 3, 365, 3, 365, 5, 365,
	4456, 10, 365, 3, 366, 3, 366, 3, 366, 5, 366, 4461, 10, 366, 3, 367, 3,
	367, 5, 367, 4465, 10, 367, 3, 367, 3, 367, 5, 367, 4469, 10, 367, 3, 368,
	3, 368, 3, 368, 6, 368, 4474, 10, 368, 13, 368, 14, 368, 4475, 3, 368,
	5, 368, 4479, 10, 368, 3, 368, 7, 368, 4482, 10, 368, 12, 368, 14, 368,
	4485, 11, 368, 3, 368, 5, 368, 4488, 10, 368, 3, 368, 7, 368, 4491, 10,
	368, 12, 368, 14, 368, 4494, 11, 368, 3, 369, 5, 369, 4497, 10, 369, 3,
	369, 3, 369, 5, 369, 4501, 10, 369, 3, 369, 6, 369, 4504, 10, 369, 13,
	369, 14, 369, 4505, 3, 370, 5, 370, 4509, 10, 370, 3, 370, 3, 370, 5, 370,
	4513, 10, 370, 3, 370, 6, 370, 4516, 10, 370, 13, 370, 14, 370, 4517, 3,
	370, 5, 370, 4521, 10, 370, 3, 370, 5, 370, 4524, 10, 370, 3, 371, 5, 371,
	4527, 10, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 372, 5, 372, 4534, 10,
	372, 3, 372, 3, 372, 5, 372, 4538, 10, 372, 3, 372, 3, 372, 3, 373, 3,
	373, 6, 373, 4544, 10, 373, 13, 373, 14, 373, 4545, 3, 374, 3, 374, 3,
	374, 5, 374, 4551, 10, 374, 3, 374, 3, 374, 5, 374, 4555, 10, 374, 3, 375,
	3, 375, 3, 375, 3, 376, 3, 376, 6, 376, 4562, 10, 376, 13, 376, 14, 376,
	4563, 3, 377, 3, 377, 3, 377, 3, 377, 3, 377, 3, 377, 3, 377, 3, 377, 3,
	377, 3, 377, 5, 377, 4576, 10, 377, 3, 378, 3, 378, 3, 378, 5, 378, 4581,
	10, 378, 3, 379, 3, 379, 3, 379, 6, 379, 4586, 10, 379, 13, 379, 14, 379,
	4587, 3, 380, 3, 380, 5, 380, 4592, 10, 380, 3, 381, 3, 381, 3, 381, 3,
	381, 6, 381, 4598, 10, 381, 13, 381, 14, 381, 4599, 3, 382, 3, 382, 3,
	382, 5, 382, 4605, 10, 382, 3, 382, 3, 382, 3, 382, 5, 382, 4610, 10, 382,
	3, 382, 5, 382, 4613, 10, 382, 3, 382, 5, 382, 4616, 10, 382, 3, 382, 5,
	382, 4619, 10, 382, 3, 383, 6, 383, 4622, 10, 383, 13, 383, 14, 383, 4623,
	3, 384, 3, 384, 5, 384, 4628, 10, 384, 3, 385, 3, 385, 3, 385, 6, 385,
	4633, 10, 385, 13, 385, 14, 385, 4634, 3, 386, 3, 386, 5, 386, 4639, 10,
	386, 3, 387, 3, 387, 5, 387, 4643, 10, 387, 3, 388, 3, 388, 3, 388, 3,
	388, 3, 388, 6, 388, 4650, 10, 388, 13, 388, 14, 388, 4651, 3, 389, 3,
	389, 6, 389, 4656, 10, 389, 13, 389, 14, 389, 4657, 3, 390, 3, 390, 3,
	390, 5, 390, 4663, 10, 390, 3, 390, 3, 390, 5, 390, 4667, 10, 390, 3, 391,
	3, 391, 6, 391, 4671, 10, 391, 13, 391, 14, 391, 4672, 3, 392, 3, 392,
	5, 392, 4677, 10, 392, 3, 392, 3, 392, 5, 392, 4681, 10, 392, 3, 393, 3,
	393, 6, 393, 4685, 10, 393, 13, 393, 14, 393, 4686, 3, 394, 3, 394, 6,
	394, 4691, 10, 394, 13, 394, 14, 394, 4692, 3, 395, 3, 395, 3, 395, 5,
	395, 4698, 10, 395, 3, 396, 5, 396, 4701, 10, 396, 3, 396, 6, 396, 4704,
	10, 396, 13, 396, 14, 396, 4705, 3, 396, 3, 396, 3, 397, 3, 397, 3, 397,
	5, 397, 4713, 10, 397, 3, 397, 5, 397, 4716, 10, 397, 3, 398, 3, 398, 3,
	398, 5, 398, 4721, 10, 398, 3, 399, 3, 399, 5, 399, 4725, 10, 399, 3, 399,
	3, 399, 3, 400, 5, 400, 4730, 10, 400, 3, 400, 3, 400, 3, 400, 3, 401,
	3, 401, 3, 401, 3, 401, 3, 401, 5, 401, 4740, 10, 401, 5, 401, 4742, 10,
	401, 3, 402, 3, 402, 3, 402, 7, 402, 4747, 10, 402, 12, 402, 14, 402, 4750,
	11, 402, 3, 403, 3, 403, 5, 403, 4754, 10, 403, 3, 403, 3, 403, 3, 403,
	3, 403, 3, 404, 3, 404, 3, 404, 3, 405, 3, 405, 3, 405, 3, 405, 5, 405,
	4767, 10, 405, 3, 406, 3, 406, 3, 406, 3, 406, 5, 406, 4773, 10, 406, 3,
	407, 5, 407, 4776, 10, 407, 3, 407, 3, 407, 3, 407, 3, 408, 3, 408, 6,
	408, 4783, 10, 408, 13, 408, 14, 408, 4784, 3, 409, 3, 409, 3, 409, 5,
	409, 4790, 10, 409, 3, 409, 5, 409, 4793, 10, 409, 3, 409, 5, 409, 4796,
	10, 409, 3, 409, 5, 409, 4799, 10, 409, 3, 409, 5, 409, 4802, 10, 409,
	3, 409, 5, 409, 4805, 10, 409, 3, 409, 5, 409, 4808, 10, 409, 3, 409, 5,
	409, 4811, 10, 409, 3, 409, 5, 409, 4814, 10, 409, 3, 409, 5, 409, 4817,
	10, 409, 3, 410, 3, 410, 3, 410, 3, 411, 5, 411, 4823, 10, 411, 3, 411,
	3, 411, 3, 411, 5, 411, 4828, 10, 411, 3, 412, 3, 412, 5, 412, 4832, 10,
	412, 3, 412, 3, 412, 3, 413, 3, 413, 3, 413, 5, 413, 4839, 10, 413, 3,
	413, 5, 413, 4842, 10, 413, 3, 413, 5, 413, 4845, 10, 413, 3, 413, 5, 413,
	4848, 10, 413, 3, 414, 3, 414, 3, 414, 3, 414, 3, 414, 3, 414, 3, 414,
	3, 414, 7, 414, 4858, 10, 414, 12, 414, 14, 414, 4861, 11, 414, 3, 415,
	3, 415, 3, 415, 3, 415, 3, 415, 3, 415, 5, 415, 4869, 10, 415, 3, 416,
	3, 416, 3, 416, 5, 416, 4874, 10, 416, 3, 416, 3, 416, 5, 416, 4878, 10,
	416, 3, 416, 5, 416, 4881, 10, 416, 3, 417, 3, 417, 3, 417, 7, 417, 4886,
	10, 417, 12, 417, 14, 417, 4889, 11, 417, 3, 418, 3, 418, 3, 418, 7, 418,
	4894, 10, 418, 12, 418, 14, 418, 4897, 11, 418, 3, 419, 3, 419, 5, 419,
	4901, 10, 419, 3, 419, 3, 419, 5, 419, 4905, 10, 419, 3, 420, 5, 420, 4908,
	10, 420, 3, 420, 3, 420, 3, 420, 3, 421, 3, 421, 5, 421, 4915, 10, 421,
	3, 421, 3, 421, 3, 422, 3, 422, 5, 422, 4921, 10, 422, 3, 422, 3, 422,
	5, 422, 4925, 10, 422, 3, 423, 3, 423, 5, 423, 4929, 10, 423, 3, 423, 3,
	423, 3, 424, 3, 424, 3, 424, 3, 424, 5, 424, 4937, 10, 424, 3, 425, 3,
	425, 3, 425, 5, 425, 4942, 10, 425, 3, 425, 5, 425, 4945, 10, 425, 3, 425,
	3, 425, 5, 425, 4949, 10, 425, 3, 425, 5, 425, 4952, 10, 425, 3, 426, 3,
	426, 3, 426, 3, 427, 3, 427, 3, 427, 5, 427, 4960, 10, 427, 3, 427, 5,
	427, 4963, 10, 427, 3, 427, 5, 427, 4966, 10, 427, 3, 427, 5, 427, 4969,
	10, 427, 3, 428, 3, 428, 3, 428, 3, 429, 3, 429, 5, 429, 4976, 10, 429,
	3, 429, 3, 429, 5, 429, 4980, 10, 429, 3, 429, 5, 429, 4983, 10, 429, 3,
	429, 6, 429, 4986, 10, 429, 13, 429, 14, 429, 4987, 3, 429, 5, 429, 4991,
	10, 429, 3, 430, 3, 430, 3, 430, 3, 431, 3, 431, 3, 431, 3, 431, 3, 431,
	7, 431, 5001, 10, 431, 12, 431, 14, 431, 5004, 11, 431, 5, 431, 5006, 10,
	431, 3, 432, 3, 432, 3, 432, 5, 432, 5011, 10, 432, 3, 432, 5, 432, 5014,
	10, 432, 3, 432, 5, 432, 5017, 10, 432, 3, 433, 3, 433, 5, 433, 5021, 10,
	433, 3, 433, 5, 433, 5024, 10, 433, 3, 433, 5, 433, 5027, 10, 433, 3, 433,
	5, 433, 5030, 10, 433, 3, 433, 5, 433, 5033, 10, 433, 3, 434, 3, 434, 3,
	434, 3, 434, 3, 435, 3, 435, 3, 435, 3, 436, 3, 436, 3, 436, 3, 436, 3,
	436, 5, 436, 5047, 10, 436, 3, 437, 3, 437, 5, 437, 5051, 10, 437, 3, 438,
	3, 438, 5, 438, 5055, 10, 438, 3, 438, 3, 438, 3, 438, 5, 438, 5060, 10,
	438, 3, 439, 3, 439, 3, 440, 3, 440, 5, 440, 5066, 10, 440, 3, 440, 5,
	440, 5069, 10, 440, 3, 441, 3, 441, 3, 442, 3, 442, 6, 442, 5075, 10, 442,
	13, 442, 14, 442, 5076, 3, 442, 5, 442, 5080, 10, 442, 3, 443, 6, 443,
	5083, 10, 443, 13, 443, 14, 443, 5084, 3, 443, 3, 443, 6, 443, 5089, 10,
	443, 13, 443, 14, 443, 5090, 3, 444, 6, 444, 5094, 10, 444, 13, 444, 14,
	444, 5095, 3, 444, 3, 444, 3, 444, 3, 444, 5, 444, 5102, 10, 444, 3, 444,
	3, 444, 3, 445, 3, 445, 3, 446, 3, 446, 3, 446, 3, 446, 5, 446, 5112, 10,
	446, 3, 447, 3, 447, 5, 447, 5116, 10, 447, 3, 448, 3, 448, 3, 448, 6,
	448, 5121, 10, 448, 13, 448, 14, 448, 5122, 3, 448, 5, 448, 5126, 10, 448,
	3, 448, 5, 448, 5129, 10, 448, 3, 448, 5, 448, 5132, 10, 448, 3, 448, 7,
	448, 5135, 10, 448, 12, 448, 14, 448, 5138, 11, 448, 3, 448, 5, 448, 5141,
	10, 448, 3, 448, 7, 448, 5144, 10, 448, 12, 448, 14, 448, 5147, 11, 448,
	3, 449, 5, 449, 5150, 10, 449, 3, 449, 3, 449, 5, 449, 5154, 10, 449, 3,
	449, 6, 449, 5157, 10, 449, 13, 449, 14, 449, 5158, 3, 450, 5, 450, 5162,
	10, 450, 3, 450, 3, 450, 5, 450, 5166, 10, 450, 3, 450, 5, 450, 5169, 10,
	450, 3, 451, 5, 451, 5172, 10, 451, 3, 451, 3, 451, 5, 451, 5176, 10, 451,
	3, 451, 6, 451, 5179, 10, 451, 13, 451, 14, 451, 5180, 3, 451, 5, 451,
	5184, 10, 451, 3, 451, 5, 451, 5187, 10, 451, 3, 452, 5, 452, 5190, 10,
	452, 3, 452, 3, 452, 3, 452, 3, 452, 3, 453, 5, 453, 5197, 10, 453, 3,
	453, 3, 453, 5, 453, 5201, 10, 453, 3, 453, 3, 453, 3, 454, 3, 454, 3,
	454, 5, 454, 5208, 10, 454, 3, 454, 3, 454, 5, 454, 5212, 10, 454, 3, 455,
	3, 455, 3, 455, 3, 456, 3, 456, 6, 456, 5219, 10, 456, 13, 456, 14, 456,
	5220, 3, 457, 3, 457, 3, 457, 5, 457, 5226, 10, 457, 3, 457, 3, 457, 5,
	457, 5230, 10, 457, 3, 458, 3, 458, 3, 458, 3, 459, 3, 459, 6, 459, 5237,
	10, 459, 13, 459, 14, 459, 5238, 3, 460, 3, 460, 3, 460, 3, 460, 3, 460,
	3, 460, 3, 460, 3, 460, 3, 460, 3, 460, 5, 460, 5251, 10, 460, 3, 461,
	3, 461, 3, 461, 5, 461, 5256, 10, 461, 3, 461, 5, 461, 5259, 10, 461, 3,
	461, 5, 461, 5262, 10, 461, 3, 461, 5, 461, 5265, 10, 461, 3, 462, 3, 462,
	5, 462, 5269, 10, 462, 3, 462, 3, 462, 5, 462, 5273, 10, 462, 3, 462, 3,
	462, 3, 462, 5, 462, 5278, 10, 462, 3, 462, 3, 462, 3, 462, 3, 462, 5,
	462, 5284, 10, 462, 3, 462, 3, 462, 3, 462, 3, 462, 5, 462, 5290, 10, 462,
	3, 462, 3, 462, 3, 462, 5, 462, 5295, 10, 462, 3, 462, 5, 462, 5298, 10,
	462, 3, 462, 3, 462, 3, 463, 3, 463, 3, 463, 5, 463, 5305, 10, 463, 3,
	464, 3, 464, 6, 464, 5309, 10, 464, 13, 464, 14, 464, 5310, 3, 464, 3,
	464, 5, 464, 5315, 10, 464, 3, 464, 5, 464, 5318, 10, 464, 3, 464, 5, 464,
	5321, 10, 464, 3, 464, 5, 464, 5324, 10, 464, 3, 465, 6, 465, 5327, 10,
	465, 13, 465, 14, 465, 5328, 3, 465, 3, 465, 5, 465, 5333, 10, 465, 3,
	466, 3, 466, 5, 466, 5337, 10, 466, 3, 467, 3, 467, 5, 467, 5341, 10, 467,
	3, 467, 3, 467, 3, 467, 5, 467, 5346, 10, 467, 3, 468, 3, 468, 3, 468,
	5, 468, 5351, 10, 468, 3, 469, 3, 469, 3, 469, 3, 470, 5, 470, 5357, 10,
	470, 3, 470, 3, 470, 3, 470, 3, 471, 3, 471, 3, 471, 3, 471, 5, 471, 5366,
	10, 471, 3, 471, 5, 471, 5369, 10, 471, 3, 471, 5, 471, 5372, 10, 471,
	3, 471, 5, 471, 5375, 10, 471, 3, 472, 6, 472, 5378, 10, 472, 13, 472,
	14, 472, 5379, 3, 472, 3, 472, 6, 472, 5384, 10, 472, 13, 472, 14, 472,
	5385, 3, 473, 6, 473, 5389, 10, 473, 13, 473, 14, 473, 5390, 3, 473, 3,
	473, 3, 473, 3, 473, 6, 473, 5397, 10, 473, 13, 473, 14, 473, 5398, 3,
	474, 3, 474, 3, 474, 3, 474, 3, 474, 3, 475, 3, 475, 5, 475, 5408, 10,
	475, 3, 476, 3, 476, 5, 476, 5412, 10, 476, 3, 477, 3, 477, 5, 477, 5416,
	10, 477, 3, 478, 3, 478, 5, 478, 5420, 10, 478, 3, 479, 3, 479, 5, 479,
	5424, 10, 479, 3, 480, 3, 480, 3, 480, 3, 481, 3, 481, 3, 481, 3, 481,
	5, 481, 5433, 10, 481, 3, 481, 5, 481, 5436, 10, 481, 3, 481, 5, 481, 5439,
	10, 481, 3, 481, 5, 481, 5442, 10, 481, 3, 481, 5, 481, 5445, 10, 481,
	3, 482, 3, 482, 3, 482, 7, 482, 5450, 10, 482, 12, 482, 14, 482, 5453,
	11, 482, 5, 482, 5455, 10, 482, 3, 483, 3, 483, 5, 483, 5459, 10, 483,
	3, 483, 5, 483, 5462, 10, 483, 3, 483, 3, 483, 5, 483, 5466, 10, 483, 3,
	484, 3, 484, 5, 484, 5470, 10, 484, 3, 484, 3, 484, 5, 484, 5474, 10, 484,
	3, 485, 3, 485, 6, 485, 5478, 10, 485, 13, 485, 14, 485, 5479, 3, 486,
	3, 486, 5, 486, 5484, 10, 486, 3, 486, 5, 486, 5487, 10, 486, 3, 487, 3,
	487, 5, 487, 5491, 10, 487, 3, 487, 3, 487, 3, 488, 3, 488, 5, 488, 5497,
	10, 488, 3, 488, 3, 488, 3, 489, 5, 489, 5502, 10, 489, 3, 489, 3, 489,
	3, 489, 3, 490, 3, 490, 5, 490, 5509, 10, 490, 3, 490, 3, 490, 3, 491,
	3, 491, 3, 491, 5, 491, 5516, 10, 491, 3, 492, 5, 492, 5519, 10, 492, 3,
	492, 3, 492, 5, 492, 5523, 10, 492, 3, 492, 3, 492, 3, 492, 5, 492, 5528,
	10, 492, 3, 492, 3, 492, 3, 493, 3, 493, 3, 493, 3, 493, 3, 493, 6, 493,
	5537, 10, 493, 13, 493, 14, 493, 5538, 5, 493, 5541, 10, 493, 3, 494, 5,
	494, 5544, 10, 494, 3, 494, 3, 494, 5, 494, 5548, 10, 494, 3, 494, 6, 494,
	5551, 10, 494, 13, 494, 14, 494, 5552, 3, 495, 3, 495, 3, 495, 3, 495,
	5, 495, 5559, 10, 495, 3, 495, 5, 495, 5562, 10, 495, 3, 495, 3, 495, 3,
	495, 5, 495, 5567, 10, 495, 3, 496, 3, 496, 3, 496, 5, 496, 5572, 10, 496,
	3, 496, 5, 496, 5575, 10, 496, 3, 496, 5, 496, 5578, 10, 496, 3, 496, 5,
	496, 5581, 10, 496, 3, 496, 5, 496, 5584, 10, 496, 3, 496, 5, 496, 5587,
	10, 496, 3, 496, 5, 496, 5590, 10, 496, 3, 497, 3, 497, 3, 497, 5, 497,
	5595, 10, 497, 3, 498, 3, 498, 5, 498, 5599, 10, 498, 3, 498, 3, 498, 3,
	498, 5, 498, 5604, 10, 498, 3, 499, 3, 499, 3, 500, 3, 500, 5, 500, 5610,
	10, 500, 3, 500, 5, 500, 5613, 10, 500, 3, 501, 3, 501, 3, 502, 5, 502,
	5618, 10, 502, 3, 502, 3, 502, 7, 502, 5622, 10, 502, 12, 502, 14, 502,
	5625, 11, 502, 3, 503, 3, 503, 5, 503, 5629, 10, 503, 3, 503, 3, 503, 7,
	503, 5633, 10, 503, 12, 503, 14, 503, 5636, 11, 503, 3, 504, 5, 504, 5639,
	10, 504, 3, 504, 3, 504, 7, 504, 5643, 10, 504, 12, 504, 14, 504, 5646,
	11, 504, 3, 505, 3, 505, 5, 505, 5650, 10, 505, 3, 505, 3, 505, 7, 505,
	5654, 10, 505, 12, 505, 14, 505, 5657, 11, 505, 3, 506, 3, 506, 5, 506,
	5661, 10, 506, 3, 506, 7, 506, 5664, 10, 506, 12, 506, 14, 506, 5667, 11,
	506, 3, 507, 3, 507, 3, 507, 5, 507, 5672, 10, 507, 3, 507, 7, 507, 5675,
	10, 507, 12, 507, 14, 507, 5678, 11, 507, 3, 508, 5, 508, 5681, 10, 508,
	3, 508, 3, 508, 7, 508, 5685, 10, 508, 12, 508, 14, 508, 5688, 11, 508,
	3, 509, 3, 509, 5, 509, 5692, 10, 509, 3, 509, 3, 509, 7, 509, 5696, 10,
	509, 12, 509, 14, 509, 5699, 11, 509, 3, 510, 5, 510, 5702, 10, 510, 3,
	510, 3, 510, 3, 510, 7, 510, 5707, 10, 510, 12, 510, 14, 510, 5710, 11,
	510, 3, 511, 3, 511, 5, 511, 5714, 10, 511, 3, 511, 3, 511, 3, 511, 7,
	511, 5719, 10, 511, 12, 511, 14, 511, 5722, 11, 511, 3, 512, 5, 512, 5725,
	10, 512, 3, 512, 3, 512, 7, 512, 5729, 10, 512, 12, 512, 14, 512, 5732,
	11, 512, 3, 513, 3, 513, 5, 513, 5736, 10, 513, 3, 513, 3, 513, 7, 513,
	5740, 10, 513, 12, 513, 14, 513, 5743, 11, 513, 3, 514, 3, 514, 7, 514,
	5747, 10, 514, 12, 514, 14, 514, 5750, 11, 514, 3, 515, 3, 515, 3, 515,
	3, 516, 3, 516, 7, 516, 5757, 10, 516, 12, 516, 14, 516, 5760, 11, 516,
	3, 517, 3, 517, 3, 517, 3, 518, 5, 518, 5766, 10, 518, 3, 518, 3, 518,
	7, 518, 5770, 10, 518, 12, 518, 14, 518, 5773, 11, 518, 3, 519, 3, 519,
	3, 519, 3, 520, 3, 520, 3, 520, 3, 520, 3, 520, 3, 520, 5, 520, 5784, 10,
	520, 3, 521, 3, 521, 7, 521, 5788, 10, 521, 12, 521, 14, 521, 5791, 11,
	521, 3, 522, 3, 522, 3, 522, 6, 522, 5796, 10, 522, 13, 522, 14, 522, 5797,
	5, 522, 5800, 10, 522, 3, 523, 5, 523, 5803, 10, 523, 3, 523, 3, 523, 3,
	524, 3, 524, 3, 524, 3, 524, 3, 524, 3, 524, 3, 524, 5, 524, 5814, 10,
	524, 3, 525, 3, 525, 5, 525, 5818, 10, 525, 3, 525, 5, 525, 5821, 10, 525,
	3, 525, 3, 525, 3, 525, 3, 525, 3, 525, 3, 525, 3, 525, 5, 525, 5830, 10,
	525, 3, 526, 3, 526, 7, 526, 5834, 10, 526, 12, 526, 14, 526, 5837, 11,
	526, 3, 526, 5, 526, 5840, 10, 526, 3, 526, 7, 526, 5843, 10, 526, 12,
	526, 14, 526, 5846, 11, 526, 3, 526, 7, 526, 5849, 10, 526, 12, 526, 14,
	526, 5852, 11, 526, 5, 526, 5854, 10, 526, 3, 527, 3, 527, 6, 527, 5858,
	10, 527, 13, 527, 14, 527, 5859, 3, 527, 3, 527, 3, 528, 3, 528, 3, 528,
	5, 528, 5867, 10, 528, 3, 529, 3, 529, 5, 529, 5871, 10, 529, 3, 529, 5,
	529, 5874, 10, 529, 3, 529, 3, 529, 3, 530, 3, 530, 3, 530, 3, 530, 3,
	531, 3, 531, 3, 531, 3, 531, 3, 531, 3, 531, 3, 532, 3, 532, 3, 532, 6,
	532, 5891, 10, 532, 13, 532, 14, 532, 5892, 3, 533, 5, 533, 5896, 10, 533,
	3, 533, 5, 533, 5899, 10, 533, 3, 533, 3, 533, 5, 533, 5903, 10, 533, 3,
	533, 3, 533, 3, 533, 5, 533, 5908, 10, 533, 3, 533, 3, 533, 3, 533, 5,
	533, 5913, 10, 533, 3, 533, 5, 533, 5916, 10, 533, 3, 533, 3, 533, 5, 533,
	5920, 10, 533, 3, 533, 3, 533, 3, 533, 5, 533, 5925, 10, 533, 3, 533, 3,
	533, 3, 533, 5, 533, 5930, 10, 533, 3, 533, 3, 533, 3, 533, 5, 533, 5935,
	10, 533, 3, 533, 5, 533, 5938, 10, 533, 3, 534, 5, 534, 5941, 10, 534,
	3, 534, 5, 534, 5944, 10, 534, 3, 534, 3, 534, 3, 534, 3, 534, 3, 534,
	3, 534, 5, 534, 5952, 10, 534, 3, 535, 3, 535, 3, 535, 3, 535, 5, 535,
	5958, 10, 535, 3, 536, 3, 536, 3, 536, 3, 536, 5, 536, 5964, 10, 536, 3,
	536, 7, 536, 5967, 10, 536, 12, 536, 14, 536, 5970, 11, 536, 3, 536, 3,
	536, 7, 536, 5974, 10, 536, 12, 536, 14, 536, 5977, 11, 536, 3, 536, 5,
	536, 5980, 10, 536, 3, 537, 3, 537, 3, 537, 3, 537, 3, 537, 5, 537, 5987,
	10, 537, 3, 537, 7, 537, 5990, 10, 537, 12, 537, 14, 537, 5993, 11, 537,
	3, 537, 3, 537, 7, 537, 5997, 10, 537, 12, 537, 14, 537, 6000, 11, 537,
	3, 537, 5, 537, 6003, 10, 537, 3, 538, 3, 538, 3, 538, 3, 538, 5, 538,
	6009, 10, 538, 3, 538, 3, 538, 3, 539, 3, 539, 3, 540, 3, 540, 3, 541,
	3, 541, 3, 541, 3, 541, 5, 541, 6021, 10, 541, 3, 541, 3, 541, 5, 541,
	6025, 10, 541, 3, 541, 5, 541, 6028, 10, 541, 3, 542, 3, 542, 3, 542, 3,
	542, 5, 542, 6034, 10, 542, 3, 542, 3, 542, 5, 542, 6038, 10, 542, 3, 542,
	5, 542, 6041, 10, 542, 3, 543, 3, 543, 3, 543, 3, 543, 5, 543, 6047, 10,
	543, 3, 544, 3, 544, 5, 544, 6051, 10, 544, 3, 544, 6, 544, 6054, 10, 544,
	13, 544, 14, 544, 6055, 3, 544, 5, 544, 6059, 10, 544, 3, 544, 5, 544,
	6062, 10, 544, 3, 545, 3, 545, 3, 545, 3, 546, 3, 546, 3, 546, 3, 547,
	3, 547, 3, 547, 3, 548, 3, 548, 5, 548, 6075, 10, 548, 3, 549, 3, 549,
	3, 549, 3, 550, 3, 550, 3, 550, 3, 551, 3, 551, 3, 551, 3, 552, 3, 552,
	3, 552, 3, 553, 3, 553, 3, 553, 3, 554, 3, 554, 3, 554, 3, 555, 3, 555,
	3, 556, 3, 556, 3, 557, 3, 557, 3, 558, 3, 558, 3, 559, 3, 559, 3, 560,
	3, 560, 3, 561, 3, 561, 3, 562, 3, 562, 3, 563, 3, 563, 3, 563, 5, 563,
	6114, 10, 563, 3, 564, 3, 564, 3, 565, 3, 565, 3, 566, 3, 566, 3, 566,
	3, 566, 3, 566, 3, 566, 5, 566, 6126, 10, 566, 3, 567, 3, 567, 3, 568,
	3, 568, 3, 569, 3, 569, 3, 570, 3, 570, 3, 571, 3, 571, 3, 572, 3, 572,
	5, 572, 6140, 10, 572, 3, 573, 3, 573, 5, 573, 6144, 10, 573, 3, 573, 5,
	573, 6147, 10, 573, 3, 574, 3, 574, 5, 574, 6151, 10, 574, 3, 575, 3, 575,
	3, 576, 3, 576, 3, 577, 3, 577, 3, 578, 3, 578, 3, 579, 3, 579, 5, 579,
	6163, 10, 579, 3, 580, 3, 580, 3, 581, 3, 581, 3, 582, 3, 582, 3, 583,
	3, 583, 3, 584, 3, 584, 3, 584, 3, 584, 3, 584, 3, 584, 5, 584, 6179, 10,
	584, 3, 585, 3, 585, 3, 586, 3, 586, 3, 586, 5, 586, 6186, 10, 586, 3,
	587, 3, 587, 3, 588, 3, 588, 3, 588, 3, 588, 5, 588, 6194, 10, 588, 3,
	588, 3, 588, 3, 589, 3, 589, 3, 589, 3, 589, 5, 589, 6202, 10, 589, 3,
	589, 3, 589, 3, 590, 3, 590, 3, 590, 3, 590, 3, 590, 3, 590, 3, 590, 3,
	590, 3, 590, 3, 590, 3, 590, 3, 590, 3, 590, 3, 590, 3, 590, 5, 590, 6221,
	10, 590, 3, 591, 3, 591, 3, 591, 3, 591, 3, 591, 3, 591, 3, 591, 3, 591,
	3, 591, 3, 591, 3, 591, 3, 591, 3, 591, 3, 591, 3, 591, 3, 591, 3, 591,
	3, 591, 3, 591, 3, 591, 3, 591, 3, 591, 3, 591, 3, 591, 3, 591, 3, 591,
	3, 591, 3, 591, 3, 591, 3, 591, 3, 591, 5, 591, 6254, 10, 591, 3, 592,
	6, 592, 6257, 10, 592, 13, 592, 14, 592, 6258, 3, 592, 2, 2, 593, 2, 4,
	6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
	44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
	80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
	114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
	144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
	174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202,
	204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232,
	234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262,
	264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292,
	294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322,
	324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352,
	354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382,
	384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412,
	414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442,
	444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472,
	474, 476, 478, 480, 482, 484, 486, 488, 490, 492, 494, 496, 498, 500, 502,
	504, 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532,
	534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562,
	564, 566, 568, 570, 572, 574, 576, 578, 580, 582, 584, 586, 588, 590, 592,
	594, 596, 598, 600, 602, 604, 606, 608, 610, 612, 614, 616, 618, 620, 622,
	624, 626, 628, 630, 632, 634, 636, 638, 640, 642, 644, 646, 648, 650, 652,
	654, 656, 658, 660, 662, 664, 666, 668, 670, 672, 674, 676, 678, 680, 682,
	684, 686, 688, 690, 692, 694, 696, 698, 700, 702, 704, 706, 708, 710, 712,
	714, 716, 718, 720, 722, 724, 726, 728, 730, 732, 734, 736, 738, 740, 742,
	744, 746, 748, 750, 752, 754, 756, 758, 760, 762, 764, 766, 768, 770, 772,
	774, 776, 778, 780, 782, 784, 786, 788, 790, 792, 794, 796, 798, 800, 802,
	804, 806, 808, 810, 812, 814, 816, 818, 820, 822, 824, 826, 828, 830, 832,
	834, 836, 838, 840, 842, 844, 846, 848, 850, 852, 854, 856, 858, 860, 862,
	864, 866, 868, 870, 872, 874, 876, 878, 880, 882, 884, 886, 888, 890, 892,
	894, 896, 898, 900, 902, 904, 906, 908, 910, 912, 914, 916, 918, 920, 922,
	924, 926, 928, 930, 932, 934, 936, 938, 940, 942, 944, 946, 948, 950, 952,
	954, 956, 958, 960, 962, 964, 966, 968, 970, 972, 974, 976, 978, 980, 982,
	984, 986, 988, 990, 992, 994, 996, 998, 1000, 1002, 1004, 1006, 1008, 1010,
	1012, 1014, 1016, 1018, 1020, 1022, 1024, 1026, 1028, 1030, 1032, 1034,
	1036, 1038, 1040, 1042, 1044, 1046, 1048, 1050, 1052, 1054, 1056, 1058,
	1060, 1062, 1064, 1066, 1068, 1070, 1072, 1074, 1076, 1078, 1080, 1082,
	1084, 1086, 1088, 1090, 1092, 1094, 1096, 1098, 1100, 1102, 1104, 1106,
	1108, 1110, 1112, 1114, 1116, 1118, 1120, 1122, 1124, 1126, 1128, 1130,
	1132, 1134, 1136, 1138, 1140, 1142, 1144, 1146, 1148, 1150, 1152, 1154,
	1156, 1158, 1160, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176, 1178,
	1180, 1182, 2, 71, 4, 2, 23, 23, 455, 455, 3, 2, 239, 240, 6, 2, 83, 83,
	135, 135, 248, 248, 279, 279, 5, 2, 67, 67, 303, 303, 521, 521, 4, 2, 303,
	303, 521, 521, 3, 2, 489, 490, 4, 2, 16, 16, 309, 309, 4, 2, 85, 85, 91,
	91, 4, 2, 270, 270, 499, 499, 4, 2, 24, 24, 259, 259, 3, 2, 25, 26, 5,
	2, 246, 246, 392, 392, 434, 434, 6, 2, 155, 155, 202, 202, 376, 376, 434,
	434, 4, 2, 388, 388, 505, 505, 5, 2, 384, 384, 445, 445, 449, 449, 4, 2,
	210, 210, 422, 422, 4, 2, 67, 67, 386, 386, 3, 2, 466, 468, 4, 2, 284,
	284, 421, 421, 4, 2, 42, 42, 45, 45, 3, 2, 194, 195, 4, 2, 234, 234, 295,
	295, 5, 2, 231, 231, 272, 272, 343, 343, 5, 2, 355, 355, 550, 550, 553,
	553, 3, 2, 78, 79, 3, 2, 218, 219, 3, 2, 39, 40, 3, 2, 353, 354, 3, 2,
	147, 148, 3, 2, 260, 261, 3, 2, 37, 38, 4, 2, 315, 315, 425, 425, 4, 2,
	162, 162, 404, 404, 4, 2, 221, 221, 274, 274, 3, 2, 284, 285, 4, 2, 122,
	122, 142, 142, 5, 2, 151, 151, 362, 362, 437, 438, 3, 2, 54, 55, 4, 2,
	559, 559, 561, 561, 4, 2, 528, 528, 530, 531, 5, 2, 83, 83, 289, 289, 344,
	344, 4, 2, 255, 255, 465, 465, 4, 2, 29, 29, 140, 140, 4, 2, 100, 100,
	389, 390, 3, 2, 474, 475, 4, 2, 271, 271, 416, 416, 6, 2, 292, 293, 323,
	323, 325, 325, 442, 442, 4, 2, 207, 207, 501, 501, 4, 2, 105, 105, 266,
	266, 3, 2, 108, 109, 4, 2, 3, 3, 338, 338, 4, 2, 191, 191, 543, 543, 9,
	2, 13, 13, 16, 17, 121, 121, 157, 157, 309, 309, 322, 322, 324, 324, 4,
	2, 11, 11, 270, 270, 5, 2, 11, 11, 215, 215, 270, 270, 4, 2, 9, 9, 43,
	43, 4, 2, 263, 263, 314, 314, 4, 2, 300, 300, 427, 427, 4, 2, 52, 52, 498,
	498, 4, 2, 193, 193, 201, 201, 4, 2, 173, 173, 190, 190, 4, 2, 550, 550,
	553, 553, 4, 2, 533, 533, 556, 556, 4, 2, 21, 21, 336, 336, 5, 2, 311,
	311, 358, 358, 528, 528, 4, 2, 244, 244, 329, 329, 91, 2, 3, 3, 23, 23,
	27, 28, 30, 30, 32, 33, 35, 35, 37, 40, 42, 42, 45, 45, 47, 47, 49, 49,
	51, 51, 58, 58, 60, 60, 64, 65, 72, 73, 75, 75, 82, 82, 103, 103, 105,
	105, 111, 111, 113, 113, 133, 135, 143, 144, 146, 146, 151, 152, 156, 156,
	162, 162, 186, 186, 188, 188, 192, 192, 194, 196, 199, 199, 202, 202, 205,
	205, 207, 207, 218, 219, 221, 221, 223, 224, 231, 231, 234, 234, 242, 243,
	255, 255, 263, 263, 266, 266, 268, 269, 272, 272, 274, 274, 276, 279, 288,
	289, 292, 295, 301, 301, 308, 309, 312, 312, 315, 316, 323, 323, 325, 325,
	328, 328, 334, 334, 338, 338, 343, 344, 349, 349, 359, 360, 362, 362, 367,
	368, 371, 371, 377, 378, 380, 380, 383, 383, 389, 389, 397, 397, 404, 404,
	407, 407, 420, 420, 425, 425, 436, 439, 442, 442, 455, 455, 472, 472, 479,
	479, 487, 488, 492, 492, 496, 497, 501, 501, 503, 504, 516, 517, 524, 527,
	529, 529, 563, 563, 4, 2, 209, 209, 500, 500, 3, 2, 558, 561, 2, 7016,
	2, 1184, 3, 2, 2, 2, 4, 1188, 3, 2, 2, 2, 6, 1193, 3, 2, 2, 2, 8, 1214,
	3, 2, 2, 2, 10, 1225, 3, 2, 2, 2, 12, 1256, 3, 2, 2, 2, 14, 1258, 3, 2,
	2, 2, 16, 1260, 3, 2, 2, 2, 18, 1276, 3, 2, 2, 2, 20, 1278, 3, 2, 2, 2,
	22, 1292, 3, 2, 2, 2, 24, 1297, 3, 2, 2, 2, 26, 1302, 3, 2, 2, 2, 28, 1307,
	3, 2, 2, 2, 30, 1312, 3, 2, 2, 2, 32, 1317, 3, 2, 2, 2, 34, 1322, 3, 2,
	2, 2, 36, 1334, 3, 2, 2, 2, 38, 1336, 3, 2, 2, 2, 40, 1347, 3, 2, 2, 2,
	42, 1349, 3, 2, 2, 2, 44, 1361, 3, 2, 2, 2, 46, 1377, 3, 2, 2, 2, 48, 1379,
	3, 2, 2, 2, 50, 1390, 3, 2, 2, 2, 52, 1405, 3, 2, 2, 2, 54, 1426, 3, 2,
	2, 2, 56, 1435, 3, 2, 2, 2, 58, 1443, 3, 2, 2, 2, 60, 1449, 3, 2, 2, 2,
	62, 1453, 3, 2, 2, 2, 64, 1475, 3, 2, 2, 2, 66, 1479, 3, 2, 2, 2, 68, 1481,
	3, 2, 2, 2, 70, 1503, 3, 2, 2, 2, 72, 1512, 3, 2, 2, 2, 74, 1515, 3, 2,
	2, 2, 76, 1521, 3, 2, 2, 2, 78, 1535, 3, 2, 2, 2, 80, 1542, 3, 2, 2, 2,
	82, 1558, 3, 2, 2, 2, 84, 1565, 3, 2, 2, 2, 86, 1569, 3, 2, 2, 2, 88, 1571,
	3, 2, 2, 2, 90, 1587, 3, 2, 2, 2, 92, 1593, 3, 2, 2, 2, 94, 1610, 3, 2,
	2, 2, 96, 1633, 3, 2, 2, 2, 98, 1671, 3, 2, 2, 2, 100, 1673, 3, 2, 2, 2,
	102, 1679, 3, 2, 2, 2, 104, 1693, 3, 2, 2, 2, 106, 1713, 3, 2, 2, 2, 108,
	1725, 3, 2, 2, 2, 110, 1736, 3, 2, 2, 2, 112, 1738, 3, 2, 2, 2, 114, 1750,
	3, 2, 2, 2, 116, 1757, 3, 2, 2, 2, 118, 1774, 3, 2, 2, 2, 120, 1776, 3,
	2, 2, 2, 122, 1791, 3, 2, 2, 2, 124, 1806, 3, 2, 2, 2, 126, 1817, 3, 2,
	2, 2, 128, 1828, 3, 2, 2, 2, 130, 1838, 3, 2, 2, 2, 132, 1847, 3, 2, 2,
	2, 134, 1864, 3, 2, 2, 2, 136, 1882, 3, 2, 2, 2, 138, 1889, 3, 2, 2, 2,
	140, 1899, 3, 2, 2, 2, 142, 1908, 3, 2, 2, 2, 144, 1928, 3, 2, 2, 2, 146,
	1930, 3, 2, 2, 2, 148, 1944, 3, 2, 2, 2, 150, 1948, 3, 2, 2, 2, 152, 1957,
	3, 2, 2, 2, 154, 1961, 3, 2, 2, 2, 156, 1976, 3, 2, 2, 2, 158, 1989, 3,
	2, 2, 2, 160, 1994, 3, 2, 2, 2, 162, 2001, 3, 2, 2, 2, 164, 2007, 3, 2,
	2, 2, 166, 2033, 3, 2, 2, 2, 168, 2042, 3, 2, 2, 2, 170, 2071, 3, 2, 2,
	2, 172, 2074, 3, 2, 2, 2, 174, 2079, 3, 2, 2, 2, 176, 2083, 3, 2, 2, 2,
	178, 2094, 3, 2, 2, 2, 180, 2097, 3, 2, 2, 2, 182, 2104, 3, 2, 2, 2, 184,
	2111, 3, 2, 2, 2, 186, 2140, 3, 2, 2, 2, 188, 2147, 3, 2, 2, 2, 190, 2150,
	3, 2, 2, 2, 192, 2170, 3, 2, 2, 2, 194, 2177, 3, 2, 2, 2, 196, 2185, 3,
	2, 2, 2, 198, 2201, 3, 2, 2, 2, 200, 2221, 3, 2, 2, 2, 202, 2224, 3, 2,
	2, 2, 204, 2235, 3, 2, 2, 2, 206, 2246, 3, 2, 2, 2, 208, 2256, 3, 2, 2,
	2, 210, 2265, 3, 2, 2, 2, 212, 2267, 3, 2, 2, 2, 214, 2281, 3, 2, 2, 2,
	216, 2288, 3, 2, 2, 2, 218, 2297, 3, 2, 2, 2, 220, 2302, 3, 2, 2, 2, 222,
	2311, 3, 2, 2, 2, 224, 2320, 3, 2, 2, 2, 226, 2333, 3, 2, 2, 2, 228, 2335,
	3, 2, 2, 2, 230, 2363, 3, 2, 2, 2, 232, 2382, 3, 2, 2, 2, 234, 2405, 3,
	2, 2, 2, 236, 2412, 3, 2, 2, 2, 238, 2426, 3, 2, 2, 2, 240, 2433, 3, 2,
	2, 2, 242, 2441, 3, 2, 2, 2, 244, 2449, 3, 2, 2, 2, 246, 2456, 3, 2, 2,
	2, 248, 2463, 3, 2, 2, 2, 250, 2471, 3, 2, 2, 2, 252, 2480, 3, 2, 2, 2,
	254, 2489, 3, 2, 2, 2, 256, 2498, 3, 2, 2, 2, 258, 2507, 3, 2, 2, 2, 260,
	2515, 3, 2, 2, 2, 262, 2522, 3, 2, 2, 2, 264, 2537, 3, 2, 2, 2, 266, 2546,
	3, 2, 2, 2, 268, 2588, 3, 2, 2, 2, 270, 2591, 3, 2, 2, 2, 272, 2593, 3,
	2, 2, 2, 274, 2595, 3, 2, 2, 2, 276, 2598, 3, 2, 2, 2, 278, 2600, 3, 2,
	2, 2, 280, 2602, 3, 2, 2, 2, 282, 2604, 3, 2, 2, 2, 284, 2606, 3, 2, 2,
	2, 286, 2614, 3, 2, 2, 2, 288, 2628, 3, 2, 2, 2, 290, 2642, 3, 2, 2, 2,
	292, 2650, 3, 2, 2, 2, 294, 2658, 3, 2, 2, 2, 296, 2664, 3, 2, 2, 2, 298,
	2670, 3, 2, 2, 2, 300, 2676, 3, 2, 2, 2, 302, 2684, 3, 2, 2, 2, 304, 2687,
	3, 2, 2, 2, 306, 2690, 3, 2, 2, 2, 308, 2696, 3, 2, 2, 2, 310, 2702, 3,
	2, 2, 2, 312, 2710, 3, 2, 2, 2, 314, 2719, 3, 2, 2, 2, 316, 2721, 3, 2,
	2, 2, 318, 2723, 3, 2, 2, 2, 320, 2725, 3, 2, 2, 2, 322, 2739, 3, 2, 2,
	2, 324, 2744, 3, 2, 2, 2, 326, 2746, 3, 2, 2, 2, 328, 2748, 3, 2, 2, 2,
	330, 2757, 3, 2, 2, 2, 332, 2763, 3, 2, 2, 2, 334, 2786, 3, 2, 2, 2, 336,
	2790, 3, 2, 2, 2, 338, 2805, 3, 2, 2, 2, 340, 2808, 3, 2, 2, 2, 342, 2812,
	3, 2, 2, 2, 344, 2816, 3, 2, 2, 2, 346, 2822, 3, 2, 2, 2, 348, 2824, 3,
	2, 2, 2, 350, 2838, 3, 2, 2, 2, 352, 2848, 3, 2, 2, 2, 354, 2873, 3, 2,
	2, 2, 356, 2879, 3, 2, 2, 2, 358, 2888, 3, 2, 2, 2, 360, 2892, 3, 2, 2,
	2, 362, 2897, 3, 2, 2, 2, 364, 2909, 3, 2, 2, 2, 366, 2917, 3, 2, 2, 2,
	368, 2920, 3, 2, 2, 2, 370, 2930, 3, 2, 2, 2, 372, 2933, 3, 2, 2, 2, 374,
	2936, 3, 2, 2, 2, 376, 2942, 3, 2, 2, 2, 378, 2950, 3, 2, 2, 2, 380, 2959,
	3, 2, 2, 2, 382, 2965, 3, 2, 2, 2, 384, 2989, 3, 2, 2, 2, 386, 3005, 3,
	2, 2, 2, 388, 3010, 3, 2, 2, 2, 390, 3015, 3, 2, 2, 2, 392, 3021, 3, 2,
	2, 2, 394, 3026, 3, 2, 2, 2, 396, 3036, 3, 2, 2, 2, 398, 3043, 3, 2, 2,
	2, 400, 3048, 3, 2, 2, 2, 402, 3050, 3, 2, 2, 2, 404, 3056, 3, 2, 2, 2,
	406, 3067, 3, 2, 2, 2, 408, 3069, 3, 2, 2, 2, 410, 3078, 3, 2, 2, 2, 412,
	3094, 3, 2, 2, 2, 414, 3102, 3, 2, 2, 2, 416, 3119, 3, 2, 2, 2, 418, 3123,
	3, 2, 2, 2, 420, 3129, 3, 2, 2, 2, 422, 3135, 3, 2, 2, 2, 424, 3140, 3,
	2, 2, 2, 426, 3154, 3, 2, 2, 2, 428, 3157, 3, 2, 2, 2, 430, 3160, 3, 2,
	2, 2, 432, 3168, 3, 2, 2, 2, 434, 3170, 3, 2, 2, 2, 436, 3178, 3, 2, 2,
	2, 438, 3181, 3, 2, 2, 2, 440, 3186, 3, 2, 2, 2, 442, 3194, 3, 2, 2, 2,
	444, 3196, 3, 2, 2, 2, 446, 3247, 3, 2, 2, 2, 448, 3252, 3, 2, 2, 2, 450,
	3258, 3, 2, 2, 2, 452, 3264, 3, 2, 2, 2, 454, 3266, 3, 2, 2, 2, 456, 3272,
	3, 2, 2, 2, 458, 3275, 3, 2, 2, 2, 460, 3283, 3, 2, 2, 2, 462, 3287, 3,
	2, 2, 2, 464, 3289, 3, 2, 2, 2, 466, 3293, 3, 2, 2, 2, 468, 3328, 3, 2,
	2, 2, 470, 3331, 3, 2, 2, 2, 472, 3343, 3, 2, 2, 2, 474, 3357, 3, 2, 2,
	2, 476, 3378, 3, 2, 2, 2, 478, 3380, 3, 2, 2, 2, 480, 3382, 3, 2, 2, 2,
	482, 3387, 3, 2, 2, 2, 484, 3394, 3, 2, 2, 2, 486, 3397, 3, 2, 2, 2, 488,
	3400, 3, 2, 2, 2, 490, 3410, 3, 2, 2, 2, 492, 3419, 3, 2, 2, 2, 494, 3424,
	3, 2, 2, 2, 496, 3428, 3, 2, 2, 2, 498, 3435, 3, 2, 2, 2, 500, 3443, 3,
	2, 2, 2, 502, 3480, 3, 2, 2, 2, 504, 3497, 3, 2, 2, 2, 506, 3504, 3, 2,
	2, 2, 508, 3510, 3, 2, 2, 2, 510, 3512, 3, 2, 2, 2, 512, 3516, 3, 2, 2,
	2, 514, 3521, 3, 2, 2, 2, 516, 3535, 3, 2, 2, 2, 518, 3546, 3, 2, 2, 2,
	520, 3549, 3, 2, 2, 2, 522, 3560, 3, 2, 2, 2, 524, 3566, 3, 2, 2, 2, 526,
	3571, 3, 2, 2, 2, 528, 3578, 3, 2, 2, 2, 530, 3585, 3, 2, 2, 2, 532, 3594,
	3, 2, 2, 2, 534, 3608, 3, 2, 2, 2, 536, 3662, 3, 2, 2, 2, 538, 3664, 3,
	2, 2, 2, 540, 3672, 3, 2, 2, 2, 542, 3694, 3, 2, 2, 2, 544, 3697, 3, 2,
	2, 2, 546, 3702, 3, 2, 2, 2, 548, 3706, 3, 2, 2, 2, 550, 3722, 3, 2, 2,
	2, 552, 3733, 3, 2, 2, 2, 554, 3751, 3, 2, 2, 2, 556, 3758, 3, 2, 2, 2,
	558, 3760, 3, 2, 2, 2, 560, 3764, 3, 2, 2, 2, 562, 3768, 3, 2, 2, 2, 564,
	3774, 3, 2, 2, 2, 566, 3780, 3, 2, 2, 2, 568, 3788, 3, 2, 2, 2, 570, 3811,
	3, 2, 2, 2, 572, 3820, 3, 2, 2, 2, 574, 3826, 3, 2, 2, 2, 576, 3841, 3,
	2, 2, 2, 578, 3844, 3, 2, 2, 2, 580, 3854, 3, 2, 2, 2, 582, 3857, 3, 2,
	2, 2, 584, 3873, 3, 2, 2, 2, 586, 3875, 3, 2, 2, 2, 588, 3878, 3, 2, 2,
	2, 590, 3889, 3, 2, 2, 2, 592, 3891, 3, 2, 2, 2, 594, 3897, 3, 2, 2, 2,
	596, 3903, 3, 2, 2, 2, 598, 3921, 3, 2, 2, 2, 600, 3935, 3, 2, 2, 2, 602,
	3948, 3, 2, 2, 2, 604, 3950, 3, 2, 2, 2, 606, 3956, 3, 2, 2, 2, 608, 3961,
	3, 2, 2, 2, 610, 3969, 3, 2, 2, 2, 612, 3986, 3, 2, 2, 2, 614, 3990, 3,
	2, 2, 2, 616, 3992, 3, 2, 2, 2, 618, 4006, 3, 2, 2, 2, 620, 4025, 3, 2,
	2, 2, 622, 4042, 3, 2, 2, 2, 624, 4044, 3, 2, 2, 2, 626, 4049, 3, 2, 2,
	2, 628, 4055, 3, 2, 2, 2, 630, 4060, 3, 2, 2, 2, 632, 4082, 3, 2, 2, 2,
	634, 4090, 3, 2, 2, 2, 636, 4096, 3, 2, 2, 2, 638, 4104, 3, 2, 2, 2, 640,
	4110, 3, 2, 2, 2, 642, 4114, 3, 2, 2, 2, 644, 4117, 3, 2, 2, 2, 646, 4136,
	3, 2, 2, 2, 648, 4146, 3, 2, 2, 2, 650, 4169, 3, 2, 2, 2, 652, 4171, 3,
	2, 2, 2, 654, 4175, 3, 2, 2, 2, 656, 4185, 3, 2, 2, 2, 658, 4203, 3, 2,
	2, 2, 660, 4205, 3, 2, 2, 2, 662, 4208, 3, 2, 2, 2, 664, 4211, 3, 2, 2,
	2, 666, 4222, 3, 2, 2, 2, 668, 4225, 3, 2, 2, 2, 670, 4230, 3, 2, 2, 2,
	672, 4235, 3, 2, 2, 2, 674, 4239, 3, 2, 2, 2, 676, 4253, 3, 2, 2, 2, 678,
	4255, 3, 2, 2, 2, 680, 4259, 3, 2, 2, 2, 682, 4262, 3, 2, 2, 2, 684, 4264,
	3, 2, 2, 2, 686, 4272, 3, 2, 2, 2, 688, 4287, 3, 2, 2, 2, 690, 4289, 3,
	2, 2, 2, 692, 4299, 3, 2, 2, 2, 694, 4311, 3, 2, 2, 2, 696, 4322, 3, 2,
	2, 2, 698, 4331, 3, 2, 2, 2, 700, 4337, 3, 2, 2, 2, 702, 4346, 3, 2, 2,
	2, 704, 4352, 3, 2, 2, 2, 706, 4360, 3, 2, 2, 2, 708, 4366, 3, 2, 2, 2,
	710, 4373, 3, 2, 2, 2, 712, 4384, 3, 2, 2, 2, 714, 4396, 3, 2, 2, 2, 716,
	4404, 3, 2, 2, 2, 718, 4411, 3, 2, 2, 2, 720, 4419, 3, 2, 2, 2, 722, 4425,
	3, 2, 2, 2, 724, 4433, 3, 2, 2, 2, 726, 4443, 3, 2, 2, 2, 728, 4452, 3,
	2, 2, 2, 730, 4457, 3, 2, 2, 2, 732, 4462, 3, 2, 2, 2, 734, 4470, 3, 2,
	2, 2, 736, 4496, 3, 2, 2, 2, 738, 4508, 3, 2, 2, 2, 740, 4526, 3, 2, 2,
	2, 742, 4533, 3, 2, 2, 2, 744, 4541, 3, 2, 2, 2, 746, 4547, 3, 2, 2, 2,
	748, 4556, 3, 2, 2, 2, 750, 4559, 3, 2, 2, 2, 752, 4565, 3, 2, 2, 2, 754,
	4577, 3, 2, 2, 2, 756, 4582, 3, 2, 2, 2, 758, 4591, 3, 2, 2, 2, 760, 4593,
	3, 2, 2, 2, 762, 4601, 3, 2, 2, 2, 764, 4621, 3, 2, 2, 2, 766, 4625, 3,
	2, 2, 2, 768, 4629, 3, 2, 2, 2, 770, 4638, 3, 2, 2, 2, 772, 4640, 3, 2,
	2, 2, 774, 4644, 3, 2, 2, 2, 776, 4653, 3, 2, 2, 2, 778, 4659, 3, 2, 2,
	2, 780, 4668, 3, 2, 2, 2, 782, 4674, 3, 2, 2, 2, 784, 4682, 3, 2, 2, 2,
	786, 4688, 3, 2, 2, 2, 788, 4694, 3, 2, 2, 2, 790, 4700, 3, 2, 2, 2, 792,
	4709, 3, 2, 2, 2, 794, 4720, 3, 2, 2, 2, 796, 4724, 3, 2, 2, 2, 798, 4729,
	3, 2, 2, 2, 800, 4741, 3, 2, 2, 2, 802, 4743, 3, 2, 2, 2, 804, 4753, 3,
	2, 2, 2, 806, 4759, 3, 2, 2, 2, 808, 4762, 3, 2, 2, 2, 810, 4768, 3, 2,
	2, 2, 812, 4775, 3, 2, 2, 2, 814, 4780, 3, 2, 2, 2, 816, 4786, 3, 2, 2,
	2, 818, 4818, 3, 2, 2, 2, 820, 4822, 3, 2, 2, 2, 822, 4829, 3, 2, 2, 2,
	824, 4835, 3, 2, 2, 2, 826, 4849, 3, 2, 2, 2, 828, 4868, 3, 2, 2, 2, 830,
	4870, 3, 2, 2, 2, 832, 4882, 3, 2, 2, 2, 834, 4890, 3, 2, 2, 2, 836, 4898,
	3, 2, 2, 2, 838, 4907, 3, 2, 2, 2, 840, 4912, 3, 2, 2, 2, 842, 4918, 3,
	2, 2, 2, 844, 4926, 3, 2, 2, 2, 846, 4932, 3, 2, 2, 2, 848, 4938, 3, 2,
	2, 2, 850, 4953, 3, 2, 2, 2, 852, 4956, 3, 2, 2, 2, 854, 4970, 3, 2, 2,
	2, 856, 4973, 3, 2, 2, 2, 858, 4992, 3, 2, 2, 2, 860, 4995, 3, 2, 2, 2,
	862, 5007, 3, 2, 2, 2, 864, 5020, 3, 2, 2, 2, 866, 5034, 3, 2, 2, 2, 868,
	5038, 3, 2, 2, 2, 870, 5041, 3, 2, 2, 2, 872, 5048, 3, 2, 2, 2, 874, 5052,
	3, 2, 2, 2, 876, 5061, 3, 2, 2, 2, 878, 5065, 3, 2, 2, 2, 880, 5070, 3,
	2, 2, 2, 882, 5072, 3, 2, 2, 2, 884, 5082, 3, 2, 2, 2, 886, 5093, 3, 2,
	2, 2, 888, 5105, 3, 2, 2, 2, 890, 5111, 3, 2, 2, 2, 892, 5115, 3, 2, 2,
	2, 894, 5117, 3, 2, 2, 2, 896, 5149, 3, 2, 2, 2, 898, 5161, 3, 2, 2, 2,
	900, 5171, 3, 2, 2, 2, 902, 5189, 3, 2, 2, 2, 904, 5196, 3, 2, 2, 2, 906,
	5204, 3, 2, 2, 2, 908, 5213, 3, 2, 2, 2, 910, 5216, 3, 2, 2, 2, 912, 5222,
	3, 2, 2, 2, 914, 5231, 3, 2, 2, 2, 916, 5234, 3, 2, 2, 2, 918, 5240, 3,
	2, 2, 2, 920, 5252, 3, 2, 2, 2, 922, 5266, 3, 2, 2, 2, 924, 5301, 3, 2,
	2, 2, 926, 5306, 3, 2, 2, 2, 928, 5326, 3, 2, 2, 2, 930, 5336, 3, 2, 2,
	2, 932, 5338, 3, 2, 2, 2, 934, 5347, 3, 2, 2, 2, 936, 5352, 3, 2, 2, 2,
	938, 5356, 3, 2, 2, 2, 940, 5361, 3, 2, 2, 2, 942, 5377, 3, 2, 2, 2, 944,
	5388, 3, 2, 2, 2, 946, 5400, 3, 2, 2, 2, 948, 5407, 3, 2, 2, 2, 950, 5409,
	3, 2, 2, 2, 952, 5415, 3, 2, 2, 2, 954, 5417, 3, 2, 2, 2, 956, 5421, 3,
	2, 2, 2, 958, 5425, 3, 2, 2, 2, 960, 5428, 3, 2, 2, 2, 962, 5446, 3, 2,
	2, 2, 964, 5456, 3, 2, 2, 2, 966, 5467, 3, 2, 2, 2, 968, 5475, 3, 2, 2,
	2, 970, 5481, 3, 2, 2, 2, 972, 5488, 3, 2, 2, 2, 974, 5494, 3, 2, 2, 2,
	976, 5501, 3, 2, 2, 2, 978, 5506, 3, 2, 2, 2, 980, 5512, 3, 2, 2, 2, 982,
	5518, 3, 2, 2, 2, 984, 5540, 3, 2, 2, 2, 986, 5543, 3, 2, 2, 2, 988, 5566,
	3, 2, 2, 2, 990, 5568, 3, 2, 2, 2, 992, 5591, 3, 2, 2, 2, 994, 5596, 3,
	2, 2, 2, 996, 5605, 3, 2, 2, 2, 998, 5609, 3, 2, 2, 2, 1000, 5614, 3, 2,
	2, 2, 1002, 5617, 3, 2, 2, 2, 1004, 5626, 3, 2, 2, 2, 1006, 5638, 3, 2,
	2, 2, 1008, 5647, 3, 2, 2, 2, 1010, 5658, 3, 2, 2, 2, 1012, 5668, 3, 2,
	2, 2, 1014, 5680, 3, 2, 2, 2, 1016, 5689, 3, 2, 2, 2, 1018, 5701, 3, 2,
	2, 2, 1020, 5711, 3, 2, 2, 2, 1022, 5724, 3, 2, 2, 2, 1024, 5733, 3, 2,
	2, 2, 1026, 5744, 3, 2, 2, 2, 1028, 5751, 3, 2, 2, 2, 1030, 5754, 3, 2,
	2, 2, 1032, 5761, 3, 2, 2, 2, 1034, 5765, 3, 2, 2, 2, 1036, 5774, 3, 2,
	2, 2, 1038, 5783, 3, 2, 2, 2, 1040, 5785, 3, 2, 2, 2, 1042, 5792, 3, 2,
	2, 2, 1044, 5802, 3, 2, 2, 2, 1046, 5813, 3, 2, 2, 2, 1048, 5815, 3, 2,
	2, 2, 1050, 5831, 3, 2, 2, 2, 1052, 5855, 3, 2, 2, 2, 1054, 5866, 3, 2,
	2, 2, 1056, 5868, 3, 2, 2, 2, 1058, 5877, 3, 2, 2, 2, 1060, 5881, 3, 2,
	2, 2, 1062, 5887, 3, 2, 2, 2, 1064, 5895, 3, 2, 2, 2, 1066, 5940, 3, 2,
	2, 2, 1068, 5957, 3, 2, 2, 2, 1070, 5959, 3, 2, 2, 2, 1072, 5981, 3, 2,
	2, 2, 1074, 6004, 3, 2, 2, 2, 1076, 6012, 3, 2, 2, 2, 1078, 6014, 3, 2,
	2, 2, 1080, 6027, 3, 2, 2, 2, 1082, 6040, 3, 2, 2, 2, 1084, 6046, 3, 2,
	2, 2, 1086, 6050, 3, 2, 2, 2, 1088, 6063, 3, 2, 2, 2, 1090, 6066, 3, 2,
	2, 2, 1092, 6069, 3, 2, 2, 2, 1094, 6074, 3, 2, 2, 2, 1096, 6076, 3, 2,
	2, 2, 1098, 6079, 3, 2, 2, 2, 1100, 6082, 3, 2, 2, 2, 1102, 6085, 3, 2,
	2, 2, 1104, 6088, 3, 2, 2, 2, 1106, 6091, 3, 2, 2, 2, 1108, 6094, 3, 2,
	2, 2, 1110, 6096, 3, 2, 2, 2, 1112, 6098, 3, 2, 2, 2, 1114, 6100, 3, 2,
	2, 2, 1116, 6102, 3, 2, 2, 2, 1118, 6104, 3, 2, 2, 2, 1120, 6106, 3, 2,
	2, 2, 1122, 6108, 3, 2, 2, 2, 1124, 6113, 3, 2, 2, 2, 1126, 6115, 3, 2,
	2, 2, 1128, 6117, 3, 2, 2, 2, 1130, 6125, 3, 2, 2, 2, 1132, 6127, 3, 2,
	2, 2, 1134, 6129, 3, 2, 2, 2, 1136, 6131, 3, 2, 2, 2, 1138, 6133, 3, 2,
	2, 2, 1140, 6135, 3, 2, 2, 2, 1142, 6139, 3, 2, 2, 2, 1144, 6146, 3, 2,
	2, 2, 1146, 6150, 3, 2, 2, 2, 1148, 6152, 3, 2, 2, 2, 1150, 6154, 3, 2,
	2, 2, 1152, 6156, 3, 2, 2, 2, 1154, 6158, 3, 2, 2, 2, 1156, 6162, 3, 2,
	2, 2, 1158, 6164, 3, 2, 2, 2, 1160, 6166, 3, 2, 2, 2, 1162, 6168, 3, 2,
	2, 2, 1164, 6170, 3, 2, 2, 2, 1166, 6178, 3, 2, 2, 2, 1168, 6180, 3, 2,
	2, 2, 1170, 6185, 3, 2, 2, 2, 1172, 6187, 3, 2, 2, 2, 1174, 6189, 3, 2,
	2, 2, 1176, 6197, 3, 2, 2, 2, 1178, 6220, 3, 2, 2, 2, 1180, 6253, 3, 2,
	2, 2, 1182, 6256, 3, 2, 2, 2, 1184, 1185, 5, 4, 3, 2, 1185, 1186, 7, 2,
	2, 3, 1186, 3, 3, 2, 2, 2, 1187, 1189, 5, 6, 4, 2, 1188, 1187, 3, 2, 2,
	2, 1189, 1190, 3, 2, 2, 2, 1190, 1188, 3, 2, 2, 2, 1190, 1191, 3, 2, 2,
	2, 1191, 5, 3, 2, 2, 2, 1192, 1194, 5, 10, 6, 2, 1193, 1192, 3, 2, 2, 2,
	1193, 1194, 3, 2, 2, 2, 1194, 1195, 3, 2, 2, 2, 1195, 1197, 5, 16, 9, 2,
	1196, 1198, 5, 34, 18, 2, 1197, 1196, 3, 2, 2, 2, 1197, 1198, 3, 2, 2,
	2, 1198, 1200, 3, 2, 2, 2, 1199, 1201, 5, 162, 82, 2, 1200, 1199, 3, 2,
	2, 2, 1200, 1201, 3, 2, 2, 2, 1201, 1203, 3, 2, 2, 2, 1202, 1204, 5, 514,
	258, 2, 1203, 1202, 3, 2, 2, 2, 1203, 1204, 3, 2, 2, 2, 1204, 1208, 3,
	2, 2, 2, 1205, 1207, 5, 6, 4, 2, 1206, 1205, 3, 2, 2, 2, 1207, 1210, 3,
	2, 2, 2, 1208, 1206, 3, 2, 2, 2, 1208, 1209, 3, 2, 2, 2, 1209, 1212, 3,
	2, 2, 2, 1210, 1208, 3, 2, 2, 2, 1211, 1213, 5, 8, 5, 2, 1212, 1211, 3,
	2, 2, 2, 1212, 1213, 3, 2, 2, 2, 1213, 7, 3, 2, 2, 2, 1214, 1215, 7, 164,
	2, 2, 1215, 1216, 7, 368, 2, 2, 1216, 1217, 5, 1146, 574, 2, 1217, 1218,
	7, 541, 2, 2, 1218, 9, 3, 2, 2, 2, 1219, 1221, 7, 367, 2, 2, 1220, 1222,
	5, 12, 7, 2, 1221, 1220, 3, 2, 2, 2, 1222, 1223, 3, 2, 2, 2, 1223, 1221,
	3, 2, 2, 2, 1223, 1224, 3, 2, 2, 2, 1224, 1226, 3, 2, 2, 2, 1225, 1219,
	3, 2, 2, 2, 1226, 1227, 3, 2, 2, 2, 1227, 1225, 3, 2, 2, 2, 1227, 1228,
	3, 2, 2, 2, 1228, 11, 3, 2, 2, 2, 1229, 1257, 7, 23, 2, 2, 1230, 1231,
	7, 27, 2, 2, 1231, 1232, 7, 549, 2, 2, 1232, 1233, 7, 206, 2, 2, 1233,
	1257, 7, 555, 2, 2, 1234, 1235, 7, 75, 2, 2, 1235, 1236, 7, 549, 2, 2,
	1236, 1237, 5, 1166, 584, 2, 1237, 1238, 7, 555, 2, 2, 1238, 1257, 3, 2,
	2, 2, 1239, 1257, 7, 121, 2, 2, 1240, 1257, 7, 276, 2, 2, 1241, 1257, 7,
	316, 2, 2, 1242, 1257, 7, 317, 2, 2, 1243, 1244, 7, 334, 2, 2, 1244, 1245,
	7, 549, 2, 2, 1245, 1246, 7, 221, 2, 2, 1246, 1257, 7, 555, 2, 2, 1247,
	1248, 7, 524, 2, 2, 1248, 1250, 7, 549, 2, 2, 1249, 1251, 5, 14, 8, 2,
	1250, 1249, 3, 2, 2, 2, 1251, 1252, 3, 2, 2, 2, 1252, 1250, 3, 2, 2, 2,
	1252, 1253, 3, 2, 2, 2, 1253, 1254, 3, 2, 2, 2, 1254, 1255, 7, 555, 2,
	2, 1255, 1257, 3, 2, 2, 2, 1256, 1229, 3, 2, 2, 2, 1256, 1230, 3, 2, 2,
	2, 1256, 1234, 3, 2, 2, 2, 1256, 1239, 3, 2, 2, 2, 1256, 1240, 3, 2, 2,
	2, 1256, 1241, 3, 2, 2, 2, 1256, 1242, 3, 2, 2, 2, 1256, 1243, 3, 2, 2,
	2, 1256, 1247, 3, 2, 2, 2, 1257, 13, 3, 2, 2, 2, 1258, 1259, 9, 2, 2, 2,
	1259, 15, 3, 2, 2, 2, 1260, 1261, 9, 3, 2, 2, 1261, 1262, 7, 150, 2, 2,
	1262, 1263, 7, 541, 2, 2, 1263, 1267, 5, 20, 11, 2, 1264, 1266, 5, 18,
	10, 2, 1265, 1264, 3, 2, 2, 2, 1266, 1269, 3, 2, 2, 2, 1267, 1265, 3, 2,
	2, 2, 1267, 1268, 3, 2, 2, 2, 1268, 17, 3, 2, 2, 2, 1269, 1267, 3, 2, 2,
	2, 1270, 1277, 5, 22, 12, 2, 1271, 1277, 5, 24, 13, 2, 1272, 1277, 5, 26,
	14, 2, 1273, 1277, 5, 28, 15, 2, 1274, 1277, 5, 30, 16, 2, 1275, 1277,
	5, 32, 17, 2, 1276, 1270, 3, 2, 2, 2, 1276, 1271, 3, 2, 2, 2, 1276, 1272,
	3, 2, 2, 2, 1276, 1273, 3, 2, 2, 2, 1276, 1274, 3, 2, 2, 2, 1276, 1275,
	3, 2, 2, 2, 1277, 19, 3, 2, 2, 2, 1278, 1279, 7, 369, 2, 2, 1279, 1280,
	7, 541, 2, 2, 1280, 1288, 5, 1146, 574, 2, 1281, 1283, 7, 259, 2, 2, 1282,
	1281, 3, 2, 2, 2, 1282, 1283, 3, 2, 2, 2, 1283, 1284, 3, 2, 2, 2, 1284,
	1286, 9, 4, 2, 2, 1285, 1287, 7, 368, 2, 2, 1286, 1285, 3, 2, 2, 2, 1286,
	1287, 3, 2, 2, 2, 1287, 1289, 3, 2, 2, 2, 1288, 1282, 3, 2, 2, 2, 1288,
	1289, 3, 2, 2, 2, 1289, 1290, 3, 2, 2, 2, 1290, 1291, 7, 541, 2, 2, 1291,
	21, 3, 2, 2, 2, 1292, 1293, 7, 36, 2, 2, 1293, 1295, 7, 541, 2, 2, 1294,
	1296, 5, 1182, 592, 2, 1295, 1294, 3, 2, 2, 2, 1295, 1296, 3, 2, 2, 2,
	1296, 23, 3, 2, 2, 2, 1297, 1298, 7, 254, 2, 2, 1298, 1300, 7, 541, 2,
	2, 1299, 1301, 5, 1182, 592, 2, 1300, 1299, 3, 2, 2, 2, 1300, 1301, 3,
	2, 2, 2, 1301, 25, 3, 2, 2, 2, 1302, 1303, 7, 118, 2, 2, 1303, 1305, 7,
	541, 2, 2, 1304, 1306, 5, 1182, 592, 2, 1305, 1304, 3, 2, 2, 2, 1305, 1306,
	3, 2, 2, 2, 1306, 27, 3, 2, 2, 2, 1307, 1308, 7, 117, 2, 2, 1308, 1310,
	7, 541, 2, 2, 1309, 1311, 5, 1182, 592, 2, 1310, 1309, 3, 2, 2, 2, 1310,
	1311, 3, 2, 2, 2, 1311, 29, 3, 2, 2, 2, 1312, 1313, 7, 426, 2, 2, 1313,
	1315, 7, 541, 2, 2, 1314, 1316, 5, 1182, 592, 2, 1315, 1314, 3, 2, 2, 2,
	1315, 1316, 3, 2, 2, 2, 1316, 31, 3, 2, 2, 2, 1317, 1318, 7, 395, 2, 2,
	1318, 1320, 7, 541, 2, 2, 1319, 1321, 5, 1182, 592, 2, 1320, 1319, 3, 2,
	2, 2, 1320, 1321, 3, 2, 2, 2, 1321, 33, 3, 2, 2, 2, 1322, 1323, 7, 189,
	2, 2, 1323, 1324, 7, 150, 2, 2, 1324, 1328, 7, 541, 2, 2, 1325, 1327, 5,
	36, 19, 2, 1326, 1325, 3, 2, 2, 2, 1327, 1330, 3, 2, 2, 2, 1328, 1326,
	3, 2, 2, 2, 1328, 1329, 3, 2, 2, 2, 1329, 35, 3, 2, 2, 2, 1330, 1328, 3,
	2, 2, 2, 1331, 1335, 5, 38, 20, 2, 1332, 1335, 5, 62, 32, 2, 1333, 1335,
	5, 108, 55, 2, 1334, 1331, 3, 2, 2, 2, 1334, 1332, 3, 2, 2, 2, 1334, 1333,
	3, 2, 2, 2, 1335, 37, 3, 2, 2, 2, 1336, 1337, 7, 98, 2, 2, 1337, 1338,
	7, 424, 2, 2, 1338, 1342, 7, 541, 2, 2, 1339, 1341, 5, 40, 21, 2, 1340,
	1339, 3, 2, 2, 2, 1341, 1344, 3, 2, 2, 2, 1342, 1340, 3, 2, 2, 2, 1342,
	1343, 3, 2, 2, 2, 1343, 39, 3, 2, 2, 2, 1344, 1342, 3, 2, 2, 2, 1345, 1348,
	5, 42, 22, 2, 1346, 1348, 5, 44, 23, 2, 1347, 1345, 3, 2, 2, 2, 1347, 1346,
	3, 2, 2, 2, 1348, 41, 3, 2, 2, 2, 1349, 1350, 7, 454, 2, 2, 1350, 1351,
	7, 541, 2, 2, 1351, 1357, 5, 1118, 560, 2, 1352, 1354, 7, 520, 2, 2, 1353,
	1352, 3, 2, 2, 2, 1353, 1354, 3, 2, 2, 2, 1354, 1355, 3, 2, 2, 2, 1355,
	1356, 7, 130, 2, 2, 1356, 1358, 7, 302, 2, 2, 1357, 1353, 3, 2, 2, 2, 1357,
	1358, 3, 2, 2, 2, 1358, 1359, 3, 2, 2, 2, 1359, 1360, 7, 541, 2, 2, 1360,
	43, 3, 2, 2, 2, 1361, 1362, 7, 326, 2, 2, 1362, 1363, 7, 541, 2, 2, 1363,
	1367, 5, 1118, 560, 2, 1364, 1366, 5, 46, 24, 2, 1365, 1364, 3, 2, 2, 2,
	1366, 1369, 3, 2, 2, 2, 1367, 1365, 3, 2, 2, 2, 1367, 1368, 3, 2, 2, 2,
	1368, 1370, 3, 2, 2, 2, 1369, 1367, 3, 2, 2, 2, 1370, 1371, 7, 541, 2,
	2, 1371, 45, 3, 2, 2, 2, 1372, 1378, 5, 48, 25, 2, 1373, 1378, 5, 50, 26,
	2, 1374, 1378, 5, 52, 27, 2, 1375, 1378, 5, 58, 30, 2, 1376, 1378, 5, 60,
	31, 2, 1377, 1372, 3, 2, 2, 2, 1377, 1373, 3, 2, 2, 2, 1377, 1374, 3, 2,
	2, 2, 1377, 1375, 3, 2, 2, 2, 1377, 1376, 3, 2, 2, 2, 1378, 47, 3, 2, 2,
	2, 1379, 1381, 7, 298, 2, 2, 1380, 1382, 7, 444, 2, 2, 1381, 1380, 3, 2,
	2, 2, 1381, 1382, 3, 2, 2, 2, 1382, 1385, 3, 2, 2, 2, 1383, 1386, 5, 1172,
	587, 2, 1384, 1386, 5, 1164, 583, 2, 1385, 1383, 3, 2, 2, 2, 1385, 1384,
	3, 2, 2, 2, 1386, 1388, 3, 2, 2, 2, 1387, 1389, 9, 5, 2, 2, 1388, 1387,
	3, 2, 2, 2, 1388, 1389, 3, 2, 2, 2, 1389, 49, 3, 2, 2, 2, 1390, 1392, 7,
	146, 2, 2, 1391, 1393, 7, 444, 2, 2, 1392, 1391, 3, 2, 2, 2, 1392, 1393,
	3, 2, 2, 2, 1393, 1395, 3, 2, 2, 2, 1394, 1396, 7, 259, 2, 2, 1395, 1394,
	3, 2, 2, 2, 1395, 1396, 3, 2, 2, 2, 1396, 1399, 3, 2, 2, 2, 1397, 1400,
	5, 1172, 587, 2, 1398, 1400, 5, 1164, 583, 2, 1399, 1397, 3, 2, 2, 2, 1399,
	1398, 3, 2, 2, 2, 1400, 1402, 3, 2, 2, 2, 1401, 1403, 9, 6, 2, 2, 1402,
	1401, 3, 2, 2, 2, 1402, 1403, 3, 2, 2, 2, 1403, 51, 3, 2, 2, 2, 1404, 1406,
	7, 368, 2, 2, 1405, 1404, 3, 2, 2, 2, 1405, 1406, 3, 2, 2, 2, 1406, 1408,
	3, 2, 2, 2, 1407, 1409, 7, 77, 2, 2, 1408, 1407, 3, 2, 2, 2, 1408, 1409,
	3, 2, 2, 2, 1409, 1410, 3, 2, 2, 2, 1410, 1412, 7, 433, 2, 2, 1411, 1413,
	7, 259, 2, 2, 1412, 1411, 3, 2, 2, 2, 1412, 1413, 3, 2, 2, 2, 1413, 1415,
	3, 2, 2, 2, 1414, 1416, 5, 1108, 555, 2, 1415, 1414, 3, 2, 2, 2, 1416,
	1417, 3, 2, 2, 2, 1417, 1415, 3, 2, 2, 2, 1417, 1418, 3, 2, 2, 2, 1418,
	1420, 3, 2, 2, 2, 1419, 1421, 5, 54, 28, 2, 1420, 1419, 3, 2, 2, 2, 1420,
	1421, 3, 2, 2, 2, 1421, 1423, 3, 2, 2, 2, 1422, 1424, 5, 56, 29, 2, 1423,
	1422, 3, 2, 2, 2, 1423, 1424, 3, 2, 2, 2, 1424, 53, 3, 2, 2, 2, 1425, 1427,
	7, 217, 2, 2, 1426, 1425, 3, 2, 2, 2, 1426, 1427, 3, 2, 2, 2, 1427, 1428,
	3, 2, 2, 2, 1428, 1430, 7, 16, 2, 2, 1429, 1431, 7, 259, 2, 2, 1430, 1429,
	3, 2, 2, 2, 1430, 1431, 3, 2, 2, 2, 1431, 1432, 3, 2, 2, 2, 1432, 1433,
	5, 1108, 555, 2, 1433, 55, 3, 2, 2, 2, 1434, 1436, 7, 217, 2, 2, 1435,
	1434, 3, 2, 2, 2, 1435, 1436, 3, 2, 2, 2, 1436, 1437, 3, 2, 2, 2, 1437,
	1439, 7, 309, 2, 2, 1438, 1440, 7, 259, 2, 2, 1439, 1438, 3, 2, 2, 2, 1439,
	1440, 3, 2, 2, 2, 1440, 1441, 3, 2, 2, 2, 1441, 1442, 5, 1108, 555, 2,
	1442, 57, 3, 2, 2, 2, 1443, 1445, 7, 428, 2, 2, 1444, 1446, 7, 259, 2,
	2, 1445, 1444, 3, 2, 2, 2, 1445, 1446, 3, 2, 2, 2, 1446, 1447, 3, 2, 2,
	2, 1447, 1448, 5, 1172, 587, 2, 1448, 59, 3, 2, 2, 2, 1449, 1450, 7, 66,
	2, 2, 1450, 1451, 7, 435, 2, 2, 1451, 1452, 7, 541, 2, 2, 1452, 61, 3,
	2, 2, 2, 1453, 1454, 7, 458, 2, 2, 1454, 1462, 7, 541, 2, 2, 1455, 1457,
	5, 64, 33, 2, 1456, 1455, 3, 2, 2, 2, 1457, 1458, 3, 2, 2, 2, 1458, 1456,
	3, 2, 2, 2, 1458, 1459, 3, 2, 2, 2, 1459, 1460, 3, 2, 2, 2, 1460, 1461,
	7, 541, 2, 2, 1461, 1463, 3, 2, 2, 2, 1462, 1456, 3, 2, 2, 2, 1462, 1463,
	3, 2, 2, 2, 1463, 63, 3, 2, 2, 2, 1464, 1476, 5, 78, 40, 2, 1465, 1476,
	5, 100, 51, 2, 1466, 1476, 5, 66, 34, 2, 1467, 1476, 5, 80, 41, 2, 1468,
	1476, 5, 88, 45, 2, 1469, 1476, 5, 90, 46, 2, 1470, 1476, 5, 104, 53, 2,
	1471, 1476, 5, 96, 49, 2, 1472, 1476, 5, 94, 48, 2, 1473, 1476, 5, 92,
	47, 2, 1474, 1476, 5, 102, 52, 2, 1475, 1464, 3, 2, 2, 2, 1475, 1465, 3,
	2, 2, 2, 1475, 1466, 3, 2, 2, 2, 1475, 1467, 3, 2, 2, 2, 1475, 1468, 3,
	2, 2, 2, 1475, 1469, 3, 2, 2, 2, 1475, 1470, 3, 2, 2, 2, 1475, 1471, 3,
	2, 2, 2, 1475, 1472, 3, 2, 2, 2, 1475, 1473, 3, 2, 2, 2, 1475, 1474, 3,
	2, 2, 2, 1476, 65, 3, 2, 2, 2, 1477, 1480, 5, 68, 35, 2, 1478, 1480, 5,
	76, 39, 2, 1479, 1477, 3, 2, 2, 2, 1479, 1478, 3, 2, 2, 2, 1480, 67, 3,
	2, 2, 2, 1481, 1482, 7, 12, 2, 2, 1482, 1485, 5, 1108, 555, 2, 1483, 1484,
	7, 217, 2, 2, 1484, 1486, 7, 16, 2, 2, 1485, 1483, 3, 2, 2, 2, 1485, 1486,
	3, 2, 2, 2, 1486, 1488, 3, 2, 2, 2, 1487, 1489, 7, 259, 2, 2, 1488, 1487,
	3, 2, 2, 2, 1488, 1489, 3, 2, 2, 2, 1489, 1501, 3, 2, 2, 2, 1490, 1502,
	7, 156, 2, 2, 1491, 1502, 7, 30, 2, 2, 1492, 1502, 7, 460, 2, 2, 1493,
	1502, 7, 461, 2, 2, 1494, 1502, 7, 310, 2, 2, 1495, 1502, 5, 1164, 583,
	2, 1496, 1498, 5, 70, 36, 2, 1497, 1496, 3, 2, 2, 2, 1498, 1499, 3, 2,
	2, 2, 1499, 1497, 3, 2, 2, 2, 1499, 1500, 3, 2, 2, 2, 1500, 1502, 3, 2,
	2, 2, 1501, 1490, 3, 2, 2, 2, 1501, 1491, 3, 2, 2, 2, 1501, 1492, 3, 2,
	2, 2, 1501, 1493, 3, 2, 2, 2, 1501, 1494, 3, 2, 2, 2, 1501, 1495, 3, 2,
	2, 2, 1501, 1497, 3, 2, 2, 2, 1502, 69, 3, 2, 2, 2, 1503, 1510, 5, 1166,
	584, 2, 1504, 1511, 5, 72, 37, 2, 1505, 1507, 5, 74, 38, 2, 1506, 1505,
	3, 2, 2, 2, 1507, 1508, 3, 2, 2, 2, 1508, 1506, 3, 2, 2, 2, 1508, 1509,
	3, 2, 2, 2, 1509, 1511, 3, 2, 2, 2, 1510, 1504, 3, 2, 2, 2, 1510, 1506,
	3, 2, 2, 2, 1510, 1511, 3, 2, 2, 2, 1511, 71, 3, 2, 2, 2, 1512, 1513, 9,
	7, 2, 2, 1513, 1514, 5, 1166, 584, 2, 1514, 73, 3, 2, 2, 2, 1515, 1517,
	7, 18, 2, 2, 1516, 1518, 5, 1166, 584, 2, 1517, 1516, 3, 2, 2, 2, 1518,
	1519, 3, 2, 2, 2, 1519, 1517, 3, 2, 2, 2, 1519, 1520, 3, 2, 2, 2, 1520,
	75, 3, 2, 2, 2, 1521, 1522, 7, 12, 2, 2, 1522, 1524, 5, 1108, 555, 2, 1523,
	1525, 7, 217, 2, 2, 1524, 1523, 3, 2, 2, 2, 1524, 1525, 3, 2, 2, 2, 1525,
	1526, 3, 2, 2, 2, 1526, 1528, 7, 309, 2, 2, 1527, 1529, 7, 259, 2, 2, 1528,
	1527, 3, 2, 2, 2, 1528, 1529, 3, 2, 2, 2, 1529, 1533, 3, 2, 2, 2, 1530,
	1534, 7, 310, 2, 2, 1531, 1532, 7, 60, 2, 2, 1532, 1534, 5, 1166, 584,
	2, 1533, 1530, 3, 2, 2, 2, 1533, 1531, 3, 2, 2, 2, 1534, 77, 3, 2, 2, 2,
	1535, 1536, 7, 65, 2, 2, 1536, 1538, 5, 1172, 587, 2, 1537, 1539, 7, 259,
	2, 2, 1538, 1537, 3, 2, 2, 2, 1538, 1539, 3, 2, 2, 2, 1539, 1540, 3, 2,
	2, 2, 1540, 1541, 5, 1140, 571, 2, 1541, 79, 3, 2, 2, 2, 1542, 1543, 7,
	68, 2, 2, 1543, 1548, 5, 1116, 559, 2, 1544, 1546, 7, 217, 2, 2, 1545,
	1544, 3, 2, 2, 2, 1545, 1546, 3, 2, 2, 2, 1546, 1547, 3, 2, 2, 2, 1547,
	1549, 9, 8, 2, 2, 1548, 1545, 3, 2, 2, 2, 1548, 1549, 3, 2, 2, 2, 1549,
	1551, 3, 2, 2, 2, 1550, 1552, 7, 259, 2, 2, 1551, 1550, 3, 2, 2, 2, 1551,
	1552, 3, 2, 2, 2, 1552, 1554, 3, 2, 2, 2, 1553, 1555, 5, 82, 42, 2, 1554,
	1553, 3, 2, 2, 2, 1555, 1556, 3, 2, 2, 2, 1556, 1554, 3, 2, 2, 2, 1556,
	1557, 3, 2, 2, 2, 1557, 81, 3, 2, 2, 2, 1558, 1561, 5, 84, 43, 2, 1559,
	1560, 9, 7, 2, 2, 1560, 1562, 5, 86, 44, 2, 1561, 1559, 3, 2, 2, 2, 1561,
	1562, 3, 2, 2, 2, 1562, 83, 3, 2, 2, 2, 1563, 1566, 5, 1068, 535, 2, 1564,
	1566, 5, 1166, 584, 2, 1565, 1563, 3, 2, 2, 2, 1565, 1564, 3, 2, 2, 2,
	1566, 85, 3, 2, 2, 2, 1567, 1570, 5, 1068, 535, 2, 1568, 1570, 5, 1166,
	584, 2, 1569, 1567, 3, 2, 2, 2, 1569, 1568, 3, 2, 2, 2, 1570, 87, 3, 2,
	2, 2, 1571, 1573, 7, 112, 2, 2, 1572, 1574, 7, 443, 2, 2, 1573, 1572, 3,
	2, 2, 2, 1573, 1574, 3, 2, 2, 2, 1574, 1576, 3, 2, 2, 2, 1575, 1577, 7,
	259, 2, 2, 1576, 1575, 3, 2, 2, 2, 1576, 1577, 3, 2, 2, 2, 1577, 1578,
	3, 2, 2, 2, 1578, 1585, 5, 1166, 584, 2, 1579, 1581, 7, 520, 2, 2, 1580,
	1579, 3, 2, 2, 2, 1580, 1581, 3, 2, 2, 2, 1581, 1582, 3, 2, 2, 2, 1582,
	1583, 7, 354, 2, 2, 1583, 1584, 7, 472, 2, 2, 1584, 1586, 5, 1166, 584,
	2, 1585, 1580, 3, 2, 2, 2, 1585, 1586, 3, 2, 2, 2, 1586, 89, 3, 2, 2, 2,
	1587, 1589, 7, 131, 2, 2, 1588, 1590, 7, 259, 2, 2, 1589, 1588, 3, 2, 2,
	2, 1589, 1590, 3, 2, 2, 2, 1590, 1591, 3, 2, 2, 2, 1591, 1592, 7, 81, 2,
	2, 1592, 91, 3, 2, 2, 2, 1593, 1595, 7, 133, 2, 2, 1594, 1596, 9, 9, 2,
	2, 1595, 1594, 3, 2, 2, 2, 1595, 1596, 3, 2, 2, 2, 1596, 1601, 3, 2, 2,
	2, 1597, 1599, 7, 443, 2, 2, 1598, 1600, 7, 259, 2, 2, 1599, 1598, 3, 2,
	2, 2, 1599, 1600, 3, 2, 2, 2, 1600, 1602, 3, 2, 2, 2, 1601, 1597, 3, 2,
	2, 2, 1601, 1602, 3, 2, 2, 2, 1602, 1604, 3, 2, 2, 2, 1603, 1605, 9, 10,
	2, 2, 1604, 1603, 3, 2, 2, 2, 1604, 1605, 3, 2, 2, 2, 1605, 1606, 3, 2,
	2, 2, 1606, 1608, 7, 432, 2, 2, 1607, 1609, 7, 66, 2, 2, 1608, 1607, 3,
	2, 2, 2, 1608, 1609, 3, 2, 2, 2, 1609, 93, 3, 2, 2, 2, 1610, 1615, 7, 134,
	2, 2, 1611, 1613, 7, 443, 2, 2, 1612, 1614, 7, 259, 2, 2, 1613, 1612, 3,
	2, 2, 2, 1613, 1614, 3, 2, 2, 2, 1614, 1616, 3, 2, 2, 2, 1615, 1611, 3,
	2, 2, 2, 1615, 1616, 3, 2, 2, 2, 1616, 1617, 3, 2, 2, 2, 1617, 1622, 9,
	10, 2, 2, 1618, 1620, 7, 432, 2, 2, 1619, 1621, 7, 66, 2, 2, 1620, 1619,
	3, 2, 2, 2, 1620, 1621, 3, 2, 2, 2, 1621, 1623, 3, 2, 2, 2, 1622, 1618,
	3, 2, 2, 2, 1622, 1623, 3, 2, 2, 2, 1623, 95, 3, 2, 2, 2, 1624, 1626, 5,
	1126, 564, 2, 1625, 1627, 7, 259, 2, 2, 1626, 1625, 3, 2, 2, 2, 1626, 1627,
	3, 2, 2, 2, 1627, 1628, 3, 2, 2, 2, 1628, 1630, 5, 1140, 571, 2, 1629,
	1631, 5, 98, 50, 2, 1630, 1629, 3, 2, 2, 2, 1630, 1631, 3, 2, 2, 2, 1631,
	1634, 3, 2, 2, 2, 1632, 1634, 5, 98, 50, 2, 1633, 1624, 3, 2, 2, 2, 1633,
	1632, 3, 2, 2, 2, 1634, 97, 3, 2, 2, 2, 1635, 1637, 7, 332, 2, 2, 1636,
	1638, 7, 463, 2, 2, 1637, 1636, 3, 2, 2, 2, 1637, 1638, 3, 2, 2, 2, 1638,
	1640, 3, 2, 2, 2, 1639, 1641, 7, 259, 2, 2, 1640, 1639, 3, 2, 2, 2, 1640,
	1641, 3, 2, 2, 2, 1641, 1642, 3, 2, 2, 2, 1642, 1651, 5, 1040, 521, 2,
	1643, 1645, 7, 330, 2, 2, 1644, 1646, 7, 463, 2, 2, 1645, 1644, 3, 2, 2,
	2, 1645, 1646, 3, 2, 2, 2, 1646, 1648, 3, 2, 2, 2, 1647, 1649, 7, 259,
	2, 2, 1648, 1647, 3, 2, 2, 2, 1648, 1649, 3, 2, 2, 2, 1649, 1650, 3, 2,
	2, 2, 1650, 1652, 5, 1040, 521, 2, 1651, 1643, 3, 2, 2, 2, 1651, 1652,
	3, 2, 2, 2, 1652, 1672, 3, 2, 2, 2, 1653, 1655, 7, 330, 2, 2, 1654, 1656,
	7, 463, 2, 2, 1655, 1654, 3, 2, 2, 2, 1655, 1656, 3, 2, 2, 2, 1656, 1658,
	3, 2, 2, 2, 1657, 1659, 7, 259, 2, 2, 1658, 1657, 3, 2, 2, 2, 1658, 1659,
	3, 2, 2, 2, 1659, 1660, 3, 2, 2, 2, 1660, 1669, 5, 1040, 521, 2, 1661,
	1663, 7, 332, 2, 2, 1662, 1664, 7, 463, 2, 2, 1663, 1662, 3, 2, 2, 2, 1663,
	1664, 3, 2, 2, 2, 1664, 1666, 3, 2, 2, 2, 1665, 1667, 7, 259, 2, 2, 1666,
	1665, 3, 2, 2, 2, 1666, 1667, 3, 2, 2, 2, 1667, 1668, 3, 2, 2, 2, 1668,
	1670, 5, 1040, 521, 2, 1669, 1661, 3, 2, 2, 2, 1669, 1670, 3, 2, 2, 2,
	1670, 1672, 3, 2, 2, 2, 1671, 1635, 3, 2, 2, 2, 1671, 1653, 3, 2, 2, 2,
	1672, 99, 3, 2, 2, 2, 1673, 1675, 7, 328, 2, 2, 1674, 1676, 7, 259, 2,
	2, 1675, 1674, 3, 2, 2, 2, 1675, 1676, 3, 2, 2, 2, 1676, 1677, 3, 2, 2,
	2, 1677, 1678, 5, 1140, 571, 2, 1678, 101, 3, 2, 2, 2, 1679, 1681, 7, 406,
	2, 2, 1680, 1682, 7, 521, 2, 2, 1681, 1680, 3, 2, 2, 2, 1681, 1682, 3,
	2, 2, 2, 1682, 1684, 3, 2, 2, 2, 1683, 1685, 7, 288, 2, 2, 1684, 1683,
	3, 2, 2, 2, 1684, 1685, 3, 2, 2, 2, 1685, 1687, 3, 2, 2, 2, 1686, 1688,
	7, 259, 2, 2, 1687, 1686, 3, 2, 2, 2, 1687, 1688, 3, 2, 2, 2, 1688, 1689,
	3, 2, 2, 2, 1689, 1691, 7, 312, 2, 2, 1690, 1692, 7, 58, 2, 2, 1691, 1690,
	3, 2, 2, 2, 1691, 1692, 3, 2, 2, 2, 1692, 103, 3, 2, 2, 2, 1693, 1695,
	7, 473, 2, 2, 1694, 1696, 7, 67, 2, 2, 1695, 1694, 3, 2, 2, 2, 1695, 1696,
	3, 2, 2, 2, 1696, 1701, 3, 2, 2, 2, 1697, 1699, 7, 217, 2, 2, 1698, 1697,
	3, 2, 2, 2, 1698, 1699, 3, 2, 2, 2, 1699, 1700, 3, 2, 2, 2, 1700, 1702,
	9, 8, 2, 2, 1701, 1698, 3, 2, 2, 2, 1701, 1702, 3, 2, 2, 2, 1702, 1704,
	3, 2, 2, 2, 1703, 1705, 5, 106, 54, 2, 1704, 1703, 3, 2, 2, 2, 1705, 1706,
	3, 2, 2, 2, 1706, 1704, 3, 2, 2, 2, 1706, 1707, 3, 2, 2, 2, 1707, 1710,
	3, 2, 2, 2, 1708, 1709, 7, 244, 2, 2, 1709, 1711, 5, 1108, 555, 2, 1710,
	1708, 3, 2, 2, 2, 1710, 1711, 3, 2, 2, 2, 1711, 105, 3, 2, 2, 2, 1712,
	1714, 5, 1160, 581, 2, 1713, 1712, 3, 2, 2, 2, 1714, 1715, 3, 2, 2, 2,
	1715, 1713, 3, 2, 2, 2, 1715, 1716, 3, 2, 2, 2, 1716, 1718, 3, 2, 2, 2,
	1717, 1719, 9, 11, 2, 2, 1718, 1717, 3, 2, 2, 2, 1718, 1719, 3, 2, 2, 2,
	1719, 1721, 3, 2, 2, 2, 1720, 1722, 5, 1172, 587, 2, 1721, 1720, 3, 2,
	2, 2, 1722, 1723, 3, 2, 2, 2, 1723, 1721, 3, 2, 2, 2, 1723, 1724, 3, 2,
	2, 2, 1724, 107, 3, 2, 2, 2, 1725, 1726, 7, 252, 2, 2, 1726, 1727, 7, 424,
	2, 2, 1727, 1731, 7, 541, 2, 2, 1728, 1730, 5, 110, 56, 2, 1729, 1728,
	3, 2, 2, 2, 1730, 1733, 3, 2, 2, 2, 1731, 1729, 3, 2, 2, 2, 1731, 1732,
	3, 2, 2, 2, 1732, 109, 3, 2, 2, 2, 1733, 1731, 3, 2, 2, 2, 1734, 1737,
	5, 112, 57, 2, 1735, 1737, 5, 142, 72, 2, 1736, 1734, 3, 2, 2, 2, 1736,
	1735, 3, 2, 2, 2, 1737, 111, 3, 2, 2, 2, 1738, 1745, 7, 212, 2, 2, 1739,
	1741, 7, 541, 2, 2, 1740, 1739, 3, 2, 2, 2, 1740, 1741, 3, 2, 2, 2, 1741,
	1742, 3, 2, 2, 2, 1742, 1744, 5, 114, 58, 2, 1743, 1740, 3, 2, 2, 2, 1744,
	1747, 3, 2, 2, 2, 1745, 1743, 3, 2, 2, 2, 1745, 1746, 3, 2, 2, 2, 1746,
	1748, 3, 2, 2, 2, 1747, 1745, 3, 2, 2, 2, 1748, 1749, 7, 541, 2, 2, 1749,
	113, 3, 2, 2, 2, 1750, 1754, 5, 116, 59, 2, 1751, 1753, 5, 118, 60, 2,
	1752, 1751, 3, 2, 2, 2, 1753, 1756, 3, 2, 2, 2, 1754, 1752, 3, 2, 2, 2,
	1754, 1755, 3, 2, 2, 2, 1755, 115, 3, 2, 2, 2, 1756, 1754, 3, 2, 2, 2,
	1757, 1759, 7, 429, 2, 2, 1758, 1760, 7, 335, 2, 2, 1759, 1758, 3, 2, 2,
	2, 1759, 1760, 3, 2, 2, 2, 1760, 1761, 3, 2, 2, 2, 1761, 1762, 5, 1128,
	565, 2, 1762, 117, 3, 2, 2, 2, 1763, 1775, 5, 120, 61, 2, 1764, 1775, 5,
	122, 62, 2, 1765, 1775, 5, 124, 63, 2, 1766, 1775, 5, 126, 64, 2, 1767,
	1775, 5, 128, 65, 2, 1768, 1775, 5, 130, 66, 2, 1769, 1775, 5, 132, 67,
	2, 1770, 1775, 5, 134, 68, 2, 1771, 1775, 5, 138, 70, 2, 1772, 1775, 5,
	136, 69, 2, 1773, 1775, 5, 140, 71, 2, 1774, 1763, 3, 2, 2, 2, 1774, 1764,
	3, 2, 2, 2, 1774, 1765, 3, 2, 2, 2, 1774, 1766, 3, 2, 2, 2, 1774, 1767,
	3, 2, 2, 2, 1774, 1768, 3, 2, 2, 2, 1774, 1769, 3, 2, 2, 2, 1774, 1770,
	3, 2, 2, 2, 1774, 1771, 3, 2, 2, 2, 1774, 1772, 3, 2, 2, 2, 1774, 1773,
	3, 2, 2, 2, 1775, 119, 3, 2, 2, 2, 1776, 1778, 7, 31, 2, 2, 1777, 1779,
	7, 495, 2, 2, 1778, 1777, 3, 2, 2, 2, 1778, 1779, 3, 2, 2, 2, 1779, 1789,
	3, 2, 2, 2, 1780, 1790, 7, 146, 2, 2, 1781, 1790, 7, 359, 2, 2, 1782, 1790,
	7, 360, 2, 2, 1783, 1790, 7, 377, 2, 2, 1784, 1790, 7, 378, 2, 2, 1785,
	1790, 7, 480, 2, 2, 1786, 1790, 7, 516, 2, 2, 1787, 1790, 5, 1110, 556,
	2, 1788, 1790, 5, 1166, 584, 2, 1789, 1780, 3, 2, 2, 2, 1789, 1781, 3,
	2, 2, 2, 1789, 1782, 3, 2, 2, 2, 1789, 1783, 3, 2, 2, 2, 1789, 1784, 3,
	2, 2, 2, 1789, 1785, 3, 2, 2, 2, 1789, 1786, 3, 2, 2, 2, 1789, 1787, 3,
	2, 2, 2, 1789, 1788, 3, 2, 2, 2, 1790, 121, 3, 2, 2, 2, 1791, 1794, 7,
	406, 2, 2, 1792, 1795, 7, 314, 2, 2, 1793, 1795, 5, 1172, 587, 2, 1794,
	1792, 3, 2, 2, 2, 1794, 1793, 3, 2, 2, 2, 1795, 1797, 3, 2, 2, 2, 1796,
	1798, 7, 20, 2, 2, 1797, 1796, 3, 2, 2, 2, 1797, 1798, 3, 2, 2, 2, 1798,
	1800, 3, 2, 2, 2, 1799, 1801, 9, 12, 2, 2, 1800, 1799, 3, 2, 2, 2, 1800,
	1801, 3, 2, 2, 2, 1801, 123, 3, 2, 2, 2, 1802, 1804, 7, 339, 2, 2, 1803,
	1805, 7, 259, 2, 2, 1804, 1803, 3, 2, 2, 2, 1804, 1805, 3, 2, 2, 2, 1805,
	1807, 3, 2, 2, 2, 1806, 1802, 3, 2, 2, 2, 1806, 1807, 3, 2, 2, 2, 1807,
	1813, 3, 2, 2, 2, 1808, 1814, 7, 284, 2, 2, 1809, 1810, 7, 384, 2, 2, 1810,
	1814, 7, 46, 2, 2, 1811, 1814, 7, 384, 2, 2, 1812, 1814, 7, 46, 2, 2, 1813,
	1808, 3, 2, 2, 2, 1813, 1809, 3, 2, 2, 2, 1813, 1811, 3, 2, 2, 2, 1813,
	1812, 3, 2, 2, 2, 1813, 1814, 3, 2, 2, 2, 1814, 1815, 3, 2, 2, 2, 1815,
	1816, 9, 13, 2, 2, 1816, 125, 3, 2, 2, 2, 1817, 1819, 7, 346, 2, 2, 1818,
	1820, 7, 66, 2, 2, 1819, 1818, 3, 2, 2, 2, 1819, 1820, 3, 2, 2, 2, 1820,
	1822, 3, 2, 2, 2, 1821, 1823, 7, 259, 2, 2, 1822, 1821, 3, 2, 2, 2, 1822,
	1823, 3, 2, 2, 2, 1823, 1826, 3, 2, 2, 2, 1824, 1827, 5, 1084, 543, 2,
	1825, 1827, 5, 1166, 584, 2, 1826, 1824, 3, 2, 2, 2, 1826, 1825, 3, 2,
	2, 2, 1827, 127, 3, 2, 2, 2, 1828, 1829, 7, 384, 2, 2, 1829, 1831, 7, 138,
	2, 2, 1830, 1832, 7, 259, 2, 2, 1831, 1830, 3, 2, 2, 2, 1831, 1832, 3,
	2, 2, 2, 1832, 1836, 3, 2, 2, 2, 1833, 1837, 7, 460, 2, 2, 1834, 1837,
	7, 242, 2, 2, 1835, 1837, 5, 1110, 556, 2, 1836, 1833, 3, 2, 2, 2, 1836,
	1834, 3, 2, 2, 2, 1836, 1835, 3, 2, 2, 2, 1837, 129, 3, 2, 2, 2, 1838,
	1840, 7, 5, 2, 2, 1839, 1841, 7, 302, 2, 2, 1840, 1839, 3, 2, 2, 2, 1840,
	1841, 3, 2, 2, 2, 1841, 1843, 3, 2, 2, 2, 1842, 1844, 7, 259, 2, 2, 1843,
	1842, 3, 2, 2, 2, 1843, 1844, 3, 2, 2, 2, 1844, 1845, 3, 2, 2, 2, 1845,
	1846, 9, 14, 2, 2, 1846, 131, 3, 2, 2, 2, 1847, 1849, 7, 384, 2, 2, 1848,
	1850, 7, 264, 2, 2, 1849, 1848, 3, 2, 2, 2, 1849, 1850, 3, 2, 2, 2, 1850,
	1852, 3, 2, 2, 2, 1851, 1853, 7, 259, 2, 2, 1852, 1851, 3, 2, 2, 2, 1852,
	1853, 3, 2, 2, 2, 1853, 1854, 3, 2, 2, 2, 1854, 1856, 5, 1084, 543, 2,
	1855, 1857, 5, 136, 69, 2, 1856, 1855, 3, 2, 2, 2, 1856, 1857, 3, 2, 2,
	2, 1857, 1862, 3, 2, 2, 2, 1858, 1860, 7, 520, 2, 2, 1859, 1858, 3, 2,
	2, 2, 1859, 1860, 3, 2, 2, 2, 1860, 1861, 3, 2, 2, 2, 1861, 1863, 7, 154,
	2, 2, 1862, 1859, 3, 2, 2, 2, 1862, 1863, 3, 2, 2, 2, 1863, 133, 3, 2,
	2, 2, 1864, 1865, 7, 20, 2, 2, 1865, 1867, 7, 384, 2, 2, 1866, 1868, 7,
	264, 2, 2, 1867, 1866, 3, 2, 2, 2, 1867, 1868, 3, 2, 2, 2, 1868, 1870,
	3, 2, 2, 2, 1869, 1871, 7, 259, 2, 2, 1870, 1869, 3, 2, 2, 2, 1870, 1871,
	3, 2, 2, 2, 1871, 1872, 3, 2, 2, 2, 1872, 1874, 5, 1084, 543, 2, 1873,
	1875, 5, 136, 69, 2, 1874, 1873, 3, 2, 2, 2, 1874, 1875, 3, 2, 2, 2, 1875,
	1880, 3, 2, 2, 2, 1876, 1878, 7, 520, 2, 2, 1877, 1876, 3, 2, 2, 2, 1877,
	1878, 3, 2, 2, 2, 1878, 1879, 3, 2, 2, 2, 1879, 1881, 7, 154, 2, 2, 1880,
	1877, 3, 2, 2, 2, 1880, 1881, 3, 2, 2, 2, 1881, 135, 3, 2, 2, 2, 1882,
	1884, 7, 349, 2, 2, 1883, 1885, 7, 259, 2, 2, 1884, 1883, 3, 2, 2, 2, 1884,
	1885, 3, 2, 2, 2, 1885, 1886, 3, 2, 2, 2, 1886, 1887, 5, 1122, 562, 2,
	1887, 137, 3, 2, 2, 2, 1888, 1890, 7, 211, 2, 2, 1889, 1888, 3, 2, 2, 2,
	1889, 1890, 3, 2, 2, 2, 1890, 1891, 3, 2, 2, 2, 1891, 1893, 7, 463, 2,
	2, 1892, 1894, 7, 259, 2, 2, 1893, 1892, 3, 2, 2, 2, 1893, 1894, 3, 2,
	2, 2, 1894, 1895, 3, 2, 2, 2, 1895, 1897, 5, 1084, 543, 2, 1896, 1898,
	5, 1084, 543, 2, 1897, 1896, 3, 2, 2, 2, 1897, 1898, 3, 2, 2, 2, 1898,
	139, 3, 2, 2, 2, 1899, 1901, 7, 392, 2, 2, 1900, 1902, 7, 264, 2, 2, 1901,
	1900, 3, 2, 2, 2, 1901, 1902, 3, 2, 2, 2, 1902, 1904, 3, 2, 2, 2, 1903,
	1905, 7, 259, 2, 2, 1904, 1903, 3, 2, 2, 2, 1904, 1905, 3, 2, 2, 2, 1905,
	1906, 3, 2, 2, 2, 1906, 1907, 5, 1084, 543, 2, 1907, 141, 3, 2, 2, 2, 1908,
	1909, 7, 238, 2, 2, 1909, 1913, 7, 541, 2, 2, 1910, 1911, 5, 1128, 565,
	2, 1911, 1912, 7, 541, 2, 2, 1912, 1914, 3, 2, 2, 2, 1913, 1910, 3, 2,
	2, 2, 1913, 1914, 3, 2, 2, 2, 1914, 1922, 3, 2, 2, 2, 1915, 1917, 5, 144,
	73, 2, 1916, 1915, 3, 2, 2, 2, 1917, 1920, 3, 2, 2, 2, 1918, 1916, 3, 2,
	2, 2, 1918, 1919, 3, 2, 2, 2, 1919, 1921, 3, 2, 2, 2, 1920, 1918, 3, 2,
	2, 2, 1921, 1923, 7, 541, 2, 2, 1922, 1918, 3, 2, 2, 2, 1922, 1923, 3,
	2, 2, 2, 1923, 143, 3, 2, 2, 2, 1924, 1929, 5, 146, 74, 2, 1925, 1929,
	5, 154, 78, 2, 1926, 1929, 5, 156, 79, 2, 1927, 1929, 5, 160, 81, 2, 1928,
	1924, 3, 2, 2, 2, 1928, 1925, 3, 2, 2, 2, 1928, 1926, 3, 2, 2, 2, 1928,
	1927, 3, 2, 2, 2, 1929, 145, 3, 2, 2, 2, 1930, 1936, 7, 405, 2, 2, 1931,
	1934, 7, 332, 2, 2, 1932, 1935, 5, 1110, 556, 2, 1933, 1935, 5, 1128, 565,
	2, 1934, 1932, 3, 2, 2, 2, 1934, 1933, 3, 2, 2, 2, 1935, 1937, 3, 2, 2,
	2, 1936, 1931, 3, 2, 2, 2, 1936, 1937, 3, 2, 2, 2, 1937, 1938, 3, 2, 2,
	2, 1938, 1942, 7, 200, 2, 2, 1939, 1943, 5, 148, 75, 2, 1940, 1943, 5,
	150, 76, 2, 1941, 1943, 5, 152, 77, 2, 1942, 1939, 3, 2, 2, 2, 1942, 1940,
	3, 2, 2, 2, 1942, 1941, 3, 2, 2, 2, 1943, 147, 3, 2, 2, 2, 1944, 1945,
	5, 1172, 587, 2, 1945, 1946, 7, 386, 2, 2, 1946, 149, 3, 2, 2, 2, 1947,
	1949, 7, 164, 2, 2, 1948, 1947, 3, 2, 2, 2, 1948, 1949, 3, 2, 2, 2, 1949,
	1951, 3, 2, 2, 2, 1950, 1952, 7, 329, 2, 2, 1951, 1950, 3, 2, 2, 2, 1951,
	1952, 3, 2, 2, 2, 1952, 1953, 3, 2, 2, 2, 1953, 1954, 9, 15, 2, 2, 1954,
	1955, 7, 329, 2, 2, 1955, 1956, 5, 1128, 565, 2, 1956, 151, 3, 2, 2, 2,
	1957, 1959, 5, 1172, 587, 2, 1958, 1960, 7, 70, 2, 2, 1959, 1958, 3, 2,
	2, 2, 1959, 1960, 3, 2, 2, 2, 1960, 153, 3, 2, 2, 2, 1961, 1963, 7, 419,
	2, 2, 1962, 1964, 9, 16, 2, 2, 1963, 1962, 3, 2, 2, 2, 1963, 1964, 3, 2,
	2, 2, 1964, 1966, 3, 2, 2, 2, 1965, 1967, 7, 25, 2, 2, 1966, 1965, 3, 2,
	2, 2, 1966, 1967, 3, 2, 2, 2, 1967, 1969, 3, 2, 2, 2, 1968, 1970, 7, 217,
	2, 2, 1969, 1968, 3, 2, 2, 2, 1969, 1970, 3, 2, 2, 2, 1970, 1972, 3, 2,
	2, 2, 1971, 1973, 5, 1128, 565, 2, 1972, 1971, 3, 2, 2, 2, 1973, 1974,
	3, 2, 2, 2, 1974, 1972, 3, 2, 2, 2, 1974, 1975, 3, 2, 2, 2, 1975, 155,
	3, 2, 2, 2, 1976, 1977, 7, 306, 2, 2, 1977, 1979, 7, 211, 2, 2, 1978, 1980,
	7, 480, 2, 2, 1979, 1978, 3, 2, 2, 2, 1979, 1980, 3, 2, 2, 2, 1980, 1982,
	3, 2, 2, 2, 1981, 1983, 7, 99, 2, 2, 1982, 1981, 3, 2, 2, 2, 1982, 1983,
	3, 2, 2, 2, 1983, 1985, 3, 2, 2, 2, 1984, 1986, 5, 158, 80, 2, 1985, 1984,
	3, 2, 2, 2, 1986, 1987, 3, 2, 2, 2, 1987, 1985, 3, 2, 2, 2, 1987, 1988,
	3, 2, 2, 2, 1988, 157, 3, 2, 2, 2, 1989, 1992, 5, 1128, 565, 2, 1990, 1991,
	7, 357, 2, 2, 1991, 1993, 5, 1172, 587, 2, 1992, 1990, 3, 2, 2, 2, 1992,
	1993, 3, 2, 2, 2, 1993, 159, 3, 2, 2, 2, 1994, 1995, 7, 82, 2, 2, 1995,
	1997, 7, 102, 2, 2, 1996, 1998, 7, 217, 2, 2, 1997, 1996, 3, 2, 2, 2, 1997,
	1998, 3, 2, 2, 2, 1998, 1999, 3, 2, 2, 2, 1999, 2000, 5, 1128, 565, 2,
	2000, 161, 3, 2, 2, 2, 2001, 2002, 7, 114, 2, 2, 2002, 2003, 7, 150, 2,
	2, 2003, 2004, 7, 541, 2, 2, 2004, 2005, 5, 164, 83, 2, 2005, 163, 3, 2,
	2, 2, 2006, 2008, 5, 166, 84, 2, 2007, 2006, 3, 2, 2, 2, 2007, 2008, 3,
	2, 2, 2, 2008, 2010, 3, 2, 2, 2, 2009, 2011, 5, 216, 109, 2, 2010, 2009,
	3, 2, 2, 2, 2010, 2011, 3, 2, 2, 2, 2011, 2013, 3, 2, 2, 2, 2012, 2014,
	5, 220, 111, 2, 2013, 2012, 3, 2, 2, 2, 2013, 2014, 3, 2, 2, 2, 2014, 2016,
	3, 2, 2, 2, 2015, 2017, 5, 222, 112, 2, 2016, 2015, 3, 2, 2, 2, 2016, 2017,
	3, 2, 2, 2, 2017, 2019, 3, 2, 2, 2, 2018, 2020, 5, 224, 113, 2, 2019, 2018,
	3, 2, 2, 2, 2019, 2020, 3, 2, 2, 2, 2020, 2022, 3, 2, 2, 2, 2021, 2023,
	5, 262, 132, 2, 2022, 2021, 3, 2, 2, 2, 2022, 2023, 3, 2, 2, 2, 2023, 2025,
	3, 2, 2, 2, 2024, 2026, 5, 264, 133, 2, 2025, 2024, 3, 2, 2, 2, 2025, 2026,
	3, 2, 2, 2, 2026, 2028, 3, 2, 2, 2, 2027, 2029, 5, 328, 165, 2, 2028, 2027,
	3, 2, 2, 2, 2028, 2029, 3, 2, 2, 2, 2029, 2031, 3, 2, 2, 2, 2030, 2032,
	5, 404, 203, 2, 2031, 2030, 3, 2, 2, 2, 2031, 2032, 3, 2, 2, 2, 2032, 165,
	3, 2, 2, 2, 2033, 2034, 7, 211, 2, 2, 2034, 2035, 7, 424, 2, 2, 2035, 2039,
	7, 541, 2, 2, 2036, 2038, 5, 168, 85, 2, 2037, 2036, 3, 2, 2, 2, 2038,
	2041, 3, 2, 2, 2, 2039, 2037, 3, 2, 2, 2, 2039, 2040, 3, 2, 2, 2, 2040,
	167, 3, 2, 2, 2, 2041, 2039, 3, 2, 2, 2, 2042, 2043, 9, 17, 2, 2, 2043,
	2050, 5, 1128, 565, 2, 2044, 2046, 7, 541, 2, 2, 2045, 2044, 3, 2, 2, 2,
	2045, 2046, 3, 2, 2, 2, 2046, 2047, 3, 2, 2, 2, 2047, 2049, 5, 170, 86,
	2, 2048, 2045, 3, 2, 2, 2, 2049, 2052, 3, 2, 2, 2, 2050, 2048, 3, 2, 2,
	2, 2050, 2051, 3, 2, 2, 2, 2051, 2053, 3, 2, 2, 2, 2052, 2050, 3, 2, 2,
	2, 2053, 2057, 7, 541, 2, 2, 2054, 2056, 5, 442, 222, 2, 2055, 2054, 3,
	2, 2, 2, 2056, 2059, 3, 2, 2, 2, 2057, 2055, 3, 2, 2, 2, 2057, 2058, 3,
	2, 2, 2, 2058, 169, 3, 2, 2, 2, 2059, 2057, 3, 2, 2, 2, 2060, 2072, 5,
	172, 87, 2, 2061, 2072, 5, 174, 88, 2, 2062, 2072, 5, 176, 89, 2, 2063,
	2072, 5, 180, 91, 2, 2064, 2072, 5, 190, 96, 2, 2065, 2072, 5, 192, 97,
	2, 2066, 2072, 5, 196, 99, 2, 2067, 2072, 5, 198, 100, 2, 2068, 2072, 5,
	212, 107, 2, 2069, 2072, 5, 214, 108, 2, 2070, 2072, 5, 208, 105, 2, 2071,
	2060, 3, 2, 2, 2, 2071, 2061, 3, 2, 2, 2, 2071, 2062, 3, 2, 2, 2, 2071,
	2063, 3, 2, 2, 2, 2071, 2064, 3, 2, 2, 2, 2071, 2065, 3, 2, 2, 2, 2071,
	2066, 3, 2, 2, 2, 2071, 2067, 3, 2, 2, 2, 2071, 2068, 3, 2, 2, 2, 2071,
	2069, 3, 2, 2, 2, 2071, 2070, 3, 2, 2, 2, 2072, 171, 3, 2, 2, 2, 2073,
	2075, 7, 259, 2, 2, 2074, 2073, 3, 2, 2, 2, 2074, 2075, 3, 2, 2, 2, 2075,
	2076, 3, 2, 2, 2, 2076, 2077, 7, 208, 2, 2, 2077, 173, 3, 2, 2, 2, 2078,
	2080, 7, 259, 2, 2, 2079, 2078, 3, 2, 2, 2, 2079, 2080, 3, 2, 2, 2, 2080,
	2081, 3, 2, 2, 2, 2081, 2082, 7, 228, 2, 2, 2082, 175, 3, 2, 2, 2, 2083,
	2085, 7, 50, 2, 2, 2084, 2086, 7, 99, 2, 2, 2085, 2084, 3, 2, 2, 2, 2085,
	2086, 3, 2, 2, 2, 2086, 2087, 3, 2, 2, 2, 2087, 2089, 5, 1172, 587, 2,
	2088, 2090, 5, 178, 90, 2, 2089, 2088, 3, 2, 2, 2, 2089, 2090, 3, 2, 2,
	2, 2090, 2092, 3, 2, 2, 2, 2091, 2093, 9, 18, 2, 2, 2092, 2091, 3, 2, 2,
	2, 2092, 2093, 3, 2, 2, 2, 2093, 177, 3, 2, 2, 2, 2094, 2095, 7, 495, 2,
	2, 2095, 2096, 5, 1172, 587, 2, 2096, 179, 3, 2, 2, 2, 2097, 2101, 7, 384,
	2, 2, 2098, 2102, 5, 182, 92, 2, 2099, 2102, 5, 184, 93, 2, 2100, 2102,
	5, 186, 94, 2, 2101, 2098, 3, 2, 2, 2, 2101, 2099, 3, 2, 2, 2, 2101, 2100,
	3, 2, 2, 2, 2102, 181, 3, 2, 2, 2, 2103, 2105, 7, 99, 2, 2, 2104, 2103,
	3, 2, 2, 2, 2104, 2105, 3, 2, 2, 2, 2105, 2106, 3, 2, 2, 2, 2106, 2108,
	5, 1172, 587, 2, 2107, 2109, 7, 67, 2, 2, 2108, 2107, 3, 2, 2, 2, 2108,
	2109, 3, 2, 2, 2, 2109, 183, 3, 2, 2, 2, 2110, 2112, 7, 259, 2, 2, 2111,
	2110, 3, 2, 2, 2, 2111, 2112, 3, 2, 2, 2, 2112, 2113, 3, 2, 2, 2, 2113,
	2115, 7, 515, 2, 2, 2114, 2116, 7, 244, 2, 2, 2115, 2114, 3, 2, 2, 2, 2115,
	2116, 3, 2, 2, 2, 2116, 2118, 3, 2, 2, 2, 2117, 2119, 7, 444, 2, 2, 2118,
	2117, 3, 2, 2, 2, 2118, 2119, 3, 2, 2, 2, 2119, 2130, 3, 2, 2, 2, 2120,
	2122, 7, 220, 2, 2, 2121, 2120, 3, 2, 2, 2, 2121, 2122, 3, 2, 2, 2, 2122,
	2123, 3, 2, 2, 2, 2123, 2125, 5, 1172, 587, 2, 2124, 2126, 5, 188, 95,
	2, 2125, 2124, 3, 2, 2, 2, 2125, 2126, 3, 2, 2, 2, 2126, 2128, 3, 2, 2,
	2, 2127, 2129, 7, 67, 2, 2, 2128, 2127, 3, 2, 2, 2, 2128, 2129, 3, 2, 2,
	2, 2129, 2131, 3, 2, 2, 2, 2130, 2121, 3, 2, 2, 2, 2130, 2131, 3, 2, 2,
	2, 2131, 2137, 3, 2, 2, 2, 2132, 2134, 7, 139, 2, 2, 2133, 2135, 7, 332,
	2, 2, 2134, 2133, 3, 2, 2, 2, 2134, 2135, 3, 2, 2, 2, 2135, 2136, 3, 2,
	2, 2, 2136, 2138, 5, 1084, 543, 2, 2137, 2132, 3, 2, 2, 2, 2137, 2138,
	3, 2, 2, 2, 2138, 185, 3, 2, 2, 2, 2139, 2141, 7, 99, 2, 2, 2140, 2139,
	3, 2, 2, 2, 2140, 2141, 3, 2, 2, 2, 2141, 2142, 3, 2, 2, 2, 2142, 2143,
	5, 1172, 587, 2, 2143, 2145, 5, 188, 95, 2, 2144, 2146, 7, 67, 2, 2, 2145,
	2144, 3, 2, 2, 2, 2145, 2146, 3, 2, 2, 2, 2146, 187, 3, 2, 2, 2, 2147,
	2148, 7, 495, 2, 2, 2148, 2149, 5, 1172, 587, 2, 2149, 189, 3, 2, 2, 2,
	2150, 2159, 7, 265, 2, 2, 2151, 2153, 7, 384, 2, 2, 2152, 2154, 7, 259,
	2, 2, 2153, 2152, 3, 2, 2, 2, 2153, 2154, 3, 2, 2, 2, 2154, 2160, 3, 2,
	2, 2, 2155, 2157, 7, 386, 2, 2, 2156, 2158, 7, 24, 2, 2, 2157, 2156, 3,
	2, 2, 2, 2157, 2158, 3, 2, 2, 2, 2158, 2160, 3, 2, 2, 2, 2159, 2151, 3,
	2, 2, 2, 2159, 2155, 3, 2, 2, 2, 2160, 2168, 3, 2, 2, 2, 2161, 2169, 7,
	331, 2, 2, 2162, 2169, 7, 459, 2, 2, 2163, 2165, 5, 1122, 562, 2, 2164,
	2163, 3, 2, 2, 2, 2165, 2166, 3, 2, 2, 2, 2166, 2164, 3, 2, 2, 2, 2166,
	2167, 3, 2, 2, 2, 2167, 2169, 3, 2, 2, 2, 2168, 2161, 3, 2, 2, 2, 2168,
	2162, 3, 2, 2, 2, 2168, 2164, 3, 2, 2, 2, 2169, 191, 3, 2, 2, 2, 2170,
	2171, 7, 513, 2, 2, 2171, 2173, 7, 329, 2, 2, 2172, 2174, 5, 194, 98, 2,
	2173, 2172, 3, 2, 2, 2, 2174, 2175, 3, 2, 2, 2, 2175, 2173, 3, 2, 2, 2,
	2175, 2176, 3, 2, 2, 2, 2176, 193, 3, 2, 2, 2, 2177, 2179, 5, 1158, 580,
	2, 2178, 2180, 7, 259, 2, 2, 2179, 2178, 3, 2, 2, 2, 2179, 2180, 3, 2,
	2, 2, 2180, 2183, 3, 2, 2, 2, 2181, 2184, 5, 1084, 543, 2, 2182, 2184,
	5, 1166, 584, 2, 2183, 2181, 3, 2, 2, 2, 2183, 2182, 3, 2, 2, 2, 2184,
	195, 3, 2, 2, 2, 2185, 2194, 7, 114, 2, 2, 2186, 2188, 7, 384, 2, 2, 2187,
	2189, 7, 259, 2, 2, 2188, 2187, 3, 2, 2, 2, 2188, 2189, 3, 2, 2, 2, 2189,
	2195, 3, 2, 2, 2, 2190, 2192, 7, 386, 2, 2, 2191, 2193, 7, 24, 2, 2, 2192,
	2191, 3, 2, 2, 2, 2192, 2193, 3, 2, 2, 2, 2193, 2195, 3, 2, 2, 2, 2194,
	2186, 3, 2, 2, 2, 2194, 2190, 3, 2, 2, 2, 2195, 2197, 3, 2, 2, 2, 2196,
	2198, 5, 1122, 562, 2, 2197, 2196, 3, 2, 2, 2, 2198, 2199, 3, 2, 2, 2,
	2199, 2197, 3, 2, 2, 2, 2199, 2200, 3, 2, 2, 2, 2200, 197, 3, 2, 2, 2,
	2201, 2203, 7, 282, 2, 2, 2202, 2204, 7, 259, 2, 2, 2203, 2202, 3, 2, 2,
	2, 2203, 2204, 3, 2, 2, 2, 2204, 2207, 3, 2, 2, 2, 2205, 2208, 5, 1122,
	562, 2, 2206, 2208, 5, 1172, 587, 2, 2207, 2205, 3, 2, 2, 2, 2207, 2206,
	3, 2, 2, 2, 2208, 2210, 3, 2, 2, 2, 2209, 2211, 7, 285, 2, 2, 2210, 2209,
	3, 2, 2, 2, 2210, 2211, 3, 2, 2, 2, 2211, 2215, 3, 2, 2, 2, 2212, 2214,
	5, 200, 101, 2, 2213, 2212, 3, 2, 2, 2, 2214, 2217, 3, 2, 2, 2, 2215, 2213,
	3, 2, 2, 2, 2215, 2216, 3, 2, 2, 2, 2216, 199, 3, 2, 2, 2, 2217, 2215,
	3, 2, 2, 2, 2218, 2222, 5, 202, 102, 2, 2219, 2222, 5, 204, 103, 2, 2220,
	2222, 5, 206, 104, 2, 2221, 2218, 3, 2, 2, 2, 2221, 2219, 3, 2, 2, 2, 2221,
	2220, 3, 2, 2, 2, 2222, 201, 3, 2, 2, 2, 2223, 2225, 7, 520, 2, 2, 2224,
	2223, 3, 2, 2, 2, 2224, 2225, 3, 2, 2, 2, 2225, 2226, 3, 2, 2, 2, 2226,
	2228, 7, 216, 2, 2, 2227, 2229, 7, 34, 2, 2, 2228, 2227, 3, 2, 2, 2, 2228,
	2229, 3, 2, 2, 2, 2229, 2232, 3, 2, 2, 2, 2230, 2233, 5, 1122, 562, 2,
	2231, 2233, 5, 1172, 587, 2, 2232, 2230, 3, 2, 2, 2, 2232, 2231, 3, 2,
	2, 2, 2233, 203, 3, 2, 2, 2, 2234, 2236, 7, 285, 2, 2, 2235, 2234, 3, 2,
	2, 2, 2235, 2236, 3, 2, 2, 2, 2236, 2238, 3, 2, 2, 2, 2237, 2239, 7, 34,
	2, 2, 2238, 2237, 3, 2, 2, 2, 2238, 2239, 3, 2, 2, 2, 2239, 2240, 3, 2,
	2, 2, 2240, 2243, 7, 498, 2, 2, 2241, 2244, 5, 1122, 562, 2, 2242, 2244,
	5, 1172, 587, 2, 2243, 2241, 3, 2, 2, 2, 2243, 2242, 3, 2, 2, 2, 2244,
	205, 3, 2, 2, 2, 2245, 2247, 7, 285, 2, 2, 2246, 2245, 3, 2, 2, 2, 2246,
	2247, 3, 2, 2, 2, 2247, 2249, 3, 2, 2, 2, 2248, 2250, 7, 34, 2, 2, 2249,
	2248, 3, 2, 2, 2, 2249, 2250, 3, 2, 2, 2, 2250, 2251, 3, 2, 2, 2, 2251,
	2254, 7, 52, 2, 2, 2252, 2255, 5, 1122, 562, 2, 2253, 2255, 5, 1172, 587,
	2, 2254, 2252, 3, 2, 2, 2, 2254, 2253, 3, 2, 2, 2, 2255, 207, 3, 2, 2,
	2, 2256, 2258, 7, 385, 2, 2, 2257, 2259, 7, 302, 2, 2, 2258, 2257, 3, 2,
	2, 2, 2258, 2259, 3, 2, 2, 2, 2259, 2261, 3, 2, 2, 2, 2260, 2262, 7, 259,
	2, 2, 2261, 2260, 3, 2, 2, 2, 2261, 2262, 3, 2, 2, 2, 2262, 2263, 3, 2,
	2, 2, 2263, 2264, 5, 210, 106, 2, 2264, 209, 3, 2, 2, 2, 2265, 2266, 5,
	1164, 583, 2, 2266, 211, 3, 2, 2, 2, 2267, 2269, 7, 76, 2, 2, 2268, 2270,
	7, 259, 2, 2, 2269, 2268, 3, 2, 2, 2, 2269, 2270, 3, 2, 2, 2, 2270, 2271,
	3, 2, 2, 2, 2271, 2272, 5, 1108, 555, 2, 2272, 213, 3, 2, 2, 2, 2273, 2275,
	7, 401, 2, 2, 2274, 2276, 7, 259, 2, 2, 2275, 2274, 3, 2, 2, 2, 2275, 2276,
	3, 2, 2, 2, 2276, 2282, 3, 2, 2, 2, 2277, 2279, 7, 403, 2, 2, 2278, 2280,
	7, 24, 2, 2, 2279, 2278, 3, 2, 2, 2, 2279, 2280, 3, 2, 2, 2, 2280, 2282,
	3, 2, 2, 2, 2281, 2273, 3, 2, 2, 2, 2281, 2277, 3, 2, 2, 2, 2282, 2284,
	3, 2, 2, 2, 2283, 2285, 5, 1150, 576, 2, 2284, 2283, 3, 2, 2, 2, 2285,
	2286, 3, 2, 2, 2, 2286, 2284, 3, 2, 2, 2, 2286, 2287, 3, 2, 2, 2, 2287,
	215, 3, 2, 2, 2, 2288, 2289, 7, 115, 2, 2, 2289, 2290, 7, 424, 2, 2, 2290,
	2294, 7, 541, 2, 2, 2291, 2293, 5, 218, 110, 2, 2292, 2291, 3, 2, 2, 2,
	2293, 2296, 3, 2, 2, 2, 2294, 2292, 3, 2, 2, 2, 2294, 2295, 3, 2, 2, 2,
	2295, 217, 3, 2, 2, 2, 2296, 2294, 3, 2, 2, 2, 2297, 2298, 5, 1172, 587,
	2, 2298, 2299, 5, 1166, 584, 2, 2299, 2300, 7, 258, 2, 2, 2300, 2301, 5,
	1166, 584, 2, 2301, 219, 3, 2, 2, 2, 2302, 2303, 7, 522, 2, 2, 2303, 2304,
	7, 424, 2, 2, 2304, 2308, 7, 541, 2, 2, 2305, 2307, 5, 442, 222, 2, 2306,
	2305, 3, 2, 2, 2, 2307, 2310, 3, 2, 2, 2, 2308, 2306, 3, 2, 2, 2, 2308,
	2309, 3, 2, 2, 2, 2309, 221, 3, 2, 2, 2, 2310, 2308, 3, 2, 2, 2, 2311,
	2312, 7, 287, 2, 2, 2312, 2313, 7, 424, 2, 2, 2313, 2317, 7, 541, 2, 2,
	2314, 2316, 5, 442, 222, 2, 2315, 2314, 3, 2, 2, 2, 2316, 2319, 3, 2, 2,
	2, 2317, 2315, 3, 2, 2, 2, 2317, 2318, 3, 2, 2, 2, 2318, 223, 3, 2, 2,
	2, 2319, 2317, 3, 2, 2, 2, 2320, 2321, 7, 84, 2, 2, 2321, 2322, 7, 424,
	2, 2, 2322, 2327, 7, 541, 2, 2, 2323, 2326, 5, 226, 114, 2, 2324, 2326,
	5, 442, 222, 2, 2325, 2323, 3, 2, 2, 2, 2325, 2324, 3, 2, 2, 2, 2326, 2329,
	3, 2, 2, 2, 2327, 2325, 3, 2, 2, 2, 2327, 2328, 3, 2, 2, 2, 2328, 225,
	3, 2, 2, 2, 2329, 2327, 3, 2, 2, 2, 2330, 2334, 5, 228, 115, 2, 2331, 2334,
	5, 230, 116, 2, 2332, 2334, 5, 232, 117, 2, 2333, 2330, 3, 2, 2, 2, 2333,
	2331, 3, 2, 2, 2, 2333, 2332, 3, 2, 2, 2, 2334, 227, 3, 2, 2, 2, 2335,
	2336, 7, 61, 2, 2, 2336, 2338, 5, 1114, 558, 2, 2337, 2339, 7, 217, 2,
	2, 2338, 2337, 3, 2, 2, 2, 2338, 2339, 3, 2, 2, 2, 2339, 2341, 3, 2, 2,
	2, 2340, 2342, 7, 248, 2, 2, 2341, 2340, 3, 2, 2, 2, 2341, 2342, 3, 2,
	2, 2, 2342, 2343, 3, 2, 2, 2, 2343, 2358, 7, 251, 2, 2, 2344, 2354, 5,
	252, 127, 2, 2345, 2354, 5, 258, 130, 2, 2346, 2354, 5, 244, 123, 2, 2347,
	2354, 5, 246, 124, 2, 2348, 2354, 5, 254, 128, 2, 2349, 2354, 5, 260, 131,
	2, 2350, 2354, 5, 238, 120, 2, 2351, 2354, 5, 248, 125, 2, 2352, 2354,
	5, 242, 122, 2, 2353, 2344, 3, 2, 2, 2, 2353, 2345, 3, 2, 2, 2, 2353, 2346,
	3, 2, 2, 2, 2353, 2347, 3, 2, 2, 2, 2353, 2348, 3, 2, 2, 2, 2353, 2349,
	3, 2, 2, 2, 2353, 2350, 3, 2, 2, 2, 2353, 2351, 3, 2, 2, 2, 2353, 2352,
	3, 2, 2, 2, 2354, 2357, 3, 2, 2, 2, 2355, 2357, 5, 1124, 563, 2, 2356,
	2353, 3, 2, 2, 2, 2356, 2355, 3, 2, 2, 2, 2357, 2360, 3, 2, 2, 2, 2358,
	2356, 3, 2, 2, 2, 2358, 2359, 3, 2, 2, 2, 2359, 2361, 3, 2, 2, 2, 2360,
	2358, 3, 2, 2, 2, 2361, 2362, 7, 541, 2, 2, 2362, 229, 3, 2, 2, 2, 2363,
	2364, 7, 61, 2, 2, 2364, 2366, 5, 1114, 558, 2, 2365, 2367, 7, 217, 2,
	2, 2366, 2365, 3, 2, 2, 2, 2366, 2367, 3, 2, 2, 2, 2367, 2368, 3, 2, 2,
	2, 2368, 2377, 7, 341, 2, 2, 2369, 2376, 5, 234, 118, 2, 2370, 2376, 5,
	260, 131, 2, 2371, 2376, 5, 248, 125, 2, 2372, 2376, 5, 236, 119, 2, 2373,
	2376, 5, 240, 121, 2, 2374, 2376, 5, 250, 126, 2, 2375, 2369, 3, 2, 2,
	2, 2375, 2370, 3, 2, 2, 2, 2375, 2371, 3, 2, 2, 2, 2375, 2372, 3, 2, 2,
	2, 2375, 2373, 3, 2, 2, 2, 2375, 2374, 3, 2, 2, 2, 2376, 2379, 3, 2, 2,
	2, 2377, 2375, 3, 2, 2, 2, 2377, 2378, 3, 2, 2, 2, 2378, 2380, 3, 2, 2,
	2, 2379, 2377, 3, 2, 2, 2, 2380, 2381, 7, 541, 2, 2, 2381, 231, 3, 2, 2,
	2, 2382, 2383, 7, 61, 2, 2, 2383, 2385, 5, 1114, 558, 2, 2384, 2386, 7,
	217, 2, 2, 2385, 2384, 3, 2, 2, 2, 2385, 2386, 3, 2, 2, 2, 2386, 2387,
	3, 2, 2, 2, 2387, 2388, 7, 248, 2, 2, 2388, 2400, 7, 237, 2, 2, 2389, 2396,
	5, 244, 123, 2, 2390, 2396, 5, 246, 124, 2, 2391, 2396, 5, 256, 129, 2,
	2392, 2396, 5, 260, 131, 2, 2393, 2396, 5, 238, 120, 2, 2394, 2396, 5,
	248, 125, 2, 2395, 2389, 3, 2, 2, 2, 2395, 2390, 3, 2, 2, 2, 2395, 2391,
	3, 2, 2, 2, 2395, 2392, 3, 2, 2, 2, 2395, 2393, 3, 2, 2, 2, 2395, 2394,
	3, 2, 2, 2, 2396, 2399, 3, 2, 2, 2, 2397, 2399, 5, 1124, 563, 2, 2398,
	2395, 3, 2, 2, 2, 2398, 2397, 3, 2, 2, 2, 2399, 2402, 3, 2, 2, 2, 2400,
	2398, 3, 2, 2, 2, 2400, 2401, 3, 2, 2, 2, 2401, 2403, 3, 2, 2, 2, 2402,
	2400, 3, 2, 2, 2, 2403, 2404, 7, 541, 2, 2, 2404, 233, 3, 2, 2, 2, 2405,
	2406, 7, 141, 2, 2, 2406, 2408, 7, 110, 2, 2, 2407, 2409, 7, 259, 2, 2,
	2408, 2407, 3, 2, 2, 2, 2408, 2409, 3, 2, 2, 2, 2409, 2410, 3, 2, 2, 2,
	2410, 2411, 5, 1124, 563, 2, 2411, 235, 3, 2, 2, 2, 2412, 2413, 7, 141,
	2, 2, 2413, 2414, 7, 476, 2, 2, 2414, 2415, 7, 327, 2, 2, 2415, 2416, 5,
	1172, 587, 2, 2416, 2424, 7, 493, 2, 2, 2417, 2418, 7, 246, 2, 2, 2418,
	2420, 7, 53, 2, 2, 2419, 2421, 5, 1132, 567, 2, 2420, 2419, 3, 2, 2, 2,
	2421, 2422, 3, 2, 2, 2, 2422, 2420, 3, 2, 2, 2, 2422, 2423, 3, 2, 2, 2,
	2423, 2425, 3, 2, 2, 2, 2424, 2417, 3, 2, 2, 2, 2424, 2425, 3, 2, 2, 2,
	2425, 237, 3, 2, 2, 2, 2426, 2427, 7, 164, 2, 2, 2427, 2429, 7, 264, 2,
	2, 2428, 2430, 7, 259, 2, 2, 2429, 2428, 3, 2, 2, 2, 2429, 2430, 3, 2,
	2, 2, 2430, 2431, 3, 2, 2, 2, 2431, 2432, 5, 1124, 563, 2, 2432, 239, 3,
	2, 2, 2, 2433, 2434, 7, 193, 2, 2, 2434, 2436, 7, 264, 2, 2, 2435, 2437,
	7, 259, 2, 2, 2436, 2435, 3, 2, 2, 2, 2436, 2437, 3, 2, 2, 2, 2437, 2438,
	3, 2, 2, 2, 2438, 2439, 5, 1124, 563, 2, 2439, 241, 3, 2, 2, 2, 2440, 2442,
	7, 300, 2, 2, 2441, 2440, 3, 2, 2, 2, 2441, 2442, 3, 2, 2, 2, 2442, 2443,
	3, 2, 2, 2, 2443, 2445, 7, 110, 2, 2, 2444, 2446, 7, 259, 2, 2, 2445, 2444,
	3, 2, 2, 2, 2445, 2446, 3, 2, 2, 2, 2446, 2447, 3, 2, 2, 2, 2447, 2448,
	5, 1124, 563, 2, 2448, 243, 3, 2, 2, 2, 2449, 2450, 7, 300, 2, 2, 2450,
	2452, 7, 116, 2, 2, 2451, 2453, 7, 259, 2, 2, 2452, 2451, 3, 2, 2, 2, 2452,
	2453, 3, 2, 2, 2, 2453, 2454, 3, 2, 2, 2, 2454, 2455, 5, 1124, 563, 2,
	2455, 245, 3, 2, 2, 2, 2456, 2457, 7, 300, 2, 2, 2457, 2459, 7, 491, 2,
	2, 2458, 2460, 7, 259, 2, 2, 2459, 2458, 3, 2, 2, 2, 2459, 2460, 3, 2,
	2, 2, 2460, 2461, 3, 2, 2, 2, 2461, 2462, 5, 1124, 563, 2, 2462, 247, 3,
	2, 2, 2, 2463, 2464, 7, 463, 2, 2, 2464, 2466, 7, 264, 2, 2, 2465, 2467,
	7, 259, 2, 2, 2466, 2465, 3, 2, 2, 2, 2466, 2467, 3, 2, 2, 2, 2467, 2468,
	3, 2, 2, 2, 2468, 2469, 5, 1124, 563, 2, 2469, 249, 3, 2, 2, 2, 2470, 2472,
	7, 473, 2, 2, 2471, 2470, 3, 2, 2, 2, 2471, 2472, 3, 2, 2, 2, 2472, 2473,
	3, 2, 2, 2, 2473, 2475, 7, 141, 2, 2, 2474, 2476, 7, 259, 2, 2, 2475, 2474,
	3, 2, 2, 2, 2475, 2476, 3, 2, 2, 2, 2476, 2477, 3, 2, 2, 2, 2477, 2478,
	5, 1124, 563, 2, 2478, 251, 3, 2, 2, 2, 2479, 2481, 7, 473, 2, 2, 2480,
	2479, 3, 2, 2, 2, 2480, 2481, 3, 2, 2, 2, 2481, 2482, 3, 2, 2, 2, 2482,
	2484, 7, 373, 2, 2, 2483, 2485, 7, 259, 2, 2, 2484, 2483, 3, 2, 2, 2, 2484,
	2485, 3, 2, 2, 2, 2485, 2486, 3, 2, 2, 2, 2486, 2487, 5, 1124, 563, 2,
	2487, 253, 3, 2, 2, 2, 2488, 2490, 7, 473, 2, 2, 2489, 2488, 3, 2, 2, 2,
	2489, 2490, 3, 2, 2, 2, 2490, 2491, 3, 2, 2, 2, 2491, 2493, 7, 453, 2,
	2, 2492, 2494, 7, 259, 2, 2, 2493, 2492, 3, 2, 2, 2, 2493, 2494, 3, 2,
	2, 2, 2494, 2495, 3, 2, 2, 2, 2495, 2496, 5, 1124, 563, 2, 2496, 255, 3,
	2, 2, 2, 2497, 2499, 7, 473, 2, 2, 2498, 2497, 3, 2, 2, 2, 2498, 2499,
	3, 2, 2, 2, 2499, 2500, 3, 2, 2, 2, 2500, 2502, 7, 481, 2, 2, 2501, 2503,
	7, 259, 2, 2, 2502, 2501, 3, 2, 2, 2, 2502, 2503, 3, 2, 2, 2, 2503, 2504,
	3, 2, 2, 2, 2504, 2505, 5, 1124, 563, 2, 2505, 257, 3, 2, 2, 2, 2506, 2508,
	7, 473, 2, 2, 2507, 2506, 3, 2, 2, 2, 2507, 2508, 3, 2, 2, 2, 2508, 2509,
	3, 2, 2, 2, 2509, 2511, 9, 19, 2, 2, 2510, 2512, 7, 259, 2, 2, 2511, 2510,
	3, 2, 2, 2, 2511, 2512, 3, 2, 2, 2, 2512, 2513, 3, 2, 2, 2, 2513, 2514,
	5, 1124, 563, 2, 2514, 259, 3, 2, 2, 2, 2515, 2516, 7, 484, 2, 2, 2516,
	2518, 7, 273, 2, 2, 2517, 2519, 7, 259, 2, 2, 2518, 2517, 3, 2, 2, 2, 2518,
	2519, 3, 2, 2, 2, 2519, 2520, 3, 2, 2, 2, 2520, 2521, 5, 1124, 563, 2,
	2521, 261, 3, 2, 2, 2, 2522, 2523, 7, 290, 2, 2, 2523, 2524, 7, 424, 2,
	2, 2524, 2529, 7, 541, 2, 2, 2525, 2526, 7, 269, 2, 2, 2526, 2527, 5, 1138,
	570, 2, 2527, 2528, 7, 541, 2, 2, 2528, 2530, 3, 2, 2, 2, 2529, 2525, 3,
	2, 2, 2, 2529, 2530, 3, 2, 2, 2, 2530, 2534, 3, 2, 2, 2, 2531, 2533, 5,
	442, 222, 2, 2532, 2531, 3, 2, 2, 2, 2533, 2536, 3, 2, 2, 2, 2534, 2532,
	3, 2, 2, 2, 2534, 2535, 3, 2, 2, 2, 2535, 263, 3, 2, 2, 2, 2536, 2534,
	3, 2, 2, 2, 2537, 2538, 7, 421, 2, 2, 2538, 2539, 7, 424, 2, 2, 2539, 2543,
	7, 541, 2, 2, 2540, 2542, 5, 266, 134, 2, 2541, 2540, 3, 2, 2, 2, 2542,
	2545, 3, 2, 2, 2, 2543, 2541, 3, 2, 2, 2, 2543, 2544, 3, 2, 2, 2, 2544,
	265, 3, 2, 2, 2, 2545, 2543, 3, 2, 2, 2, 2546, 2549, 7, 561, 2, 2, 2547,
	2550, 7, 213, 2, 2, 2548, 2550, 5, 1154, 578, 2, 2549, 2547, 3, 2, 2, 2,
	2549, 2548, 3, 2, 2, 2, 2549, 2550, 3, 2, 2, 2, 2550, 2583, 3, 2, 2, 2,
	2551, 2582, 5, 268, 135, 2, 2552, 2582, 5, 270, 136, 2, 2553, 2582, 5,
	272, 137, 2, 2554, 2582, 5, 274, 138, 2, 2555, 2582, 5, 276, 139, 2, 2556,
	2582, 5, 278, 140, 2, 2557, 2582, 5, 280, 141, 2, 2558, 2582, 5, 282, 142,
	2, 2559, 2582, 5, 284, 143, 2, 2560, 2582, 5, 286, 144, 2, 2561, 2582,
	5, 288, 145, 2, 2562, 2582, 5, 290, 146, 2, 2563, 2582, 5, 292, 147, 2,
	2564, 2582, 5, 294, 148, 2, 2565, 2582, 5, 296, 149, 2, 2566, 2582, 5,
	298, 150, 2, 2567, 2570, 5, 300, 151, 2, 2568, 2570, 5, 304, 153, 2, 2569,
	2567, 3, 2, 2, 2, 2569, 2568, 3, 2, 2, 2, 2570, 2582, 3, 2, 2, 2, 2571,
	2582, 5, 306, 154, 2, 2572, 2582, 5, 308, 155, 2, 2573, 2582, 5, 310, 156,
	2, 2574, 2582, 5, 312, 157, 2, 2575, 2582, 5, 314, 158, 2, 2576, 2582,
	5, 316, 159, 2, 2577, 2582, 5, 318, 160, 2, 2578, 2582, 5, 320, 161, 2,
	2579, 2582, 5, 324, 163, 2, 2580, 2582, 5, 326, 164, 2, 2581, 2551, 3,
	2, 2, 2, 2581, 2552, 3, 2, 2, 2, 2581, 2553, 3, 2, 2, 2, 2581, 2554, 3,
	2, 2, 2, 2581, 2555, 3, 2, 2, 2, 2581, 2556, 3, 2, 2, 2, 2581, 2557, 3,
	2, 2, 2, 2581, 2558, 3, 2, 2, 2, 2581, 2559, 3, 2, 2, 2, 2581, 2560, 3,
	2, 2, 2, 2581, 2561, 3, 2, 2, 2, 2581, 2562, 3, 2, 2, 2, 2581, 2563, 3,
	2, 2, 2, 2581, 2564, 3, 2, 2, 2, 2581, 2565, 3, 2, 2, 2, 2581, 2566, 3,
	2, 2, 2, 2581, 2569, 3, 2, 2, 2, 2581, 2571, 3, 2, 2, 2, 2581, 2572, 3,
	2, 2, 2, 2581, 2573, 3, 2, 2, 2, 2581, 2574, 3, 2, 2, 2, 2581, 2575, 3,
	2, 2, 2, 2581, 2576, 3, 2, 2, 2, 2581, 2577, 3, 2, 2, 2, 2581, 2578, 3,
	2, 2, 2, 2581, 2579, 3, 2, 2, 2, 2581, 2580, 3, 2, 2, 2, 2582, 2585, 3,
	2, 2, 2, 2583, 2581, 3, 2, 2, 2, 2583, 2584, 3, 2, 2, 2, 2584, 2586, 3,
	2, 2, 2, 2585, 2583, 3, 2, 2, 2, 2586, 2587, 7, 541, 2, 2, 2587, 267, 3,
	2, 2, 2, 2588, 2589, 7, 48, 2, 2, 2589, 2590, 9, 20, 2, 2, 2590, 269, 3,
	2, 2, 2, 2591, 2592, 9, 21, 2, 2, 2592, 271, 3, 2, 2, 2, 2593, 2594, 7,
	49, 2, 2, 2594, 273, 3, 2, 2, 2, 2595, 2596, 7, 192, 2, 2, 2596, 2597,
	9, 22, 2, 2, 2597, 275, 3, 2, 2, 2, 2598, 2599, 9, 23, 2, 2, 2599, 277,
	3, 2, 2, 2, 2600, 2601, 9, 24, 2, 2, 2601, 279, 3, 2, 2, 2, 2602, 2603,
	7, 407, 2, 2, 2603, 281, 3, 2, 2, 2, 2604, 2605, 7, 504, 2, 2, 2605, 283,
	3, 2, 2, 2, 2606, 2608, 7, 444, 2, 2, 2607, 2609, 7, 259, 2, 2, 2608, 2607,
	3, 2, 2, 2, 2608, 2609, 3, 2, 2, 2, 2609, 2612, 3, 2, 2, 2, 2610, 2613,
	5, 1068, 535, 2, 2611, 2613, 5, 1172, 587, 2, 2612, 2610, 3, 2, 2, 2, 2612,
	2611, 3, 2, 2, 2, 2613, 285, 3, 2, 2, 2, 2614, 2622, 7, 284, 2, 2, 2615,
	2617, 7, 321, 2, 2, 2616, 2615, 3, 2, 2, 2, 2616, 2617, 3, 2, 2, 2, 2617,
	2619, 3, 2, 2, 2, 2618, 2620, 7, 259, 2, 2, 2619, 2618, 3, 2, 2, 2, 2619,
	2620, 3, 2, 2, 2, 2620, 2621, 3, 2, 2, 2, 2621, 2623, 9, 25, 2, 2, 2622,
	2616, 3, 2, 2, 2, 2622, 2623, 3, 2, 2, 2, 2623, 2626, 3, 2, 2, 2, 2624,
	2627, 5, 1068, 535, 2, 2625, 2627, 5, 1172, 587, 2, 2626, 2624, 3, 2, 2,
	2, 2626, 2625, 3, 2, 2, 2, 2627, 287, 3, 2, 2, 2, 2628, 2636, 9, 26, 2,
	2, 2629, 2631, 7, 321, 2, 2, 2630, 2629, 3, 2, 2, 2, 2630, 2631, 3, 2,
	2, 2, 2631, 2633, 3, 2, 2, 2, 2632, 2634, 7, 259, 2, 2, 2633, 2632, 3,
	2, 2, 2, 2633, 2634, 3, 2, 2, 2, 2634, 2635, 3, 2, 2, 2, 2635, 2637, 9,
	25, 2, 2, 2636, 2630, 3, 2, 2, 2, 2636, 2637, 3, 2, 2, 2, 2637, 2640, 3,
	2, 2, 2, 2638, 2641, 5, 1068, 535, 2, 2639, 2641, 5, 1172, 587, 2, 2640,
	2638, 3, 2, 2, 2, 2640, 2639, 3, 2, 2, 2, 2641, 289, 3, 2, 2, 2, 2642,
	2644, 9, 27, 2, 2, 2643, 2645, 7, 259, 2, 2, 2644, 2643, 3, 2, 2, 2, 2644,
	2645, 3, 2, 2, 2, 2645, 2648, 3, 2, 2, 2, 2646, 2649, 5, 1068, 535, 2,
	2647, 2649, 5, 1172, 587, 2, 2648, 2646, 3, 2, 2, 2, 2648, 2647, 3, 2,
	2, 2, 2649, 291, 3, 2, 2, 2, 2650, 2652, 9, 28, 2, 2, 2651, 2653, 7, 259,
	2, 2, 2652, 2651, 3, 2, 2, 2, 2652, 2653, 3, 2, 2, 2, 2653, 2656, 3, 2,
	2, 2, 2654, 2657, 5, 1068, 535, 2, 2655, 2657, 5, 1172, 587, 2, 2656, 2654,
	3, 2, 2, 2, 2656, 2655, 3, 2, 2, 2, 2657, 293, 3, 2, 2, 2, 2658, 2660,
	7, 102, 2, 2, 2659, 2661, 7, 259, 2, 2, 2660, 2659, 3, 2, 2, 2, 2660, 2661,
	3, 2, 2, 2, 2661, 2662, 3, 2, 2, 2, 2662, 2663, 5, 1068, 535, 2, 2663,
	295, 3, 2, 2, 2, 2664, 2666, 7, 513, 2, 2, 2665, 2667, 7, 259, 2, 2, 2666,
	2665, 3, 2, 2, 2, 2666, 2667, 3, 2, 2, 2, 2667, 2668, 3, 2, 2, 2, 2668,
	2669, 5, 1166, 584, 2, 2669, 297, 3, 2, 2, 2, 2670, 2672, 9, 29, 2, 2,
	2671, 2673, 7, 259, 2, 2, 2672, 2671, 3, 2, 2, 2, 2672, 2673, 3, 2, 2,
	2, 2673, 2674, 3, 2, 2, 2, 2674, 2675, 5, 474, 238, 2, 2675, 299, 3, 2,
	2, 2, 2676, 2679, 7, 220, 2, 2, 2677, 2680, 5, 1068, 535, 2, 2678, 2680,
	5, 1166, 584, 2, 2679, 2677, 3, 2, 2, 2, 2679, 2678, 3, 2, 2, 2, 2680,
	2682, 3, 2, 2, 2, 2681, 2683, 5, 302, 152, 2, 2682, 2681, 3, 2, 2, 2, 2682,
	2683, 3, 2, 2, 2, 2683, 301, 3, 2, 2, 2, 2684, 2685, 7, 495, 2, 2, 2685,
	2686, 5, 1068, 535, 2, 2686, 303, 3, 2, 2, 2, 2687, 2688, 7, 512, 2, 2,
	2688, 2689, 5, 1068, 535, 2, 2689, 305, 3, 2, 2, 2, 2690, 2692, 7, 510,
	2, 2, 2691, 2693, 7, 259, 2, 2, 2692, 2691, 3, 2, 2, 2, 2692, 2693, 3,
	2, 2, 2, 2693, 2694, 3, 2, 2, 2, 2694, 2695, 9, 30, 2, 2, 2695, 307, 3,
	2, 2, 2, 2696, 2698, 7, 48, 2, 2, 2697, 2699, 7, 518, 2, 2, 2698, 2697,
	3, 2, 2, 2, 2698, 2699, 3, 2, 2, 2, 2699, 2700, 3, 2, 2, 2, 2700, 2701,
	7, 528, 2, 2, 2701, 309, 3, 2, 2, 2, 2702, 2704, 9, 31, 2, 2, 2703, 2705,
	7, 416, 2, 2, 2704, 2703, 3, 2, 2, 2, 2704, 2705, 3, 2, 2, 2, 2705, 311,
	3, 2, 2, 2, 2706, 2708, 7, 443, 2, 2, 2707, 2709, 7, 259, 2, 2, 2708, 2707,
	3, 2, 2, 2, 2708, 2709, 3, 2, 2, 2, 2709, 2711, 3, 2, 2, 2, 2710, 2706,
	3, 2, 2, 2, 2710, 2711, 3, 2, 2, 2, 2711, 2712, 3, 2, 2, 2, 2712, 2717,
	9, 10, 2, 2, 2713, 2715, 7, 432, 2, 2, 2714, 2716, 7, 66, 2, 2, 2715, 2714,
	3, 2, 2, 2, 2715, 2716, 3, 2, 2, 2, 2716, 2718, 3, 2, 2, 2, 2717, 2713,
	3, 2, 2, 2, 2717, 2718, 3, 2, 2, 2, 2718, 313, 3, 2, 2, 2, 2719, 2720,
	9, 32, 2, 2, 2720, 315, 3, 2, 2, 2, 2721, 2722, 9, 33, 2, 2, 2722, 317,
	3, 2, 2, 2, 2723, 2724, 9, 34, 2, 2, 2724, 319, 3, 2, 2, 2, 2725, 2727,
	7, 371, 2, 2, 2726, 2728, 7, 66, 2, 2, 2727, 2726, 3, 2, 2, 2, 2727, 2728,
	3, 2, 2, 2, 2728, 2730, 3, 2, 2, 2, 2729, 2731, 7, 259, 2, 2, 2730, 2729,
	3, 2, 2, 2, 2730, 2731, 3, 2, 2, 2, 2731, 2734, 3, 2, 2, 2, 2732, 2735,
	5, 1068, 535, 2, 2733, 2735, 5, 1166, 584, 2, 2734, 2732, 3, 2, 2, 2, 2734,
	2733, 3, 2, 2, 2, 2735, 2737, 3, 2, 2, 2, 2736, 2738, 5, 322, 162, 2, 2737,
	2736, 3, 2, 2, 2, 2737, 2738, 3, 2, 2, 2, 2738, 321, 3, 2, 2, 2, 2739,
	2740, 7, 327, 2, 2, 2740, 2742, 5, 1172, 587, 2, 2741, 2743, 7, 493, 2,
	2, 2742, 2741, 3, 2, 2, 2, 2742, 2743, 3, 2, 2, 2, 2743, 323, 3, 2, 2,
	2, 2744, 2745, 9, 35, 2, 2, 2745, 325, 3, 2, 2, 2, 2746, 2747, 7, 529,
	2, 2, 2747, 327, 3, 2, 2, 2, 2748, 2749, 7, 401, 2, 2, 2749, 2750, 7, 424,
	2, 2, 2750, 2754, 7, 541, 2, 2, 2751, 2753, 5, 330, 166, 2, 2752, 2751,
	3, 2, 2, 2, 2753, 2756, 3, 2, 2, 2, 2754, 2752, 3, 2, 2, 2, 2754, 2755,
	3, 2, 2, 2, 2755, 329, 3, 2, 2, 2, 2756, 2754, 3, 2, 2, 2, 2757, 2759,
	5, 332, 167, 2, 2758, 2760, 5, 346, 174, 2, 2759, 2758, 3, 2, 2, 2, 2760,
	2761, 3, 2, 2, 2, 2761, 2759, 3, 2, 2, 2, 2761, 2762, 3, 2, 2, 2, 2762,
	331, 3, 2, 2, 2, 2763, 2764, 7, 379, 2, 2, 2764, 2766, 5, 1150, 576, 2,
	2765, 2767, 5, 334, 168, 2, 2766, 2765, 3, 2, 2, 2, 2766, 2767, 3, 2, 2,
	2, 2767, 2781, 3, 2, 2, 2, 2768, 2770, 5, 336, 169, 2, 2769, 2771, 5, 338,
	170, 2, 2770, 2769, 3, 2, 2, 2, 2770, 2771, 3, 2, 2, 2, 2771, 2773, 3,
	2, 2, 2, 2772, 2774, 5, 340, 171, 2, 2773, 2772, 3, 2, 2, 2, 2773, 2774,
	3, 2, 2, 2, 2774, 2776, 3, 2, 2, 2, 2775, 2777, 5, 342, 172, 2, 2776, 2775,
	3, 2, 2, 2, 2776, 2777, 3, 2, 2, 2, 2777, 2779, 3, 2, 2, 2, 2778, 2780,
	5, 344, 173, 2, 2779, 2778, 3, 2, 2, 2, 2779, 2780, 3, 2, 2, 2, 2780, 2782,
	3, 2, 2, 2, 2781, 2768, 3, 2, 2, 2, 2781, 2782, 3, 2, 2, 2, 2782, 2783,
	3, 2, 2, 2, 2783, 2784, 7, 541, 2, 2, 2784, 333, 3, 2, 2, 2, 2785, 2787,
	7, 259, 2, 2, 2786, 2785, 3, 2, 2, 2, 2786, 2787, 3, 2, 2, 2, 2787, 2788,
	3, 2, 2, 2, 2788, 2789, 7, 228, 2, 2, 2789, 335, 3, 2, 2, 2, 2790, 2799,
	7, 347, 2, 2, 2791, 2793, 7, 280, 2, 2, 2792, 2794, 7, 259, 2, 2, 2793,
	2792, 3, 2, 2, 2, 2793, 2794, 3, 2, 2, 2, 2794, 2800, 3, 2, 2, 2, 2795,
	2797, 7, 281, 2, 2, 2796, 2798, 7, 24, 2, 2, 2797, 2796, 3, 2, 2, 2, 2797,
	2798, 3, 2, 2, 2, 2798, 2800, 3, 2, 2, 2, 2799, 2791, 3, 2, 2, 2, 2799,
	2795, 3, 2, 2, 2, 2799, 2800, 3, 2, 2, 2, 2800, 2801, 3, 2, 2, 2, 2801,
	2803, 5, 1172, 587, 2, 2802, 2804, 9, 36, 2, 2, 2803, 2802, 3, 2, 2, 2,
	2803, 2804, 3, 2, 2, 2, 2804, 337, 3, 2, 2, 2, 2805, 2806, 7, 233, 2, 2,
	2806, 2807, 5, 1172, 587, 2, 2807, 339, 3, 2, 2, 2, 2808, 2809, 7, 215,
	2, 2, 2809, 2810, 7, 142, 2, 2, 2810, 2811, 5, 1172, 587, 2, 2811, 341,
	3, 2, 2, 2, 2812, 2813, 7, 267, 2, 2, 2813, 2814, 7, 142, 2, 2, 2814, 2815,
	5, 1172, 587, 2, 2815, 343, 3, 2, 2, 2, 2816, 2817, 7, 216, 2, 2, 2817,
	2818, 5, 1172, 587, 2, 2818, 345, 3, 2, 2, 2, 2819, 2823, 5, 348, 175,
	2, 2820, 2823, 5, 350, 176, 2, 2821, 2823, 5, 352, 177, 2, 2822, 2819,
	3, 2, 2, 2, 2822, 2820, 3, 2, 2, 2, 2822, 2821, 3, 2, 2, 2, 2823, 347,
	3, 2, 2, 2, 2824, 2825, 5, 1172, 587, 2, 2825, 2827, 5, 1122, 562, 2, 2826,
	2828, 5, 362, 182, 2, 2827, 2826, 3, 2, 2, 2, 2827, 2828, 3, 2, 2, 2, 2828,
	2830, 3, 2, 2, 2, 2829, 2831, 5, 368, 185, 2, 2830, 2829, 3, 2, 2, 2, 2830,
	2831, 3, 2, 2, 2, 2831, 2832, 3, 2, 2, 2, 2832, 2834, 5, 384, 193, 2, 2833,
	2835, 5, 396, 199, 2, 2834, 2833, 3, 2, 2, 2, 2834, 2835, 3, 2, 2, 2, 2835,
	2836, 3, 2, 2, 2, 2836, 2837, 7, 541, 2, 2, 2837, 349, 3, 2, 2, 2, 2838,
	2840, 5, 1172, 587, 2, 2839, 2841, 5, 1122, 562, 2, 2840, 2839, 3, 2, 2,
	2, 2840, 2841, 3, 2, 2, 2, 2841, 2843, 3, 2, 2, 2, 2842, 2844, 5, 362,
	182, 2, 2843, 2842, 3, 2, 2, 2, 2843, 2844, 3, 2, 2, 2, 2844, 2845, 3,
	2, 2, 2, 2845, 2846, 5, 396, 199, 2, 2846, 2847, 7, 541, 2, 2, 2847, 351,
	3, 2, 2, 2, 2848, 2850, 5, 1172, 587, 2, 2849, 2851, 5, 1122, 562, 2, 2850,
	2849, 3, 2, 2, 2, 2850, 2851, 3, 2, 2, 2, 2851, 2868, 3, 2, 2, 2, 2852,
	2867, 5, 374, 188, 2, 2853, 2867, 5, 396, 199, 2, 2854, 2867, 5, 378, 190,
	2, 2855, 2867, 5, 360, 181, 2, 2856, 2867, 5, 354, 178, 2, 2857, 2867,
	5, 362, 182, 2, 2858, 2867, 5, 356, 179, 2, 2859, 2864, 5, 380, 191, 2,
	2860, 2864, 5, 402, 202, 2, 2861, 2864, 5, 382, 192, 2, 2862, 2864, 5,
	376, 189, 2, 2863, 2859, 3, 2, 2, 2, 2863, 2860, 3, 2, 2, 2, 2863, 2861,
	3, 2, 2, 2, 2863, 2862, 3, 2, 2, 2, 2864, 2867, 3, 2, 2, 2, 2865, 2867,
	5, 358, 180, 2, 2866, 2852, 3, 2, 2, 2, 2866, 2853, 3, 2, 2, 2, 2866, 2854,
	3, 2, 2, 2, 2866, 2855, 3, 2, 2, 2, 2866, 2856, 3, 2, 2, 2, 2866, 2857,
	3, 2, 2, 2, 2866, 2858, 3, 2, 2, 2, 2866, 2863, 3, 2, 2, 2, 2866, 2865,
	3, 2, 2, 2, 2867, 2870, 3, 2, 2, 2, 2868, 2866, 3, 2, 2, 2, 2868, 2869,
	3, 2, 2, 2, 2869, 2871, 3, 2, 2, 2, 2870, 2868, 3, 2, 2, 2, 2871, 2872,
	7, 541, 2, 2, 2872, 353, 3, 2, 2, 2, 2873, 2875, 7, 48, 2, 2, 2874, 2876,
	7, 518, 2, 2, 2875, 2874, 3, 2, 2, 2, 2875, 2876, 3, 2, 2, 2, 2876, 2877,
	3, 2, 2, 2, 2877, 2878, 7, 528, 2, 2, 2878, 355, 3, 2, 2, 2, 2879, 2881,
	7, 79, 2, 2, 2880, 2882, 7, 321, 2, 2, 2881, 2880, 3, 2, 2, 2, 2881, 2882,
	3, 2, 2, 2, 2882, 2884, 3, 2, 2, 2, 2883, 2885, 7, 259, 2, 2, 2884, 2883,
	3, 2, 2, 2, 2884, 2885, 3, 2, 2, 2, 2885, 2886, 3, 2, 2, 2, 2886, 2887,
	5, 1172, 587, 2, 2887, 357, 3, 2, 2, 2, 2888, 2890, 7, 232, 2, 2, 2889,
	2891, 7, 247, 2, 2, 2890, 2889, 3, 2, 2, 2, 2890, 2891, 3, 2, 2, 2, 2891,
	359, 3, 2, 2, 2, 2892, 2894, 9, 31, 2, 2, 2893, 2895, 7, 416, 2, 2, 2894,
	2893, 3, 2, 2, 2, 2894, 2895, 3, 2, 2, 2, 2895, 361, 3, 2, 2, 2, 2896,
	2898, 7, 284, 2, 2, 2897, 2896, 3, 2, 2, 2, 2897, 2898, 3, 2, 2, 2, 2898,
	2900, 3, 2, 2, 2, 2899, 2901, 7, 321, 2, 2, 2900, 2899, 3, 2, 2, 2, 2900,
	2901, 3, 2, 2, 2, 2901, 2903, 3, 2, 2, 2, 2902, 2904, 7, 259, 2, 2, 2903,
	2902, 3, 2, 2, 2, 2903, 2904, 3, 2, 2, 2, 2904, 2907, 3, 2, 2, 2, 2905,
	2908, 5, 364, 183, 2, 2906, 2908, 5, 366, 184, 2, 2907, 2905, 3, 2, 2,
	2, 2907, 2906, 3, 2, 2, 2, 2908, 363, 3, 2, 2, 2, 2909, 2915, 5, 1172,
	587, 2, 2910, 2912, 7, 332, 2, 2, 2911, 2910, 3, 2, 2, 2, 2911, 2912, 3,
	2, 2, 2, 2912, 2913, 3, 2, 2, 2, 2913, 2914, 7, 313, 2, 2, 2914, 2916,
	7, 347, 2, 2, 2915, 2911, 3, 2, 2, 2, 2915, 2916, 3, 2, 2, 2, 2916, 365,
	3, 2, 2, 2, 2917, 2918, 7, 355, 2, 2, 2918, 2919, 5, 1172, 587, 2, 2919,
	367, 3, 2, 2, 2, 2920, 2921, 7, 313, 2, 2, 2921, 2923, 7, 232, 2, 2, 2922,
	2924, 7, 259, 2, 2, 2923, 2922, 3, 2, 2, 2, 2923, 2924, 3, 2, 2, 2, 2924,
	2928, 3, 2, 2, 2, 2925, 2929, 5, 1172, 587, 2, 2926, 2929, 5, 372, 187,
	2, 2927, 2929, 5, 370, 186, 2, 2928, 2925, 3, 2, 2, 2, 2928, 2926, 3, 2,
	2, 2, 2928, 2927, 3, 2, 2, 2, 2929, 369, 3, 2, 2, 2, 2930, 2931, 7, 355,
	2, 2, 2931, 2932, 5, 1172, 587, 2, 2932, 371, 3, 2, 2, 2, 2933, 2934, 7,
	313, 2, 2, 2934, 2935, 7, 347, 2, 2, 2935, 373, 3, 2, 2, 2, 2936, 2938,
	9, 29, 2, 2, 2937, 2939, 7, 259, 2, 2, 2938, 2937, 3, 2, 2, 2, 2938, 2939,
	3, 2, 2, 2, 2939, 2940, 3, 2, 2, 2, 2940, 2941, 5, 474, 238, 2, 2941, 375,
	3, 2, 2, 2, 2942, 2944, 7, 408, 2, 2, 2943, 2945, 7, 332, 2, 2, 2944, 2943,
	3, 2, 2, 2, 2944, 2945, 3, 2, 2, 2, 2945, 2948, 3, 2, 2, 2, 2946, 2949,
	7, 214, 2, 2, 2947, 2949, 5, 1122, 562, 2, 2948, 2946, 3, 2, 2, 2, 2948,
	2947, 3, 2, 2, 2, 2949, 377, 3, 2, 2, 2, 2950, 2952, 7, 443, 2, 2, 2951,
	2953, 7, 259, 2, 2, 2952, 2951, 3, 2, 2, 2, 2952, 2953, 3, 2, 2, 2, 2953,
	2954, 3, 2, 2, 2, 2954, 2955, 9, 10, 2, 2, 2955, 2957, 7, 432, 2, 2, 2956,
	2958, 7, 66, 2, 2, 2957, 2956, 3, 2, 2, 2, 2957, 2958, 3, 2, 2, 2, 2958,
	379, 3, 2, 2, 2, 2959, 2961, 7, 453, 2, 2, 2960, 2962, 7, 259, 2, 2, 2961,
	2960, 3, 2, 2, 2, 2961, 2962, 3, 2, 2, 2, 2962, 2963, 3, 2, 2, 2, 2963,
	2964, 5, 1068, 535, 2, 2964, 381, 3, 2, 2, 2, 2965, 2966, 7, 470, 2, 2,
	2966, 2973, 5, 1068, 535, 2, 2967, 2969, 7, 536, 2, 2, 2968, 2967, 3, 2,
	2, 2, 2968, 2969, 3, 2, 2, 2, 2969, 2970, 3, 2, 2, 2, 2970, 2972, 5, 1068,
	535, 2, 2971, 2968, 3, 2, 2, 2, 2972, 2975, 3, 2, 2, 2, 2973, 2971, 3,
	2, 2, 2, 2973, 2974, 3, 2, 2, 2, 2974, 2987, 3, 2, 2, 2, 2975, 2973, 3,
	2, 2, 2, 2976, 2977, 7, 509, 2, 2, 2977, 2984, 5, 1122, 562, 2, 2978, 2980,
	7, 536, 2, 2, 2979, 2978, 3, 2, 2, 2, 2979, 2980, 3, 2, 2, 2, 2980, 2981,
	3, 2, 2, 2, 2981, 2983, 5, 1122, 562, 2, 2982, 2979, 3, 2, 2, 2, 2983,
	2986, 3, 2, 2, 2, 2984, 2982, 3, 2, 2, 2, 2984, 2985, 3, 2, 2, 2, 2985,
	2988, 3, 2, 2, 2, 2986, 2984, 3, 2, 2, 2, 2987, 2976, 3, 2, 2, 2, 2987,
	2988, 3, 2, 2, 2, 2988, 383, 3, 2, 2, 2, 2989, 2991, 7, 502, 2, 2, 2990,
	2992, 7, 259, 2, 2, 2991, 2990, 3, 2, 2, 2, 2991, 2992, 3, 2, 2, 2, 2992,
	3000, 3, 2, 2, 2, 2993, 3001, 5, 386, 194, 2, 2994, 3001, 5, 388, 195,
	2, 2995, 3001, 5, 390, 196, 2, 2996, 3001, 5, 392, 197, 2, 2997, 3001,
	5, 394, 198, 2, 2998, 3001, 5, 398, 200, 2, 2999, 3001, 5, 400, 201, 2,
	3000, 2993, 3, 2, 2, 2, 3000, 2994, 3, 2, 2, 2, 3000, 2995, 3, 2, 2, 2,
	3000, 2996, 3, 2, 2, 2, 3000, 2997, 3, 2, 2, 2, 3000, 2998, 3, 2, 2, 2,
	3000, 2999, 3, 2, 2, 2, 3001, 385, 3, 2, 2, 2, 3002, 3003, 7, 401, 2, 2,
	3003, 3006, 7, 233, 2, 2, 3004, 3006, 7, 415, 2, 2, 3005, 3002, 3, 2, 2,
	2, 3005, 3004, 3, 2, 2, 2, 3006, 387, 3, 2, 2, 2, 3007, 3008, 7, 347, 2,
	2, 3008, 3011, 7, 233, 2, 2, 3009, 3011, 7, 352, 2, 2, 3010, 3007, 3, 2,
	2, 2, 3010, 3009, 3, 2, 2, 2, 3011, 389, 3, 2, 2, 2, 3012, 3013, 7, 102,
	2, 2, 3013, 3016, 7, 233, 2, 2, 3014, 3016, 7, 63, 2, 2, 3015, 3012, 3,
	2, 2, 2, 3015, 3014, 3, 2, 2, 2, 3016, 3019, 3, 2, 2, 2, 3017, 3020, 7,
	214, 2, 2, 3018, 3020, 5, 1122, 562, 2, 3019, 3017, 3, 2, 2, 2, 3019, 3018,
	3, 2, 2, 2, 3020, 391, 3, 2, 2, 2, 3021, 3022, 9, 37, 2, 2, 3022, 393,
	3, 2, 2, 2, 3023, 3024, 7, 102, 2, 2, 3024, 3027, 7, 216, 2, 2, 3025, 3027,
	7, 62, 2, 2, 3026, 3023, 3, 2, 2, 2, 3026, 3025, 3, 2, 2, 2, 3027, 3030,
	3, 2, 2, 2, 3028, 3031, 7, 214, 2, 2, 3029, 3031, 5, 1122, 562, 2, 3030,
	3028, 3, 2, 2, 2, 3030, 3029, 3, 2, 2, 2, 3031, 395, 3, 2, 2, 2, 3032,
	3034, 7, 510, 2, 2, 3033, 3035, 7, 259, 2, 2, 3034, 3033, 3, 2, 2, 2, 3034,
	3035, 3, 2, 2, 2, 3035, 3037, 3, 2, 2, 2, 3036, 3032, 3, 2, 2, 2, 3036,
	3037, 3, 2, 2, 2, 3037, 3038, 3, 2, 2, 2, 3038, 3039, 9, 30, 2, 2, 3039,
	397, 3, 2, 2, 2, 3040, 3041, 7, 347, 2, 2, 3041, 3044, 7, 216, 2, 2, 3042,
	3044, 7, 351, 2, 2, 3043, 3040, 3, 2, 2, 2, 3043, 3042, 3, 2, 2, 2, 3044,
	399, 3, 2, 2, 2, 3045, 3046, 7, 401, 2, 2, 3046, 3049, 7, 216, 2, 2, 3047,
	3049, 7, 414, 2, 2, 3048, 3045, 3, 2, 2, 2, 3048, 3047, 3, 2, 2, 2, 3049,
	401, 3, 2, 2, 2, 3050, 3052, 7, 513, 2, 2, 3051, 3053, 7, 259, 2, 2, 3052,
	3051, 3, 2, 2, 2, 3052, 3053, 3, 2, 2, 2, 3053, 3054, 3, 2, 2, 2, 3054,
	3055, 5, 1166, 584, 2, 3055, 403, 3, 2, 2, 2, 3056, 3057, 7, 370, 2, 2,
	3057, 3058, 7, 424, 2, 2, 3058, 3062, 7, 541, 2, 2, 3059, 3061, 5, 406,
	204, 2, 3060, 3059, 3, 2, 2, 2, 3061, 3064, 3, 2, 2, 2, 3062, 3060, 3,
	2, 2, 2, 3062, 3063, 3, 2, 2, 2, 3063, 405, 3, 2, 2, 2, 3064, 3062, 3,
	2, 2, 2, 3065, 3068, 5, 408, 205, 2, 3066, 3068, 5, 410, 206, 2, 3067,
	3065, 3, 2, 2, 2, 3067, 3066, 3, 2, 2, 2, 3068, 407, 3, 2, 2, 2, 3069,
	3070, 7, 269, 2, 2, 3070, 3071, 5, 1136, 569, 2, 3071, 3073, 7, 205, 2,
	2, 3072, 3074, 5, 412, 207, 2, 3073, 3072, 3, 2, 2, 2, 3073, 3074, 3, 2,
	2, 2, 3074, 3076, 3, 2, 2, 2, 3075, 3077, 5, 422, 212, 2, 3076, 3075, 3,
	2, 2, 2, 3076, 3077, 3, 2, 2, 2, 3077, 409, 3, 2, 2, 2, 3078, 3079, 7,
	268, 2, 2, 3079, 3080, 5, 1136, 569, 2, 3080, 3082, 7, 243, 2, 2, 3081,
	3083, 5, 440, 221, 2, 3082, 3081, 3, 2, 2, 2, 3082, 3083, 3, 2, 2, 2, 3083,
	3085, 3, 2, 2, 2, 3084, 3086, 5, 438, 220, 2, 3085, 3084, 3, 2, 2, 2, 3085,
	3086, 3, 2, 2, 2, 3086, 3091, 3, 2, 2, 2, 3087, 3090, 5, 414, 208, 2, 3088,
	3090, 5, 424, 213, 2, 3089, 3087, 3, 2, 2, 2, 3089, 3088, 3, 2, 2, 2, 3090,
	3093, 3, 2, 2, 2, 3091, 3089, 3, 2, 2, 2, 3091, 3092, 3, 2, 2, 2, 3092,
	411, 3, 2, 2, 2, 3093, 3091, 3, 2, 2, 2, 3094, 3100, 7, 35, 2, 2, 3095,
	3097, 7, 439, 2, 2, 3096, 3098, 7, 259, 2, 2, 3097, 3096, 3, 2, 2, 2, 3097,
	3098, 3, 2, 2, 2, 3098, 3099, 3, 2, 2, 2, 3099, 3101, 9, 38, 2, 2, 3100,
	3095, 3, 2, 2, 2, 3100, 3101, 3, 2, 2, 2, 3101, 413, 3, 2, 2, 2, 3102,
	3104, 7, 35, 2, 2, 3103, 3105, 5, 416, 209, 2, 3104, 3103, 3, 2, 2, 2,
	3104, 3105, 3, 2, 2, 2, 3105, 3111, 3, 2, 2, 2, 3106, 3108, 7, 277, 2,
	2, 3107, 3109, 7, 259, 2, 2, 3108, 3107, 3, 2, 2, 2, 3108, 3109, 3, 2,
	2, 2, 3109, 3110, 3, 2, 2, 2, 3110, 3112, 9, 39, 2, 2, 3111, 3106, 3, 2,
	2, 2, 3111, 3112, 3, 2, 2, 2, 3112, 3114, 3, 2, 2, 2, 3113, 3115, 5, 418,
	210, 2, 3114, 3113, 3, 2, 2, 2, 3114, 3115, 3, 2, 2, 2, 3115, 3117, 3,
	2, 2, 2, 3116, 3118, 5, 420, 211, 2, 3117, 3116, 3, 2, 2, 2, 3117, 3118,
	3, 2, 2, 2, 3118, 415, 3, 2, 2, 2, 3119, 3120, 7, 223, 2, 2, 3120, 3121,
	7, 259, 2, 2, 3121, 3122, 5, 1166, 584, 2, 3122, 417, 3, 2, 2, 2, 3123,
	3125, 7, 278, 2, 2, 3124, 3126, 7, 259, 2, 2, 3125, 3124, 3, 2, 2, 2, 3125,
	3126, 3, 2, 2, 2, 3126, 3127, 3, 2, 2, 2, 3127, 3128, 5, 1166, 584, 2,
	3128, 419, 3, 2, 2, 2, 3129, 3131, 7, 494, 2, 2, 3130, 3132, 7, 259, 2,
	2, 3131, 3130, 3, 2, 2, 2, 3131, 3132, 3, 2, 2, 2, 3132, 3133, 3, 2, 2,
	2, 3133, 3134, 5, 1166, 584, 2, 3134, 421, 3, 2, 2, 2, 3135, 3136, 7, 188,
	2, 2, 3136, 3138, 5, 1146, 574, 2, 3137, 3139, 5, 426, 214, 2, 3138, 3137,
	3, 2, 2, 2, 3138, 3139, 3, 2, 2, 2, 3139, 423, 3, 2, 2, 2, 3140, 3141,
	7, 188, 2, 2, 3141, 3143, 5, 1146, 574, 2, 3142, 3144, 5, 426, 214, 2,
	3143, 3142, 3, 2, 2, 2, 3143, 3144, 3, 2, 2, 2, 3144, 3146, 3, 2, 2, 2,
	3145, 3147, 5, 434, 218, 2, 3146, 3145, 3, 2, 2, 2, 3146, 3147, 3, 2, 2,
	2, 3147, 3149, 3, 2, 2, 2, 3148, 3150, 5, 430, 216, 2, 3149, 3148, 3, 2,
	2, 2, 3149, 3150, 3, 2, 2, 2, 3150, 3152, 3, 2, 2, 2, 3151, 3153, 5, 428,
	215, 2, 3152, 3151, 3, 2, 2, 2, 3152, 3153, 3, 2, 2, 2, 3153, 425, 3, 2,
	2, 2, 3154, 3155, 7, 217, 2, 2, 3155, 3156, 5, 1166, 584, 2, 3156, 427,
	3, 2, 2, 2, 3157, 3158, 7, 227, 2, 2, 3158, 3159, 5, 1122, 562, 2, 3159,
	429, 3, 2, 2, 2, 3160, 3162, 7, 512, 2, 2, 3161, 3163, 5, 432, 217, 2,
	3162, 3161, 3, 2, 2, 2, 3163, 3164, 3, 2, 2, 2, 3164, 3162, 3, 2, 2, 2,
	3164, 3165, 3, 2, 2, 2, 3165, 431, 3, 2, 2, 2, 3166, 3169, 5, 1122, 562,
	2, 3167, 3169, 5, 1128, 565, 2, 3168, 3166, 3, 2, 2, 2, 3168, 3167, 3,
	2, 2, 2, 3169, 433, 3, 2, 2, 2, 3170, 3172, 7, 520, 2, 2, 3171, 3173, 5,
	436, 219, 2, 3172, 3171, 3, 2, 2, 2, 3173, 3174, 3, 2, 2, 2, 3174, 3172,
	3, 2, 2, 2, 3174, 3175, 3, 2, 2, 2, 3175, 435, 3, 2, 2, 2, 3176, 3179,
	5, 1138, 570, 2, 3177, 3179, 5, 1128, 565, 2, 3178, 3176, 3, 2, 2, 2, 3178,
	3177, 3, 2, 2, 2, 3179, 437, 3, 2, 2, 2, 3180, 3182, 7, 259, 2, 2, 3181,
	3180, 3, 2, 2, 2, 3181, 3182, 3, 2, 2, 2, 3182, 3183, 3, 2, 2, 2, 3183,
	3184, 7, 83, 2, 2, 3184, 439, 3, 2, 2, 2, 3185, 3187, 7, 259, 2, 2, 3186,
	3185, 3, 2, 2, 2, 3186, 3187, 3, 2, 2, 2, 3187, 3188, 3, 2, 2, 2, 3188,
	3189, 7, 228, 2, 2, 3189, 441, 3, 2, 2, 2, 3190, 3195, 5, 444, 223, 2,
	3191, 3195, 5, 446, 224, 2, 3192, 3195, 5, 448, 225, 2, 3193, 3195, 5,
	450, 226, 2, 3194, 3190, 3, 2, 2, 2, 3194, 3191, 3, 2, 2, 2, 3194, 3192,
	3, 2, 2, 2, 3194, 3193, 3, 2, 2, 2, 3195, 443, 3, 2, 2, 2, 3196, 3199,
	9, 40, 2, 2, 3197, 3200, 7, 213, 2, 2, 3198, 3200, 5, 1122, 562, 2, 3199,
	3197, 3, 2, 2, 2, 3199, 3198, 3, 2, 2, 2, 3199, 3200, 3, 2, 2, 2, 3200,
	3202, 3, 2, 2, 2, 3201, 3203, 5, 486, 244, 2, 3202, 3201, 3, 2, 2, 2, 3202,
	3203, 3, 2, 2, 2, 3203, 3205, 3, 2, 2, 2, 3204, 3206, 5, 462, 232, 2, 3205,
	3204, 3, 2, 2, 2, 3205, 3206, 3, 2, 2, 2, 3206, 3208, 3, 2, 2, 2, 3207,
	3209, 5, 458, 230, 2, 3208, 3207, 3, 2, 2, 2, 3208, 3209, 3, 2, 2, 2, 3209,
	3211, 3, 2, 2, 2, 3210, 3212, 5, 460, 231, 2, 3211, 3210, 3, 2, 2, 2, 3211,
	3212, 3, 2, 2, 2, 3212, 3214, 3, 2, 2, 2, 3213, 3215, 5, 498, 250, 2, 3214,
	3213, 3, 2, 2, 2, 3214, 3215, 3, 2, 2, 2, 3215, 3217, 3, 2, 2, 2, 3216,
	3218, 5, 494, 248, 2, 3217, 3216, 3, 2, 2, 2, 3217, 3218, 3, 2, 2, 2, 3218,
	3233, 3, 2, 2, 2, 3219, 3232, 5, 472, 237, 2, 3220, 3232, 5, 456, 229,
	2, 3221, 3232, 5, 496, 249, 2, 3222, 3232, 5, 502, 252, 2, 3223, 3232,
	5, 504, 253, 2, 3224, 3232, 5, 500, 251, 2, 3225, 3232, 5, 482, 242, 2,
	3226, 3232, 5, 466, 234, 2, 3227, 3232, 5, 490, 246, 2, 3228, 3232, 5,
	492, 247, 2, 3229, 3232, 5, 464, 233, 2, 3230, 3232, 5, 454, 228, 2, 3231,
	3219, 3, 2, 2, 2, 3231, 3220, 3, 2, 2, 2, 3231, 3221, 3, 2, 2, 2, 3231,
	3222, 3, 2, 2, 2, 3231, 3223, 3, 2, 2, 2, 3231, 3224, 3, 2, 2, 2, 3231,
	3225, 3, 2, 2, 2, 3231, 3226, 3, 2, 2, 2, 3231, 3227, 3, 2, 2, 2, 3231,
	3228, 3, 2, 2, 2, 3231, 3229, 3, 2, 2, 2, 3231, 3230, 3, 2, 2, 2, 3232,
	3235, 3, 2, 2, 2, 3233, 3231, 3, 2, 2, 2, 3233, 3234, 3, 2, 2, 2, 3234,
	3237, 3, 2, 2, 2, 3235, 3233, 3, 2, 2, 2, 3236, 3238, 5, 512, 257, 2, 3237,
	3236, 3, 2, 2, 2, 3237, 3238, 3, 2, 2, 2, 3238, 3240, 3, 2, 2, 2, 3239,
	3241, 5, 452, 227, 2, 3240, 3239, 3, 2, 2, 2, 3240, 3241, 3, 2, 2, 2, 3241,
	3243, 3, 2, 2, 2, 3242, 3244, 5, 484, 243, 2, 3243, 3242, 3, 2, 2, 2, 3243,
	3244, 3, 2, 2, 2, 3244, 3245, 3, 2, 2, 2, 3245, 3246, 7, 541, 2, 2, 3246,
	445, 3, 2, 2, 2, 3247, 3248, 7, 558, 2, 2, 3248, 3249, 5, 1122, 562, 2,
	3249, 3250, 5, 488, 245, 2, 3250, 3251, 7, 541, 2, 2, 3251, 447, 3, 2,
	2, 2, 3252, 3253, 7, 560, 2, 2, 3253, 3254, 5, 1120, 561, 2, 3254, 3255,
	5, 504, 253, 2, 3255, 3256, 7, 541, 2, 2, 3256, 449, 3, 2, 2, 2, 3257,
	3259, 7, 567, 2, 2, 3258, 3257, 3, 2, 2, 2, 3259, 3260, 3, 2, 2, 2, 3260,
	3258, 3, 2, 2, 2, 3260, 3261, 3, 2, 2, 2, 3261, 3262, 3, 2, 2, 2, 3262,
	3263, 7, 541, 2, 2, 3263, 451, 3, 2, 2, 2, 3264, 3265, 7, 10, 2, 2, 3265,
	453, 3, 2, 2, 2, 3266, 3268, 7, 48, 2, 2, 3267, 3269, 7, 518, 2, 2, 3268,
	3267, 3, 2, 2, 2, 3268, 3269, 3, 2, 2, 2, 3269, 3270, 3, 2, 2, 2, 3270,
	3271, 9, 41, 2, 2, 3271, 455, 3, 2, 2, 2, 3272, 3273, 9, 42, 2, 2, 3273,
	457, 3, 2, 2, 2, 3274, 3276, 7, 259, 2, 2, 3275, 3274, 3, 2, 2, 2, 3275,
	3276, 3, 2, 2, 2, 3276, 3277, 3, 2, 2, 2, 3277, 3280, 7, 208, 2, 2, 3278,
	3279, 7, 53, 2, 2, 3279, 3281, 5, 1166, 584, 2, 3280, 3278, 3, 2, 2, 2,
	3280, 3281, 3, 2, 2, 2, 3281, 459, 3, 2, 2, 2, 3282, 3284, 7, 259, 2, 2,
	3283, 3282, 3, 2, 2, 2, 3283, 3284, 3, 2, 2, 2, 3284, 3285, 3, 2, 2, 2,
	3285, 3286, 7, 228, 2, 2, 3286, 461, 3, 2, 2, 2, 3287, 3288, 9, 43, 2,
	2, 3288, 463, 3, 2, 2, 2, 3289, 3291, 9, 31, 2, 2, 3290, 3292, 7, 416,
	2, 2, 3291, 3290, 3, 2, 2, 2, 3291, 3292, 3, 2, 2, 2, 3292, 465, 3, 2,
	2, 2, 3293, 3294, 7, 327, 2, 2, 3294, 3296, 5, 1172, 587, 2, 3295, 3297,
	5, 468, 235, 2, 3296, 3295, 3, 2, 2, 2, 3296, 3297, 3, 2, 2, 2, 3297, 3299,
	3, 2, 2, 2, 3298, 3300, 7, 493, 2, 2, 3299, 3298, 3, 2, 2, 2, 3299, 3300,
	3, 2, 2, 2, 3300, 3306, 3, 2, 2, 2, 3301, 3303, 7, 139, 2, 2, 3302, 3304,
	7, 332, 2, 2, 3303, 3302, 3, 2, 2, 2, 3303, 3304, 3, 2, 2, 2, 3304, 3305,
	3, 2, 2, 2, 3305, 3307, 5, 1084, 543, 2, 3306, 3301, 3, 2, 2, 2, 3306,
	3307, 3, 2, 2, 2, 3307, 3311, 3, 2, 2, 2, 3308, 3310, 5, 470, 236, 2, 3309,
	3308, 3, 2, 2, 2, 3310, 3313, 3, 2, 2, 2, 3311, 3309, 3, 2, 2, 2, 3311,
	3312, 3, 2, 2, 2, 3312, 3326, 3, 2, 2, 2, 3313, 3311, 3, 2, 2, 2, 3314,
	3316, 7, 246, 2, 2, 3315, 3317, 7, 53, 2, 2, 3316, 3315, 3, 2, 2, 2, 3316,
	3317, 3, 2, 2, 2, 3317, 3319, 3, 2, 2, 2, 3318, 3320, 7, 289, 2, 2, 3319,
	3318, 3, 2, 2, 2, 3319, 3320, 3, 2, 2, 2, 3320, 3322, 3, 2, 2, 2, 3321,
	3323, 5, 1132, 567, 2, 3322, 3321, 3, 2, 2, 2, 3323, 3324, 3, 2, 2, 2,
	3324, 3322, 3, 2, 2, 2, 3324, 3325, 3, 2, 2, 2, 3325, 3327, 3, 2, 2, 2,
	3326, 3314, 3, 2, 2, 2, 3326, 3327, 3, 2, 2, 2, 3327, 467, 3, 2, 2, 2,
	3328, 3329, 7, 495, 2, 2, 3329, 3330, 5, 1172, 587, 2, 3330, 469, 3, 2,
	2, 2, 3331, 3333, 9, 44, 2, 2, 3332, 3334, 7, 264, 2, 2, 3333, 3332, 3,
	2, 2, 2, 3333, 3334, 3, 2, 2, 2, 3334, 3336, 3, 2, 2, 2, 3335, 3337, 7,
	259, 2, 2, 3336, 3335, 3, 2, 2, 2, 3336, 3337, 3, 2, 2, 2, 3337, 3339,
	3, 2, 2, 2, 3338, 3340, 5, 1084, 543, 2, 3339, 3338, 3, 2, 2, 2, 3340,
	3341, 3, 2, 2, 2, 3341, 3339, 3, 2, 2, 2, 3341, 3342, 3, 2, 2, 2, 3342,
	471, 3, 2, 2, 2, 3343, 3345, 9, 29, 2, 2, 3344, 3346, 7, 259, 2, 2, 3345,
	3344, 3, 2, 2, 2, 3345, 3346, 3, 2, 2, 2, 3346, 3347, 3, 2, 2, 2, 3347,
	3348, 5, 474, 238, 2, 3348, 473, 3, 2, 2, 2, 3349, 3351, 5, 476, 239, 2,
	3350, 3349, 3, 2, 2, 2, 3351, 3352, 3, 2, 2, 2, 3352, 3350, 3, 2, 2, 2,
	3352, 3353, 3, 2, 2, 2, 3353, 3355, 3, 2, 2, 2, 3354, 3356, 5, 480, 241,
	2, 3355, 3354, 3, 2, 2, 2, 3355, 3356, 3, 2, 2, 2, 3356, 3358, 3, 2, 2,
	2, 3357, 3350, 3, 2, 2, 2, 3358, 3359, 3, 2, 2, 2, 3359, 3357, 3, 2, 2,
	2, 3359, 3360, 3, 2, 2, 2, 3360, 475, 3, 2, 2, 2, 3361, 3379, 7, 539, 2,
	2, 3362, 3379, 7, 563, 2, 2, 3363, 3379, 7, 562, 2, 2, 3364, 3379, 7, 556,
	2, 2, 3365, 3379, 7, 536, 2, 2, 3366, 3379, 7, 542, 2, 2, 3367, 3379, 7,
	535, 2, 2, 3368, 3379, 7, 533, 2, 2, 3369, 3379, 7, 534, 2, 2, 3370, 3379,
	7, 549, 2, 2, 3371, 3379, 7, 555, 2, 2, 3372, 3379, 7, 553, 2, 2, 3373,
	3379, 7, 550, 2, 2, 3374, 3379, 7, 547, 2, 2, 3375, 3379, 7, 551, 2, 2,
	3376, 3379, 5, 1172, 587, 2, 3377, 3379, 5, 478, 240, 2, 3378, 3361, 3,
	2, 2, 2, 3378, 3362, 3, 2, 2, 2, 3378, 3363, 3, 2, 2, 2, 3378, 3364, 3,
	2, 2, 2, 3378, 3365, 3, 2, 2, 2, 3378, 3366, 3, 2, 2, 2, 3378, 3367, 3,
	2, 2, 2, 3378, 3368, 3, 2, 2, 2, 3378, 3369, 3, 2, 2, 2, 3378, 3370, 3,
	2, 2, 2, 3378, 3371, 3, 2, 2, 2, 3378, 3372, 3, 2, 2, 2, 3378, 3373, 3,
	2, 2, 2, 3378, 3374, 3, 2, 2, 2, 3378, 3375, 3, 2, 2, 2, 3378, 3376, 3,
	2, 2, 2, 3378, 3377, 3, 2, 2, 2, 3379, 477, 3, 2, 2, 2, 3380, 3381, 7,
	455, 2, 2, 3381, 479, 3, 2, 2, 2, 3382, 3383, 7, 549, 2, 2, 3383, 3384,
	5, 1172, 587, 2, 3384, 3385, 7, 555, 2, 2, 3385, 481, 3, 2, 2, 2, 3386,
	3388, 7, 383, 2, 2, 3387, 3386, 3, 2, 2, 2, 3387, 3388, 3, 2, 2, 2, 3388,
	3390, 3, 2, 2, 2, 3389, 3391, 7, 53, 2, 2, 3390, 3389, 3, 2, 2, 2, 3390,
	3391, 3, 2, 2, 2, 3391, 3392, 3, 2, 2, 2, 3392, 3393, 9, 45, 2, 2, 3393,
	483, 3, 2, 2, 2, 3394, 3395, 7, 384, 2, 2, 3395, 3396, 7, 25, 2, 2, 3396,
	485, 3, 2, 2, 2, 3397, 3398, 7, 387, 2, 2, 3398, 3399, 5, 1122, 562, 2,
	3399, 487, 3, 2, 2, 2, 3400, 3401, 7, 398, 2, 2, 3401, 3404, 5, 1084, 543,
	2, 3402, 3403, 9, 7, 2, 2, 3403, 3405, 5, 1084, 543, 2, 3404, 3402, 3,
	2, 2, 2, 3404, 3405, 3, 2, 2, 2, 3405, 489, 3, 2, 2, 2, 3406, 3408, 7,
	443, 2, 2, 3407, 3409, 7, 259, 2, 2, 3408, 3407, 3, 2, 2, 2, 3408, 3409,
	3, 2, 2, 2, 3409, 3411, 3, 2, 2, 2, 3410, 3406, 3, 2, 2, 2, 3410, 3411,
	3, 2, 2, 2, 3411, 3412, 3, 2, 2, 2, 3412, 3417, 9, 10, 2, 2, 3413, 3415,
	7, 432, 2, 2, 3414, 3416, 7, 66, 2, 2, 3415, 3414, 3, 2, 2, 2, 3415, 3416,
	3, 2, 2, 2, 3416, 3418, 3, 2, 2, 2, 3417, 3413, 3, 2, 2, 2, 3417, 3418,
	3, 2, 2, 2, 3418, 491, 3, 2, 2, 2, 3419, 3421, 9, 46, 2, 2, 3420, 3422,
	9, 47, 2, 2, 3421, 3420, 3, 2, 2, 2, 3421, 3422, 3, 2, 2, 2, 3422, 493,
	3, 2, 2, 2, 3423, 3425, 7, 259, 2, 2, 3424, 3423, 3, 2, 2, 2, 3424, 3425,
	3, 2, 2, 2, 3425, 3426, 3, 2, 2, 2, 3426, 3427, 7, 488, 2, 2, 3427, 495,
	3, 2, 2, 2, 3428, 3430, 7, 502, 2, 2, 3429, 3431, 7, 259, 2, 2, 3430, 3429,
	3, 2, 2, 2, 3430, 3431, 3, 2, 2, 2, 3431, 3432, 3, 2, 2, 2, 3432, 3433,
	9, 48, 2, 2, 3433, 497, 3, 2, 2, 2, 3434, 3436, 7, 259, 2, 2, 3435, 3434,
	3, 2, 2, 2, 3435, 3436, 3, 2, 2, 2, 3436, 3437, 3, 2, 2, 2, 3437, 3438,
	7, 503, 2, 2, 3438, 499, 3, 2, 2, 2, 3439, 3441, 7, 510, 2, 2, 3440, 3442,
	7, 259, 2, 2, 3441, 3440, 3, 2, 2, 2, 3441, 3442, 3, 2, 2, 2, 3442, 3444,
	3, 2, 2, 2, 3443, 3439, 3, 2, 2, 2, 3443, 3444, 3, 2, 2, 2, 3444, 3478,
	3, 2, 2, 2, 3445, 3447, 7, 46, 2, 2, 3446, 3448, 9, 49, 2, 2, 3447, 3446,
	3, 2, 2, 2, 3447, 3448, 3, 2, 2, 2, 3448, 3479, 3, 2, 2, 2, 3449, 3479,
	7, 47, 2, 2, 3450, 3479, 7, 85, 2, 2, 3451, 3479, 7, 86, 2, 2, 3452, 3479,
	7, 87, 2, 2, 3453, 3479, 7, 88, 2, 2, 3454, 3479, 7, 89, 2, 2, 3455, 3479,
	7, 90, 2, 2, 3456, 3479, 7, 91, 2, 2, 3457, 3479, 7, 92, 2, 2, 3458, 3479,
	7, 93, 2, 2, 3459, 3479, 7, 94, 2, 2, 3460, 3479, 7, 95, 2, 2, 3461, 3479,
	7, 96, 2, 2, 3462, 3479, 7, 103, 2, 2, 3463, 3479, 7, 116, 2, 2, 3464,
	3479, 7, 147, 2, 2, 3465, 3479, 7, 148, 2, 2, 3466, 3479, 7, 152, 2, 2,
	3467, 3479, 7, 199, 2, 2, 3468, 3479, 7, 224, 2, 2, 3469, 3479, 7, 245,
	2, 2, 3470, 3479, 7, 262, 2, 2, 3471, 3479, 7, 291, 2, 2, 3472, 3479, 7,
	309, 2, 2, 3473, 3479, 7, 345, 2, 2, 3474, 3479, 7, 356, 2, 2, 3475, 3479,
	7, 364, 2, 2, 3476, 3479, 7, 380, 2, 2, 3477, 3479, 7, 479, 2, 2, 3478,
	3445, 3, 2, 2, 2, 3478, 3449, 3, 2, 2, 2, 3478, 3450, 3, 2, 2, 2, 3478,
	3451, 3, 2, 2, 2, 3478, 3452, 3, 2, 2, 2, 3478, 3453, 3, 2, 2, 2, 3478,
	3454, 3, 2, 2, 2, 3478, 3455, 3, 2, 2, 2, 3478, 3456, 3, 2, 2, 2, 3478,
	3457, 3, 2, 2, 2, 3478, 3458, 3, 2, 2, 2, 3478, 3459, 3, 2, 2, 2, 3478,
	3460, 3, 2, 2, 2, 3478, 3461, 3, 2, 2, 2, 3478, 3462, 3, 2, 2, 2, 3478,
	3463, 3, 2, 2, 2, 3478, 3464, 3, 2, 2, 2, 3478, 3465, 3, 2, 2, 2, 3478,
	3466, 3, 2, 2, 2, 3478, 3467, 3, 2, 2, 2, 3478, 3468, 3, 2, 2, 2, 3478,
	3469, 3, 2, 2, 2, 3478, 3470, 3, 2, 2, 2, 3478, 3471, 3, 2, 2, 2, 3478,
	3472, 3, 2, 2, 2, 3478, 3473, 3, 2, 2, 2, 3478, 3474, 3, 2, 2, 2, 3478,
	3475, 3, 2, 2, 2, 3478, 3476, 3, 2, 2, 2, 3478, 3477, 3, 2, 2, 2, 3479,
	501, 3, 2, 2, 2, 3480, 3481, 7, 512, 2, 2, 3481, 3483, 9, 50, 2, 2, 3482,
	3484, 7, 329, 2, 2, 3483, 3482, 3, 2, 2, 2, 3483, 3484, 3, 2, 2, 2, 3484,
	3487, 3, 2, 2, 2, 3485, 3488, 5, 1164, 583, 2, 3486, 3488, 5, 1122, 562,
	2, 3487, 3485, 3, 2, 2, 2, 3487, 3486, 3, 2, 2, 2, 3488, 503, 3, 2, 2,
	2, 3489, 3491, 7, 513, 2, 2, 3490, 3492, 7, 259, 2, 2, 3491, 3490, 3, 2,
	2, 2, 3491, 3492, 3, 2, 2, 2, 3492, 3498, 3, 2, 2, 2, 3493, 3495, 7, 514,
	2, 2, 3494, 3496, 7, 24, 2, 2, 3495, 3494, 3, 2, 2, 2, 3495, 3496, 3, 2,
	2, 2, 3496, 3498, 3, 2, 2, 2, 3497, 3489, 3, 2, 2, 2, 3497, 3493, 3, 2,
	2, 2, 3497, 3498, 3, 2, 2, 2, 3498, 3500, 3, 2, 2, 2, 3499, 3501, 5, 506,
	254, 2, 3500, 3499, 3, 2, 2, 2, 3501, 3502, 3, 2, 2, 2, 3502, 3500, 3,
	2, 2, 2, 3502, 3503, 3, 2, 2, 2, 3503, 505, 3, 2, 2, 2, 3504, 3506, 5,
	508, 255, 2, 3505, 3507, 5, 510, 256, 2, 3506, 3505, 3, 2, 2, 2, 3506,
	3507, 3, 2, 2, 2, 3507, 507, 3, 2, 2, 2, 3508, 3511, 5, 1166, 584, 2, 3509,
	3511, 5, 1164, 583, 2, 3510, 3508, 3, 2, 2, 2, 3510, 3509, 3, 2, 2, 2,
	3511, 509, 3, 2, 2, 2, 3512, 3513, 9, 7, 2, 2, 3513, 3514, 5, 1166, 584,
	2, 3514, 511, 3, 2, 2, 2, 3515, 3517, 7, 520, 2, 2, 3516, 3515, 3, 2, 2,
	2, 3516, 3517, 3, 2, 2, 2, 3517, 3518, 3, 2, 2, 2, 3518, 3519, 7, 294,
	2, 2, 3519, 3520, 7, 51, 2, 2, 3520, 513, 3, 2, 2, 2, 3521, 3522, 7, 363,
	2, 2, 3522, 3524, 7, 150, 2, 2, 3523, 3525, 5, 516, 259, 2, 3524, 3523,
	3, 2, 2, 2, 3524, 3525, 3, 2, 2, 2, 3525, 3527, 3, 2, 2, 2, 3526, 3528,
	5, 518, 260, 2, 3527, 3526, 3, 2, 2, 2, 3527, 3528, 3, 2, 2, 2, 3528, 3529,
	3, 2, 2, 2, 3529, 3531, 7, 541, 2, 2, 3530, 3532, 5, 520, 261, 2, 3531,
	3530, 3, 2, 2, 2, 3531, 3532, 3, 2, 2, 2, 3532, 3533, 3, 2, 2, 2, 3533,
	3534, 5, 526, 264, 2, 3534, 515, 3, 2, 2, 2, 3535, 3542, 7, 512, 2, 2,
	3536, 3537, 7, 465, 2, 2, 3537, 3543, 5, 1122, 562, 2, 3538, 3539, 7, 255,
	2, 2, 3539, 3543, 5, 1122, 562, 2, 3540, 3543, 5, 1122, 562, 2, 3541, 3543,
	5, 1128, 565, 2, 3542, 3536, 3, 2, 2, 2, 3542, 3538, 3, 2, 2, 2, 3542,
	3540, 3, 2, 2, 2, 3542, 3541, 3, 2, 2, 2, 3543, 3544, 3, 2, 2, 2, 3544,
	3542, 3, 2, 2, 2, 3544, 3545, 3, 2, 2, 2, 3545, 517, 3, 2, 2, 2, 3546,
	3547, 7, 227, 2, 2, 3547, 3548, 5, 1122, 562, 2, 3548, 519, 3, 2, 2, 2,
	3549, 3550, 7, 132, 2, 2, 3550, 3552, 7, 541, 2, 2, 3551, 3553, 5, 522,
	262, 2, 3552, 3551, 3, 2, 2, 2, 3553, 3554, 3, 2, 2, 2, 3554, 3552, 3,
	2, 2, 2, 3554, 3555, 3, 2, 2, 2, 3555, 3556, 3, 2, 2, 2, 3556, 3557, 7,
	164, 2, 2, 3557, 3558, 7, 132, 2, 2, 3558, 3559, 7, 541, 2, 2, 3559, 521,
	3, 2, 2, 2, 3560, 3561, 5, 524, 263, 2, 3561, 3562, 7, 541, 2, 2, 3562,
	3563, 5, 980, 491, 2, 3563, 3564, 7, 541, 2, 2, 3564, 3565, 5, 530, 266,
	2, 3565, 523, 3, 2, 2, 2, 3566, 3567, 5, 1156, 579, 2, 3567, 3569, 7, 424,
	2, 2, 3568, 3570, 5, 1172, 587, 2, 3569, 3568, 3, 2, 2, 2, 3569, 3570,
	3, 2, 2, 2, 3570, 525, 3, 2, 2, 2, 3571, 3575, 5, 530, 266, 2, 3572, 3574,
	5, 528, 265, 2, 3573, 3572, 3, 2, 2, 2, 3574, 3577, 3, 2, 2, 2, 3575, 3573,
	3, 2, 2, 2, 3575, 3576, 3, 2, 2, 2, 3576, 527, 3, 2, 2, 2, 3577, 3575,
	3, 2, 2, 2, 3578, 3579, 5, 524, 263, 2, 3579, 3580, 7, 541, 2, 2, 3580,
	3581, 5, 530, 266, 2, 3581, 529, 3, 2, 2, 2, 3582, 3584, 5, 534, 268, 2,
	3583, 3582, 3, 2, 2, 2, 3584, 3587, 3, 2, 2, 2, 3585, 3583, 3, 2, 2, 2,
	3585, 3586, 3, 2, 2, 2, 3586, 3591, 3, 2, 2, 2, 3587, 3585, 3, 2, 2, 2,
	3588, 3590, 5, 532, 267, 2, 3589, 3588, 3, 2, 2, 2, 3590, 3593, 3, 2, 2,
	2, 3591, 3589, 3, 2, 2, 2, 3591, 3592, 3, 2, 2, 2, 3592, 531, 3, 2, 2,
	2, 3593, 3591, 3, 2, 2, 2, 3594, 3595, 5, 1142, 572, 2, 3595, 3603, 7,
	541, 2, 2, 3596, 3604, 5, 562, 282, 2, 3597, 3599, 5, 534, 268, 2, 3598,
	3597, 3, 2, 2, 2, 3599, 3602, 3, 2, 2, 2, 3600, 3598, 3, 2, 2, 2, 3600,
	3601, 3, 2, 2, 2, 3601, 3604, 3, 2, 2, 2, 3602, 3600, 3, 2, 2, 2, 3603,
	3596, 3, 2, 2, 2, 3603, 3600, 3, 2, 2, 2, 3604, 533, 3, 2, 2, 2, 3605,
	3607, 5, 536, 269, 2, 3606, 3605, 3, 2, 2, 2, 3607, 3610, 3, 2, 2, 2, 3608,
	3606, 3, 2, 2, 2, 3608, 3609, 3, 2, 2, 2, 3609, 3611, 3, 2, 2, 2, 3610,
	3608, 3, 2, 2, 2, 3611, 3612, 7, 541, 2, 2, 3612, 535, 3, 2, 2, 2, 3613,
	3663, 5, 538, 270, 2, 3614, 3663, 5, 548, 275, 2, 3615, 3663, 5, 564, 283,
	2, 3616, 3663, 5, 568, 285, 2, 3617, 3663, 5, 588, 295, 2, 3618, 3663,
	5, 592, 297, 2, 3619, 3663, 5, 610, 306, 2, 3620, 3663, 5, 614, 308, 2,
	3621, 3663, 5, 616, 309, 2, 3622, 3663, 5, 618, 310, 2, 3623, 3663, 5,
	620, 311, 2, 3624, 3663, 5, 630, 316, 2, 3625, 3663, 5, 644, 323, 2, 3626,
	3663, 5, 646, 324, 2, 3627, 3663, 5, 648, 325, 2, 3628, 3663, 5, 674, 338,
	2, 3629, 3663, 5, 668, 335, 2, 3630, 3663, 5, 670, 336, 2, 3631, 3663,
	5, 672, 337, 2, 3632, 3663, 5, 678, 340, 2, 3633, 3663, 5, 680, 341, 2,
	3634, 3663, 5, 682, 342, 2, 3635, 3663, 5, 684, 343, 2, 3636, 3663, 5,
	690, 346, 2, 3637, 3663, 5, 696, 349, 2, 3638, 3663, 5, 702, 352, 2, 3639,
	3663, 5, 704, 353, 2, 3640, 3663, 5, 734, 368, 2, 3641, 3663, 5, 754, 378,
	2, 3642, 3663, 5, 762, 382, 2, 3643, 3663, 5, 774, 388, 2, 3644, 3663,
	5, 788, 395, 2, 3645, 3663, 5, 814, 408, 2, 3646, 3663, 5, 816, 409, 2,
	3647, 3663, 5, 824, 413, 2, 3648, 3663, 5, 846, 424, 2, 3649, 3663, 5,
	848, 425, 2, 3650, 3663, 5, 852, 427, 2, 3651, 3663, 5, 856, 429, 2, 3652,
	3663, 5, 862, 432, 2, 3653, 3663, 5, 882, 442, 2, 3654, 3663, 5, 894, 448,
	2, 3655, 3663, 5, 920, 461, 2, 3656, 3663, 5, 924, 463, 2, 3657, 3663,
	5, 926, 464, 2, 3658, 3663, 5, 940, 471, 2, 3659, 3663, 5, 958, 480, 2,
	3660, 3663, 5, 960, 481, 2, 3661, 3663, 5, 990, 496, 2, 3662, 3613, 3,
	2, 2, 2, 3662, 3614, 3, 2, 2, 2, 3662, 3615, 3, 2, 2, 2, 3662, 3616, 3,
	2, 2, 2, 3662, 3617, 3, 2, 2, 2, 3662, 3618, 3, 2, 2, 2, 3662, 3619, 3,
	2, 2, 2, 3662, 3620, 3, 2, 2, 2, 3662, 3621, 3, 2, 2, 2, 3662, 3622, 3,
	2, 2, 2, 3662, 3623, 3, 2, 2, 2, 3662, 3624, 3, 2, 2, 2, 3662, 3625, 3,
	2, 2, 2, 3662, 3626, 3, 2, 2, 2, 3662, 3627, 3, 2, 2, 2, 3662, 3628, 3,
	2, 2, 2, 3662, 3629, 3, 2, 2, 2, 3662, 3630, 3, 2, 2, 2, 3662, 3631, 3,
	2, 2, 2, 3662, 3632, 3, 2, 2, 2, 3662, 3633, 3, 2, 2, 2, 3662, 3634, 3,
	2, 2, 2, 3662, 3635, 3, 2, 2, 2, 3662, 3636, 3, 2, 2, 2, 3662, 3637, 3,
	2, 2, 2, 3662, 3638, 3, 2, 2, 2, 3662, 3639, 3, 2, 2, 2, 3662, 3640, 3,
	2, 2, 2, 3662, 3641, 3, 2, 2, 2, 3662, 3642, 3, 2, 2, 2, 3662, 3643, 3,
	2, 2, 2, 3662, 3644, 3, 2, 2, 2, 3662, 3645, 3, 2, 2, 2, 3662, 3646, 3,
	2, 2, 2, 3662, 3647, 3, 2, 2, 2, 3662, 3648, 3, 2, 2, 2, 3662, 3649, 3,
	2, 2, 2, 3662, 3650, 3, 2, 2, 2, 3662, 3651, 3, 2, 2, 2, 3662, 3652, 3,
	2, 2, 2, 3662, 3653, 3, 2, 2, 2, 3662, 3654, 3, 2, 2, 2, 3662, 3655, 3,
	2, 2, 2, 3662, 3656, 3, 2, 2, 2, 3662, 3657, 3, 2, 2, 2, 3662, 3658, 3,
	2, 2, 2, 3662, 3659, 3, 2, 2, 2, 3662, 3660, 3, 2, 2, 2, 3662, 3661, 3,
	2, 2, 2, 3663, 537, 3, 2, 2, 2, 3664, 3665, 7, 4, 2, 2, 3665, 3670, 5,
	1068, 535, 2, 3666, 3671, 5, 540, 271, 2, 3667, 3671, 5, 544, 273, 2, 3668,
	3671, 5, 542, 272, 2, 3669, 3671, 5, 546, 274, 2, 3670, 3666, 3, 2, 2,
	2, 3670, 3667, 3, 2, 2, 2, 3670, 3668, 3, 2, 2, 2, 3670, 3669, 3, 2, 2,
	2, 3670, 3671, 3, 2, 2, 2, 3671, 539, 3, 2, 2, 2, 3672, 3692, 7, 220, 2,
	2, 3673, 3675, 7, 116, 2, 2, 3674, 3676, 7, 526, 2, 2, 3675, 3674, 3, 2,
	2, 2, 3675, 3676, 3, 2, 2, 2, 3676, 3693, 3, 2, 2, 2, 3677, 3679, 7, 119,
	2, 2, 3678, 3680, 7, 527, 2, 2, 3679, 3678, 3, 2, 2, 2, 3679, 3680, 3,
	2, 2, 2, 3680, 3693, 3, 2, 2, 2, 3681, 3693, 7, 120, 2, 2, 3682, 3693,
	7, 491, 2, 2, 3683, 3693, 7, 492, 2, 2, 3684, 3686, 7, 496, 2, 2, 3685,
	3687, 7, 301, 2, 2, 3686, 3685, 3, 2, 2, 2, 3686, 3687, 3, 2, 2, 2, 3687,
	3693, 3, 2, 2, 2, 3688, 3693, 7, 497, 2, 2, 3689, 3693, 7, 525, 2, 2, 3690,
	3693, 7, 526, 2, 2, 3691, 3693, 7, 527, 2, 2, 3692, 3673, 3, 2, 2, 2, 3692,
	3677, 3, 2, 2, 2, 3692, 3681, 3, 2, 2, 2, 3692, 3682, 3, 2, 2, 2, 3692,
	3683, 3, 2, 2, 2, 3692, 3684, 3, 2, 2, 2, 3692, 3688, 3, 2, 2, 2, 3692,
	3689, 3, 2, 2, 2, 3692, 3690, 3, 2, 2, 2, 3692, 3691, 3, 2, 2, 2, 3693,
	541, 3, 2, 2, 2, 3694, 3695, 7, 220, 2, 2, 3695, 3696, 5, 1140, 571, 2,
	3696, 543, 3, 2, 2, 2, 3697, 3698, 7, 220, 2, 2, 3698, 3699, 7, 196, 2,
	2, 3699, 3700, 7, 264, 2, 2, 3700, 545, 3, 2, 2, 2, 3701, 3703, 7, 300,
	2, 2, 3702, 3701, 3, 2, 2, 2, 3702, 3703, 3, 2, 2, 2, 3703, 3704, 3, 2,
	2, 2, 3704, 3705, 7, 110, 2, 2, 3705, 547, 3, 2, 2, 2, 3706, 3710, 7, 6,
	2, 2, 3707, 3711, 5, 550, 276, 2, 3708, 3711, 5, 552, 277, 2, 3709, 3711,
	5, 554, 278, 2, 3710, 3707, 3, 2, 2, 2, 3710, 3708, 3, 2, 2, 2, 3710, 3709,
	3, 2, 2, 2, 3711, 3713, 3, 2, 2, 2, 3712, 3714, 5, 1018, 510, 2, 3713,
	3712, 3, 2, 2, 2, 3713, 3714, 3, 2, 2, 2, 3714, 3716, 3, 2, 2, 2, 3715,
	3717, 5, 1020, 511, 2, 3716, 3715, 3, 2, 2, 2, 3716, 3717, 3, 2, 2, 2,
	3717, 3719, 3, 2, 2, 2, 3718, 3720, 7, 165, 2, 2, 3719, 3718, 3, 2, 2,
	2, 3719, 3720, 3, 2, 2, 2, 3720, 549, 3, 2, 2, 2, 3721, 3723, 5, 556, 279,
	2, 3722, 3721, 3, 2, 2, 2, 3723, 3724, 3, 2, 2, 2, 3724, 3722, 3, 2, 2,
	2, 3724, 3725, 3, 2, 2, 2, 3725, 3726, 3, 2, 2, 2, 3726, 3728, 7, 495,
	2, 2, 3727, 3729, 5, 558, 280, 2, 3728, 3727, 3, 2, 2, 2, 3729, 3730, 3,
	2, 2, 2, 3730, 3728, 3, 2, 2, 2, 3730, 3731, 3, 2, 2, 2, 3731, 551, 3,
	2, 2, 2, 3732, 3734, 5, 556, 279, 2, 3733, 3732, 3, 2, 2, 2, 3734, 3735,
	3, 2, 2, 2, 3735, 3733, 3, 2, 2, 2, 3735, 3736, 3, 2, 2, 2, 3736, 3743,
	3, 2, 2, 2, 3737, 3739, 7, 495, 2, 2, 3738, 3740, 5, 558, 280, 2, 3739,
	3738, 3, 2, 2, 2, 3740, 3741, 3, 2, 2, 2, 3741, 3739, 3, 2, 2, 2, 3741,
	3742, 3, 2, 2, 2, 3742, 3744, 3, 2, 2, 2, 3743, 3737, 3, 2, 2, 2, 3743,
	3744, 3, 2, 2, 2, 3744, 3745, 3, 2, 2, 2, 3745, 3747, 7, 227, 2, 2, 3746,
	3748, 5, 560, 281, 2, 3747, 3746, 3, 2, 2, 2, 3748, 3749, 3, 2, 2, 2, 3749,
	3747, 3, 2, 2, 2, 3749, 3750, 3, 2, 2, 2, 3750, 553, 3, 2, 2, 2, 3751,
	3752, 9, 51, 2, 2, 3752, 3753, 5, 1068, 535, 2, 3753, 3754, 7, 495, 2,
	2, 3754, 3755, 5, 558, 280, 2, 3755, 555, 3, 2, 2, 2, 3756, 3759, 5, 1068,
	535, 2, 3757, 3759, 5, 1166, 584, 2, 3758, 3756, 3, 2, 2, 2, 3758, 3757,
	3, 2, 2, 2, 3759, 557, 3, 2, 2, 2, 3760, 3762, 5, 1068, 535, 2, 3761, 3763,
	7, 417, 2, 2, 3762, 3761, 3, 2, 2, 2, 3762, 3763, 3, 2, 2, 2, 3763, 559,
	3, 2, 2, 2, 3764, 3766, 5, 1068, 535, 2, 3765, 3767, 7, 417, 2, 2, 3766,
	3765, 3, 2, 2, 2, 3766, 3767, 3, 2, 2, 2, 3767, 561, 3, 2, 2, 2, 3768,
	3770, 7, 229, 2, 2, 3769, 3771, 7, 495, 2, 2, 3770, 3769, 3, 2, 2, 2, 3770,
	3771, 3, 2, 2, 2, 3771, 3772, 3, 2, 2, 2, 3772, 3773, 7, 541, 2, 2, 3773,
	563, 3, 2, 2, 2, 3774, 3776, 7, 19, 2, 2, 3775, 3777, 5, 566, 284, 2, 3776,
	3775, 3, 2, 2, 2, 3777, 3778, 3, 2, 2, 2, 3778, 3776, 3, 2, 2, 2, 3778,
	3779, 3, 2, 2, 2, 3779, 565, 3, 2, 2, 2, 3780, 3781, 5, 1144, 573, 2, 3781,
	3784, 7, 495, 2, 2, 3782, 3783, 7, 366, 2, 2, 3783, 3785, 7, 495, 2, 2,
	3784, 3782, 3, 2, 2, 2, 3784, 3785, 3, 2, 2, 2, 3785, 3786, 3, 2, 2, 2,
	3786, 3787, 5, 1144, 573, 2, 3787, 567, 3, 2, 2, 2, 3788, 3791, 7, 56,
	2, 2, 3789, 3792, 5, 1068, 535, 2, 3790, 3792, 5, 1166, 584, 2, 3791, 3789,
	3, 2, 2, 2, 3791, 3790, 3, 2, 2, 2, 3792, 3794, 3, 2, 2, 2, 3793, 3795,
	5, 570, 286, 2, 3794, 3793, 3, 2, 2, 2, 3794, 3795, 3, 2, 2, 2, 3795, 3797,
	3, 2, 2, 2, 3796, 3798, 5, 586, 294, 2, 3797, 3796, 3, 2, 2, 2, 3797, 3798,
	3, 2, 2, 2, 3798, 3800, 3, 2, 2, 2, 3799, 3801, 5, 1014, 508, 2, 3800,
	3799, 3, 2, 2, 2, 3800, 3801, 3, 2, 2, 2, 3801, 3803, 3, 2, 2, 2, 3802,
	3804, 5, 1022, 512, 2, 3803, 3802, 3, 2, 2, 2, 3803, 3804, 3, 2, 2, 2,
	3804, 3806, 3, 2, 2, 2, 3805, 3807, 5, 1024, 513, 2, 3806, 3805, 3, 2,
	2, 2, 3806, 3807, 3, 2, 2, 2, 3807, 3809, 3, 2, 2, 2, 3808, 3810, 7, 166,
	2, 2, 3809, 3808, 3, 2, 2, 2, 3809, 3810, 3, 2, 2, 2, 3810, 569, 3, 2,
	2, 2, 3811, 3813, 7, 512, 2, 2, 3812, 3814, 5, 572, 287, 2, 3813, 3812,
	3, 2, 2, 2, 3814, 3815, 3, 2, 2, 2, 3815, 3813, 3, 2, 2, 2, 3815, 3816,
	3, 2, 2, 2, 3816, 571, 3, 2, 2, 2, 3817, 3821, 5, 574, 288, 2, 3818, 3821,
	5, 578, 290, 2, 3819, 3821, 5, 582, 292, 2, 3820, 3817, 3, 2, 2, 2, 3820,
	3818, 3, 2, 2, 2, 3820, 3819, 3, 2, 2, 2, 3821, 573, 3, 2, 2, 2, 3822,
	3824, 7, 53, 2, 2, 3823, 3822, 3, 2, 2, 2, 3823, 3824, 3, 2, 2, 2, 3824,
	3825, 3, 2, 2, 2, 3825, 3827, 7, 390, 2, 2, 3826, 3823, 3, 2, 2, 2, 3826,
	3827, 3, 2, 2, 2, 3827, 3829, 3, 2, 2, 2, 3828, 3830, 5, 576, 289, 2, 3829,
	3828, 3, 2, 2, 2, 3830, 3831, 3, 2, 2, 2, 3831, 3829, 3, 2, 2, 2, 3831,
	3832, 3, 2, 2, 2, 3832, 575, 3, 2, 2, 2, 3833, 3834, 7, 7, 2, 2, 3834,
	3838, 7, 329, 2, 2, 3835, 3838, 7, 255, 2, 2, 3836, 3838, 7, 465, 2, 2,
	3837, 3833, 3, 2, 2, 2, 3837, 3835, 3, 2, 2, 2, 3837, 3836, 3, 2, 2, 2,
	3837, 3838, 3, 2, 2, 2, 3838, 3839, 3, 2, 2, 2, 3839, 3842, 5, 1068, 535,
	2, 3840, 3842, 5, 1128, 565, 2, 3841, 3837, 3, 2, 2, 2, 3841, 3840, 3,
	2, 2, 2, 3842, 577, 3, 2, 2, 2, 3843, 3845, 7, 53, 2, 2, 3844, 3843, 3,
	2, 2, 2, 3844, 3845, 3, 2, 2, 2, 3845, 3846, 3, 2, 2, 2, 3846, 3848, 7,
	513, 2, 2, 3847, 3849, 5, 580, 291, 2, 3848, 3847, 3, 2, 2, 2, 3849, 3850,
	3, 2, 2, 2, 3850, 3848, 3, 2, 2, 2, 3850, 3851, 3, 2, 2, 2, 3851, 579,
	3, 2, 2, 2, 3852, 3855, 5, 1068, 535, 2, 3853, 3855, 5, 1166, 584, 2, 3854,
	3852, 3, 2, 2, 2, 3854, 3853, 3, 2, 2, 2, 3855, 581, 3, 2, 2, 2, 3856,
	3858, 7, 53, 2, 2, 3857, 3856, 3, 2, 2, 2, 3857, 3858, 3, 2, 2, 2, 3858,
	3859, 3, 2, 2, 2, 3859, 3861, 7, 100, 2, 2, 3860, 3862, 5, 584, 293, 2,
	3861, 3860, 3, 2, 2, 2, 3862, 3863, 3, 2, 2, 2, 3863, 3861, 3, 2, 2, 2,
	3863, 3864, 3, 2, 2, 2, 3864, 583, 3, 2, 2, 2, 3865, 3866, 7, 7, 2, 2,
	3866, 3870, 7, 329, 2, 2, 3867, 3868, 7, 273, 2, 2, 3868, 3870, 7, 329,
	2, 2, 3869, 3865, 3, 2, 2, 2, 3869, 3867, 3, 2, 2, 2, 3869, 3870, 3, 2,
	2, 2, 3870, 3871, 3, 2, 2, 2, 3871, 3874, 5, 1068, 535, 2, 3872, 3874,
	5, 1166, 584, 2, 3873, 3869, 3, 2, 2, 2, 3873, 3872, 3, 2, 2, 2, 3874,
	585, 3, 2, 2, 2, 3875, 3876, 7, 227, 2, 2, 3876, 3877, 5, 1068, 535, 2,
	3877, 587, 3, 2, 2, 2, 3878, 3880, 7, 57, 2, 2, 3879, 3881, 5, 590, 296,
	2, 3880, 3879, 3, 2, 2, 2, 3881, 3882, 3, 2, 2, 2, 3882, 3880, 3, 2, 2,
	2, 3882, 3883, 3, 2, 2, 2, 3883, 589, 3, 2, 2, 2, 3884, 3885, 5, 1136,
	569, 2, 3885, 3886, 9, 39, 2, 2, 3886, 3890, 3, 2, 2, 2, 3887, 3890, 5,
	1068, 535, 2, 3888, 3890, 5, 1166, 584, 2, 3889, 3884, 3, 2, 2, 2, 3889,
	3887, 3, 2, 2, 2, 3889, 3888, 3, 2, 2, 2, 3890, 591, 3, 2, 2, 2, 3891,
	3893, 7, 71, 2, 2, 3892, 3894, 5, 594, 298, 2, 3893, 3892, 3, 2, 2, 2,
	3894, 3895, 3, 2, 2, 2, 3895, 3893, 3, 2, 2, 2, 3895, 3896, 3, 2, 2, 2,
	3896, 593, 3, 2, 2, 2, 3897, 3901, 5, 1128, 565, 2, 3898, 3902, 5, 596,
	299, 2, 3899, 3902, 5, 598, 300, 2, 3900, 3902, 5, 600, 301, 2, 3901, 3898,
	3, 2, 2, 2, 3901, 3899, 3, 2, 2, 2, 3901, 3900, 3, 2, 2, 2, 3901, 3902,
	3, 2, 2, 2, 3902, 595, 3, 2, 2, 2, 3903, 3908, 9, 15, 2, 2, 3904, 3906,
	7, 217, 2, 2, 3905, 3904, 3, 2, 2, 2, 3905, 3906, 3, 2, 2, 2, 3906, 3907,
	3, 2, 2, 2, 3907, 3909, 7, 396, 2, 2, 3908, 3905, 3, 2, 2, 2, 3908, 3909,
	3, 2, 2, 2, 3909, 3918, 3, 2, 2, 2, 3910, 3912, 7, 520, 2, 2, 3911, 3910,
	3, 2, 2, 2, 3911, 3912, 3, 2, 2, 2, 3912, 3916, 3, 2, 2, 2, 3913, 3914,
	7, 314, 2, 2, 3914, 3917, 7, 412, 2, 2, 3915, 3917, 7, 291, 2, 2, 3916,
	3913, 3, 2, 2, 2, 3916, 3915, 3, 2, 2, 2, 3917, 3919, 3, 2, 2, 2, 3918,
	3911, 3, 2, 2, 2, 3918, 3919, 3, 2, 2, 2, 3919, 597, 3, 2, 2, 2, 3920,
	3922, 7, 520, 2, 2, 3921, 3920, 3, 2, 2, 2, 3921, 3922, 3, 2, 2, 2, 3922,
	3926, 3, 2, 2, 2, 3923, 3924, 7, 314, 2, 2, 3924, 3927, 7, 412, 2, 2, 3925,
	3927, 7, 291, 2, 2, 3926, 3923, 3, 2, 2, 2, 3926, 3925, 3, 2, 2, 2, 3927,
	599, 3, 2, 2, 2, 3928, 3930, 7, 520, 2, 2, 3929, 3928, 3, 2, 2, 2, 3929,
	3930, 3, 2, 2, 2, 3930, 3931, 3, 2, 2, 2, 3931, 3932, 7, 314, 2, 2, 3932,
	3936, 7, 517, 2, 2, 3933, 3934, 7, 520, 2, 2, 3934, 3936, 7, 517, 2, 2,
	3935, 3929, 3, 2, 2, 2, 3935, 3933, 3, 2, 2, 2, 3936, 3943, 3, 2, 2, 2,
	3937, 3939, 7, 512, 2, 2, 3938, 3940, 5, 602, 302, 2, 3939, 3938, 3, 2,
	2, 2, 3940, 3941, 3, 2, 2, 2, 3941, 3939, 3, 2, 2, 2, 3941, 3942, 3, 2,
	2, 2, 3942, 3944, 3, 2, 2, 2, 3943, 3937, 3, 2, 2, 2, 3943, 3944, 3, 2,
	2, 2, 3944, 601, 3, 2, 2, 2, 3945, 3949, 5, 604, 303, 2, 3946, 3949, 5,
	606, 304, 2, 3947, 3949, 5, 608, 305, 2, 3948, 3945, 3, 2, 2, 2, 3948,
	3946, 3, 2, 2, 2, 3948, 3947, 3, 2, 2, 2, 3949, 603, 3, 2, 2, 2, 3950,
	3952, 7, 72, 2, 2, 3951, 3953, 7, 329, 2, 2, 3952, 3951, 3, 2, 2, 2, 3952,
	3953, 3, 2, 2, 2, 3953, 3954, 3, 2, 2, 2, 3954, 3955, 9, 52, 2, 2, 3955,
	605, 3, 2, 2, 2, 3956, 3959, 7, 32, 2, 2, 3957, 3960, 5, 1068, 535, 2,
	3958, 3960, 5, 1172, 587, 2, 3959, 3957, 3, 2, 2, 2, 3959, 3958, 3, 2,
	2, 2, 3960, 607, 3, 2, 2, 2, 3961, 3963, 7, 33, 2, 2, 3962, 3964, 7, 329,
	2, 2, 3963, 3962, 3, 2, 2, 2, 3963, 3964, 3, 2, 2, 2, 3964, 3967, 3, 2,
	2, 2, 3965, 3968, 5, 1068, 535, 2, 3966, 3968, 5, 1172, 587, 2, 3967, 3965,
	3, 2, 2, 2, 3967, 3966, 3, 2, 2, 2, 3968, 609, 3, 2, 2, 2, 3969, 3971,
	7, 97, 2, 2, 3970, 3972, 5, 612, 307, 2, 3971, 3970, 3, 2, 2, 2, 3972,
	3973, 3, 2, 2, 2, 3973, 3971, 3, 2, 2, 2, 3973, 3974, 3, 2, 2, 2, 3974,
	3975, 3, 2, 2, 2, 3975, 3976, 9, 53, 2, 2, 3976, 3978, 5, 1026, 514, 2,
	3977, 3979, 5, 1018, 510, 2, 3978, 3977, 3, 2, 2, 2, 3978, 3979, 3, 2,
	2, 2, 3979, 3981, 3, 2, 2, 2, 3980, 3982, 5, 1020, 511, 2, 3981, 3980,
	3, 2, 2, 2, 3981, 3982, 3, 2, 2, 2, 3982, 3984, 3, 2, 2, 2, 3983, 3985,
	7, 167, 2, 2, 3984, 3983, 3, 2, 2, 2, 3984, 3985, 3, 2, 2, 2, 3985, 611,
	3, 2, 2, 2, 3986, 3988, 5, 1068, 535, 2, 3987, 3989, 7, 417, 2, 2, 3988,
	3987, 3, 2, 2, 2, 3988, 3989, 3, 2, 2, 2, 3989, 613, 3, 2, 2, 2, 3990,
	3991, 7, 101, 2, 2, 3991, 615, 3, 2, 2, 2, 3992, 3993, 7, 136, 2, 2, 3993,
	3995, 5, 1128, 565, 2, 3994, 3996, 7, 384, 2, 2, 3995, 3994, 3, 2, 2, 2,
	3995, 3996, 3, 2, 2, 2, 3996, 3998, 3, 2, 2, 2, 3997, 3999, 5, 1010, 506,
	2, 3998, 3997, 3, 2, 2, 2, 3998, 3999, 3, 2, 2, 2, 3999, 4001, 3, 2, 2,
	2, 4000, 4002, 5, 1012, 507, 2, 4001, 4000, 3, 2, 2, 2, 4001, 4002, 3,
	2, 2, 2, 4002, 4004, 3, 2, 2, 2, 4003, 4005, 7, 168, 2, 2, 4004, 4003,
	3, 2, 2, 2, 4004, 4005, 3, 2, 2, 2, 4005, 617, 3, 2, 2, 2, 4006, 4014,
	7, 145, 2, 2, 4007, 4009, 7, 251, 2, 2, 4008, 4010, 7, 481, 2, 2, 4009,
	4008, 3, 2, 2, 2, 4009, 4010, 3, 2, 2, 2, 4010, 4015, 3, 2, 2, 2, 4011,
	4012, 7, 237, 2, 2, 4012, 4015, 7, 481, 2, 2, 4013, 4015, 7, 341, 2, 2,
	4014, 4007, 3, 2, 2, 2, 4014, 4011, 3, 2, 2, 2, 4014, 4013, 3, 2, 2, 2,
	4015, 4016, 3, 2, 2, 2, 4016, 4018, 5, 1114, 558, 2, 4017, 4019, 7, 520,
	2, 2, 4018, 4017, 3, 2, 2, 2, 4018, 4019, 3, 2, 2, 2, 4019, 4020, 3, 2,
	2, 2, 4020, 4023, 7, 264, 2, 2, 4021, 4024, 5, 1068, 535, 2, 4022, 4024,
	5, 1166, 584, 2, 4023, 4021, 3, 2, 2, 2, 4023, 4022, 3, 2, 2, 2, 4024,
	619, 3, 2, 2, 2, 4025, 4027, 7, 147, 2, 2, 4026, 4028, 5, 622, 312, 2,
	4027, 4026, 3, 2, 2, 2, 4028, 4029, 3, 2, 2, 2, 4029, 4027, 3, 2, 2, 2,
	4029, 4030, 3, 2, 2, 2, 4030, 4032, 3, 2, 2, 2, 4031, 4033, 5, 624, 313,
	2, 4032, 4031, 3, 2, 2, 2, 4032, 4033, 3, 2, 2, 2, 4033, 4035, 3, 2, 2,
	2, 4034, 4036, 5, 626, 314, 2, 4035, 4034, 3, 2, 2, 2, 4035, 4036, 3, 2,
	2, 2, 4036, 4038, 3, 2, 2, 2, 4037, 4039, 5, 628, 315, 2, 4038, 4037, 3,
	2, 2, 2, 4038, 4039, 3, 2, 2, 2, 4039, 621, 3, 2, 2, 2, 4040, 4043, 5,
	1068, 535, 2, 4041, 4043, 5, 1166, 584, 2, 4042, 4040, 3, 2, 2, 2, 4042,
	4041, 3, 2, 2, 2, 4043, 623, 3, 2, 2, 2, 4044, 4047, 7, 34, 2, 2, 4045,
	4048, 5, 1068, 535, 2, 4046, 4048, 5, 1166, 584, 2, 4047, 4045, 3, 2, 2,
	2, 4047, 4046, 3, 2, 2, 2, 4048, 625, 3, 2, 2, 2, 4049, 4052, 7, 509, 2,
	2, 4050, 4053, 5, 1140, 571, 2, 4051, 4053, 5, 1126, 564, 2, 4052, 4050,
	3, 2, 2, 2, 4052, 4051, 3, 2, 2, 2, 4053, 627, 3, 2, 2, 2, 4054, 4056,
	7, 520, 2, 2, 4055, 4054, 3, 2, 2, 2, 4055, 4056, 3, 2, 2, 2, 4056, 4057,
	3, 2, 2, 2, 4057, 4058, 7, 314, 2, 2, 4058, 4059, 7, 8, 2, 2, 4059, 629,
	3, 2, 2, 2, 4060, 4063, 7, 149, 2, 2, 4061, 4064, 5, 1068, 535, 2, 4062,
	4064, 5, 1166, 584, 2, 4063, 4061, 3, 2, 2, 2, 4063, 4062, 3, 2, 2, 2,
	4064, 4068, 3, 2, 2, 2, 4065, 4069, 5, 632, 317, 2, 4066, 4069, 5, 634,
	318, 2, 4067, 4069, 5, 636, 319, 2, 4068, 4065, 3, 2, 2, 2, 4068, 4066,
	3, 2, 2, 2, 4068, 4067, 3, 2, 2, 2, 4069, 4071, 3, 2, 2, 2, 4070, 4072,
	5, 642, 322, 2, 4071, 4070, 3, 2, 2, 2, 4071, 4072, 3, 2, 2, 2, 4072, 4074,
	3, 2, 2, 2, 4073, 4075, 5, 1018, 510, 2, 4074, 4073, 3, 2, 2, 2, 4074,
	4075, 3, 2, 2, 2, 4075, 4077, 3, 2, 2, 2, 4076, 4078, 5, 1020, 511, 2,
	4077, 4076, 3, 2, 2, 2, 4077, 4078, 3, 2, 2, 2, 4078, 4080, 3, 2, 2, 2,
	4079, 4081, 7, 169, 2, 2, 4080, 4079, 3, 2, 2, 2, 4080, 4081, 3, 2, 2,
	2, 4081, 631, 3, 2, 2, 2, 4082, 4085, 7, 256, 2, 2, 4083, 4086, 5, 1068,
	535, 2, 4084, 4086, 5, 1166, 584, 2, 4085, 4083, 3, 2, 2, 2, 4085, 4084,
	3, 2, 2, 2, 4086, 4088, 3, 2, 2, 2, 4087, 4089, 5, 638, 320, 2, 4088, 4087,
	3, 2, 2, 2, 4088, 4089, 3, 2, 2, 2, 4089, 633, 3, 2, 2, 2, 4090, 4092,
	7, 256, 2, 2, 4091, 4093, 5, 640, 321, 2, 4092, 4091, 3, 2, 2, 2, 4093,
	4094, 3, 2, 2, 2, 4094, 4092, 3, 2, 2, 2, 4094, 4095, 3, 2, 2, 2, 4095,
	635, 3, 2, 2, 2, 4096, 4099, 7, 53, 2, 2, 4097, 4100, 5, 1068, 535, 2,
	4098, 4100, 5, 1166, 584, 2, 4099, 4097, 3, 2, 2, 2, 4099, 4098, 3, 2,
	2, 2, 4100, 4102, 3, 2, 2, 2, 4101, 4103, 5, 638, 320, 2, 4102, 4101, 3,
	2, 2, 2, 4102, 4103, 3, 2, 2, 2, 4103, 637, 3, 2, 2, 2, 4104, 4106, 7,
	227, 2, 2, 4105, 4107, 5, 640, 321, 2, 4106, 4105, 3, 2, 2, 2, 4107, 4108,
	3, 2, 2, 2, 4108, 4106, 3, 2, 2, 2, 4108, 4109, 3, 2, 2, 2, 4109, 639,
	3, 2, 2, 2, 4110, 4112, 5, 1068, 535, 2, 4111, 4113, 7, 417, 2, 2, 4112,
	4111, 3, 2, 2, 2, 4112, 4113, 3, 2, 2, 2, 4113, 641, 3, 2, 2, 2, 4114,
	4115, 7, 394, 2, 2, 4115, 4116, 5, 1068, 535, 2, 4116, 643, 3, 2, 2, 2,
	4117, 4125, 7, 163, 2, 2, 4118, 4120, 7, 251, 2, 2, 4119, 4121, 7, 481,
	2, 2, 4120, 4119, 3, 2, 2, 2, 4120, 4121, 3, 2, 2, 2, 4121, 4126, 3, 2,
	2, 2, 4122, 4123, 7, 237, 2, 2, 4123, 4126, 7, 481, 2, 2, 4124, 4126, 7,
	341, 2, 2, 4125, 4118, 3, 2, 2, 2, 4125, 4122, 3, 2, 2, 2, 4125, 4124,
	3, 2, 2, 2, 4126, 4127, 3, 2, 2, 2, 4127, 4129, 5, 1114, 558, 2, 4128,
	4130, 7, 520, 2, 2, 4129, 4128, 3, 2, 2, 2, 4129, 4130, 3, 2, 2, 2, 4130,
	4131, 3, 2, 2, 2, 4131, 4134, 7, 264, 2, 2, 4132, 4135, 5, 1166, 584, 2,
	4133, 4135, 5, 1068, 535, 2, 4134, 4132, 3, 2, 2, 2, 4134, 4133, 3, 2,
	2, 2, 4135, 645, 3, 2, 2, 2, 4136, 4137, 7, 187, 2, 2, 4137, 4144, 5, 1166,
	584, 2, 4138, 4140, 7, 512, 2, 2, 4139, 4141, 5, 1068, 535, 2, 4140, 4139,
	3, 2, 2, 2, 4141, 4142, 3, 2, 2, 2, 4142, 4140, 3, 2, 2, 2, 4142, 4143,
	3, 2, 2, 2, 4143, 4145, 3, 2, 2, 2, 4144, 4138, 3, 2, 2, 2, 4144, 4145,
	3, 2, 2, 2, 4145, 647, 3, 2, 2, 2, 4146, 4147, 7, 198, 2, 2, 4147, 4151,
	5, 650, 326, 2, 4148, 4150, 5, 652, 327, 2, 4149, 4148, 3, 2, 2, 2, 4150,
	4153, 3, 2, 2, 2, 4151, 4149, 3, 2, 2, 2, 4151, 4152, 3, 2, 2, 2, 4152,
	4155, 3, 2, 2, 2, 4153, 4151, 3, 2, 2, 2, 4154, 4156, 5, 654, 328, 2, 4155,
	4154, 3, 2, 2, 2, 4156, 4157, 3, 2, 2, 2, 4157, 4155, 3, 2, 2, 2, 4157,
	4158, 3, 2, 2, 2, 4158, 4160, 3, 2, 2, 2, 4159, 4161, 5, 664, 333, 2, 4160,
	4159, 3, 2, 2, 2, 4160, 4161, 3, 2, 2, 2, 4161, 4163, 3, 2, 2, 2, 4162,
	4164, 7, 170, 2, 2, 4163, 4162, 3, 2, 2, 2, 4163, 4164, 3, 2, 2, 2, 4164,
	649, 3, 2, 2, 2, 4165, 4170, 5, 1068, 535, 2, 4166, 4170, 5, 1166, 584,
	2, 4167, 4170, 5, 1026, 514, 2, 4168, 4170, 5, 1040, 521, 2, 4169, 4165,
	3, 2, 2, 2, 4169, 4166, 3, 2, 2, 2, 4169, 4167, 3, 2, 2, 2, 4169, 4168,
	3, 2, 2, 2, 4170, 651, 3, 2, 2, 2, 4171, 4172, 7, 18, 2, 2, 4172, 4173,
	5, 650, 326, 2, 4173, 653, 3, 2, 2, 2, 4174, 4176, 5, 656, 329, 2, 4175,
	4174, 3, 2, 2, 2, 4176, 4177, 3, 2, 2, 2, 4177, 4175, 3, 2, 2, 2, 4177,
	4178, 3, 2, 2, 2, 4178, 4182, 3, 2, 2, 2, 4179, 4181, 5, 536, 269, 2, 4180,
	4179, 3, 2, 2, 2, 4181, 4184, 3, 2, 2, 2, 4182, 4180, 3, 2, 2, 2, 4182,
	4183, 3, 2, 2, 2, 4183, 655, 3, 2, 2, 2, 4184, 4182, 3, 2, 2, 2, 4185,
	4186, 7, 518, 2, 2, 4186, 4190, 5, 658, 330, 2, 4187, 4189, 5, 662, 332,
	2, 4188, 4187, 3, 2, 2, 2, 4189, 4192, 3, 2, 2, 2, 4190, 4188, 3, 2, 2,
	2, 4190, 4191, 3, 2, 2, 2, 4191, 657, 3, 2, 2, 2, 4192, 4190, 3, 2, 2,
	2, 4193, 4204, 7, 22, 2, 2, 4194, 4196, 7, 318, 2, 2, 4195, 4194, 3, 2,
	2, 2, 4195, 4196, 3, 2, 2, 2, 4196, 4197, 3, 2, 2, 2, 4197, 4199, 5, 666,
	334, 2, 4198, 4200, 5, 660, 331, 2, 4199, 4198, 3, 2, 2, 2, 4199, 4200,
	3, 2, 2, 2, 4200, 4204, 3, 2, 2, 2, 4201, 4204, 5, 1040, 521, 2, 4202,
	4204, 5, 1168, 585, 2, 4203, 4193, 3, 2, 2, 2, 4203, 4195, 3, 2, 2, 2,
	4203, 4201, 3, 2, 2, 2, 4203, 4202, 3, 2, 2, 2, 4204, 659, 3, 2, 2, 2,
	4205, 4206, 9, 7, 2, 2, 4206, 4207, 5, 666, 334, 2, 4207, 661, 3, 2, 2,
	2, 4208, 4209, 7, 18, 2, 2, 4209, 4210, 5, 658, 330, 2, 4210, 663, 3, 2,
	2, 2, 4211, 4212, 7, 518, 2, 2, 4212, 4216, 7, 340, 2, 2, 4213, 4215, 5,
	536, 269, 2, 4214, 4213, 3, 2, 2, 2, 4215, 4218, 3, 2, 2, 2, 4216, 4214,
	3, 2, 2, 2, 4216, 4217, 3, 2, 2, 2, 4217, 665, 3, 2, 2, 2, 4218, 4216,
	3, 2, 2, 2, 4219, 4223, 5, 1068, 535, 2, 4220, 4223, 5, 1166, 584, 2, 4221,
	4223, 5, 1026, 514, 2, 4222, 4219, 3, 2, 2, 2, 4222, 4220, 3, 2, 2, 2,
	4222, 4221, 3, 2, 2, 2, 4223, 667, 3, 2, 2, 2, 4224, 4226, 7, 565, 2, 2,
	4225, 4224, 3, 2, 2, 2, 4226, 4227, 3, 2, 2, 2, 4227, 4225, 3, 2, 2, 2,
	4227, 4228, 3, 2, 2, 2, 4228, 669, 3, 2, 2, 2, 4229, 4231, 7, 567, 2, 2,
	4230, 4229, 3, 2, 2, 2, 4231, 4232, 3, 2, 2, 2, 4232, 4230, 3, 2, 2, 2,
	4232, 4233, 3, 2, 2, 2, 4233, 671, 3, 2, 2, 2, 4234, 4236, 7, 566, 2, 2,
	4235, 4234, 3, 2, 2, 2, 4236, 4237, 3, 2, 2, 2, 4237, 4235, 3, 2, 2, 2,
	4237, 4238, 3, 2, 2, 2, 4238, 673, 3, 2, 2, 2, 4239, 4241, 7, 203, 2, 2,
	4240, 4242, 7, 308, 2, 2, 4241, 4240, 3, 2, 2, 2, 4241, 4242, 3, 2, 2,
	2, 4242, 4244, 3, 2, 2, 2, 4243, 4245, 7, 64, 2, 2, 4244, 4243, 3, 2, 2,
	2, 4244, 4245, 3, 2, 2, 2, 4245, 4247, 3, 2, 2, 2, 4246, 4248, 5, 676,
	339, 2, 4247, 4246, 3, 2, 2, 2, 4248, 4249, 3, 2, 2, 2, 4249, 4247, 3,
	2, 2, 2, 4249, 4250, 3, 2, 2, 2, 4250, 675, 3, 2, 2, 2, 4251, 4254, 5,
	1068, 535, 2, 4252, 4254, 5, 1166, 584, 2, 4253, 4251, 3, 2, 2, 2, 4253,
	4252, 3, 2, 2, 2, 4254, 677, 3, 2, 2, 2, 4255, 4257, 7, 204, 2, 2, 4256,
	4258, 7, 368, 2, 2, 4257, 4256, 3, 2, 2, 2, 4257, 4258, 3, 2, 2, 2, 4258,
	679, 3, 2, 2, 2, 4259, 4260, 7, 225, 2, 2, 4260, 4261, 5, 1150, 576, 2,
	4261, 681, 3, 2, 2, 2, 4262, 4263, 7, 226, 2, 2, 4263, 683, 3, 2, 2, 2,
	4264, 4266, 7, 229, 2, 2, 4265, 4267, 7, 495, 2, 2, 4266, 4265, 3, 2, 2,
	2, 4266, 4267, 3, 2, 2, 2, 4267, 4270, 3, 2, 2, 2, 4268, 4271, 5, 686,
	344, 2, 4269, 4271, 5, 688, 345, 2, 4270, 4268, 3, 2, 2, 2, 4270, 4269,
	3, 2, 2, 2, 4271, 685, 3, 2, 2, 2, 4272, 4273, 5, 1144, 573, 2, 4273, 687,
	3, 2, 2, 2, 4274, 4288, 7, 304, 2, 2, 4275, 4277, 5, 1144, 573, 2, 4276,
	4275, 3, 2, 2, 2, 4277, 4278, 3, 2, 2, 2, 4278, 4276, 3, 2, 2, 2, 4278,
	4279, 3, 2, 2, 2, 4279, 4285, 3, 2, 2, 2, 4280, 4282, 7, 139, 2, 2, 4281,
	4283, 7, 332, 2, 2, 4282, 4281, 3, 2, 2, 2, 4282, 4283, 3, 2, 2, 2, 4283,
	4284, 3, 2, 2, 2, 4284, 4286, 5, 1068, 535, 2, 4285, 4280, 3, 2, 2, 2,
	4285, 4286, 3, 2, 2, 2, 4286, 4288, 3, 2, 2, 2, 4287, 4274, 3, 2, 2, 2,
	4287, 4276, 3, 2, 2, 2, 4288, 689, 3, 2, 2, 2, 4289, 4290, 7, 241, 2, 2,
	4290, 4291, 5, 1040, 521, 2, 4291, 4293, 5, 692, 347, 2, 4292, 4294, 5,
	694, 348, 2, 4293, 4292, 3, 2, 2, 2, 4293, 4294, 3, 2, 2, 2, 4294, 4296,
	3, 2, 2, 2, 4295, 4297, 7, 171, 2, 2, 4296, 4295, 3, 2, 2, 2, 4296, 4297,
	3, 2, 2, 2, 4297, 691, 3, 2, 2, 2, 4298, 4300, 7, 486, 2, 2, 4299, 4298,
	3, 2, 2, 2, 4299, 4300, 3, 2, 2, 2, 4300, 4309, 3, 2, 2, 2, 4301, 4302,
	7, 313, 2, 2, 4302, 4310, 7, 431, 2, 2, 4303, 4305, 5, 536, 269, 2, 4304,
	4303, 3, 2, 2, 2, 4305, 4308, 3, 2, 2, 2, 4306, 4304, 3, 2, 2, 2, 4306,
	4307, 3, 2, 2, 2, 4307, 4310, 3, 2, 2, 2, 4308, 4306, 3, 2, 2, 2, 4309,
	4301, 3, 2, 2, 2, 4309, 4306, 3, 2, 2, 2, 4310, 693, 3, 2, 2, 2, 4311,
	4320, 7, 160, 2, 2, 4312, 4313, 7, 313, 2, 2, 4313, 4321, 7, 431, 2, 2,
	4314, 4316, 5, 536, 269, 2, 4315, 4314, 3, 2, 2, 2, 4316, 4319, 3, 2, 2,
	2, 4317, 4315, 3, 2, 2, 2, 4317, 4318, 3, 2, 2, 2, 4318, 4321, 3, 2, 2,
	2, 4319, 4317, 3, 2, 2, 2, 4320, 4312, 3, 2, 2, 2, 4320, 4317, 3, 2, 2,
	2, 4321, 695, 3, 2, 2, 2, 4322, 4324, 7, 249, 2, 2, 4323, 4325, 5, 1068,
	535, 2, 4324, 4323, 3, 2, 2, 2, 4325, 4326, 3, 2, 2, 2, 4326, 4324, 3,
	2, 2, 2, 4326, 4327, 3, 2, 2, 2, 4327, 4329, 3, 2, 2, 2, 4328, 4330, 5,
	698, 350, 2, 4329, 4328, 3, 2, 2, 2, 4329, 4330, 3, 2, 2, 2, 4330, 697,
	3, 2, 2, 2, 4331, 4333, 7, 400, 2, 2, 4332, 4334, 5, 700, 351, 2, 4333,
	4332, 3, 2, 2, 2, 4334, 4335, 3, 2, 2, 2, 4335, 4333, 3, 2, 2, 2, 4335,
	4336, 3, 2, 2, 2, 4336, 699, 3, 2, 2, 2, 4337, 4339, 9, 54, 2, 2, 4338,
	4340, 7, 114, 2, 2, 4339, 4338, 3, 2, 2, 2, 4339, 4340, 3, 2, 2, 2, 4340,
	4341, 3, 2, 2, 2, 4341, 4344, 7, 53, 2, 2, 4342, 4345, 5, 1068, 535, 2,
	4343, 4345, 5, 1166, 584, 2, 4344, 4342, 3, 2, 2, 2, 4344, 4343, 3, 2,
	2, 2, 4345, 701, 3, 2, 2, 2, 4346, 4348, 7, 250, 2, 2, 4347, 4349, 5, 1150,
	576, 2, 4348, 4347, 3, 2, 2, 2, 4349, 4350, 3, 2, 2, 2, 4350, 4348, 3,
	2, 2, 2, 4350, 4351, 3, 2, 2, 2, 4351, 703, 3, 2, 2, 2, 4352, 4353, 7,
	253, 2, 2, 4353, 4358, 5, 1068, 535, 2, 4354, 4359, 5, 706, 354, 2, 4355,
	4359, 5, 708, 355, 2, 4356, 4359, 5, 710, 356, 2, 4357, 4359, 5, 712, 357,
	2, 4358, 4354, 3, 2, 2, 2, 4358, 4355, 3, 2, 2, 2, 4358, 4356, 3, 2, 2,
	2, 4358, 4357, 3, 2, 2, 2, 4359, 705, 3, 2, 2, 2, 4360, 4362, 7, 478, 2,
	2, 4361, 4363, 5, 714, 358, 2, 4362, 4361, 3, 2, 2, 2, 4363, 4364, 3, 2,
	2, 2, 4364, 4362, 3, 2, 2, 2, 4364, 4365, 3, 2, 2, 2, 4365, 707, 3, 2,
	2, 2, 4366, 4369, 7, 400, 2, 2, 4367, 4370, 5, 718, 360, 2, 4368, 4370,
	5, 722, 362, 2, 4369, 4367, 3, 2, 2, 2, 4369, 4368, 3, 2, 2, 2, 4370, 4371,
	3, 2, 2, 2, 4371, 4369, 3, 2, 2, 2, 4371, 4372, 3, 2, 2, 2, 4372, 709,
	3, 2, 2, 2, 4373, 4375, 7, 478, 2, 2, 4374, 4376, 5, 714, 358, 2, 4375,
	4374, 3, 2, 2, 2, 4376, 4377, 3, 2, 2, 2, 4377, 4375, 3, 2, 2, 2, 4377,
	4378, 3, 2, 2, 2, 4378, 4380, 3, 2, 2, 2, 4379, 4381, 5, 708, 355, 2, 4380,
	4379, 3, 2, 2, 2, 4381, 4382, 3, 2, 2, 2, 4382, 4380, 3, 2, 2, 2, 4382,
	4383, 3, 2, 2, 2, 4383, 711, 3, 2, 2, 2, 4384, 4387, 7, 106, 2, 2, 4385,
	4388, 5, 1068, 535, 2, 4386, 4388, 5, 1166, 584, 2, 4387, 4385, 3, 2, 2,
	2, 4387, 4386, 3, 2, 2, 2, 4388, 4389, 3, 2, 2, 2, 4389, 4393, 5, 730,
	366, 2, 4390, 4392, 5, 732, 367, 2, 4391, 4390, 3, 2, 2, 2, 4392, 4395,
	3, 2, 2, 2, 4393, 4391, 3, 2, 2, 2, 4393, 4394, 3, 2, 2, 2, 4394, 713,
	3, 2, 2, 2, 4395, 4393, 3, 2, 2, 2, 4396, 4397, 5, 1068, 535, 2, 4397,
	4400, 7, 217, 2, 2, 4398, 4401, 5, 716, 359, 2, 4399, 4401, 5, 720, 361,
	2, 4400, 4398, 3, 2, 2, 2, 4400, 4399, 3, 2, 2, 2, 4401, 4402, 3, 2, 2,
	2, 4402, 4400, 3, 2, 2, 2, 4402, 4403, 3, 2, 2, 2, 4403, 715, 3, 2, 2,
	2, 4404, 4408, 7, 67, 2, 2, 4405, 4407, 5, 732, 367, 2, 4406, 4405, 3,
	2, 2, 2, 4407, 4410, 3, 2, 2, 2, 4408, 4406, 3, 2, 2, 2, 4408, 4409, 3,
	2, 2, 2, 4409, 717, 3, 2, 2, 2, 4410, 4408, 3, 2, 2, 2, 4411, 4412, 7,
	67, 2, 2, 4412, 4416, 5, 728, 365, 2, 4413, 4415, 5, 732, 367, 2, 4414,
	4413, 3, 2, 2, 2, 4415, 4418, 3, 2, 2, 2, 4416, 4414, 3, 2, 2, 2, 4416,
	4417, 3, 2, 2, 2, 4417, 719, 3, 2, 2, 2, 4418, 4416, 3, 2, 2, 2, 4419,
	4421, 9, 55, 2, 2, 4420, 4422, 5, 724, 363, 2, 4421, 4420, 3, 2, 2, 2,
	4422, 4423, 3, 2, 2, 2, 4423, 4421, 3, 2, 2, 2, 4423, 4424, 3, 2, 2, 2,
	4424, 721, 3, 2, 2, 2, 4425, 4427, 9, 56, 2, 2, 4426, 4428, 5, 726, 364,
	2, 4427, 4426, 3, 2, 2, 2, 4428, 4429, 3, 2, 2, 2, 4429, 4427, 3, 2, 2,
	2, 4429, 4430, 3, 2, 2, 2, 4430, 723, 3, 2, 2, 2, 4431, 4434, 5, 1068,
	535, 2, 4432, 4434, 5, 1166, 584, 2, 4433, 4431, 3, 2, 2, 2, 4433, 4432,
	3, 2, 2, 2, 4434, 4438, 3, 2, 2, 2, 4435, 4437, 5, 732, 367, 2, 4436, 4435,
	3, 2, 2, 2, 4437, 4440, 3, 2, 2, 2, 4438, 4436, 3, 2, 2, 2, 4438, 4439,
	3, 2, 2, 2, 4439, 725, 3, 2, 2, 2, 4440, 4438, 3, 2, 2, 2, 4441, 4444,
	5, 1068, 535, 2, 4442, 4444, 5, 1166, 584, 2, 4443, 4441, 3, 2, 2, 2, 4443,
	4442, 3, 2, 2, 2, 4444, 4445, 3, 2, 2, 2, 4445, 4449, 5, 728, 365, 2, 4446,
	4448, 5, 732, 367, 2, 4447, 4446, 3, 2, 2, 2, 4448, 4451, 3, 2, 2, 2, 4449,
	4447, 3, 2, 2, 2, 4449, 4450, 3, 2, 2, 2, 4450, 727, 3, 2, 2, 2, 4451,
	4449, 3, 2, 2, 2, 4452, 4455, 7, 53, 2, 2, 4453, 4456, 5, 1068, 535, 2,
	4454, 4456, 5, 1166, 584, 2, 4455, 4453, 3, 2, 2, 2, 4455, 4454, 3, 2,
	2, 2, 4456, 729, 3, 2, 2, 2, 4457, 4460, 7, 495, 2, 2, 4458, 4461, 5, 1068,
	535, 2, 4459, 4461, 5, 1166, 584, 2, 4460, 4458, 3, 2, 2, 2, 4460, 4459,
	3, 2, 2, 2, 4461, 731, 3, 2, 2, 2, 4462, 4464, 9, 57, 2, 2, 4463, 4465,
	7, 248, 2, 2, 4464, 4463, 3, 2, 2, 2, 4464, 4465, 3, 2, 2, 2, 4465, 4468,
	3, 2, 2, 2, 4466, 4469, 5, 1068, 535, 2, 4467, 4469, 5, 1166, 584, 2, 4468,
	4466, 3, 2, 2, 2, 4468, 4467, 3, 2, 2, 2, 4469, 733, 3, 2, 2, 2, 4470,
	4471, 7, 299, 2, 2, 4471, 4473, 5, 1128, 565, 2, 4472, 4474, 5, 736, 369,
	2, 4473, 4472, 3, 2, 2, 2, 4474, 4475, 3, 2, 2, 2, 4475, 4473, 3, 2, 2,
	2, 4475, 4476, 3, 2, 2, 2, 4476, 4478, 3, 2, 2, 2, 4477, 4479, 5, 738,
	370, 2, 4478, 4477, 3, 2, 2, 2, 4478, 4479, 3, 2, 2, 2, 4479, 4483, 3,
	2, 2, 2, 4480, 4482, 5, 744, 373, 2, 4481, 4480, 3, 2, 2, 2, 4482, 4485,
	3, 2, 2, 2, 4483, 4481, 3, 2, 2, 2, 4483, 4484, 3, 2, 2, 2, 4484, 4487,
	3, 2, 2, 2, 4485, 4483, 3, 2, 2, 2, 4486, 4488, 5, 746, 374, 2, 4487, 4486,
	3, 2, 2, 2, 4487, 4488, 3, 2, 2, 2, 4488, 4492, 3, 2, 2, 2, 4489, 4491,
	5, 750, 376, 2, 4490, 4489, 3, 2, 2, 2, 4491, 4494, 3, 2, 2, 2, 4492, 4490,
	3, 2, 2, 2, 4492, 4493, 3, 2, 2, 2, 4493, 735, 3, 2, 2, 2, 4494, 4492,
	3, 2, 2, 2, 4495, 4497, 7, 332, 2, 2, 4496, 4495, 3, 2, 2, 2, 4496, 4497,
	3, 2, 2, 2, 4497, 4498, 3, 2, 2, 2, 4498, 4500, 9, 44, 2, 2, 4499, 4501,
	7, 264, 2, 2, 4500, 4499, 3, 2, 2, 2, 4500, 4501, 3, 2, 2, 2, 4501, 4503,
	3, 2, 2, 2, 4502, 4504, 5, 1084, 543, 2, 4503, 4502, 3, 2, 2, 2, 4504,
	4505, 3, 2, 2, 2, 4505, 4503, 3, 2, 2, 2, 4505, 4506, 3, 2, 2, 2, 4506,
	737, 3, 2, 2, 2, 4507, 4509, 7, 77, 2, 2, 4508, 4507, 3, 2, 2, 2, 4508,
	4509, 3, 2, 2, 2, 4509, 4510, 3, 2, 2, 2, 4510, 4512, 7, 433, 2, 2, 4511,
	4513, 7, 259, 2, 2, 4512, 4511, 3, 2, 2, 2, 4512, 4513, 3, 2, 2, 2, 4513,
	4515, 3, 2, 2, 2, 4514, 4516, 5, 1108, 555, 2, 4515, 4514, 3, 2, 2, 2,
	4516, 4517, 3, 2, 2, 2, 4517, 4515, 3, 2, 2, 2, 4517, 4518, 3, 2, 2, 2,
	4518, 4520, 3, 2, 2, 2, 4519, 4521, 5, 740, 371, 2, 4520, 4519, 3, 2, 2,
	2, 4520, 4521, 3, 2, 2, 2, 4521, 4523, 3, 2, 2, 2, 4522, 4524, 5, 742,
	372, 2, 4523, 4522, 3, 2, 2, 2, 4523, 4524, 3, 2, 2, 2, 4524, 739, 3, 2,
	2, 2, 4525, 4527, 7, 217, 2, 2, 4526, 4525, 3, 2, 2, 2, 4526, 4527, 3,
	2, 2, 2, 4527, 4528, 3, 2, 2, 2, 4528, 4529, 7, 16, 2, 2, 4529, 4530, 7,
	259, 2, 2, 4530, 4531, 5, 1108, 555, 2, 4531, 741, 3, 2, 2, 2, 4532, 4534,
	7, 217, 2, 2, 4533, 4532, 3, 2, 2, 2, 4533, 4534, 3, 2, 2, 2, 4534, 4535,
	3, 2, 2, 2, 4535, 4537, 7, 309, 2, 2, 4536, 4538, 7, 259, 2, 2, 4537, 4536,
	3, 2, 2, 2, 4537, 4538, 3, 2, 2, 2, 4538, 4539, 3, 2, 2, 2, 4539, 4540,
	5, 1108, 555, 2, 4540, 743, 3, 2, 2, 2, 4541, 4543, 7, 512, 2, 2, 4542,
	4544, 5, 1128, 565, 2, 4543, 4542, 3, 2, 2, 2, 4544, 4545, 3, 2, 2, 2,
	4545, 4543, 3, 2, 2, 2, 4545, 4546, 3, 2, 2, 2, 4546, 745, 3, 2, 2, 2,
	4547, 4548, 7, 341, 2, 2, 4548, 4550, 7, 363, 2, 2, 4549, 4551, 7, 259,
	2, 2, 4550, 4549, 3, 2, 2, 2, 4550, 4551, 3, 2, 2, 2, 4551, 4552, 3, 2,
	2, 2, 4552, 4554, 5, 1144, 573, 2, 4553, 4555, 5, 748, 375, 2, 4554, 4553,
	3, 2, 2, 2, 4554, 4555, 3, 2, 2, 2, 4555, 747, 3, 2, 2, 2, 4556, 4557,
	9, 7, 2, 2, 4557, 4558, 5, 1144, 573, 2, 4558, 749, 3, 2, 2, 2, 4559, 4561,
	7, 227, 2, 2, 4560, 4562, 5, 752, 377, 2, 4561, 4560, 3, 2, 2, 2, 4562,
	4563, 3, 2, 2, 2, 4563, 4561, 3, 2, 2, 2, 4563, 4564, 3, 2, 2, 2, 4564,
	751, 3, 2, 2, 2, 4565, 4575, 5, 1128, 565, 2, 4566, 4576, 7, 291, 2, 2,
	4567, 4576, 7, 420, 2, 2, 4568, 4569, 7, 314, 2, 2, 4569, 4576, 7, 412,
	2, 2, 4570, 4576, 7, 111, 2, 2, 4571, 4576, 7, 393, 2, 2, 4572, 4573, 7,
	520, 2, 2, 4573, 4574, 7, 397, 2, 2, 4574, 4576, 7, 111, 2, 2, 4575, 4566,
	3, 2, 2, 2, 4575, 4567, 3, 2, 2, 2, 4575, 4568, 3, 2, 2, 2, 4575, 4570,
	3, 2, 2, 2, 4575, 4571, 3, 2, 2, 2, 4575, 4572, 3, 2, 2, 2, 4575, 4576,
	3, 2, 2, 2, 4576, 753, 3, 2, 2, 2, 4577, 4580, 7, 305, 2, 2, 4578, 4581,
	5, 756, 379, 2, 4579, 4581, 5, 760, 381, 2, 4580, 4578, 3, 2, 2, 2, 4580,
	4579, 3, 2, 2, 2, 4581, 755, 3, 2, 2, 2, 4582, 4583, 5, 758, 380, 2, 4583,
	4585, 7, 495, 2, 2, 4584, 4586, 5, 1068, 535, 2, 4585, 4584, 3, 2, 2, 2,
	4586, 4587, 3, 2, 2, 2, 4587, 4585, 3, 2, 2, 2, 4587, 4588, 3, 2, 2, 2,
	4588, 757, 3, 2, 2, 2, 4589, 4592, 5, 1068, 535, 2, 4590, 4592, 5, 1166,
	584, 2, 4591, 4589, 3, 2, 2, 2, 4591, 4590, 3, 2, 2, 2, 4592, 759, 3, 2,
	2, 2, 4593, 4594, 9, 51, 2, 2, 4594, 4595, 5, 1084, 543, 2, 4595, 4597,
	7, 495, 2, 2, 4596, 4598, 5, 1068, 535, 2, 4597, 4596, 3, 2, 2, 2, 4598,
	4599, 3, 2, 2, 2, 4599, 4597, 3, 2, 2, 2, 4599, 4600, 3, 2, 2, 2, 4600,
	761, 3, 2, 2, 2, 4601, 4604, 7, 307, 2, 2, 4602, 4605, 5, 1068, 535, 2,
	4603, 4605, 5, 1166, 584, 2, 4604, 4602, 3, 2, 2, 2, 4604, 4603, 3, 2,
	2, 2, 4605, 4606, 3, 2, 2, 2, 4606, 4609, 7, 53, 2, 2, 4607, 4610, 5, 764,
	383, 2, 4608, 4610, 5, 768, 385, 2, 4609, 4607, 3, 2, 2, 2, 4609, 4608,
	3, 2, 2, 2, 4610, 4612, 3, 2, 2, 2, 4611, 4613, 5, 1018, 510, 2, 4612,
	4611, 3, 2, 2, 2, 4612, 4613, 3, 2, 2, 2, 4613, 4615, 3, 2, 2, 2, 4614,
	4616, 5, 1020, 511, 2, 4615, 4614, 3, 2, 2, 2, 4615, 4616, 3, 2, 2, 2,
	4616, 4618, 3, 2, 2, 2, 4617, 4619, 7, 172, 2, 2, 4618, 4617, 3, 2, 2,
	2, 4618, 4619, 3, 2, 2, 2, 4619, 763, 3, 2, 2, 2, 4620, 4622, 5, 766, 384,
	2, 4621, 4620, 3, 2, 2, 2, 4622, 4623, 3, 2, 2, 2, 4623, 4621, 3, 2, 2,
	2, 4623, 4624, 3, 2, 2, 2, 4624, 765, 3, 2, 2, 2, 4625, 4627, 5, 1068,
	535, 2, 4626, 4628, 7, 417, 2, 2, 4627, 4626, 3, 2, 2, 2, 4627, 4628, 3,
	2, 2, 2, 4628, 767, 3, 2, 2, 2, 4629, 4630, 5, 770, 386, 2, 4630, 4632,
	7, 227, 2, 2, 4631, 4633, 5, 772, 387, 2, 4632, 4631, 3, 2, 2, 2, 4633,
	4634, 3, 2, 2, 2, 4634, 4632, 3, 2, 2, 2, 4634, 4635, 3, 2, 2, 2, 4635,
	769, 3, 2, 2, 2, 4636, 4639, 5, 1068, 535, 2, 4637, 4639, 5, 1166, 584,
	2, 4638, 4636, 3, 2, 2, 2, 4638, 4637, 3, 2, 2, 2, 4639, 771, 3, 2, 2,
	2, 4640, 4642, 5, 1068, 535, 2, 4641, 4643, 7, 417, 2, 2, 4642, 4641, 3,
	2, 2, 2, 4642, 4643, 3, 2, 2, 2, 4643, 773, 3, 2, 2, 2, 4644, 4649, 7,
	333, 2, 2, 4645, 4650, 5, 776, 389, 2, 4646, 4650, 5, 780, 391, 2, 4647,
	4650, 5, 784, 393, 2, 4648, 4650, 5, 786, 394, 2, 4649, 4645, 3, 2, 2,
	2, 4649, 4646, 3, 2, 2, 2, 4649, 4647, 3, 2, 2, 2, 4649, 4648, 3, 2, 2,
	2, 4650, 4651, 3, 2, 2, 2, 4651, 4649, 3, 2, 2, 2, 4651, 4652, 3, 2, 2,
	2, 4652, 775, 3, 2, 2, 2, 4653, 4655, 7, 251, 2, 2, 4654, 4656, 5, 778,
	390, 2, 4655, 4654, 3, 2, 2, 2, 4656, 4657, 3, 2, 2, 2, 4657, 4655, 3,
	2, 2, 2, 4657, 4658, 3, 2, 2, 2, 4658, 777, 3, 2, 2, 2, 4659, 4666, 5,
	1128, 565, 2, 4660, 4667, 7, 411, 2, 2, 4661, 4663, 7, 520, 2, 2, 4662,
	4661, 3, 2, 2, 2, 4662, 4663, 3, 2, 2, 2, 4663, 4664, 3, 2, 2, 2, 4664,
	4665, 7, 314, 2, 2, 4665, 4667, 7, 412, 2, 2, 4666, 4660, 3, 2, 2, 2, 4666,
	4662, 3, 2, 2, 2, 4666, 4667, 3, 2, 2, 2, 4667, 779, 3, 2, 2, 2, 4668,
	4670, 7, 341, 2, 2, 4669, 4671, 5, 782, 392, 2, 4670, 4669, 3, 2, 2, 2,
	4671, 4672, 3, 2, 2, 2, 4672, 4670, 3, 2, 2, 2, 4672, 4673, 3, 2, 2, 2,
	4673, 781, 3, 2, 2, 2, 4674, 4680, 5, 1128, 565, 2, 4675, 4677, 7, 520,
	2, 2, 4676, 4675, 3, 2, 2, 2, 4676, 4677, 3, 2, 2, 2, 4677, 4678, 3, 2,
	2, 2, 4678, 4679, 7, 314, 2, 2, 4679, 4681, 7, 412, 2, 2, 4680, 4676, 3,
	2, 2, 2, 4680, 4681, 3, 2, 2, 2, 4681, 783, 3, 2, 2, 2, 4682, 4684, 7,
	237, 2, 2, 4683, 4685, 5, 1128, 565, 2, 4684, 4683, 3, 2, 2, 2, 4685, 4686,
	3, 2, 2, 2, 4686, 4684, 3, 2, 2, 2, 4686, 4687, 3, 2, 2, 2, 4687, 785,
	3, 2, 2, 2, 4688, 4690, 7, 206, 2, 2, 4689, 4691, 5, 1128, 565, 2, 4690,
	4689, 3, 2, 2, 2, 4691, 4692, 3, 2, 2, 2, 4692, 4690, 3, 2, 2, 2, 4692,
	4693, 3, 2, 2, 2, 4693, 787, 3, 2, 2, 2, 4694, 4697, 7, 350, 2, 2, 4695,
	4698, 5, 790, 396, 2, 4696, 4698, 5, 792, 397, 2, 4697, 4695, 3, 2, 2,
	2, 4697, 4696, 3, 2, 2, 2, 4698, 789, 3, 2, 2, 2, 4699, 4701, 5, 794, 398,
	2, 4700, 4699, 3, 2, 2, 2, 4700, 4701, 3, 2, 2, 2, 4701, 4703, 3, 2, 2,
	2, 4702, 4704, 5, 536, 269, 2, 4703, 4702, 3, 2, 2, 2, 4704, 4705, 3, 2,
	2, 2, 4705, 4703, 3, 2, 2, 2, 4705, 4706, 3, 2, 2, 2, 4706, 4707, 3, 2,
	2, 2, 4707, 4708, 7, 174, 2, 2, 4708, 791, 3, 2, 2, 2, 4709, 4712, 5, 1144,
	573, 2, 4710, 4711, 9, 7, 2, 2, 4711, 4713, 5, 1144, 573, 2, 4712, 4710,
	3, 2, 2, 2, 4712, 4713, 3, 2, 2, 2, 4713, 4715, 3, 2, 2, 2, 4714, 4716,
	5, 794, 398, 2, 4715, 4714, 3, 2, 2, 2, 4715, 4716, 3, 2, 2, 2, 4716, 793,
	3, 2, 2, 2, 4717, 4721, 5, 796, 399, 2, 4718, 4721, 5, 798, 400, 2, 4719,
	4721, 5, 800, 401, 2, 4720, 4717, 3, 2, 2, 2, 4720, 4718, 3, 2, 2, 2, 4720,
	4719, 3, 2, 2, 2, 4721, 795, 3, 2, 2, 2, 4722, 4725, 5, 1068, 535, 2, 4723,
	4725, 5, 1172, 587, 2, 4724, 4722, 3, 2, 2, 2, 4724, 4723, 3, 2, 2, 2,
	4725, 4726, 3, 2, 2, 2, 4726, 4727, 7, 493, 2, 2, 4727, 797, 3, 2, 2, 2,
	4728, 4730, 5, 812, 407, 2, 4729, 4728, 3, 2, 2, 2, 4729, 4730, 3, 2, 2,
	2, 4730, 4731, 3, 2, 2, 2, 4731, 4732, 7, 507, 2, 2, 4732, 4733, 5, 1040,
	521, 2, 4733, 799, 3, 2, 2, 2, 4734, 4735, 5, 812, 407, 2, 4735, 4736,
	5, 802, 402, 2, 4736, 4742, 3, 2, 2, 2, 4737, 4739, 5, 802, 402, 2, 4738,
	4740, 5, 812, 407, 2, 4739, 4738, 3, 2, 2, 2, 4739, 4740, 3, 2, 2, 2, 4740,
	4742, 3, 2, 2, 2, 4741, 4734, 3, 2, 2, 2, 4741, 4737, 3, 2, 2, 2, 4742,
	801, 3, 2, 2, 2, 4743, 4744, 7, 515, 2, 2, 4744, 4748, 5, 804, 403, 2,
	4745, 4747, 5, 806, 404, 2, 4746, 4745, 3, 2, 2, 2, 4747, 4750, 3, 2, 2,
	2, 4748, 4746, 3, 2, 2, 2, 4748, 4749, 3, 2, 2, 2, 4749, 803, 3, 2, 2,
	2, 4750, 4748, 3, 2, 2, 2, 4751, 4754, 5, 1068, 535, 2, 4752, 4754, 5,
	1166, 584, 2, 4753, 4751, 3, 2, 2, 2, 4753, 4752, 3, 2, 2, 2, 4754, 4755,
	3, 2, 2, 2, 4755, 4756, 5, 808, 405, 2, 4756, 4757, 5, 810, 406, 2, 4757,
	4758, 5, 798, 400, 2, 4758, 805, 3, 2, 2, 2, 4759, 4760, 7, 9, 2, 2, 4760,
	4761, 5, 804, 403, 2, 4761, 807, 3, 2, 2, 2, 4762, 4766, 7, 220, 2, 2,
	4763, 4767, 5, 1068, 535, 2, 4764, 4767, 5, 1166, 584, 2, 4765, 4767, 5,
	1026, 514, 2, 4766, 4763, 3, 2, 2, 2, 4766, 4764, 3, 2, 2, 2, 4766, 4765,
	3, 2, 2, 2, 4767, 809, 3, 2, 2, 2, 4768, 4772, 7, 53, 2, 2, 4769, 4773,
	5, 1068, 535, 2, 4770, 4773, 5, 1166, 584, 2, 4771, 4773, 5, 1026, 514,
	2, 4772, 4769, 3, 2, 2, 2, 4772, 4770, 3, 2, 2, 2, 4772, 4771, 3, 2, 2,
	2, 4773, 811, 3, 2, 2, 2, 4774, 4776, 7, 520, 2, 2, 4775, 4774, 3, 2, 2,
	2, 4775, 4776, 3, 2, 2, 2, 4776, 4777, 3, 2, 2, 2, 4777, 4778, 7, 483,
	2, 2, 4778, 4779, 9, 57, 2, 2, 4779, 813, 3, 2, 2, 2, 4780, 4782, 7, 372,
	2, 2, 4781, 4783, 5, 1114, 558, 2, 4782, 4781, 3, 2, 2, 2, 4783, 4784,
	3, 2, 2, 2, 4784, 4782, 3, 2, 2, 2, 4784, 4785, 3, 2, 2, 2, 4785, 815,
	3, 2, 2, 2, 4786, 4787, 7, 381, 2, 2, 4787, 4789, 5, 1128, 565, 2, 4788,
	4790, 7, 313, 2, 2, 4789, 4788, 3, 2, 2, 2, 4789, 4790, 3, 2, 2, 2, 4790,
	4792, 3, 2, 2, 2, 4791, 4793, 7, 384, 2, 2, 4792, 4791, 3, 2, 2, 2, 4792,
	4793, 3, 2, 2, 2, 4793, 4795, 3, 2, 2, 2, 4794, 4796, 5, 818, 410, 2, 4795,
	4794, 3, 2, 2, 2, 4795, 4796, 3, 2, 2, 2, 4796, 4798, 3, 2, 2, 2, 4797,
	4799, 5, 820, 411, 2, 4798, 4797, 3, 2, 2, 2, 4798, 4799, 3, 2, 2, 2, 4799,
	4801, 3, 2, 2, 2, 4800, 4802, 5, 822, 412, 2, 4801, 4800, 3, 2, 2, 2, 4801,
	4802, 3, 2, 2, 2, 4802, 4804, 3, 2, 2, 2, 4803, 4805, 5, 1010, 506, 2,
	4804, 4803, 3, 2, 2, 2, 4804, 4805, 3, 2, 2, 2, 4805, 4807, 3, 2, 2, 2,
	4806, 4808, 5, 1012, 507, 2, 4807, 4806, 3, 2, 2, 2, 4807, 4808, 3, 2,
	2, 2, 4808, 4810, 3, 2, 2, 2, 4809, 4811, 5, 1006, 504, 2, 4810, 4809,
	3, 2, 2, 2, 4810, 4811, 3, 2, 2, 2, 4811, 4813, 3, 2, 2, 2, 4812, 4814,
	5, 1008, 505, 2, 4813, 4812, 3, 2, 2, 2, 4813, 4814, 3, 2, 2, 2, 4814,
	4816, 3, 2, 2, 2, 4815, 4817, 7, 175, 2, 2, 4816, 4815, 3, 2, 2, 2, 4816,
	4817, 3, 2, 2, 2, 4817, 817, 3, 2, 2, 2, 4818, 4819, 7, 256, 2, 2, 4819,
	4820, 5, 1068, 535, 2, 4820, 819, 3, 2, 2, 2, 4821, 4823, 7, 520, 2, 2,
	4822, 4821, 3, 2, 2, 2, 4822, 4823, 3, 2, 2, 2, 4823, 4827, 3, 2, 2, 2,
	4824, 4825, 9, 58, 2, 2, 4825, 4828, 7, 291, 2, 2, 4826, 4828, 7, 517,
	2, 2, 4827, 4824, 3, 2, 2, 2, 4827, 4826, 3, 2, 2, 2, 4828, 821, 3, 2,
	2, 2, 4829, 4831, 7, 264, 2, 2, 4830, 4832, 7, 259, 2, 2, 4831, 4830, 3,
	2, 2, 2, 4831, 4832, 3, 2, 2, 2, 4832, 4833, 3, 2, 2, 2, 4833, 4834, 5,
	1084, 543, 2, 4834, 823, 3, 2, 2, 2, 4835, 4838, 7, 382, 2, 2, 4836, 4839,
	5, 826, 414, 2, 4837, 4839, 5, 830, 416, 2, 4838, 4836, 3, 2, 2, 2, 4838,
	4837, 3, 2, 2, 2, 4839, 4841, 3, 2, 2, 2, 4840, 4842, 5, 1022, 512, 2,
	4841, 4840, 3, 2, 2, 2, 4841, 4842, 3, 2, 2, 2, 4842, 4844, 3, 2, 2, 2,
	4843, 4845, 5, 1024, 513, 2, 4844, 4843, 3, 2, 2, 2, 4844, 4845, 3, 2,
	2, 2, 4845, 4847, 3, 2, 2, 2, 4846, 4848, 7, 176, 2, 2, 4847, 4846, 3,
	2, 2, 2, 4847, 4848, 3, 2, 2, 2, 4848, 825, 3, 2, 2, 2, 4849, 4850, 5,
	1122, 562, 2, 4850, 4851, 7, 220, 2, 2, 4851, 4859, 5, 828, 415, 2, 4852,
	4858, 5, 836, 419, 2, 4853, 4858, 5, 838, 420, 2, 4854, 4858, 5, 840, 421,
	2, 4855, 4858, 5, 842, 422, 2, 4856, 4858, 5, 844, 423, 2, 4857, 4852,
	3, 2, 2, 2, 4857, 4853, 3, 2, 2, 2, 4857, 4854, 3, 2, 2, 2, 4857, 4855,
	3, 2, 2, 2, 4857, 4856, 3, 2, 2, 2, 4858, 4861, 3, 2, 2, 2, 4859, 4857,
	3, 2, 2, 2, 4859, 4860, 3, 2, 2, 2, 4860, 827, 3, 2, 2, 2, 4861, 4859,
	3, 2, 2, 2, 4862, 4863, 7, 487, 2, 2, 4863, 4869, 5, 1122, 562, 2, 4864,
	4865, 7, 267, 2, 2, 4865, 4869, 7, 487, 2, 2, 4866, 4867, 7, 22, 2, 2,
	4867, 4869, 7, 487, 2, 2, 4868, 4862, 3, 2, 2, 2, 4868, 4864, 3, 2, 2,
	2, 4868, 4866, 3, 2, 2, 2, 4869, 829, 3, 2, 2, 2, 4870, 4871, 5, 1114,
	558, 2, 4871, 4873, 9, 59, 2, 2, 4872, 4874, 7, 256, 2, 2, 4873, 4872,
	3, 2, 2, 2, 4873, 4874, 3, 2, 2, 2, 4874, 4875, 3, 2, 2, 2, 4875, 4877,
	5, 1068, 535, 2, 4876, 4878, 5, 832, 417, 2, 4877, 4876, 3, 2, 2, 2, 4877,
	4878, 3, 2, 2, 2, 4878, 4880, 3, 2, 2, 2, 4879, 4881, 5, 834, 418, 2, 4880,
	4879, 3, 2, 2, 2, 4880, 4881, 3, 2, 2, 2, 4881, 831, 3, 2, 2, 2, 4882,
	4883, 7, 314, 2, 2, 4883, 4887, 7, 114, 2, 2, 4884, 4886, 5, 536, 269,
	2, 4885, 4884, 3, 2, 2, 2, 4886, 4889, 3, 2, 2, 2, 4887, 4885, 3, 2, 2,
	2, 4887, 4888, 3, 2, 2, 2, 4888, 833, 3, 2, 2, 2, 4889, 4887, 3, 2, 2,
	2, 4890, 4891, 7, 520, 2, 2, 4891, 4895, 7, 114, 2, 2, 4892, 4894, 5, 536,
	269, 2, 4893, 4892, 3, 2, 2, 2, 4894, 4897, 3, 2, 2, 2, 4895, 4893, 3,
	2, 2, 2, 4895, 4896, 3, 2, 2, 2, 4896, 835, 3, 2, 2, 2, 4897, 4895, 3,
	2, 2, 2, 4898, 4900, 7, 43, 2, 2, 4899, 4901, 7, 491, 2, 2, 4900, 4899,
	3, 2, 2, 2, 4900, 4901, 3, 2, 2, 2, 4901, 4904, 3, 2, 2, 2, 4902, 4905,
	5, 1170, 586, 2, 4903, 4905, 5, 1068, 535, 2, 4904, 4902, 3, 2, 2, 2, 4904,
	4903, 3, 2, 2, 2, 4905, 837, 3, 2, 2, 2, 4906, 4908, 7, 520, 2, 2, 4907,
	4906, 3, 2, 2, 2, 4907, 4908, 3, 2, 2, 2, 4908, 4909, 3, 2, 2, 2, 4909,
	4910, 7, 314, 2, 2, 4910, 4911, 7, 517, 2, 2, 4911, 839, 3, 2, 2, 2, 4912,
	4914, 7, 487, 2, 2, 4913, 4915, 7, 244, 2, 2, 4914, 4913, 3, 2, 2, 2, 4914,
	4915, 3, 2, 2, 2, 4915, 4916, 3, 2, 2, 2, 4916, 4917, 5, 1122, 562, 2,
	4917, 841, 3, 2, 2, 2, 4918, 4920, 7, 444, 2, 2, 4919, 4921, 7, 244, 2,
	2, 4920, 4919, 3, 2, 2, 2, 4920, 4921, 3, 2, 2, 2, 4921, 4924, 3, 2, 2,
	2, 4922, 4925, 5, 1170, 586, 2, 4923, 4925, 5, 1068, 535, 2, 4924, 4922,
	3, 2, 2, 2, 4924, 4923, 3, 2, 2, 2, 4925, 843, 3, 2, 2, 2, 4926, 4928,
	7, 463, 2, 2, 4927, 4929, 7, 244, 2, 2, 4928, 4927, 3, 2, 2, 2, 4928, 4929,
	3, 2, 2, 2, 4929, 4930, 3, 2, 2, 2, 4930, 4931, 5, 1068, 535, 2, 4931,
	845, 3, 2, 2, 2, 4932, 4933, 7, 393, 2, 2, 4933, 4936, 5, 1148, 575, 2,
	4934, 4935, 7, 220, 2, 2, 4935, 4937, 5, 1084, 543, 2, 4936, 4934, 3, 2,
	2, 2, 4936, 4937, 3, 2, 2, 2, 4937, 847, 3, 2, 2, 2, 4938, 4939, 7, 409,
	2, 2, 4939, 4941, 5, 1128, 565, 2, 4940, 4942, 7, 384, 2, 2, 4941, 4940,
	3, 2, 2, 2, 4941, 4942, 3, 2, 2, 2, 4942, 4944, 3, 2, 2, 2, 4943, 4945,
	5, 850, 426, 2, 4944, 4943, 3, 2, 2, 2, 4944, 4945, 3, 2, 2, 2, 4945, 4946,
	3, 2, 2, 2, 4946, 4948, 5, 1006, 504, 2, 4947, 4949, 5, 1008, 505, 2, 4948,
	4947, 3, 2, 2, 2, 4948, 4949, 3, 2, 2, 2, 4949, 4951, 3, 2, 2, 2, 4950,
	4952, 7, 177, 2, 2, 4951, 4950, 3, 2, 2, 2, 4951, 4952, 3, 2, 2, 2, 4952,
	849, 3, 2, 2, 2, 4953, 4954, 7, 256, 2, 2, 4954, 4955, 5, 1084, 543, 2,
	4955, 851, 3, 2, 2, 2, 4956, 4957, 7, 413, 2, 2, 4957, 4959, 5, 1148, 575,
	2, 4958, 4960, 5, 854, 428, 2, 4959, 4958, 3, 2, 2, 2, 4959, 4960, 3, 2,
	2, 2, 4960, 4962, 3, 2, 2, 2, 4961, 4963, 5, 1010, 506, 2, 4962, 4961,
	3, 2, 2, 2, 4962, 4963, 3, 2, 2, 2, 4963, 4965, 3, 2, 2, 2, 4964, 4966,
	5, 1012, 507, 2, 4965, 4964, 3, 2, 2, 2, 4965, 4966, 3, 2, 2, 2, 4966,
	4968, 3, 2, 2, 2, 4967, 4969, 7, 178, 2, 2, 4968, 4967, 3, 2, 2, 2, 4968,
	4969, 3, 2, 2, 2, 4969, 853, 3, 2, 2, 2, 4970, 4971, 7, 220, 2, 2, 4971,
	4972, 5, 1068, 535, 2, 4972, 855, 3, 2, 2, 2, 4973, 4975, 7, 423, 2, 2,
	4974, 4976, 7, 11, 2, 2, 4975, 4974, 3, 2, 2, 2, 4975, 4976, 3, 2, 2, 2,
	4976, 4977, 3, 2, 2, 2, 4977, 4979, 5, 1084, 543, 2, 4978, 4980, 5, 858,
	430, 2, 4979, 4978, 3, 2, 2, 2, 4979, 4980, 3, 2, 2, 2, 4980, 4982, 3,
	2, 2, 2, 4981, 4983, 5, 1006, 504, 2, 4982, 4981, 3, 2, 2, 2, 4982, 4983,
	3, 2, 2, 2, 4983, 4985, 3, 2, 2, 2, 4984, 4986, 5, 860, 431, 2, 4985, 4984,
	3, 2, 2, 2, 4986, 4987, 3, 2, 2, 2, 4987, 4985, 3, 2, 2, 2, 4987, 4988,
	3, 2, 2, 2, 4988, 4990, 3, 2, 2, 2, 4989, 4991, 7, 179, 2, 2, 4990, 4989,
	3, 2, 2, 2, 4990, 4991, 3, 2, 2, 2, 4991, 857, 3, 2, 2, 2, 4992, 4993,
	7, 515, 2, 2, 4993, 4994, 5, 1084, 543, 2, 4994, 859, 3, 2, 2, 2, 4995,
	4996, 7, 518, 2, 2, 4996, 5005, 5, 1040, 521, 2, 4997, 4998, 7, 313, 2,
	2, 4998, 5006, 7, 431, 2, 2, 4999, 5001, 5, 536, 269, 2, 5000, 4999, 3,
	2, 2, 2, 5001, 5004, 3, 2, 2, 2, 5002, 5000, 3, 2, 2, 2, 5002, 5003, 3,
	2, 2, 2, 5003, 5006, 3, 2, 2, 2, 5004, 5002, 3, 2, 2, 2, 5005, 4997, 3,
	2, 2, 2, 5005, 5002, 3, 2, 2, 2, 5006, 861, 3, 2, 2, 2, 5007, 5010, 7,
	430, 2, 2, 5008, 5011, 5, 864, 433, 2, 5009, 5011, 5, 866, 434, 2, 5010,
	5008, 3, 2, 2, 2, 5010, 5009, 3, 2, 2, 2, 5011, 5013, 3, 2, 2, 2, 5012,
	5014, 5, 1022, 512, 2, 5013, 5012, 3, 2, 2, 2, 5013, 5014, 3, 2, 2, 2,
	5014, 5016, 3, 2, 2, 2, 5015, 5017, 5, 1024, 513, 2, 5016, 5015, 3, 2,
	2, 2, 5016, 5017, 3, 2, 2, 2, 5017, 863, 3, 2, 2, 2, 5018, 5021, 5, 1068,
	535, 2, 5019, 5021, 5, 1166, 584, 2, 5020, 5018, 3, 2, 2, 2, 5020, 5019,
	3, 2, 2, 2, 5021, 5023, 3, 2, 2, 2, 5022, 5024, 5, 868, 435, 2, 5023, 5022,
	3, 2, 2, 2, 5023, 5024, 3, 2, 2, 2, 5024, 5026, 3, 2, 2, 2, 5025, 5027,
	5, 870, 436, 2, 5026, 5025, 3, 2, 2, 2, 5026, 5027, 3, 2, 2, 2, 5027, 5029,
	3, 2, 2, 2, 5028, 5030, 5, 872, 437, 2, 5029, 5028, 3, 2, 2, 2, 5029, 5030,
	3, 2, 2, 2, 5030, 5032, 3, 2, 2, 2, 5031, 5033, 5, 874, 438, 2, 5032, 5031,
	3, 2, 2, 2, 5032, 5033, 3, 2, 2, 2, 5033, 865, 3, 2, 2, 2, 5034, 5035,
	7, 495, 2, 2, 5035, 5036, 9, 60, 2, 2, 5036, 5037, 5, 1068, 535, 2, 5037,
	867, 3, 2, 2, 2, 5038, 5039, 7, 220, 2, 2, 5039, 5040, 5, 1068, 535, 2,
	5040, 869, 3, 2, 2, 2, 5041, 5046, 7, 520, 2, 2, 5042, 5047, 7, 158, 2,
	2, 5043, 5047, 7, 161, 2, 2, 5044, 5047, 7, 197, 2, 2, 5045, 5047, 5, 1068,
	535, 2, 5046, 5042, 3, 2, 2, 2, 5046, 5043, 3, 2, 2, 2, 5046, 5044, 3,
	2, 2, 2, 5046, 5045, 3, 2, 2, 2, 5047, 871, 3, 2, 2, 2, 5048, 5050, 7,
	400, 2, 2, 5049, 5051, 7, 284, 2, 2, 5050, 5049, 3, 2, 2, 2, 5050, 5051,
	3, 2, 2, 2, 5051, 873, 3, 2, 2, 2, 5052, 5054, 9, 57, 2, 2, 5053, 5055,
	7, 8, 2, 2, 5054, 5053, 3, 2, 2, 2, 5054, 5055, 3, 2, 2, 2, 5055, 5059,
	3, 2, 2, 2, 5056, 5060, 5, 876, 439, 2, 5057, 5060, 5, 878, 440, 2, 5058,
	5060, 5, 880, 441, 2, 5059, 5056, 3, 2, 2, 2, 5059, 5057, 3, 2, 2, 2, 5059,
	5058, 3, 2, 2, 2, 5060, 875, 3, 2, 2, 2, 5061, 5062, 7, 347, 2, 2, 5062,
	877, 3, 2, 2, 2, 5063, 5066, 5, 1068, 535, 2, 5064, 5066, 5, 1166, 584,
	2, 5065, 5063, 3, 2, 2, 2, 5065, 5064, 3, 2, 2, 2, 5066, 5068, 3, 2, 2,
	2, 5067, 5069, 9, 36, 2, 2, 5068, 5067, 3, 2, 2, 2, 5068, 5069, 3, 2, 2,
	2, 5069, 879, 3, 2, 2, 2, 5070, 5071, 5, 1140, 571, 2, 5071, 881, 3, 2,
	2, 2, 5072, 5079, 7, 435, 2, 2, 5073, 5075, 5, 884, 443, 2, 5074, 5073,
	3, 2, 2, 2, 5075, 5076, 3, 2, 2, 2, 5076, 5074, 3, 2, 2, 2, 5076, 5077,
	3, 2, 2, 2, 5077, 5080, 3, 2, 2, 2, 5078, 5080, 5, 886, 444, 2, 5079, 5074,
	3, 2, 2, 2, 5079, 5078, 3, 2, 2, 2, 5080, 883, 3, 2, 2, 2, 5081, 5083,
	5, 888, 445, 2, 5082, 5081, 3, 2, 2, 2, 5083, 5084, 3, 2, 2, 2, 5084, 5082,
	3, 2, 2, 2, 5084, 5085, 3, 2, 2, 2, 5085, 5086, 3, 2, 2, 2, 5086, 5088,
	7, 495, 2, 2, 5087, 5089, 5, 890, 446, 2, 5088, 5087, 3, 2, 2, 2, 5089,
	5090, 3, 2, 2, 2, 5090, 5088, 3, 2, 2, 2, 5090, 5091, 3, 2, 2, 2, 5091,
	885, 3, 2, 2, 2, 5092, 5094, 5, 888, 445, 2, 5093, 5092, 3, 2, 2, 2, 5094,
	5095, 3, 2, 2, 2, 5095, 5093, 3, 2, 2, 2, 5095, 5096, 3, 2, 2, 2, 5096,
	5101, 3, 2, 2, 2, 5097, 5098, 7, 508, 2, 2, 5098, 5102, 7, 53, 2, 2, 5099,
	5100, 7, 153, 2, 2, 5100, 5102, 7, 53, 2, 2, 5101, 5097, 3, 2, 2, 2, 5101,
	5099, 3, 2, 2, 2, 5102, 5103, 3, 2, 2, 2, 5103, 5104, 5, 892, 447, 2, 5104,
	887, 3, 2, 2, 2, 5105, 5106, 5, 1068, 535, 2, 5106, 889, 3, 2, 2, 2, 5107,
	5112, 7, 332, 2, 2, 5108, 5112, 7, 330, 2, 2, 5109, 5112, 5, 1068, 535,
	2, 5110, 5112, 5, 1166, 584, 2, 5111, 5107, 3, 2, 2, 2, 5111, 5108, 3,
	2, 2, 2, 5111, 5109, 3, 2, 2, 2, 5111, 5110, 3, 2, 2, 2, 5112, 891, 3,
	2, 2, 2, 5113, 5116, 5, 1068, 535, 2, 5114, 5116, 5, 1166, 584, 2, 5115,
	5113, 3, 2, 2, 2, 5115, 5114, 3, 2, 2, 2, 5116, 893, 3, 2, 2, 2, 5117,
	5118, 7, 445, 2, 2, 5118, 5120, 5, 1128, 565, 2, 5119, 5121, 5, 896, 449,
	2, 5120, 5119, 3, 2, 2, 2, 5121, 5122, 3, 2, 2, 2, 5122, 5120, 3, 2, 2,
	2, 5122, 5123, 3, 2, 2, 2, 5123, 5125, 3, 2, 2, 2, 5124, 5126, 5, 898,
	450, 2, 5125, 5124, 3, 2, 2, 2, 5125, 5126, 3, 2, 2, 2, 5126, 5128, 3,
	2, 2, 2, 5127, 5129, 5, 900, 451, 2, 5128, 5127, 3, 2, 2, 2, 5128, 5129,
	3, 2, 2, 2, 5129, 5131, 3, 2, 2, 2, 5130, 5132, 5, 906, 454, 2, 5131, 5130,
	3, 2, 2, 2, 5131, 5132, 3, 2, 2, 2, 5132, 5136, 3, 2, 2, 2, 5133, 5135,
	5, 910, 456, 2, 5134, 5133, 3, 2, 2, 2, 5135, 5138, 3, 2, 2, 2, 5136, 5134,
	3, 2, 2, 2, 5136, 5137, 3, 2, 2, 2, 5137, 5140, 3, 2, 2, 2, 5138, 5136,
	3, 2, 2, 2, 5139, 5141, 5, 912, 457, 2, 5140, 5139, 3, 2, 2, 2, 5140, 5141,
	3, 2, 2, 2, 5141, 5145, 3, 2, 2, 2, 5142, 5144, 5, 916, 459, 2, 5143, 5142,
	3, 2, 2, 2, 5144, 5147, 3, 2, 2, 2, 5145, 5143, 3, 2, 2, 2, 5145, 5146,
	3, 2, 2, 2, 5146, 895, 3, 2, 2, 2, 5147, 5145, 3, 2, 2, 2, 5148, 5150,
	7, 332, 2, 2, 5149, 5148, 3, 2, 2, 2, 5149, 5150, 3, 2, 2, 2, 5150, 5151,
	3, 2, 2, 2, 5151, 5153, 9, 44, 2, 2, 5152, 5154, 7, 264, 2, 2, 5153, 5152,
	3, 2, 2, 2, 5153, 5154, 3, 2, 2, 2, 5154, 5156, 3, 2, 2, 2, 5155, 5157,
	5, 1084, 543, 2, 5156, 5155, 3, 2, 2, 2, 5157, 5158, 3, 2, 2, 2, 5158,
	5156, 3, 2, 2, 2, 5158, 5159, 3, 2, 2, 2, 5159, 897, 3, 2, 2, 2, 5160,
	5162, 7, 520, 2, 2, 5161, 5160, 3, 2, 2, 2, 5161, 5162, 3, 2, 2, 2, 5162,
	5163, 3, 2, 2, 2, 5163, 5165, 7, 154, 2, 2, 5164, 5166, 7, 244, 2, 2, 5165,
	5164, 3, 2, 2, 2, 5165, 5166, 3, 2, 2, 2, 5166, 5168, 3, 2, 2, 2, 5167,
	5169, 7, 337, 2, 2, 5168, 5167, 3, 2, 2, 2, 5168, 5169, 3, 2, 2, 2, 5169,
	899, 3, 2, 2, 2, 5170, 5172, 7, 77, 2, 2, 5171, 5170, 3, 2, 2, 2, 5171,
	5172, 3, 2, 2, 2, 5172, 5173, 3, 2, 2, 2, 5173, 5175, 7, 433, 2, 2, 5174,
	5176, 7, 259, 2, 2, 5175, 5174, 3, 2, 2, 2, 5175, 5176, 3, 2, 2, 2, 5176,
	5178, 3, 2, 2, 2, 5177, 5179, 5, 1108, 555, 2, 5178, 5177, 3, 2, 2, 2,
	5179, 5180, 3, 2, 2, 2, 5180, 5178, 3, 2, 2, 2, 5180, 5181, 3, 2, 2, 2,
	5181, 5183, 3, 2, 2, 2, 5182, 5184, 5, 902, 452, 2, 5183, 5182, 3, 2, 2,
	2, 5183, 5184, 3, 2, 2, 2, 5184, 5186, 3, 2, 2, 2, 5185, 5187, 5, 904,
	453, 2, 5186, 5185, 3, 2, 2, 2, 5186, 5187, 3, 2, 2, 2, 5187, 901, 3, 2,
	2, 2, 5188, 5190, 7, 217, 2, 2, 5189, 5188, 3, 2, 2, 2, 5189, 5190, 3,
	2, 2, 2, 5190, 5191, 3, 2, 2, 2, 5191, 5192, 7, 16, 2, 2, 5192, 5193, 7,
	259, 2, 2, 5193, 5194, 5, 1108, 555, 2, 5194, 903, 3, 2, 2, 2, 5195, 5197,
	7, 217, 2, 2, 5196, 5195, 3, 2, 2, 2, 5196, 5197, 3, 2, 2, 2, 5197, 5198,
	3, 2, 2, 2, 5198, 5200, 7, 309, 2, 2, 5199, 5201, 7, 259, 2, 2, 5200, 5199,
	3, 2, 2, 2, 5200, 5201, 3, 2, 2, 2, 5201, 5202, 3, 2, 2, 2, 5202, 5203,
	5, 1108, 555, 2, 5203, 905, 3, 2, 2, 2, 5204, 5205, 7, 251, 2, 2, 5205,
	5207, 7, 363, 2, 2, 5206, 5208, 7, 259, 2, 2, 5207, 5206, 3, 2, 2, 2, 5207,
	5208, 3, 2, 2, 2, 5208, 5209, 3, 2, 2, 2, 5209, 5211, 5, 1144, 573, 2,
	5210, 5212, 5, 908, 455, 2, 5211, 5210, 3, 2, 2, 2, 5211, 5212, 3, 2, 2,
	2, 5212, 907, 3, 2, 2, 2, 5213, 5214, 9, 7, 2, 2, 5214, 5215, 5, 1144,
	573, 2, 5215, 909, 3, 2, 2, 2, 5216, 5218, 7, 512, 2, 2, 5217, 5219, 5,
	1128, 565, 2, 5218, 5217, 3, 2, 2, 2, 5219, 5220, 3, 2, 2, 2, 5220, 5218,
	3, 2, 2, 2, 5220, 5221, 3, 2, 2, 2, 5221, 911, 3, 2, 2, 2, 5222, 5223,
	7, 341, 2, 2, 5223, 5225, 7, 363, 2, 2, 5224, 5226, 7, 259, 2, 2, 5225,
	5224, 3, 2, 2, 2, 5225, 5226, 3, 2, 2, 2, 5226, 5227, 3, 2, 2, 2, 5227,
	5229, 5, 1144, 573, 2, 5228, 5230, 5, 914, 458, 2, 5229, 5228, 3, 2, 2,
	2, 5229, 5230, 3, 2, 2, 2, 5230, 913, 3, 2, 2, 2, 5231, 5232, 9, 7, 2,
	2, 5232, 5233, 5, 1144, 573, 2, 5233, 915, 3, 2, 2, 2, 5234, 5236, 7, 227,
	2, 2, 5235, 5237, 5, 918, 460, 2, 5236, 5235, 3, 2, 2, 2, 5237, 5238, 3,
	2, 2, 2, 5238, 5236, 3, 2, 2, 2, 5238, 5239, 3, 2, 2, 2, 5239, 917, 3,
	2, 2, 2, 5240, 5250, 5, 1128, 565, 2, 5241, 5251, 7, 291, 2, 2, 5242, 5251,
	7, 420, 2, 2, 5243, 5244, 7, 314, 2, 2, 5244, 5251, 7, 412, 2, 2, 5245,
	5251, 7, 111, 2, 2, 5246, 5251, 7, 393, 2, 2, 5247, 5248, 7, 520, 2, 2,
	5248, 5249, 7, 397, 2, 2, 5249, 5251, 7, 111, 2, 2, 5250, 5241, 3, 2, 2,
	2, 5250, 5242, 3, 2, 2, 2, 5250, 5243, 3, 2, 2, 2, 5250, 5245, 3, 2, 2,
	2, 5250, 5246, 3, 2, 2, 2, 5250, 5247, 3, 2, 2, 2, 5250, 5251, 3, 2, 2,
	2, 5251, 919, 3, 2, 2, 2, 5252, 5253, 7, 462, 2, 2, 5253, 5255, 5, 1128,
	565, 2, 5254, 5256, 5, 922, 462, 2, 5255, 5254, 3, 2, 2, 2, 5255, 5256,
	3, 2, 2, 2, 5256, 5258, 3, 2, 2, 2, 5257, 5259, 5, 1010, 506, 2, 5258,
	5257, 3, 2, 2, 2, 5258, 5259, 3, 2, 2, 2, 5259, 5261, 3, 2, 2, 2, 5260,
	5262, 5, 1012, 507, 2, 5261, 5260, 3, 2, 2, 2, 5261, 5262, 3, 2, 2, 2,
	5262, 5264, 3, 2, 2, 2, 5263, 5265, 7, 180, 2, 2, 5264, 5263, 3, 2, 2,
	2, 5264, 5265, 3, 2, 2, 2, 5265, 921, 3, 2, 2, 2, 5266, 5268, 7, 264, 2,
	2, 5267, 5269, 7, 259, 2, 2, 5268, 5267, 3, 2, 2, 2, 5268, 5269, 3, 2,
	2, 2, 5269, 5297, 3, 2, 2, 2, 5270, 5272, 7, 191, 2, 2, 5271, 5273, 7,
	495, 2, 2, 5272, 5271, 3, 2, 2, 2, 5272, 5273, 3, 2, 2, 2, 5273, 5298,
	3, 2, 2, 2, 5274, 5298, 7, 543, 2, 2, 5275, 5277, 7, 230, 2, 2, 5276, 5278,
	7, 485, 2, 2, 5277, 5276, 3, 2, 2, 2, 5277, 5278, 3, 2, 2, 2, 5278, 5298,
	3, 2, 2, 2, 5279, 5298, 7, 551, 2, 2, 5280, 5281, 7, 318, 2, 2, 5281, 5283,
	7, 275, 2, 2, 5282, 5284, 7, 485, 2, 2, 5283, 5282, 3, 2, 2, 2, 5283, 5284,
	3, 2, 2, 2, 5284, 5298, 3, 2, 2, 2, 5285, 5286, 7, 318, 2, 2, 5286, 5298,
	7, 547, 2, 2, 5287, 5289, 7, 230, 2, 2, 5288, 5290, 7, 485, 2, 2, 5289,
	5288, 3, 2, 2, 2, 5289, 5290, 3, 2, 2, 2, 5290, 5291, 3, 2, 2, 2, 5291,
	5292, 7, 336, 2, 2, 5292, 5294, 7, 191, 2, 2, 5293, 5295, 7, 495, 2, 2,
	5294, 5293, 3, 2, 2, 2, 5294, 5295, 3, 2, 2, 2, 5295, 5298, 3, 2, 2, 2,
	5296, 5298, 7, 552, 2, 2, 5297, 5270, 3, 2, 2, 2, 5297, 5274, 3, 2, 2,
	2, 5297, 5275, 3, 2, 2, 2, 5297, 5279, 3, 2, 2, 2, 5297, 5280, 3, 2, 2,
	2, 5297, 5285, 3, 2, 2, 2, 5297, 5287, 3, 2, 2, 2, 5297, 5296, 3, 2, 2,
	2, 5298, 5299, 3, 2, 2, 2, 5299, 5300, 5, 1084, 543, 2, 5300, 923, 3, 2,
	2, 2, 5301, 5304, 7, 464, 2, 2, 5302, 5305, 7, 418, 2, 2, 5303, 5305, 5,
	1166, 584, 2, 5304, 5302, 3, 2, 2, 2, 5304, 5303, 3, 2, 2, 2, 5305, 925,
	3, 2, 2, 2, 5306, 5308, 7, 465, 2, 2, 5307, 5309, 5, 928, 465, 2, 5308,
	5307, 3, 2, 2, 2, 5309, 5310, 3, 2, 2, 2, 5310, 5308, 3, 2, 2, 2, 5310,
	5311, 3, 2, 2, 2, 5311, 5312, 3, 2, 2, 2, 5312, 5314, 5, 936, 469, 2, 5313,
	5315, 5, 938, 470, 2, 5314, 5313, 3, 2, 2, 2, 5314, 5315, 3, 2, 2, 2, 5315,
	5317, 3, 2, 2, 2, 5316, 5318, 5, 1014, 508, 2, 5317, 5316, 3, 2, 2, 2,
	5317, 5318, 3, 2, 2, 2, 5318, 5320, 3, 2, 2, 2, 5319, 5321, 5, 1016, 509,
	2, 5320, 5319, 3, 2, 2, 2, 5320, 5321, 3, 2, 2, 2, 5321, 5323, 3, 2, 2,
	2, 5322, 5324, 7, 181, 2, 2, 5323, 5322, 3, 2, 2, 2, 5323, 5324, 3, 2,
	2, 2, 5324, 927, 3, 2, 2, 2, 5325, 5327, 5, 930, 466, 2, 5326, 5325, 3,
	2, 2, 2, 5327, 5328, 3, 2, 2, 2, 5328, 5326, 3, 2, 2, 2, 5328, 5329, 3,
	2, 2, 2, 5329, 5332, 3, 2, 2, 2, 5330, 5333, 5, 932, 467, 2, 5331, 5333,
	5, 934, 468, 2, 5332, 5330, 3, 2, 2, 2, 5332, 5331, 3, 2, 2, 2, 5333, 929,
	3, 2, 2, 2, 5334, 5337, 5, 1070, 536, 2, 5335, 5337, 5, 1166, 584, 2, 5336,
	5334, 3, 2, 2, 2, 5336, 5335, 3, 2, 2, 2, 5337, 931, 3, 2, 2, 2, 5338,
	5340, 7, 137, 2, 2, 5339, 5341, 7, 53, 2, 2, 5340, 5339, 3, 2, 2, 2, 5340,
	5341, 3, 2, 2, 2, 5341, 5345, 3, 2, 2, 2, 5342, 5346, 7, 444, 2, 2, 5343,
	5346, 5, 1068, 535, 2, 5344, 5346, 5, 1166, 584, 2, 5345, 5342, 3, 2, 2,
	2, 5345, 5343, 3, 2, 2, 2, 5345, 5344, 3, 2, 2, 2, 5346, 933, 3, 2, 2,
	2, 5347, 5350, 7, 217, 2, 2, 5348, 5351, 5, 1068, 535, 2, 5349, 5351, 5,
	1166, 584, 2, 5350, 5348, 3, 2, 2, 2, 5350, 5349, 3, 2, 2, 2, 5351, 935,
	3, 2, 2, 2, 5352, 5353, 7, 256, 2, 2, 5353, 5354, 5, 1068, 535, 2, 5354,
	937, 3, 2, 2, 2, 5355, 5357, 7, 520, 2, 2, 5356, 5355, 3, 2, 2, 2, 5356,
	5357, 3, 2, 2, 2, 5357, 5358, 3, 2, 2, 2, 5358, 5359, 7, 356, 2, 2, 5359,
	5360, 5, 1084, 543, 2, 5360, 939, 3, 2, 2, 2, 5361, 5365, 7, 469, 2, 2,
	5362, 5366, 5, 942, 472, 2, 5363, 5366, 5, 944, 473, 2, 5364, 5366, 5,
	946, 474, 2, 5365, 5362, 3, 2, 2, 2, 5365, 5363, 3, 2, 2, 2, 5365, 5364,
	3, 2, 2, 2, 5366, 5368, 3, 2, 2, 2, 5367, 5369, 5, 1018, 510, 2, 5368,
	5367, 3, 2, 2, 2, 5368, 5369, 3, 2, 2, 2, 5369, 5371, 3, 2, 2, 2, 5370,
	5372, 5, 1020, 511, 2, 5371, 5370, 3, 2, 2, 2, 5371, 5372, 3, 2, 2, 2,
	5372, 5374, 3, 2, 2, 2, 5373, 5375, 7, 182, 2, 2, 5374, 5373, 3, 2, 2,
	2, 5374, 5375, 3, 2, 2, 2, 5375, 941, 3, 2, 2, 2, 5376, 5378, 5, 948, 475,
	2, 5377, 5376, 3, 2, 2, 2, 5378, 5379, 3, 2, 2, 2, 5379, 5377, 3, 2, 2,
	2, 5379, 5380, 3, 2, 2, 2, 5380, 5381, 3, 2, 2, 2, 5381, 5383, 7, 220,
	2, 2, 5382, 5384, 5, 950, 476, 2, 5383, 5382, 3, 2, 2, 2, 5384, 5385, 3,
	2, 2, 2, 5385, 5383, 3, 2, 2, 2, 5385, 5386, 3, 2, 2, 2, 5386, 943, 3,
	2, 2, 2, 5387, 5389, 5, 948, 475, 2, 5388, 5387, 3, 2, 2, 2, 5389, 5390,
	3, 2, 2, 2, 5390, 5388, 3, 2, 2, 2, 5390, 5391, 3, 2, 2, 2, 5391, 5392,
	3, 2, 2, 2, 5392, 5393, 7, 220, 2, 2, 5393, 5394, 5, 952, 477, 2, 5394,
	5396, 7, 227, 2, 2, 5395, 5397, 5, 954, 478, 2, 5396, 5395, 3, 2, 2, 2,
	5397, 5398, 3, 2, 2, 2, 5398, 5396, 3, 2, 2, 2, 5398, 5399, 3, 2, 2, 2,
	5399, 945, 3, 2, 2, 2, 5400, 5401, 9, 51, 2, 2, 5401, 5402, 5, 1084, 543,
	2, 5402, 5403, 7, 220, 2, 2, 5403, 5404, 5, 956, 479, 2, 5404, 947, 3,
	2, 2, 2, 5405, 5408, 5, 1068, 535, 2, 5406, 5408, 5, 1166, 584, 2, 5407,
	5405, 3, 2, 2, 2, 5407, 5406, 3, 2, 2, 2, 5408, 949, 3, 2, 2, 2, 5409,
	5411, 5, 1068, 535, 2, 5410, 5412, 7, 417, 2, 2, 5411, 5410, 3, 2, 2, 2,
	5411, 5412, 3, 2, 2, 2, 5412, 951, 3, 2, 2, 2, 5413, 5416, 5, 1068, 535,
	2, 5414, 5416, 5, 1166, 584, 2, 5415, 5413, 3, 2, 2, 2, 5415, 5414, 3,
	2, 2, 2, 5416, 953, 3, 2, 2, 2, 5417, 5419, 5, 1068, 535, 2, 5418, 5420,
	7, 417, 2, 2, 5419, 5418, 3, 2, 2, 2, 5419, 5420, 3, 2, 2, 2, 5420, 955,
	3, 2, 2, 2, 5421, 5423, 5, 1084, 543, 2, 5422, 5424, 7, 417, 2, 2, 5423,
	5422, 3, 2, 2, 2, 5423, 5424, 3, 2, 2, 2, 5424, 957, 3, 2, 2, 2, 5425,
	5426, 7, 482, 2, 2, 5426, 5427, 5, 1150, 576, 2, 5427, 959, 3, 2, 2, 2,
	5428, 5429, 7, 506, 2, 2, 5429, 5430, 5, 962, 482, 2, 5430, 5432, 5, 968,
	485, 2, 5431, 5433, 5, 976, 489, 2, 5432, 5431, 3, 2, 2, 2, 5432, 5433,
	3, 2, 2, 2, 5433, 5435, 3, 2, 2, 2, 5434, 5436, 5, 978, 490, 2, 5435, 5434,
	3, 2, 2, 2, 5435, 5436, 3, 2, 2, 2, 5436, 5438, 3, 2, 2, 2, 5437, 5439,
	5, 1014, 508, 2, 5438, 5437, 3, 2, 2, 2, 5438, 5439, 3, 2, 2, 2, 5439,
	5441, 3, 2, 2, 2, 5440, 5442, 5, 1016, 509, 2, 5441, 5440, 3, 2, 2, 2,
	5441, 5442, 3, 2, 2, 2, 5442, 5444, 3, 2, 2, 2, 5443, 5445, 7, 183, 2,
	2, 5444, 5443, 3, 2, 2, 2, 5444, 5445, 3, 2, 2, 2, 5445, 961, 3, 2, 2,
	2, 5446, 5454, 5, 1084, 543, 2, 5447, 5451, 5, 964, 483, 2, 5448, 5450,
	5, 966, 484, 2, 5449, 5448, 3, 2, 2, 2, 5450, 5453, 3, 2, 2, 2, 5451, 5449,
	3, 2, 2, 2, 5451, 5452, 3, 2, 2, 2, 5452, 5455, 3, 2, 2, 2, 5453, 5451,
	3, 2, 2, 2, 5454, 5447, 3, 2, 2, 2, 5454, 5455, 3, 2, 2, 2, 5455, 963,
	3, 2, 2, 2, 5456, 5458, 7, 137, 2, 2, 5457, 5459, 7, 53, 2, 2, 5458, 5457,
	3, 2, 2, 2, 5458, 5459, 3, 2, 2, 2, 5459, 5461, 3, 2, 2, 2, 5460, 5462,
	7, 11, 2, 2, 5461, 5460, 3, 2, 2, 2, 5461, 5462, 3, 2, 2, 2, 5462, 5465,
	3, 2, 2, 2, 5463, 5466, 5, 1068, 535, 2, 5464, 5466, 5, 1166, 584, 2, 5465,
	5463, 3, 2, 2, 2, 5465, 5464, 3, 2, 2, 2, 5466, 965, 3, 2, 2, 2, 5467,
	5469, 7, 336, 2, 2, 5468, 5470, 7, 11, 2, 2, 5469, 5468, 3, 2, 2, 2, 5469,
	5470, 3, 2, 2, 2, 5470, 5473, 3, 2, 2, 2, 5471, 5474, 5, 1068, 535, 2,
	5472, 5474, 5, 1166, 584, 2, 5473, 5471, 3, 2, 2, 2, 5473, 5472, 3, 2,
	2, 2, 5474, 967, 3, 2, 2, 2, 5475, 5477, 7, 256, 2, 2, 5476, 5478, 5, 970,
	486, 2, 5477, 5476, 3, 2, 2, 2, 5478, 5479, 3, 2, 2, 2, 5479, 5477, 3,
	2, 2, 2, 5479, 5480, 3, 2, 2, 2, 5480, 969, 3, 2, 2, 2, 5481, 5483, 5,
	1068, 535, 2, 5482, 5484, 5, 972, 487, 2, 5483, 5482, 3, 2, 2, 2, 5483,
	5484, 3, 2, 2, 2, 5484, 5486, 3, 2, 2, 2, 5485, 5487, 5, 974, 488, 2, 5486,
	5485, 3, 2, 2, 2, 5486, 5487, 3, 2, 2, 2, 5487, 971, 3, 2, 2, 2, 5488,
	5490, 7, 138, 2, 2, 5489, 5491, 7, 244, 2, 2, 5490, 5489, 3, 2, 2, 2, 5490,
	5491, 3, 2, 2, 2, 5491, 5492, 3, 2, 2, 2, 5492, 5493, 5, 1068, 535, 2,
	5493, 973, 3, 2, 2, 2, 5494, 5496, 7, 110, 2, 2, 5495, 5497, 7, 244, 2,
	2, 5496, 5495, 3, 2, 2, 2, 5496, 5497, 3, 2, 2, 2, 5497, 5498, 3, 2, 2,
	2, 5498, 5499, 5, 1068, 535, 2, 5499, 975, 3, 2, 2, 2, 5500, 5502, 7, 520,
	2, 2, 5501, 5500, 3, 2, 2, 2, 5501, 5502, 3, 2, 2, 2, 5502, 5503, 3, 2,
	2, 2, 5503, 5504, 7, 356, 2, 2, 5504, 5505, 5, 1084, 543, 2, 5505, 977,
	3, 2, 2, 2, 5506, 5508, 7, 478, 2, 2, 5507, 5509, 7, 244, 2, 2, 5508, 5507,
	3, 2, 2, 2, 5508, 5509, 3, 2, 2, 2, 5509, 5510, 3, 2, 2, 2, 5510, 5511,
	5, 1084, 543, 2, 5511, 979, 3, 2, 2, 2, 5512, 5515, 7, 511, 2, 2, 5513,
	5516, 5, 982, 492, 2, 5514, 5516, 5, 986, 494, 2, 5515, 5513, 3, 2, 2,
	2, 5515, 5514, 3, 2, 2, 2, 5516, 981, 3, 2, 2, 2, 5517, 5519, 7, 228, 2,
	2, 5518, 5517, 3, 2, 2, 2, 5518, 5519, 3, 2, 2, 2, 5519, 5520, 3, 2, 2,
	2, 5520, 5522, 7, 9, 2, 2, 5521, 5523, 7, 459, 2, 2, 5522, 5521, 3, 2,
	2, 2, 5522, 5523, 3, 2, 2, 2, 5523, 5524, 3, 2, 2, 2, 5524, 5525, 9, 61,
	2, 2, 5525, 5527, 7, 363, 2, 2, 5526, 5528, 7, 332, 2, 2, 5527, 5526, 3,
	2, 2, 2, 5527, 5528, 3, 2, 2, 2, 5528, 5529, 3, 2, 2, 2, 5529, 5530, 5,
	984, 493, 2, 5530, 983, 3, 2, 2, 2, 5531, 5541, 7, 251, 2, 2, 5532, 5541,
	7, 341, 2, 2, 5533, 5541, 7, 237, 2, 2, 5534, 5541, 7, 206, 2, 2, 5535,
	5537, 5, 1128, 565, 2, 5536, 5535, 3, 2, 2, 2, 5537, 5538, 3, 2, 2, 2,
	5538, 5536, 3, 2, 2, 2, 5538, 5539, 3, 2, 2, 2, 5539, 5541, 3, 2, 2, 2,
	5540, 5531, 3, 2, 2, 2, 5540, 5532, 3, 2, 2, 2, 5540, 5533, 3, 2, 2, 2,
	5540, 5534, 3, 2, 2, 2, 5540, 5536, 3, 2, 2, 2, 5541, 985, 3, 2, 2, 2,
	5542, 5544, 7, 217, 2, 2, 5543, 5542, 3, 2, 2, 2, 5543, 5544, 3, 2, 2,
	2, 5544, 5545, 3, 2, 2, 2, 5545, 5547, 7, 130, 2, 2, 5546, 5548, 7, 332,
	2, 2, 5547, 5546, 3, 2, 2, 2, 5547, 5548, 3, 2, 2, 2, 5548, 5550, 3, 2,
	2, 2, 5549, 5551, 5, 988, 495, 2, 5550, 5549, 3, 2, 2, 2, 5551, 5552, 3,
	2, 2, 2, 5552, 5550, 3, 2, 2, 2, 5552, 5553, 3, 2, 2, 2, 5553, 987, 3,
	2, 2, 2, 5554, 5555, 7, 11, 2, 2, 5555, 5567, 7, 365, 2, 2, 5556, 5558,
	7, 11, 2, 2, 5557, 5559, 7, 391, 2, 2, 5558, 5557, 3, 2, 2, 2, 5558, 5559,
	3, 2, 2, 2, 5559, 5561, 3, 2, 2, 2, 5560, 5562, 7, 329, 2, 2, 5561, 5560,
	3, 2, 2, 2, 5561, 5562, 3, 2, 2, 2, 5562, 5563, 3, 2, 2, 2, 5563, 5567,
	5, 1068, 535, 2, 5564, 5567, 5, 1144, 573, 2, 5565, 5567, 5, 1128, 565,
	2, 5566, 5554, 3, 2, 2, 2, 5566, 5556, 3, 2, 2, 2, 5566, 5564, 3, 2, 2,
	2, 5566, 5565, 3, 2, 2, 2, 5567, 989, 3, 2, 2, 2, 5568, 5569, 7, 523, 2,
	2, 5569, 5571, 5, 1148, 575, 2, 5570, 5572, 5, 992, 497, 2, 5571, 5570,
	3, 2, 2, 2, 5571, 5572, 3, 2, 2, 2, 5572, 5574, 3, 2, 2, 2, 5573, 5575,
	5, 994, 498, 2, 5574, 5573, 3, 2, 2, 2, 5574, 5575, 3, 2, 2, 2, 5575, 5577,
	3, 2, 2, 2, 5576, 5578, 5, 1002, 502, 2, 5577, 5576, 3, 2, 2, 2, 5577,
	5578, 3, 2, 2, 2, 5578, 5580, 3, 2, 2, 2, 5579, 5581, 5, 1004, 503, 2,
	5580, 5579, 3, 2, 2, 2, 5580, 5581, 3, 2, 2, 2, 5581, 5583, 3, 2, 2, 2,
	5582, 5584, 5, 1010, 506, 2, 5583, 5582, 3, 2, 2, 2, 5583, 5584, 3, 2,
	2, 2, 5584, 5586, 3, 2, 2, 2, 5585, 5587, 5, 1012, 507, 2, 5586, 5585,
	3, 2, 2, 2, 5586, 5587, 3, 2, 2, 2, 5587, 5589, 3, 2, 2, 2, 5588, 5590,
	7, 184, 2, 2, 5589, 5588, 3, 2, 2, 2, 5589, 5590, 3, 2, 2, 2, 5590, 991,
	3, 2, 2, 2, 5591, 5594, 7, 220, 2, 2, 5592, 5595, 5, 1068, 535, 2, 5593,
	5595, 5, 1166, 584, 2, 5594, 5592, 3, 2, 2, 2, 5594, 5593, 3, 2, 2, 2,
	5595, 993, 3, 2, 2, 2, 5596, 5598, 9, 57, 2, 2, 5597, 5599, 7, 8, 2, 2,
	5598, 5597, 3, 2, 2, 2, 5598, 5599, 3, 2, 2, 2, 5599, 5603, 3, 2, 2, 2,
	5600, 5604, 5, 996, 499, 2, 5601, 5604, 5, 998, 500, 2, 5602, 5604, 5,
	1000, 501, 2, 5603, 5600, 3, 2, 2, 2, 5603, 5601, 3, 2, 2, 2, 5603, 5602,
	3, 2, 2, 2, 5604, 995, 3, 2, 2, 2, 5605, 5606, 7, 347, 2, 2, 5606, 997,
	3, 2, 2, 2, 5607, 5610, 5, 1068, 535, 2, 5608, 5610, 5, 1166, 584, 2, 5609,
	5607, 3, 2, 2, 2, 5609, 5608, 3, 2, 2, 2, 5610, 5612, 3, 2, 2, 2, 5611,
	5613, 9, 36, 2, 2, 5612, 5611, 3, 2, 2, 2, 5612, 5613, 3, 2, 2, 2, 5613,
	999, 3, 2, 2, 2, 5614, 5615, 5, 1140, 571, 2, 5615, 1001, 3, 2, 2, 2, 5616,
	5618, 7, 34, 2, 2, 5617, 5616, 3, 2, 2, 2, 5617, 5618, 3, 2, 2, 2, 5618,
	5619, 3, 2, 2, 2, 5619, 5623, 9, 62, 2, 2, 5620, 5622, 5, 536, 269, 2,
	5621, 5620, 3, 2, 2, 2, 5622, 5625, 3, 2, 2, 2, 5623, 5621, 3, 2, 2, 2,
	5623, 5624, 3, 2, 2, 2, 5624, 1003, 3, 2, 2, 2, 5625, 5623, 3, 2, 2, 2,
	5626, 5628, 7, 318, 2, 2, 5627, 5629, 7, 34, 2, 2, 5628, 5627, 3, 2, 2,
	2, 5628, 5629, 3, 2, 2, 2, 5629, 5630, 3, 2, 2, 2, 5630, 5634, 9, 62, 2,
	2, 5631, 5633, 5, 536, 269, 2, 5632, 5631, 3, 2, 2, 2, 5633, 5636, 3, 2,
	2, 2, 5634, 5632, 3, 2, 2, 2, 5634, 5635, 3, 2, 2, 2, 5635, 1005, 3, 2,
	2, 2, 5636, 5634, 3, 2, 2, 2, 5637, 5639, 7, 34, 2, 2, 5638, 5637, 3, 2,
	2, 2, 5638, 5639, 3, 2, 2, 2, 5639, 5640, 3, 2, 2, 2, 5640, 5644, 7, 164,
	2, 2, 5641, 5643, 5, 536, 269, 2, 5642, 5641, 3, 2, 2, 2, 5643, 5646, 3,
	2, 2, 2, 5644, 5642, 3, 2, 2, 2, 5644, 5645, 3, 2, 2, 2, 5645, 1007, 3,
	2, 2, 2, 5646, 5644, 3, 2, 2, 2, 5647, 5649, 7, 318, 2, 2, 5648, 5650,
	7, 34, 2, 2, 5649, 5648, 3, 2, 2, 2, 5649, 5650, 3, 2, 2, 2, 5650, 5651,
	3, 2, 2, 2, 5651, 5655, 7, 164, 2, 2, 5652, 5654, 5, 536, 269, 2, 5653,
	5652, 3, 2, 2, 2, 5654, 5657, 3, 2, 2, 2, 5655, 5653, 3, 2, 2, 2, 5655,
	5656, 3, 2, 2, 2, 5656, 1009, 3, 2, 2, 2, 5657, 5655, 3, 2, 2, 2, 5658,
	5660, 7, 257, 2, 2, 5659, 5661, 7, 264, 2, 2, 5660, 5659, 3, 2, 2, 2, 5660,
	5661, 3, 2, 2, 2, 5661, 5665, 3, 2, 2, 2, 5662, 5664, 5, 536, 269, 2, 5663,
	5662, 3, 2, 2, 2, 5664, 5667, 3, 2, 2, 2, 5665, 5663, 3, 2, 2, 2, 5665,
	5666, 3, 2, 2, 2, 5666, 1011, 3, 2, 2, 2, 5667, 5665, 3, 2, 2, 2, 5668,
	5669, 7, 318, 2, 2, 5669, 5671, 7, 257, 2, 2, 5670, 5672, 7, 264, 2, 2,
	5671, 5670, 3, 2, 2, 2, 5671, 5672, 3, 2, 2, 2, 5672, 5676, 3, 2, 2, 2,
	5673, 5675, 5, 536, 269, 2, 5674, 5673, 3, 2, 2, 2, 5675, 5678, 3, 2, 2,
	2, 5676, 5674, 3, 2, 2, 2, 5676, 5677, 3, 2, 2, 2, 5677, 1013, 3, 2, 2,
	2, 5678, 5676, 3, 2, 2, 2, 5679, 5681, 7, 332, 2, 2, 5680, 5679, 3, 2,
	2, 2, 5680, 5681, 3, 2, 2, 2, 5681, 5682, 3, 2, 2, 2, 5682, 5686, 7, 342,
	2, 2, 5683, 5685, 5, 536, 269, 2, 5684, 5683, 3, 2, 2, 2, 5685, 5688, 3,
	2, 2, 2, 5686, 5684, 3, 2, 2, 2, 5686, 5687, 3, 2, 2, 2, 5687, 1015, 3,
	2, 2, 2, 5688, 5686, 3, 2, 2, 2, 5689, 5691, 7, 318, 2, 2, 5690, 5692,
	7, 332, 2, 2, 5691, 5690, 3, 2, 2, 2, 5691, 5692, 3, 2, 2, 2, 5692, 5693,
	3, 2, 2, 2, 5693, 5697, 7, 342, 2, 2, 5694, 5696, 5, 536, 269, 2, 5695,
	5694, 3, 2, 2, 2, 5696, 5699, 3, 2, 2, 2, 5697, 5695, 3, 2, 2, 2, 5697,
	5698, 3, 2, 2, 2, 5698, 1017, 3, 2, 2, 2, 5699, 5697, 3, 2, 2, 2, 5700,
	5702, 7, 332, 2, 2, 5701, 5700, 3, 2, 2, 2, 5701, 5702, 3, 2, 2, 2, 5702,
	5703, 3, 2, 2, 2, 5703, 5704, 7, 444, 2, 2, 5704, 5708, 7, 193, 2, 2, 5705,
	5707, 5, 536, 269, 2, 5706, 5705, 3, 2, 2, 2, 5707, 5710, 3, 2, 2, 2, 5708,
	5706, 3, 2, 2, 2, 5708, 5709, 3, 2, 2, 2, 5709, 1019, 3, 2, 2, 2, 5710,
	5708, 3, 2, 2, 2, 5711, 5713, 7, 318, 2, 2, 5712, 5714, 7, 332, 2, 2, 5713,
	5712, 3, 2, 2, 2, 5713, 5714, 3, 2, 2, 2, 5714, 5715, 3, 2, 2, 2, 5715,
	5716, 7, 444, 2, 2, 5716, 5720, 7, 193, 2, 2, 5717, 5719, 5, 536, 269,
	2, 5718, 5717, 3, 2, 2, 2, 5719, 5722, 3, 2, 2, 2, 5720, 5718, 3, 2, 2,
	2, 5720, 5721, 3, 2, 2, 2, 5721, 1021, 3, 2, 2, 2, 5722, 5720, 3, 2, 2,
	2, 5723, 5725, 7, 332, 2, 2, 5724, 5723, 3, 2, 2, 2, 5724, 5725, 3, 2,
	2, 2, 5725, 5726, 3, 2, 2, 2, 5726, 5730, 7, 201, 2, 2, 5727, 5729, 5,
	536, 269, 2, 5728, 5727, 3, 2, 2, 2, 5729, 5732, 3, 2, 2, 2, 5730, 5728,
	3, 2, 2, 2, 5730, 5731, 3, 2, 2, 2, 5731, 1023, 3, 2, 2, 2, 5732, 5730,
	3, 2, 2, 2, 5733, 5735, 7, 318, 2, 2, 5734, 5736, 7, 332, 2, 2, 5735, 5734,
	3, 2, 2, 2, 5735, 5736, 3, 2, 2, 2, 5736, 5737, 3, 2, 2, 2, 5737, 5741,
	7, 201, 2, 2, 5738, 5740, 5, 536, 269, 2, 5739, 5738, 3, 2, 2, 2, 5740,
	5743, 3, 2, 2, 2, 5741, 5739, 3, 2, 2, 2, 5741, 5742, 3, 2, 2, 2, 5742,
	1025, 3, 2, 2, 2, 5743, 5741, 3, 2, 2, 2, 5744, 5748, 5, 1030, 516, 2,
	5745, 5747, 5, 1028, 515, 2, 5746, 5745, 3, 2, 2, 2, 5747, 5750, 3, 2,
	2, 2, 5748, 5746, 3, 2, 2, 2, 5748, 5749, 3, 2, 2, 2, 5749, 1027, 3, 2,
	2, 2, 5750, 5748, 3, 2, 2, 2, 5751, 5752, 9, 63, 2, 2, 5752, 5753, 5, 1030,
	516, 2, 5753, 1029, 3, 2, 2, 2, 5754, 5758, 5, 1034, 518, 2, 5755, 5757,
	5, 1032, 517, 2, 5756, 5755, 3, 2, 2, 2, 5757, 5760, 3, 2, 2, 2, 5758,
	5756, 3, 2, 2, 2, 5758, 5759, 3, 2, 2, 2, 5759, 1031, 3, 2, 2, 2, 5760,
	5758, 3, 2, 2, 2, 5761, 5762, 9, 64, 2, 2, 5762, 5763, 5, 1034, 518, 2,
	5763, 1033, 3, 2, 2, 2, 5764, 5766, 9, 63, 2, 2, 5765, 5764, 3, 2, 2, 2,
	5765, 5766, 3, 2, 2, 2, 5766, 5767, 3, 2, 2, 2, 5767, 5771, 5, 1038, 520,
	2, 5768, 5770, 5, 1036, 519, 2, 5769, 5768, 3, 2, 2, 2, 5770, 5773, 3,
	2, 2, 2, 5771, 5769, 3, 2, 2, 2, 5771, 5772, 3, 2, 2, 2, 5772, 1035, 3,
	2, 2, 2, 5773, 5771, 3, 2, 2, 2, 5774, 5775, 7, 534, 2, 2, 5775, 5776,
	5, 1038, 520, 2, 5776, 1037, 3, 2, 2, 2, 5777, 5778, 7, 549, 2, 2, 5778,
	5779, 5, 1026, 514, 2, 5779, 5780, 7, 555, 2, 2, 5780, 5784, 3, 2, 2, 2,
	5781, 5784, 5, 1068, 535, 2, 5782, 5784, 5, 1166, 584, 2, 5783, 5777, 3,
	2, 2, 2, 5783, 5781, 3, 2, 2, 2, 5783, 5782, 3, 2, 2, 2, 5784, 1039, 3,
	2, 2, 2, 5785, 5789, 5, 1044, 523, 2, 5786, 5788, 5, 1042, 522, 2, 5787,
	5786, 3, 2, 2, 2, 5788, 5791, 3, 2, 2, 2, 5789, 5787, 3, 2, 2, 2, 5789,
	5790, 3, 2, 2, 2, 5790, 1041, 3, 2, 2, 2, 5791, 5789, 3, 2, 2, 2, 5792,
	5799, 9, 65, 2, 2, 5793, 5800, 5, 1044, 523, 2, 5794, 5796, 5, 1066, 534,
	2, 5795, 5794, 3, 2, 2, 2, 5796, 5797, 3, 2, 2, 2, 5797, 5795, 3, 2, 2,
	2, 5797, 5798, 3, 2, 2, 2, 5798, 5800, 3, 2, 2, 2, 5799, 5793, 3, 2, 2,
	2, 5799, 5795, 3, 2, 2, 2, 5800, 1043, 3, 2, 2, 2, 5801, 5803, 7, 318,
	2, 2, 5802, 5801, 3, 2, 2, 2, 5802, 5803, 3, 2, 2, 2, 5803, 5804, 3, 2,
	2, 2, 5804, 5805, 5, 1046, 524, 2, 5805, 1045, 3, 2, 2, 2, 5806, 5807,
	7, 549, 2, 2, 5807, 5808, 5, 1040, 521, 2, 5808, 5809, 7, 555, 2, 2, 5809,
	5814, 3, 2, 2, 2, 5810, 5814, 5, 1054, 528, 2, 5811, 5814, 5, 1048, 525,
	2, 5812, 5814, 5, 1050, 526, 2, 5813, 5806, 3, 2, 2, 2, 5813, 5810, 3,
	2, 2, 2, 5813, 5811, 3, 2, 2, 2, 5813, 5812, 3, 2, 2, 2, 5814, 1047, 3,
	2, 2, 2, 5815, 5817, 5, 1068, 535, 2, 5816, 5818, 7, 259, 2, 2, 5817, 5816,
	3, 2, 2, 2, 5817, 5818, 3, 2, 2, 2, 5818, 5820, 3, 2, 2, 2, 5819, 5821,
	7, 318, 2, 2, 5820, 5819, 3, 2, 2, 2, 5820, 5821, 3, 2, 2, 2, 5821, 5829,
	3, 2, 2, 2, 5822, 5830, 7, 322, 2, 2, 5823, 5830, 7, 13, 2, 2, 5824, 5830,
	7, 14, 2, 2, 5825, 5830, 7, 15, 2, 2, 5826, 5830, 7, 121, 2, 2, 5827, 5830,
	7, 262, 2, 2, 5828, 5830, 5, 1116, 559, 2, 5829, 5822, 3, 2, 2, 2, 5829,
	5823, 3, 2, 2, 2, 5829, 5824, 3, 2, 2, 2, 5829, 5825, 3, 2, 2, 2, 5829,
	5826, 3, 2, 2, 2, 5829, 5827, 3, 2, 2, 2, 5829, 5828, 3, 2, 2, 2, 5830,
	1049, 3, 2, 2, 2, 5831, 5853, 5, 1120, 561, 2, 5832, 5834, 5, 1096, 549,
	2, 5833, 5832, 3, 2, 2, 2, 5834, 5837, 3, 2, 2, 2, 5835, 5833, 3, 2, 2,
	2, 5835, 5836, 3, 2, 2, 2, 5836, 5839, 3, 2, 2, 2, 5837, 5835, 3, 2, 2,
	2, 5838, 5840, 5, 1098, 550, 2, 5839, 5838, 3, 2, 2, 2, 5839, 5840, 3,
	2, 2, 2, 5840, 5844, 3, 2, 2, 2, 5841, 5843, 5, 1052, 527, 2, 5842, 5841,
	3, 2, 2, 2, 5843, 5846, 3, 2, 2, 2, 5844, 5842, 3, 2, 2, 2, 5844, 5845,
	3, 2, 2, 2, 5845, 5854, 3, 2, 2, 2, 5846, 5844, 3, 2, 2, 2, 5847, 5849,
	5, 1100, 551, 2, 5848, 5847, 3, 2, 2, 2, 5849, 5852, 3, 2, 2, 2, 5850,
	5848, 3, 2, 2, 2, 5850, 5851, 3, 2, 2, 2, 5851, 5854, 3, 2, 2, 2, 5852,
	5850, 3, 2, 2, 2, 5853, 5835, 3, 2, 2, 2, 5853, 5850, 3, 2, 2, 2, 5854,
	1051, 3, 2, 2, 2, 5855, 5857, 7, 549, 2, 2, 5856, 5858, 5, 1080, 541, 2,
	5857, 5856, 3, 2, 2, 2, 5858, 5859, 3, 2, 2, 2, 5859, 5857, 3, 2, 2, 2,
	5859, 5860, 3, 2, 2, 2, 5860, 5861, 3, 2, 2, 2, 5861, 5862, 7, 555, 2,
	2, 5862, 1053, 3, 2, 2, 2, 5863, 5867, 5, 1056, 529, 2, 5864, 5867, 5,
	1058, 530, 2, 5865, 5867, 5, 1060, 531, 2, 5866, 5863, 3, 2, 2, 2, 5866,
	5864, 3, 2, 2, 2, 5866, 5865, 3, 2, 2, 2, 5867, 1055, 3, 2, 2, 2, 5868,
	5870, 5, 1026, 514, 2, 5869, 5871, 7, 259, 2, 2, 5870, 5869, 3, 2, 2, 2,
	5870, 5871, 3, 2, 2, 2, 5871, 5873, 3, 2, 2, 2, 5872, 5874, 7, 318, 2,
	2, 5873, 5872, 3, 2, 2, 2, 5873, 5874, 3, 2, 2, 2, 5874, 5875, 3, 2, 2,
	2, 5875, 5876, 9, 66, 2, 2, 5876, 1057, 3, 2, 2, 2, 5877, 5878, 5, 1026,
	514, 2, 5878, 5879, 5, 1064, 533, 2, 5879, 5880, 5, 1026, 514, 2, 5880,
	1059, 3, 2, 2, 2, 5881, 5882, 5, 1026, 514, 2, 5882, 5883, 5, 1064, 533,
	2, 5883, 5884, 7, 549, 2, 2, 5884, 5885, 5, 1062, 532, 2, 5885, 5886, 7,
	555, 2, 2, 5886, 1061, 3, 2, 2, 2, 5887, 5890, 5, 1026, 514, 2, 5888, 5889,
	7, 336, 2, 2, 5889, 5891, 5, 1026, 514, 2, 5890, 5888, 3, 2, 2, 2, 5891,
	5892, 3, 2, 2, 2, 5892, 5890, 3, 2, 2, 2, 5892, 5893, 3, 2, 2, 2, 5893,
	1063, 3, 2, 2, 2, 5894, 5896, 9, 11, 2, 2, 5895, 5894, 3, 2, 2, 2, 5895,
	5896, 3, 2, 2, 2, 5896, 5937, 3, 2, 2, 2, 5897, 5899, 7, 318, 2, 2, 5898,
	5897, 3, 2, 2, 2, 5898, 5899, 3, 2, 2, 2, 5899, 5915, 3, 2, 2, 2, 5900,
	5902, 7, 230, 2, 2, 5901, 5903, 7, 485, 2, 2, 5902, 5901, 3, 2, 2, 2, 5902,
	5903, 3, 2, 2, 2, 5903, 5916, 3, 2, 2, 2, 5904, 5916, 7, 551, 2, 2, 5905,
	5907, 7, 275, 2, 2, 5906, 5908, 7, 485, 2, 2, 5907, 5906, 3, 2, 2, 2, 5907,
	5908, 3, 2, 2, 2, 5908, 5916, 3, 2, 2, 2, 5909, 5916, 7, 547, 2, 2, 5910,
	5912, 7, 191, 2, 2, 5911, 5913, 7, 495, 2, 2, 5912, 5911, 3, 2, 2, 2, 5912,
	5913, 3, 2, 2, 2, 5913, 5916, 3, 2, 2, 2, 5914, 5916, 7, 543, 2, 2, 5915,
	5900, 3, 2, 2, 2, 5915, 5904, 3, 2, 2, 2, 5915, 5905, 3, 2, 2, 2, 5915,
	5909, 3, 2, 2, 2, 5915, 5910, 3, 2, 2, 2, 5915, 5914, 3, 2, 2, 2, 5916,
	5938, 3, 2, 2, 2, 5917, 5919, 7, 230, 2, 2, 5918, 5920, 7, 485, 2, 2, 5919,
	5918, 3, 2, 2, 2, 5919, 5920, 3, 2, 2, 2, 5920, 5921, 3, 2, 2, 2, 5921,
	5922, 7, 336, 2, 2, 5922, 5924, 7, 191, 2, 2, 5923, 5925, 7, 495, 2, 2,
	5924, 5923, 3, 2, 2, 2, 5924, 5925, 3, 2, 2, 2, 5925, 5938, 3, 2, 2, 2,
	5926, 5938, 7, 552, 2, 2, 5927, 5929, 7, 275, 2, 2, 5928, 5930, 7, 485,
	2, 2, 5929, 5928, 3, 2, 2, 2, 5929, 5930, 3, 2, 2, 2, 5930, 5931, 3, 2,
	2, 2, 5931, 5932, 7, 336, 2, 2, 5932, 5934, 7, 191, 2, 2, 5933, 5935, 7,
	495, 2, 2, 5934, 5933, 3, 2, 2, 2, 5934, 5935, 3, 2, 2, 2, 5935, 5938,
	3, 2, 2, 2, 5936, 5938, 7, 548, 2, 2, 5937, 5898, 3, 2, 2, 2, 5937, 5917,
	3, 2, 2, 2, 5937, 5926, 3, 2, 2, 2, 5937, 5927, 3, 2, 2, 2, 5937, 5936,
	3, 2, 2, 2, 5938, 1065, 3, 2, 2, 2, 5939, 5941, 7, 318, 2, 2, 5940, 5939,
	3, 2, 2, 2, 5940, 5941, 3, 2, 2, 2, 5941, 5943, 3, 2, 2, 2, 5942, 5944,
	5, 1064, 533, 2, 5943, 5942, 3, 2, 2, 2, 5943, 5944, 3, 2, 2, 2, 5944,
	5951, 3, 2, 2, 2, 5945, 5952, 5, 1026, 514, 2, 5946, 5947, 7, 549, 2, 2,
	5947, 5948, 5, 1026, 514, 2, 5948, 5949, 5, 1066, 534, 2, 5949, 5950, 7,
	555, 2, 2, 5950, 5952, 3, 2, 2, 2, 5951, 5945, 3, 2, 2, 2, 5951, 5946,
	3, 2, 2, 2, 5952, 1067, 3, 2, 2, 2, 5953, 5958, 5, 1084, 543, 2, 5954,
	5958, 5, 1070, 536, 2, 5955, 5958, 5, 1072, 537, 2, 5956, 5958, 5, 1180,
	591, 2, 5957, 5953, 3, 2, 2, 2, 5957, 5954, 3, 2, 2, 2, 5957, 5955, 3,
	2, 2, 2, 5957, 5956, 3, 2, 2, 2, 5958, 1069, 3, 2, 2, 2, 5959, 5975, 5,
	1084, 543, 2, 5960, 5961, 7, 549, 2, 2, 5961, 5968, 5, 1080, 541, 2, 5962,
	5964, 7, 536, 2, 2, 5963, 5962, 3, 2, 2, 2, 5963, 5964, 3, 2, 2, 2, 5964,
	5965, 3, 2, 2, 2, 5965, 5967, 5, 1080, 541, 2, 5966, 5963, 3, 2, 2, 2,
	5967, 5970, 3, 2, 2, 2, 5968, 5966, 3, 2, 2, 2, 5968, 5969, 3, 2, 2, 2,
	5969, 5971, 3, 2, 2, 2, 5970, 5968, 3, 2, 2, 2, 5971, 5972, 7, 555, 2,
	2, 5972, 5974, 3, 2, 2, 2, 5973, 5960, 3, 2, 2, 2, 5974, 5977, 3, 2, 2,
	2, 5975, 5973, 3, 2, 2, 2, 5975, 5976, 3, 2, 2, 2, 5976, 5979, 3, 2, 2,
	2, 5977, 5975, 3, 2, 2, 2, 5978, 5980, 5, 1074, 538, 2, 5979, 5978, 3,
	2, 2, 2, 5979, 5980, 3, 2, 2, 2, 5980, 1071, 3, 2, 2, 2, 5981, 5982, 7,
	222, 2, 2, 5982, 5998, 5, 1130, 566, 2, 5983, 5984, 7, 549, 2, 2, 5984,
	5991, 5, 1082, 542, 2, 5985, 5987, 7, 536, 2, 2, 5986, 5985, 3, 2, 2, 2,
	5986, 5987, 3, 2, 2, 2, 5987, 5988, 3, 2, 2, 2, 5988, 5990, 5, 1082, 542,
	2, 5989, 5986, 3, 2, 2, 2, 5990, 5993, 3, 2, 2, 2, 5991, 5989, 3, 2, 2,
	2, 5991, 5992, 3, 2, 2, 2, 5992, 5994, 3, 2, 2, 2, 5993, 5991, 3, 2, 2,
	2, 5994, 5995, 7, 555, 2, 2, 5995, 5997, 3, 2, 2, 2, 5996, 5983, 3, 2,
	2, 2, 5997, 6000, 3, 2, 2, 2, 5998, 5996, 3, 2, 2, 2, 5998, 5999, 3, 2,
	2, 2, 5999, 6002, 3, 2, 2, 2, 6000, 5998, 3, 2, 2, 2, 6001, 6003, 5, 1074,
	538, 2, 6002, 6001, 3, 2, 2, 2, 6002, 6003, 3, 2, 2, 2, 6003, 1073, 3,
	2, 2, 2, 6004, 6005, 7, 549, 2, 2, 6005, 6006, 5, 1076, 539, 2, 6006, 6008,
	7, 535, 2, 2, 6007, 6009, 5, 1078, 540, 2, 6008, 6007, 3, 2, 2, 2, 6008,
	6009, 3, 2, 2, 2, 6009, 6010, 3, 2, 2, 2, 6010, 6011, 7, 555, 2, 2, 6011,
	1075, 3, 2, 2, 2, 6012, 6013, 5, 1026, 514, 2, 6013, 1077, 3, 2, 2, 2,
	6014, 6015, 5, 1026, 514, 2, 6015, 1079, 3, 2, 2, 2, 6016, 6028, 7, 11,
	2, 2, 6017, 6028, 5, 1172, 587, 2, 6018, 6020, 5, 1084, 543, 2, 6019, 6021,
	5, 1172, 587, 2, 6020, 6019, 3, 2, 2, 2, 6020, 6021, 3, 2, 2, 2, 6021,
	6028, 3, 2, 2, 2, 6022, 6024, 5, 1132, 567, 2, 6023, 6025, 5, 1172, 587,
	2, 6024, 6023, 3, 2, 2, 2, 6024, 6025, 3, 2, 2, 2, 6025, 6028, 3, 2, 2,
	2, 6026, 6028, 5, 1026, 514, 2, 6027, 6016, 3, 2, 2, 2, 6027, 6017, 3,
	2, 2, 2, 6027, 6018, 3, 2, 2, 2, 6027, 6022, 3, 2, 2, 2, 6027, 6026, 3,
	2, 2, 2, 6028, 1081, 3, 2, 2, 2, 6029, 6041, 5, 1166, 584, 2, 6030, 6041,
	5, 1068, 535, 2, 6031, 6033, 5, 1084, 543, 2, 6032, 6034, 5, 1172, 587,
	2, 6033, 6032, 3, 2, 2, 2, 6033, 6034, 3, 2, 2, 2, 6034, 6041, 3, 2, 2,
	2, 6035, 6037, 5, 1132, 567, 2, 6036, 6038, 5, 1172, 587, 2, 6037, 6036,
	3, 2, 2, 2, 6037, 6038, 3, 2, 2, 2, 6038, 6041, 3, 2, 2, 2, 6039, 6041,
	5, 1026, 514, 2, 6040, 6029, 3, 2, 2, 2, 6040, 6030, 3, 2, 2, 2, 6040,
	6031, 3, 2, 2, 2, 6040, 6035, 3, 2, 2, 2, 6040, 6039, 3, 2, 2, 2, 6041,
	1083, 3, 2, 2, 2, 6042, 6047, 5, 1086, 544, 2, 6043, 6047, 5, 1088, 545,
	2, 6044, 6047, 5, 1090, 546, 2, 6045, 6047, 5, 1092, 547, 2, 6046, 6042,
	3, 2, 2, 2, 6046, 6043, 3, 2, 2, 2, 6046, 6044, 3, 2, 2, 2, 6046, 6045,
	3, 2, 2, 2, 6047, 1085, 3, 2, 2, 2, 6048, 6051, 5, 1122, 562, 2, 6049,
	6051, 5, 1120, 561, 2, 6050, 6048, 3, 2, 2, 2, 6050, 6049, 3, 2, 2, 2,
	6051, 6061, 3, 2, 2, 2, 6052, 6054, 5, 1094, 548, 2, 6053, 6052, 3, 2,
	2, 2, 6054, 6055, 3, 2, 2, 2, 6055, 6053, 3, 2, 2, 2, 6055, 6056, 3, 2,
	2, 2, 6056, 6058, 3, 2, 2, 2, 6057, 6059, 5, 1098, 550, 2, 6058, 6057,
	3, 2, 2, 2, 6058, 6059, 3, 2, 2, 2, 6059, 6062, 3, 2, 2, 2, 6060, 6062,
	5, 1098, 550, 2, 6061, 6053, 3, 2, 2, 2, 6061, 6060, 3, 2, 2, 2, 6061,
	6062, 3, 2, 2, 2, 6062, 1087, 3, 2, 2, 2, 6063, 6064, 5, 1142, 572, 2,
	6064, 6065, 5, 1102, 552, 2, 6065, 1089, 3, 2, 2, 2, 6066, 6067, 5, 1162,
	582, 2, 6067, 6068, 5, 1104, 553, 2, 6068, 1091, 3, 2, 2, 2, 6069, 6070,
	7, 283, 2, 2, 6070, 6071, 5, 1098, 550, 2, 6071, 1093, 3, 2, 2, 2, 6072,
	6075, 5, 1096, 549, 2, 6073, 6075, 5, 1106, 554, 2, 6074, 6072, 3, 2, 2,
	2, 6074, 6073, 3, 2, 2, 2, 6075, 1095, 3, 2, 2, 2, 6076, 6077, 9, 67, 2,
	2, 6077, 6078, 5, 1122, 562, 2, 6078, 1097, 3, 2, 2, 2, 6079, 6080, 9,
	67, 2, 2, 6080, 6081, 5, 1128, 565, 2, 6081, 1099, 3, 2, 2, 2, 6082, 6083,
	9, 67, 2, 2, 6083, 6084, 5, 1140, 571, 2, 6084, 1101, 3, 2, 2, 2, 6085,
	6086, 9, 67, 2, 2, 6086, 6087, 5, 1156, 579, 2, 6087, 1103, 3, 2, 2, 2,
	6088, 6089, 9, 67, 2, 2, 6089, 6090, 5, 1136, 569, 2, 6090, 1105, 3, 2,
	2, 2, 6091, 6092, 9, 67, 2, 2, 6092, 6093, 5, 1070, 536, 2, 6093, 1107,
	3, 2, 2, 2, 6094, 6095, 5, 1164, 583, 2, 6095, 1109, 3, 2, 2, 2, 6096,
	6097, 5, 1158, 580, 2, 6097, 1111, 3, 2, 2, 2, 6098, 6099, 5, 1146, 574,
	2, 6099, 1113, 3, 2, 2, 2, 6100, 6101, 5, 1164, 583, 2, 6101, 1115, 3,
	2, 2, 2, 6102, 6103, 5, 1164, 583, 2, 6103, 1117, 3, 2, 2, 2, 6104, 6105,
	5, 1158, 580, 2, 6105, 1119, 3, 2, 2, 2, 6106, 6107, 5, 1164, 583, 2, 6107,
	1121, 3, 2, 2, 2, 6108, 6109, 5, 1164, 583, 2, 6109, 1123, 3, 2, 2, 2,
	6110, 6114, 7, 213, 2, 2, 6111, 6114, 7, 113, 2, 2, 6112, 6114, 5, 1122,
	562, 2, 6113, 6110, 3, 2, 2, 2, 6113, 6111, 3, 2, 2, 2, 6113, 6112, 3,
	2, 2, 2, 6114, 1125, 3, 2, 2, 2, 6115, 6116, 5, 1158, 580, 2, 6116, 1127,
	3, 2, 2, 2, 6117, 6118, 5, 1164, 583, 2, 6118, 1129, 3, 2, 2, 2, 6119,
	6126, 7, 255, 2, 2, 6120, 6126, 7, 273, 2, 2, 6121, 6126, 7, 376, 2, 2,
	6122, 6126, 7, 470, 2, 2, 6123, 6126, 7, 519, 2, 2, 6124, 6126, 5, 1164,
	583, 2, 6125, 6119, 3, 2, 2, 2, 6125, 6120, 3, 2, 2, 2, 6125, 6121, 3,
	2, 2, 2, 6125, 6122, 3, 2, 2, 2, 6125, 6123, 3, 2, 2, 2, 6125, 6124, 3,
	2, 2, 2, 6126, 1131, 3, 2, 2, 2, 6127, 6128, 5, 1164, 583, 2, 6128, 1133,
	3, 2, 2, 2, 6129, 6130, 5, 1158, 580, 2, 6130, 1135, 3, 2, 2, 2, 6131,
	6132, 5, 1164, 583, 2, 6132, 1137, 3, 2, 2, 2, 6133, 6134, 5, 1164, 583,
	2, 6134, 1139, 3, 2, 2, 2, 6135, 6136, 5, 1164, 583, 2, 6136, 1141, 3,
	2, 2, 2, 6137, 6140, 5, 1164, 583, 2, 6138, 6140, 5, 1172, 587, 2, 6139,
	6137, 3, 2, 2, 2, 6139, 6138, 3, 2, 2, 2, 6140, 1143, 3, 2, 2, 2, 6141,
	6143, 5, 1142, 572, 2, 6142, 6144, 5, 1102, 552, 2, 6143, 6142, 3, 2, 2,
	2, 6143, 6144, 3, 2, 2, 2, 6144, 6147, 3, 2, 2, 2, 6145, 6147, 5, 1156,
	579, 2, 6146, 6141, 3, 2, 2, 2, 6146, 6145, 3, 2, 2, 2, 6147, 1145, 3,
	2, 2, 2, 6148, 6151, 7, 557, 2, 2, 6149, 6151, 5, 1164, 583, 2, 6150, 6148,
	3, 2, 2, 2, 6150, 6149, 3, 2, 2, 2, 6151, 1147, 3, 2, 2, 2, 6152, 6153,
	5, 1084, 543, 2, 6153, 1149, 3, 2, 2, 2, 6154, 6155, 5, 1084, 543, 2, 6155,
	1151, 3, 2, 2, 2, 6156, 6157, 5, 1164, 583, 2, 6157, 1153, 3, 2, 2, 2,
	6158, 6159, 5, 1164, 583, 2, 6159, 1155, 3, 2, 2, 2, 6160, 6163, 5, 1164,
	583, 2, 6161, 6163, 5, 1172, 587, 2, 6162, 6160, 3, 2, 2, 2, 6162, 6161,
	3, 2, 2, 2, 6163, 1157, 3, 2, 2, 2, 6164, 6165, 5, 1164, 583, 2, 6165,
	1159, 3, 2, 2, 2, 6166, 6167, 5, 1164, 583, 2, 6167, 1161, 3, 2, 2, 2,
	6168, 6169, 5, 1164, 583, 2, 6169, 1163, 3, 2, 2, 2, 6170, 6171, 9, 68,
	2, 2, 6171, 1165, 3, 2, 2, 2, 6172, 6179, 7, 557, 2, 2, 6173, 6179, 5,
	1178, 590, 2, 6174, 6179, 5, 1170, 586, 2, 6175, 6179, 5, 1168, 585, 2,
	6176, 6179, 5, 1174, 588, 2, 6177, 6179, 5, 1176, 589, 2, 6178, 6172, 3,
	2, 2, 2, 6178, 6173, 3, 2, 2, 2, 6178, 6174, 3, 2, 2, 2, 6178, 6175, 3,
	2, 2, 2, 6178, 6176, 3, 2, 2, 2, 6178, 6177, 3, 2, 2, 2, 6179, 1167, 3,
	2, 2, 2, 6180, 6181, 9, 69, 2, 2, 6181, 1169, 3, 2, 2, 2, 6182, 6186, 7,
	562, 2, 2, 6183, 6186, 7, 528, 2, 2, 6184, 6186, 5, 1172, 587, 2, 6185,
	6182, 3, 2, 2, 2, 6185, 6183, 3, 2, 2, 2, 6185, 6184, 3, 2, 2, 2, 6186,
	1171, 3, 2, 2, 2, 6187, 6188, 9, 70, 2, 2, 6188, 1173, 3, 2, 2, 2, 6189,
	6190, 7, 143, 2, 2, 6190, 6193, 7, 549, 2, 2, 6191, 6194, 5, 1164, 583,
	2, 6192, 6194, 5, 1166, 584, 2, 6193, 6191, 3, 2, 2, 2, 6193, 6192, 3,
	2, 2, 2, 6194, 6195, 3, 2, 2, 2, 6195, 6196, 7, 555, 2, 2, 6196, 1175,
	3, 2, 2, 2, 6197, 6198, 7, 144, 2, 2, 6198, 6201, 7, 549, 2, 2, 6199, 6202,
	5, 1164, 583, 2, 6200, 6202, 5, 1166, 584, 2, 6201, 6199, 3, 2, 2, 2, 6201,
	6200, 3, 2, 2, 2, 6202, 6203, 3, 2, 2, 2, 6203, 6204, 7, 555, 2, 2, 6204,
	1177, 3, 2, 2, 2, 6205, 6206, 7, 11, 2, 2, 6206, 6221, 5, 1166, 584, 2,
	6207, 6221, 7, 235, 2, 2, 6208, 6221, 7, 236, 2, 2, 6209, 6221, 7, 296,
	2, 2, 6210, 6221, 7, 297, 2, 2, 6211, 6221, 7, 319, 2, 2, 6212, 6221, 7,
	320, 2, 2, 6213, 6221, 7, 374, 2, 2, 6214, 6221, 7, 375, 2, 2, 6215, 6221,
	7, 456, 2, 2, 6216, 6221, 7, 457, 2, 2, 6217, 6221, 7, 528, 2, 2, 6218,
	6221, 7, 530, 2, 2, 6219, 6221, 7, 531, 2, 2, 6220, 6205, 3, 2, 2, 2, 6220,
	6207, 3, 2, 2, 2, 6220, 6208, 3, 2, 2, 2, 6220, 6209, 3, 2, 2, 2, 6220,
	6210, 3, 2, 2, 2, 6220, 6211, 3, 2, 2, 2, 6220, 6212, 3, 2, 2, 2, 6220,
	6213, 3, 2, 2, 2, 6220, 6214, 3, 2, 2, 2, 6220, 6215, 3, 2, 2, 2, 6220,
	6216, 3, 2, 2, 2, 6220, 6217, 3, 2, 2, 2, 6220, 6218, 3, 2, 2, 2, 6220,
	6219, 3, 2, 2, 2, 6221, 1179, 3, 2, 2, 2, 6222, 6223, 7, 7, 2, 2, 6223,
	6224, 7, 329, 2, 2, 6224, 6254, 5, 1068, 535, 2, 6225, 6254, 7, 116, 2,
	2, 6226, 6254, 7, 119, 2, 2, 6227, 6254, 7, 120, 2, 2, 6228, 6254, 7, 123,
	2, 2, 6229, 6254, 7, 124, 2, 2, 6230, 6254, 7, 125, 2, 2, 6231, 6254, 7,
	126, 2, 2, 6232, 6254, 7, 127, 2, 2, 6233, 6254, 7, 128, 2, 2, 6234, 6254,
	7, 129, 2, 2, 6235, 6236, 7, 273, 2, 2, 6236, 6237, 7, 329, 2, 2, 6237,
	6254, 5, 1068, 535, 2, 6238, 6254, 7, 283, 2, 2, 6239, 6254, 7, 286, 2,
	2, 6240, 6254, 7, 348, 2, 2, 6241, 6254, 7, 410, 2, 2, 6242, 6254, 7, 440,
	2, 2, 6243, 6254, 7, 441, 2, 2, 6244, 6254, 7, 446, 2, 2, 6245, 6254, 7,
	447, 2, 2, 6246, 6254, 7, 448, 2, 2, 6247, 6254, 7, 450, 2, 2, 6248, 6254,
	7, 451, 2, 2, 6249, 6254, 7, 452, 2, 2, 6250, 6254, 7, 477, 2, 2, 6251,
	6254, 7, 491, 2, 2, 6252, 6254, 7, 519, 2, 2, 6253, 6222, 3, 2, 2, 2, 6253,
	6225, 3, 2, 2, 2, 6253, 6226, 3, 2, 2, 2, 6253, 6227, 3, 2, 2, 2, 6253,
	6228, 3, 2, 2, 2, 6253, 6229, 3, 2, 2, 2, 6253, 6230, 3, 2, 2, 2, 6253,
	6231, 3, 2, 2, 2, 6253, 6232, 3, 2, 2, 2, 6253, 6233, 3, 2, 2, 2, 6253,
	6234, 3, 2, 2, 2, 6253, 6235, 3, 2, 2, 2, 6253, 6238, 3, 2, 2, 2, 6253,
	6239, 3, 2, 2, 2, 6253, 6240, 3, 2, 2, 2, 6253, 6241, 3, 2, 2, 2, 6253,
	6242, 3, 2, 2, 2, 6253, 6243, 3, 2, 2, 2, 6253, 6244, 3, 2, 2, 2, 6253,
	6245, 3, 2, 2, 2, 6253, 6246, 3, 2, 2, 2, 6253, 6247, 3, 2, 2, 2, 6253,
	6248, 3, 2, 2, 2, 6253, 6249, 3, 2, 2, 2, 6253, 6250, 3, 2, 2, 2, 6253,
	6251, 3, 2, 2, 2, 6253, 6252, 3, 2, 2, 2, 6254, 1181, 3, 2, 2, 2, 6255,
	6257, 7, 568, 2, 2, 6256, 6255, 3, 2, 2, 2, 6257, 6258, 3, 2, 2, 2, 6258,
	6256, 3, 2, 2, 2, 6258, 6259, 3, 2, 2, 2, 6259, 1183, 3, 2, 2, 2, 976,
	1190, 1193, 1197, 1200, 1203, 1208, 1212, 1223, 1227, 1252, 1256, 1267,
	1276, 1282, 1286, 1288, 1295, 1300, 1305, 1310, 1315, 1320, 1328, 1334,
	1342, 1347, 1353, 1357, 1367, 1377, 1381, 1385, 1388, 1392, 1395, 1399,
	1402, 1405, 1408, 1412, 1417, 1420, 1423, 1426, 1430, 1435, 1439, 1445,
	1458, 1462, 1475, 1479, 1485, 1488, 1499, 1501, 1508, 1510, 1519, 1524,
	1528, 1533, 1538, 1545, 1548, 1551, 1556, 1561, 1565, 1569, 1573, 1576,
	1580, 1585, 1589, 1595, 1599, 1601, 1604, 1608, 1613, 1615, 1620, 1622,
	1626, 1630, 1633, 1637, 1640, 1645, 1648, 1651, 1655, 1658, 1663, 1666,
	1669, 1671, 1675, 1681, 1684, 1687, 1691, 1695, 1698, 1701, 1706, 1710,
	1715, 1718, 1723, 1731, 1736, 1740, 1745, 1754, 1759, 1774, 1778, 1789,
	1794, 1797, 1800, 1804, 1806, 1813, 1819, 1822, 1826, 1831, 1836, 1840,
	1843, 1849, 1852, 1856, 1859, 1862, 1867, 1870, 1874, 1877, 1880, 1884,
	1889, 1893, 1897, 1901, 1904, 1913, 1918, 1922, 1928, 1934, 1936, 1942,
	1948, 1951, 1959, 1963, 1966, 1969, 1974, 1979, 1982, 1987, 1992, 1997,
	2007, 2010, 2013, 2016, 2019, 2022, 2025, 2028, 2031, 2039, 2045, 2050,
	2057, 2071, 2074, 2079, 2085, 2089, 2092, 2101, 2104, 2108, 2111, 2115,
	2118, 2121, 2125, 2128, 2130, 2134, 2137, 2140, 2145, 2153, 2157, 2159,
	2166, 2168, 2175, 2179, 2183, 2188, 2192, 2194, 2199, 2203, 2207, 2210,
	2215, 2221, 2224, 2228, 2232, 2235, 2238, 2243, 2246, 2249, 2254, 2258,
	2261, 2269, 2275, 2279, 2281, 2286, 2294, 2308, 2317, 2325, 2327, 2333,
	2338, 2341, 2353, 2356, 2358, 2366, 2375, 2377, 2385, 2395, 2398, 2400,
	2408, 2422, 2424, 2429, 2436, 2441, 2445, 2452, 2459, 2466, 2471, 2475,
	2480, 2484, 2489, 2493, 2498, 2502, 2507, 2511, 2518, 2529, 2534, 2543,
	2549, 2569, 2581, 2583, 2608, 2612, 2616, 2619, 2622, 2626, 2630, 2633,
	2636, 2640, 2644, 2648, 2652, 2656, 2660, 2666, 2672, 2679, 2682, 2692,
	2698, 2704, 2708, 2710, 2715, 2717, 2727, 2730, 2734, 2737, 2742, 2754,
	2761, 2766, 2770, 2773, 2776, 2779, 2781, 2786, 2793, 2797, 2799, 2803,
	2822, 2827, 2830, 2834, 2840, 2843, 2850, 2863, 2866, 2868, 2875, 2881,
	2884, 2890, 2894, 2897, 2900, 2903, 2907, 2911, 2915, 2923, 2928, 2938,
	2944, 2948, 2952, 2957, 2961, 2968, 2973, 2979, 2984, 2987, 2991, 3000,
	3005, 3010, 3015, 3019, 3026, 3030, 3034, 3036, 3043, 3048, 3052, 3062,
	3067, 3073, 3076, 3082, 3085, 3089, 3091, 3097, 3100, 3104, 3108, 3111,
	3114, 3117, 3125, 3131, 3138, 3143, 3146, 3149, 3152, 3164, 3168, 3174,
	3178, 3181, 3186, 3194, 3199, 3202, 3205, 3208, 3211, 3214, 3217, 3231,
	3233, 3237, 3240, 3243, 3260, 3268, 3275, 3280, 3283, 3291, 3296, 3299,
	3303, 3306, 3311, 3316, 3319, 3324, 3326, 3333, 3336, 3341, 3345, 3352,
	3355, 3359, 3378, 3387, 3390, 3404, 3408, 3410, 3415, 3417, 3421, 3424,
	3430, 3435, 3441, 3443, 3447, 3478, 3483, 3487, 3491, 3495, 3497, 3502,
	3506, 3510, 3516, 3524, 3527, 3531, 3542, 3544, 3554, 3569, 3575, 3585,
	3591, 3600, 3603, 3608, 3662, 3670, 3675, 3679, 3686, 3692, 3702, 3710,
	3713, 3716, 3719, 3724, 3730, 3735, 3741, 3743, 3749, 3758, 3762, 3766,
	3770, 3778, 3784, 3791, 3794, 3797, 3800, 3803, 3806, 3809, 3815, 3820,
	3823, 3826, 3831, 3837, 3841, 3844, 3850, 3854, 3857, 3863, 3869, 3873,
	3882, 3889, 3895, 3901, 3905, 3908, 3911, 3916, 3918, 3921, 3926, 3929,
	3935, 3941, 3943, 3948, 3952, 3959, 3963, 3967, 3973, 3978, 3981, 3984,
	3988, 3995, 3998, 4001, 4004, 4009, 4014, 4018, 4023, 4029, 4032, 4035,
	4038, 4042, 4047, 4052, 4055, 4063, 4068, 4071, 4074, 4077, 4080, 4085,
	4088, 4094, 4099, 4102, 4108, 4112, 4120, 4125, 4129, 4134, 4142, 4144,
	4151, 4157, 4160, 4163, 4169, 4177, 4182, 4190, 4195, 4199, 4203, 4216,
	4222, 4227, 4232, 4237, 4241, 4244, 4249, 4253, 4257, 4266, 4270, 4278,
	4282, 4285, 4287, 4293, 4296, 4299, 4306, 4309, 4317, 4320, 4326, 4329,
	4335, 4339, 4344, 4350, 4358, 4364, 4369, 4371, 4377, 4382, 4387, 4393,
	4400, 4402, 4408, 4416, 4423, 4429, 4433, 4438, 4443, 4449, 4455, 4460,
	4464, 4468, 4475, 4478, 4483, 4487, 4492, 4496, 4500, 4505, 4508, 4512,
	4517, 4520, 4523, 4526, 4533, 4537, 4545, 4550, 4554, 4563, 4575, 4580,
	4587, 4591, 4599, 4604, 4609, 4612, 4615, 4618, 4623, 4627, 4634, 4638,
	4642, 4649, 4651, 4657, 4662, 4666, 4672, 4676, 4680, 4686, 4692, 4697,
	4700, 4705, 4712, 4715, 4720, 4724, 4729, 4739, 4741, 4748, 4753, 4766,
	4772, 4775, 4784, 4789, 4792, 4795, 4798, 4801, 4804, 4807, 4810, 4813,
	4816, 4822, 4827, 4831, 4838, 4841, 4844, 4847, 4857, 4859, 4868, 4873,
	4877, 4880, 4887, 4895, 4900, 4904, 4907, 4914, 4920, 4924, 4928, 4936,
	4941, 4944, 4948, 4951, 4959, 4962, 4965, 4968, 4975, 4979, 4982, 4987,
	4990, 5002, 5005, 5010, 5013, 5016, 5020, 5023, 5026, 5029, 5032, 5046,
	5050, 5054, 5059, 5065, 5068, 5076, 5079, 5084, 5090, 5095, 5101, 5111,
	5115, 5122, 5125, 5128, 5131, 5136, 5140, 5145, 5149, 5153, 5158, 5161,
	5165, 5168, 5171, 5175, 5180, 5183, 5186, 5189, 5196, 5200, 5207, 5211,
	5220, 5225, 5229, 5238, 5250, 5255, 5258, 5261, 5264, 5268, 5272, 5277,
	5283, 5289, 5294, 5297, 5304, 5310, 5314, 5317, 5320, 5323, 5328, 5332,
	5336, 5340, 5345, 5350, 5356, 5365, 5368, 5371, 5374, 5379, 5385, 5390,
	5398, 5407, 5411, 5415, 5419, 5423, 5432, 5435, 5438, 5441, 5444, 5451,
	5454, 5458, 5461, 5465, 5469, 5473, 5479, 5483, 5486, 5490, 5496, 5501,
	5508, 5515, 5518, 5522, 5527, 5538, 5540, 5543, 5547, 5552, 5558, 5561,
	5566, 5571, 5574, 5577, 5580, 5583, 5586, 5589, 5594, 5598, 5603, 5609,
	5612, 5617, 5623, 5628, 5634, 5638, 5644, 5649, 5655, 5660, 5665, 5671,
	5676, 5680, 5686, 5691, 5697, 5701, 5708, 5713, 5720, 5724, 5730, 5735,
	5741, 5748, 5758, 5765, 5771, 5783, 5789, 5797, 5799, 5802, 5813, 5817,
	5820, 5829, 5835, 5839, 5844, 5850, 5853, 5859, 5866, 5870, 5873, 5892,
	5895, 5898, 5902, 5907, 5912, 5915, 5919, 5924, 5929, 5934, 5937, 5940,
	5943, 5951, 5957, 5963, 5968, 5975, 5979, 5986, 5991, 5998, 6002, 6008,
	6020, 6024, 6027, 6033, 6037, 6040, 6046, 6050, 6055, 6058, 6061, 6074,
	6113, 6125, 6139, 6143, 6146, 6150, 6162, 6178, 6185, 6193, 6201, 6220,
	6253, 6258,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "'&'", "'*'", "'**'", "':'", "','", "'>*CE'",
	"'>*'", "'$'", "'\"'", "", "'.'", "'='", "'>*EXECCICS'", "'>*EXECSQL'",
	"'>*EXECSQLIMS'", "'<'", "'<='", "'('", "'-'", "'>'", "'>='", "'+'", "'''",
	"')'", "'/'", "", "'66'", "'77'", "'88'", "", "", "", "", "", "", "", "",
	"", "", "', '",
}
var symbolicNames = []string{
	"", "ABORT", "ACCEPT", "ACCESS", "ADD", "ADDRESS", "ADVANCING", "AFTER",
	"ALIGNED", "ALL", "ALPHABET", "ALPHABETIC", "ALPHABETIC_LOWER", "ALPHABETIC_UPPER",
	"ALPHANUMERIC", "ALPHANUMERIC_EDITED", "ALSO", "ALTER", "ALTERNATE", "AND",
	"ANY", "APOST", "ARE", "AREA", "AREAS", "ARITH", "AS", "ASCENDING", "ASCII",
	"ASSIGN", "ASSOCIATED_DATA", "ASSOCIATED_DATA_LENGTH", "AT", "ATTRIBUTE",
	"AUTHOR", "AUTO", "AUTO_SKIP", "BACKGROUND_COLOR", "BACKGROUND_COLOUR",
	"BASIS", "BEEP", "BEFORE", "BEGINNING", "BELL", "BINARY", "BIT", "BLANK",
	"BLINK", "BLOCK", "BOUNDS", "BOTTOM", "BY", "BYFUNCTION", "BYTITLE", "CALL",
	"CANCEL", "CAPABLE", "CBL", "CCSVERSION", "CD", "CF", "CH", "CHANGED",
	"CHANNEL", "CHARACTER", "CHARACTERS", "CLASS", "CLASS_ID", "CLOCK_UNITS",
	"CLOSE", "CLOSE_DISPOSITION", "COBOL", "CODE", "CODEPAGE", "CODE_SET",
	"COLLATING", "COL", "COLUMN", "COM_REG", "COMMA", "COMMITMENT", "COMMON",
	"COMMUNICATION", "COMP", "COMP_1", "COMP_2", "COMP_3", "COMP_4", "COMP_5",
	"COMPUTATIONAL", "COMPUTATIONAL_1", "COMPUTATIONAL_2", "COMPUTATIONAL_3",
	"COMPUTATIONAL_4", "COMPUTATIONAL_5", "COMPUTE", "CONFIGURATION", "CONTAINS",
	"CONTENT", "CONTINUE", "CONTROL", "CONTROL_POINT", "CONTROLS", "CONVENTION",
	"CONVERTING", "COPY", "CORR", "CORRESPONDING", "COUNT", "CRUNCH", "CURRENCY",
	"CURSOR", "DATA", "DATA_BASE", "DATE", "DATE_COMPILED", "DATE_WRITTEN",
	"DAY", "DAY_OF_WEEK", "DBCS", "DE", "DEBUG_CONTENTS", "DEBUG_ITEM", "DEBUG_LINE",
	"DEBUG_NAME", "DEBUG_SUB_1", "DEBUG_SUB_2", "DEBUG_SUB_3", "DEBUGGING",
	"DECIMAL_POINT", "DECLARATIVES", "DEFAULT", "DEFAULT_DISPLAY", "DEFINITION",
	"DELETE", "DELIMITED", "DELIMITER", "DEPENDING", "DESCENDING", "DESTINATION",
	"DETAIL", "DFHRESP", "DFHVALUE", "DISABLE", "DISK", "DISPLAY", "DISPLAY_1",
	"DIVIDE", "DIVISION", "DONTCARE", "DOUBLE", "DOWN", "DUPLICATES", "DYNAMIC",
	"EBCDIC", "EGCS", "EGI", "EJECT", "ELSE", "EMI", "EMPTY_CHECK", "ENABLE",
	"END", "END_ADD", "END_CALL", "END_COMPUTE", "END_DELETE", "END_DIVIDE",
	"END_EVALUATE", "END_IF", "END_MULTIPLY", "END_OF_PAGE", "END_PERFORM",
	"END_READ", "END_RECEIVE", "END_RETURN", "END_REWRITE", "END_SEARCH", "END_START",
	"END_STRING", "END_SUBTRACT", "END_UNSTRING", "END_WRITE", "ENDING", "ENTER",
	"ENTRY", "ENTRY_PROCEDURE", "ENVIRONMENT", "EOP", "EQUAL", "ERASE", "ERROR",
	"EOL", "EOS", "ESCAPE", "ESI", "EVALUATE", "EVENT", "EVERY", "EXCEPTION",
	"EXCLUSIVE", "EXHIBIT", "EXIT", "EXPORT", "EXTEND", "EXTENDED", "EXTERNAL",
	"FALSE", "FD", "FILE", "FILE_CONTROL", "FILLER", "FINAL", "FIRST", "FOOTING",
	"FOR", "FOREGROUND_COLOR", "FOREGROUND_COLOUR", "FROM", "FULL", "FUNCTION",
	"FUNCTIONNAME", "FUNCTION_POINTER", "GENERATE", "GOBACK", "GIVING", "GLOBAL",
	"GO", "GREATER", "GRID", "GROUP", "HEADING", "HIGHLIGHT", "HIGH_VALUE",
	"HIGH_VALUES", "I_O", "I_O_CONTROL", "ID", "IDENTIFICATION", "IF", "IMPLICIT",
	"IMPORT", "IN", "INDEX", "INDEXED", "INDICATE", "INITIAL", "INITIALIZE",
	"INITIATE", "INPUT", "INPUT_OUTPUT", "INSPECT", "INSTALLATION", "INTEGER",
	"INTO", "INVALID", "INVOKE", "IS", "JUST", "JUSTIFIED", "KANJI", "KEPT",
	"KEY", "LABEL", "LANGUAGE", "LAST", "LB", "LD", "LEADING", "LEFT", "LEFTLINE",
	"LENGTH", "LENGTH_CHECK", "LESS", "LIB", "LIBACCESS", "LIBPARAMETER", "LIBRARY",
	"LIMIT", "LIMITS", "LINAGE", "LINAGE_COUNTER", "LINE", "LINES", "LINE_COUNTER",
	"LINKAGE", "LIST", "LOCAL", "LOCAL_STORAGE", "LOCK", "LONG_DATE", "LONG_TIME",
	"LOWER", "LOWLIGHT", "LOW_VALUE", "LOW_VALUES", "MEMORY", "MERGE", "MESSAGE",
	"MMDDYYYY", "MODE", "MODULES", "MORE_LABELS", "MOVE", "MULTIPLE", "MULTIPLY",
	"NAMED", "NATIONAL", "NATIVE", "NEGATIVE", "NETWORK", "NEXT", "NO", "NO_ECHO",
	"NOSEQ", "NOSTDTRUNC", "NOT", "NULL", "NULLS", "NUMBER", "NUMERIC", "NUMERIC_DATE",
	"NUMERIC_EDITED", "NUMERIC_TIME", "OBJECT_COMPUTER", "OCCURS", "ODT", "OF",
	"OFF", "OMITTED", "ON", "OPEN", "OPTIMIZE", "OPTIONAL", "OR", "ORDER",
	"ORDERLY", "ORGANIZATION", "OTHER", "OUTPUT", "OVERFLOW", "OVERLINE", "OWN",
	"PACKED_DECIMAL", "PADDING", "PAGE", "PAGE_COUNTER", "PASSWORD", "PERFORM",
	"PF", "PH", "PIC", "PICTURE", "PLUS", "POINTER", "POSITION", "POSITIVE",
	"PORT", "PRINTER", "PRINTING", "PRIVATE", "PROCEDURE", "PROCEDURE_POINTER",
	"PROCEDURES", "PROCEED", "PROCESS", "PROGRAM", "PROGRAM_ID", "PROGRAM_LIBRARY",
	"PROMPT", "PURGE", "QUEUE", "QUOTE", "QUOTES", "RANDOM", "READER", "REMOTE",
	"RD", "REAL", "READ", "RECEIVE", "RECEIVED", "RECORD", "RECORDING", "RECORDS",
	"REDEFINES", "REEL", "REF", "REFERENCE", "REFERENCES", "RELATIVE", "RELEASE",
	"REMAINDER", "REMARKS", "REMOVAL", "REMOVE", "RENAMES", "REPLACE", "REPLACING",
	"REPORT", "REPORTING", "REPORTS", "REQUIRED", "RERUN", "RESERVE", "REVERSE_VIDEO",
	"RESET", "RETURN", "RETURN_CODE", "REVERSED", "REWIND", "REWRITE", "RF",
	"RH", "RIGHT", "ROUNDED", "RUN", "SAME", "SAVE", "SCREEN", "SD", "SEARCH",
	"SECTION", "SECURE", "SECURITY", "SEGMENT", "SEGMENT_LIMIT", "SELECT",
	"SEND", "SENTENCE", "SEPARATE", "SEQUENCE", "SEQUENTIAL", "SET", "SHARED",
	"SHAREDBYALL", "SHAREDBYRUNUNIT", "SHARING", "SHIFT_IN", "SHIFT_OUT", "SHORT_DATE",
	"SIGN", "SIZE", "SORT", "SORT_CONTROL", "SORT_CORE_SIZE", "SORT_FILE_SIZE",
	"SORT_MERGE", "SORT_MESSAGE", "SORT_MODE_SIZE", "SORT_RETURN", "SOURCE",
	"SOURCE_COMPUTER", "SP", "SPACE", "SPACES", "SPECIAL_NAMES", "STANDARD",
	"STANDARD_1", "STANDARD_2", "START", "STATUS", "STOP", "STRING", "SUB_QUEUE_1",
	"SUB_QUEUE_2", "SUB_QUEUE_3", "SUBTRACT", "SUM", "SUPPRESS", "SYMBOL",
	"SYMBOLIC", "SYNC", "SYNCHRONIZED", "TABLE", "TALLY", "TALLYING", "TASK",
	"TAPE", "TERMINAL", "TERMINATE", "TEST", "TEXT", "THAN", "THEN", "THREAD",
	"THREAD_LOCAL", "THROUGH", "THRU", "TIME", "TIMER", "TIMES", "TITLE", "TO",
	"TODAYS_DATE", "TODAYS_NAME", "TOP", "TRAILING", "TRUE", "TRUNCATED", "TYPE",
	"TYPEDEF", "UNDERLINE", "UNIT", "UNSTRING", "UNTIL", "UP", "UPON", "USAGE",
	"USE", "USING", "VALUE", "VALUES", "VARYING", "VIRTUAL", "WAIT", "WHEN",
	"WHEN_COMPILED", "WITH", "WORDS", "WORKING_STORAGE", "WRITE", "XOPTS",
	"YEAR", "YYYYMMDD", "YYYYDDD", "ZERO", "ZERO_FILL", "ZEROS", "ZEROES",
	"AMPCHAR", "ASTERISKCHAR", "DOUBLEASTERISKCHAR", "COLONCHAR", "COMMACHAR",
	"COMMENTENTRYTAG", "COMMENTTAG", "DOLLARCHAR", "DOUBLEQUOTE", "DOT_FS",
	"DOT", "EQUALCHAR", "EXECCICSTAG", "EXECSQLTAG", "EXECSQLIMSTAG", "LESSTHANCHAR",
	"LESSTHANOREQUAL", "LPARENCHAR", "MINUSCHAR", "MORETHANCHAR", "MORETHANOREQUAL",
	"PLUSCHAR", "SINGLEQUOTE", "RPARENCHAR", "SLASHCHAR", "NONNUMERICLITERAL",
	"LEVEL_NUMBER_66", "LEVEL_NUMBER_77", "LEVEL_NUMBER_88", "INTEGERLITERAL",
	"NUMERICLITERAL", "IDENTIFIER", "NEWLINE", "EXECCICSLINE", "EXECSQLIMSLINE",
	"EXECSQLLINE", "COMMENTENTRYLINE", "COMMENTLINE", "WS", "SEPARATOR",
}

var ruleNames = []string{
	"startRule", "compilationUnit", "programUnit", "endProgramStatement", "compilerOptions",
	"compilerOption", "compilerSubOption", "identificationDivision", "identificationDivisionBody",
	"programIdParagraph", "authorParagraph", "installationParagraph", "dateWrittenParagraph",
	"dateCompiledParagraph", "securityParagraph", "remarksParagraph", "environmentDivision",
	"environmentDivisionBody", "configurationSection", "configurationSectionParagraph",
	"sourceComputerParagraph", "objectComputerParagraph", "objectComputerClause",
	"memorySizeClause", "diskSizeClause", "collatingSequenceClause", "collatingSequenceClauseAlphanumeric",
	"collatingSequenceClauseNational", "segmentLimitClause", "characterSetClause",
	"specialNamesParagraph", "specialNameClause", "alphabetClause", "alphabetClauseFormat1",
	"alphabetLiterals", "alphabetThrough", "alphabetAlso", "alphabetClauseFormat2",
	"channelClause", "classClause", "classClauseThrough", "classClauseFrom",
	"classClauseTo", "currencySignClause", "decimalPointClause", "defaultComputationalSignClause",
	"defaultDisplaySignClause", "environmentSwitchNameClause", "environmentSwitchNameSpecialNamesStatusPhrase",
	"odtClause", "reserveNetworkClause", "symbolicCharactersClause", "symbolicCharacters",
	"inputOutputSection", "inputOutputSectionParagraph", "fileControlParagraph",
	"fileControlEntry", "selectClause", "fileControlClause", "assignClause",
	"reserveClause", "organizationClause", "paddingCharacterClause", "recordDelimiterClause",
	"accessModeClause", "recordKeyClause", "alternateRecordKeyClause", "passwordClause",
	"fileStatusClause", "relativeKeyClause", "ioControlParagraph", "ioControlClause",
	"rerunClause", "rerunEveryRecords", "rerunEveryOf", "rerunEveryClock",
	"sameClause", "multipleFileClause", "multipleFilePosition", "commitmentControlClause",
	"dataDivision", "dataDivisionBody", "fileSection", "fileDescriptionEntry",
	"fileDescriptionEntryClause", "externalClause", "globalClause", "blockContainsClause",
	"blockContainsTo", "recordContainsClause", "recordContainsClauseFormat1",
	"recordContainsClauseFormat2", "recordContainsClauseFormat3", "recordContainsTo",
	"labelRecordsClause", "valueOfClause", "valuePair", "dataRecordsClause",
	"linageClause", "linageAt", "linageFootingAt", "linageLinesAtTop", "linageLinesAtBottom",
	"recordingModeClause", "modeStatement", "codeSetClause", "reportClause",
	"dataBaseSection", "dataBaseSectionEntry", "workingStorageSection", "linkageSection",
	"communicationSection", "communicationDescriptionEntry", "communicationDescriptionEntryFormat1",
	"communicationDescriptionEntryFormat2", "communicationDescriptionEntryFormat3",
	"destinationCountClause", "destinationTableClause", "endKeyClause", "errorKeyClause",
	"messageCountClause", "messageDateClause", "messageTimeClause", "statusKeyClause",
	"symbolicDestinationClause", "symbolicQueueClause", "symbolicSourceClause",
	"symbolicTerminalClause", "symbolicSubQueueClause", "textLengthClause",
	"localStorageSection", "screenSection", "screenDescriptionEntry", "screenDescriptionBlankClause",
	"screenDescriptionBellClause", "screenDescriptionBlinkClause", "screenDescriptionEraseClause",
	"screenDescriptionLightClause", "screenDescriptionGridClause", "screenDescriptionReverseVideoClause",
	"screenDescriptionUnderlineClause", "screenDescriptionSizeClause", "screenDescriptionLineClause",
	"screenDescriptionColumnClause", "screenDescriptionForegroundColorClause",
	"screenDescriptionBackgroundColorClause", "screenDescriptionControlClause",
	"screenDescriptionValueClause", "screenDescriptionPictureClause", "screenDescriptionFromClause",
	"screenDescriptionToClause", "screenDescriptionUsingClause", "screenDescriptionUsageClause",
	"screenDescriptionBlankWhenZeroClause", "screenDescriptionJustifiedClause",
	"screenDescriptionSignClause", "screenDescriptionAutoClause", "screenDescriptionSecureClause",
	"screenDescriptionRequiredClause", "screenDescriptionPromptClause", "screenDescriptionPromptOccursClause",
	"screenDescriptionFullClause", "screenDescriptionZeroFillClause", "reportSection",
	"reportDescription", "reportDescriptionEntry", "reportDescriptionGlobalClause",
	"reportDescriptionPageLimitClause", "reportDescriptionHeadingClause", "reportDescriptionFirstDetailClause",
	"reportDescriptionLastDetailClause", "reportDescriptionFootingClause",
	"reportGroupDescriptionEntry", "reportGroupDescriptionEntryFormat1", "reportGroupDescriptionEntryFormat2",
	"reportGroupDescriptionEntryFormat3", "reportGroupBlankWhenZeroClause",
	"reportGroupColumnNumberClause", "reportGroupIndicateClause", "reportGroupJustifiedClause",
	"reportGroupLineNumberClause", "reportGroupLineNumberNextPage", "reportGroupLineNumberPlus",
	"reportGroupNextGroupClause", "reportGroupNextGroupPlus", "reportGroupNextGroupNextPage",
	"reportGroupPictureClause", "reportGroupResetClause", "reportGroupSignClause",
	"reportGroupSourceClause", "reportGroupSumClause", "reportGroupTypeClause",
	"reportGroupTypeReportHeading", "reportGroupTypePageHeading", "reportGroupTypeControlHeading",
	"reportGroupTypeDetail", "reportGroupTypeControlFooting", "reportGroupUsageClause",
	"reportGroupTypePageFooting", "reportGroupTypeReportFooting", "reportGroupValueClause",
	"programLibrarySection", "libraryDescriptionEntry", "libraryDescriptionEntryFormat1",
	"libraryDescriptionEntryFormat2", "libraryAttributeClauseFormat1", "libraryAttributeClauseFormat2",
	"libraryAttributeFunction", "libraryAttributeParameter", "libraryAttributeTitle",
	"libraryEntryProcedureClauseFormat1", "libraryEntryProcedureClauseFormat2",
	"libraryEntryProcedureForClause", "libraryEntryProcedureGivingClause",
	"libraryEntryProcedureUsingClause", "libraryEntryProcedureUsingName", "libraryEntryProcedureWithClause",
	"libraryEntryProcedureWithName", "libraryIsCommonClause", "libraryIsGlobalClause",
	"dataDescriptionEntry", "dataDescriptionEntryFormat1", "dataDescriptionEntryFormat2",
	"dataDescriptionEntryFormat3", "dataDescriptionEntryExecSql", "dataAlignedClause",
	"dataBlankWhenZeroClause", "dataCommonOwnLocalClause", "dataExternalClause",
	"dataGlobalClause", "dataIntegerStringClause", "dataJustifiedClause", "dataOccursClause",
	"dataOccursTo", "dataOccursSort", "dataPictureClause", "pictureString",
	"pictureChars", "pictureCharsKeyword", "pictureCardinality", "dataReceivedByClause",
	"dataRecordAreaClause", "dataRedefinesClause", "dataRenamesClause", "dataSignClause",
	"dataSynchronizedClause", "dataThreadLocalClause", "dataTypeClause", "dataTypeDefClause",
	"dataUsageClause", "dataUsingClause", "dataValueClause", "dataValueInterval",
	"dataValueIntervalFrom", "dataValueIntervalTo", "dataWithLowerBoundsClause",
	"procedureDivision", "procedureDivisionUsingClause", "procedureDivisionGivingClause",
	"procedureDeclaratives", "procedureDeclarative", "procedureSectionHeader",
	"procedureDivisionBody", "procedureSection", "paragraphs", "paragraph",
	"sentence", "statement", "acceptStatement", "acceptFromDateStatement",
	"acceptFromMnemonicStatement", "acceptFromEscapeKeyStatement", "acceptMessageCountStatement",
	"addStatement", "addToStatement", "addToGivingStatement", "addCorrespondingStatement",
	"addFrom", "addTo", "addGiving", "alteredGoTo", "alterStatement", "alterProceedTo",
	"callStatement", "callUsingPhrase", "callUsingParameter", "callByReferencePhrase",
	"callByReference", "callByValuePhrase", "callByValue", "callByContentPhrase",
	"callByContent", "callGivingPhrase", "cancelStatement", "cancelCall", "closeStatement",
	"closeFile", "closeReelUnitStatement", "closeRelativeStatement", "closePortFileIOStatement",
	"closePortFileIOUsing", "closePortFileIOUsingCloseDisposition", "closePortFileIOUsingAssociatedData",
	"closePortFileIOUsingAssociatedDataLength", "computeStatement", "computeStore",
	"continueStatement", "deleteStatement", "disableStatement", "displayStatement",
	"displayOperand", "displayAt", "displayUpon", "displayWith", "divideStatement",
	"divideIntoStatement", "divideIntoGivingStatement", "divideByGivingStatement",
	"divideGivingPhrase", "divideGiving", "divideRemainder", "enableStatement",
	"entryStatement", "evaluateStatement", "evaluateSelect", "evaluateAlsoSelect",
	"evaluateWhenPhrase", "evaluateWhen", "evaluateCondition", "evaluateThrough",
	"evaluateAlsoCondition", "evaluateWhenOther", "evaluateValue", "execCicsStatement",
	"execSqlStatement", "execSqlImsStatement", "exhibitStatement", "exhibitOperand",
	"exitStatement", "generateStatement", "gobackStatement", "goToStatement",
	"goToStatementSimple", "goToDependingOnStatement", "ifStatement", "ifThen",
	"ifElse", "initializeStatement", "initializeReplacingPhrase", "initializeReplacingBy",
	"initiateStatement", "inspectStatement", "inspectTallyingPhrase", "inspectReplacingPhrase",
	"inspectTallyingReplacingPhrase", "inspectConvertingPhrase", "inspectFor",
	"inspectCharacters", "inspectReplacingCharacters", "inspectAllLeadings",
	"inspectReplacingAllLeadings", "inspectAllLeading", "inspectReplacingAllLeading",
	"inspectBy", "inspectTo", "inspectBeforeAfter", "mergeStatement", "mergeOnKeyClause",
	"mergeCollatingSequencePhrase", "mergeCollatingAlphanumeric", "mergeCollatingNational",
	"mergeUsing", "mergeOutputProcedurePhrase", "mergeOutputThrough", "mergeGivingPhrase",
	"mergeGiving", "moveStatement", "moveToStatement", "moveToSendingArea",
	"moveCorrespondingToStatement", "multiplyStatement", "multiplyRegular",
	"multiplyRegularOperand", "multiplyGiving", "multiplyGivingOperand", "multiplyGivingResult",
	"openStatement", "openInputStatement", "openInput", "openOutputStatement",
	"openOutput", "openIOStatement", "openExtendStatement", "performStatement",
	"performInlineStatement", "performProcedureStatement", "performType", "performTimes",
	"performUntil", "performVarying", "performVaryingClause", "performVaryingPhrase",
	"performAfter", "performFrom", "performBy", "performTestClause", "purgeStatement",
	"readStatement", "readInto", "readWith", "readKey", "receiveStatement",
	"receiveFromStatement", "receiveFrom", "receiveIntoStatement", "receiveNoData",
	"receiveWithData", "receiveBefore", "receiveWith", "receiveThread", "receiveSize",
	"receiveStatus", "releaseStatement", "returnStatement", "returnInto", "rewriteStatement",
	"rewriteFrom", "searchStatement", "searchVarying", "searchWhen", "sendStatement",
	"sendStatementSync", "sendStatementAsync", "sendFromPhrase", "sendWithPhrase",
	"sendReplacingPhrase", "sendAdvancingPhrase", "sendAdvancingPage", "sendAdvancingLines",
	"sendAdvancingMnemonic", "setStatement", "setToStatement", "setUpDownByStatement",
	"setTo", "setToValue", "setByValue", "sortStatement", "sortOnKeyClause",
	"sortDuplicatesPhrase", "sortCollatingSequencePhrase", "sortCollatingAlphanumeric",
	"sortCollatingNational", "sortInputProcedurePhrase", "sortInputThrough",
	"sortUsing", "sortOutputProcedurePhrase", "sortOutputThrough", "sortGivingPhrase",
	"sortGiving", "startStatement", "startKey", "stopStatement", "stringStatement",
	"stringSendingPhrase", "stringSending", "stringDelimitedByPhrase", "stringForPhrase",
	"stringIntoPhrase", "stringWithPointerPhrase", "subtractStatement", "subtractFromStatement",
	"subtractFromGivingStatement", "subtractCorrespondingStatement", "subtractSubtrahend",
	"subtractMinuend", "subtractMinuendGiving", "subtractGiving", "subtractMinuendCorresponding",
	"terminateStatement", "unstringStatement", "unstringSendingPhrase", "unstringDelimitedByPhrase",
	"unstringOrAllPhrase", "unstringIntoPhrase", "unstringInto", "unstringDelimiterIn",
	"unstringCountIn", "unstringWithPointerPhrase", "unstringTallyingPhrase",
	"useStatement", "useAfterClause", "useAfterOn", "useDebugClause", "useDebugOn",
	"writeStatement", "writeFromPhrase", "writeAdvancingPhrase", "writeAdvancingPage",
	"writeAdvancingLines", "writeAdvancingMnemonic", "writeAtEndOfPagePhrase",
	"writeNotAtEndOfPagePhrase", "atEndPhrase", "notAtEndPhrase", "invalidKeyPhrase",
	"notInvalidKeyPhrase", "onOverflowPhrase", "notOnOverflowPhrase", "onSizeErrorPhrase",
	"notOnSizeErrorPhrase", "onExceptionClause", "notOnExceptionClause", "arithmeticExpression",
	"plusMinus", "multDivs", "multDiv", "powers", "power", "basis", "condition",
	"andOrCondition", "combinableCondition", "simpleCondition", "classCondition",
	"conditionNameReference", "conditionNameSubscriptReference", "relationCondition",
	"relationSignCondition", "relationArithmeticComparison", "relationCombinedComparison",
	"relationCombinedCondition", "relationalOperator", "abbreviation", "identifier",
	"tableCall", "functionCall", "referenceModifier", "characterPosition",
	"length", "subscript", "argument", "qualifiedDataName", "qualifiedDataNameFormat1",
	"qualifiedDataNameFormat2", "qualifiedDataNameFormat3", "qualifiedDataNameFormat4",
	"qualifiedInData", "inData", "inFile", "inMnemonic", "inSection", "inLibrary",
	"inTable", "alphabetName", "assignmentName", "basisName", "cdName", "className",
	"computerName", "conditionName", "dataName", "dataDescName", "environmentName",
	"fileName", "functionName", "indexName", "languageName", "libraryName",
	"localName", "mnemonicName", "paragraphName", "procedureName", "programName",
	"recordName", "reportName", "routineName", "screenName", "sectionName",
	"systemName", "symbolicCharacter", "textName", "cobolWord", "literal",
	"booleanLiteral", "numericLiteral", "integerLiteral", "cicsDfhRespLiteral",
	"cicsDfhValueLiteral", "figurativeConstant", "specialRegister", "commentEntry",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type Cobol85Parser struct {
	*antlr.BaseParser
}

func NewCobol85Parser(input antlr.TokenStream) *Cobol85Parser {
	this := new(Cobol85Parser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Cobol85.g4"

	return this
}

// Cobol85Parser tokens.
const (
	Cobol85ParserEOF                    = antlr.TokenEOF
	Cobol85ParserABORT                  = 1
	Cobol85ParserACCEPT                 = 2
	Cobol85ParserACCESS                 = 3
	Cobol85ParserADD                    = 4
	Cobol85ParserADDRESS                = 5
	Cobol85ParserADVANCING              = 6
	Cobol85ParserAFTER                  = 7
	Cobol85ParserALIGNED                = 8
	Cobol85ParserALL                    = 9
	Cobol85ParserALPHABET               = 10
	Cobol85ParserALPHABETIC             = 11
	Cobol85ParserALPHABETIC_LOWER       = 12
	Cobol85ParserALPHABETIC_UPPER       = 13
	Cobol85ParserALPHANUMERIC           = 14
	Cobol85ParserALPHANUMERIC_EDITED    = 15
	Cobol85ParserALSO                   = 16
	Cobol85ParserALTER                  = 17
	Cobol85ParserALTERNATE              = 18
	Cobol85ParserAND                    = 19
	Cobol85ParserANY                    = 20
	Cobol85ParserAPOST                  = 21
	Cobol85ParserARE                    = 22
	Cobol85ParserAREA                   = 23
	Cobol85ParserAREAS                  = 24
	Cobol85ParserARITH                  = 25
	Cobol85ParserAS                     = 26
	Cobol85ParserASCENDING              = 27
	Cobol85ParserASCII                  = 28
	Cobol85ParserASSIGN                 = 29
	Cobol85ParserASSOCIATED_DATA        = 30
	Cobol85ParserASSOCIATED_DATA_LENGTH = 31
	Cobol85ParserAT                     = 32
	Cobol85ParserATTRIBUTE              = 33
	Cobol85ParserAUTHOR                 = 34
	Cobol85ParserAUTO                   = 35
	Cobol85ParserAUTO_SKIP              = 36
	Cobol85ParserBACKGROUND_COLOR       = 37
	Cobol85ParserBACKGROUND_COLOUR      = 38
	Cobol85ParserBASIS                  = 39
	Cobol85ParserBEEP                   = 40
	Cobol85ParserBEFORE                 = 41
	Cobol85ParserBEGINNING              = 42
	Cobol85ParserBELL                   = 43
	Cobol85ParserBINARY                 = 44
	Cobol85ParserBIT                    = 45
	Cobol85ParserBLANK                  = 46
	Cobol85ParserBLINK                  = 47
	Cobol85ParserBLOCK                  = 48
	Cobol85ParserBOUNDS                 = 49
	Cobol85ParserBOTTOM                 = 50
	Cobol85ParserBY                     = 51
	Cobol85ParserBYFUNCTION             = 52
	Cobol85ParserBYTITLE                = 53
	Cobol85ParserCALL                   = 54
	Cobol85ParserCANCEL                 = 55
	Cobol85ParserCAPABLE                = 56
	Cobol85ParserCBL                    = 57
	Cobol85ParserCCSVERSION             = 58
	Cobol85ParserCD                     = 59
	Cobol85ParserCF                     = 60
	Cobol85ParserCH                     = 61
	Cobol85ParserCHANGED                = 62
	Cobol85ParserCHANNEL                = 63
	Cobol85ParserCHARACTER              = 64
	Cobol85ParserCHARACTERS             = 65
	Cobol85ParserCLASS                  = 66
	Cobol85ParserCLASS_ID               = 67
	Cobol85ParserCLOCK_UNITS            = 68
	Cobol85ParserCLOSE                  = 69
	Cobol85ParserCLOSE_DISPOSITION      = 70
	Cobol85ParserCOBOL                  = 71
	Cobol85ParserCODE                   = 72
	Cobol85ParserCODEPAGE               = 73
	Cobol85ParserCODE_SET               = 74
	Cobol85ParserCOLLATING              = 75
	Cobol85ParserCOL                    = 76
	Cobol85ParserCOLUMN                 = 77
	Cobol85ParserCOM_REG                = 78
	Cobol85ParserCOMMA                  = 79
	Cobol85ParserCOMMITMENT             = 80
	Cobol85ParserCOMMON                 = 81
	Cobol85ParserCOMMUNICATION          = 82
	Cobol85ParserCOMP                   = 83
	Cobol85ParserCOMP_1                 = 84
	Cobol85ParserCOMP_2                 = 85
	Cobol85ParserCOMP_3                 = 86
	Cobol85ParserCOMP_4                 = 87
	Cobol85ParserCOMP_5                 = 88
	Cobol85ParserCOMPUTATIONAL          = 89
	Cobol85ParserCOMPUTATIONAL_1        = 90
	Cobol85ParserCOMPUTATIONAL_2        = 91
	Cobol85ParserCOMPUTATIONAL_3        = 92
	Cobol85ParserCOMPUTATIONAL_4        = 93
	Cobol85ParserCOMPUTATIONAL_5        = 94
	Cobol85ParserCOMPUTE                = 95
	Cobol85ParserCONFIGURATION          = 96
	Cobol85ParserCONTAINS               = 97
	Cobol85ParserCONTENT                = 98
	Cobol85ParserCONTINUE               = 99
	Cobol85ParserCONTROL                = 100
	Cobol85ParserCONTROL_POINT          = 101
	Cobol85ParserCONTROLS               = 102
	Cobol85ParserCONVENTION             = 103
	Cobol85ParserCONVERTING             = 104
	Cobol85ParserCOPY                   = 105
	Cobol85ParserCORR                   = 106
	Cobol85ParserCORRESPONDING          = 107
	Cobol85ParserCOUNT                  = 108
	Cobol85ParserCRUNCH                 = 109
	Cobol85ParserCURRENCY               = 110
	Cobol85ParserCURSOR                 = 111
	Cobol85ParserDATA                   = 112
	Cobol85ParserDATA_BASE              = 113
	Cobol85ParserDATE                   = 114
	Cobol85ParserDATE_COMPILED          = 115
	Cobol85ParserDATE_WRITTEN           = 116
	Cobol85ParserDAY                    = 117
	Cobol85ParserDAY_OF_WEEK            = 118
	Cobol85ParserDBCS                   = 119
	Cobol85ParserDE                     = 120
	Cobol85ParserDEBUG_CONTENTS         = 121
	Cobol85ParserDEBUG_ITEM             = 122
	Cobol85ParserDEBUG_LINE             = 123
	Cobol85ParserDEBUG_NAME             = 124
	Cobol85ParserDEBUG_SUB_1            = 125
	Cobol85ParserDEBUG_SUB_2            = 126
	Cobol85ParserDEBUG_SUB_3            = 127
	Cobol85ParserDEBUGGING              = 128
	Cobol85ParserDECIMAL_POINT          = 129
	Cobol85ParserDECLARATIVES           = 130
	Cobol85ParserDEFAULT                = 131
	Cobol85ParserDEFAULT_DISPLAY        = 132
	Cobol85ParserDEFINITION             = 133
	Cobol85ParserDELETE                 = 134
	Cobol85ParserDELIMITED              = 135
	Cobol85ParserDELIMITER              = 136
	Cobol85ParserDEPENDING              = 137
	Cobol85ParserDESCENDING             = 138
	Cobol85ParserDESTINATION            = 139
	Cobol85ParserDETAIL                 = 140
	Cobol85ParserDFHRESP                = 141
	Cobol85ParserDFHVALUE               = 142
	Cobol85ParserDISABLE                = 143
	Cobol85ParserDISK                   = 144
	Cobol85ParserDISPLAY                = 145
	Cobol85ParserDISPLAY_1              = 146
	Cobol85ParserDIVIDE                 = 147
	Cobol85ParserDIVISION               = 148
	Cobol85ParserDONTCARE               = 149
	Cobol85ParserDOUBLE                 = 150
	Cobol85ParserDOWN                   = 151
	Cobol85ParserDUPLICATES             = 152
	Cobol85ParserDYNAMIC                = 153
	Cobol85ParserEBCDIC                 = 154
	Cobol85ParserEGCS                   = 155
	Cobol85ParserEGI                    = 156
	Cobol85ParserEJECT                  = 157
	Cobol85ParserELSE                   = 158
	Cobol85ParserEMI                    = 159
	Cobol85ParserEMPTY_CHECK            = 160
	Cobol85ParserENABLE                 = 161
	Cobol85ParserEND                    = 162
	Cobol85ParserEND_ADD                = 163
	Cobol85ParserEND_CALL               = 164
	Cobol85ParserEND_COMPUTE            = 165
	Cobol85ParserEND_DELETE             = 166
	Cobol85ParserEND_DIVIDE             = 167
	Cobol85ParserEND_EVALUATE           = 168
	Cobol85ParserEND_IF                 = 169
	Cobol85ParserEND_MULTIPLY           = 170
	Cobol85ParserEND_OF_PAGE            = 171
	Cobol85ParserEND_PERFORM            = 172
	Cobol85ParserEND_READ               = 173
	Cobol85ParserEND_RECEIVE            = 174
	Cobol85ParserEND_RETURN             = 175
	Cobol85ParserEND_REWRITE            = 176
	Cobol85ParserEND_SEARCH             = 177
	Cobol85ParserEND_START              = 178
	Cobol85ParserEND_STRING             = 179
	Cobol85ParserEND_SUBTRACT           = 180
	Cobol85ParserEND_UNSTRING           = 181
	Cobol85ParserEND_WRITE              = 182
	Cobol85ParserENDING                 = 183
	Cobol85ParserENTER                  = 184
	Cobol85ParserENTRY                  = 185
	Cobol85ParserENTRY_PROCEDURE        = 186
	Cobol85ParserENVIRONMENT            = 187
	Cobol85ParserEOP                    = 188
	Cobol85ParserEQUAL                  = 189
	Cobol85ParserERASE                  = 190
	Cobol85ParserERROR                  = 191
	Cobol85ParserEOL                    = 192
	Cobol85ParserEOS                    = 193
	Cobol85ParserESCAPE                 = 194
	Cobol85ParserESI                    = 195
	Cobol85ParserEVALUATE               = 196
	Cobol85ParserEVENT                  = 197
	Cobol85ParserEVERY                  = 198
	Cobol85ParserEXCEPTION              = 199
	Cobol85ParserEXCLUSIVE              = 200
	Cobol85ParserEXHIBIT                = 201
	Cobol85ParserEXIT                   = 202
	Cobol85ParserEXPORT                 = 203
	Cobol85ParserEXTEND                 = 204
	Cobol85ParserEXTENDED               = 205
	Cobol85ParserEXTERNAL               = 206
	Cobol85ParserFALSE                  = 207
	Cobol85ParserFD                     = 208
	Cobol85ParserFILE                   = 209
	Cobol85ParserFILE_CONTROL           = 210
	Cobol85ParserFILLER                 = 211
	Cobol85ParserFINAL                  = 212
	Cobol85ParserFIRST                  = 213
	Cobol85ParserFOOTING                = 214
	Cobol85ParserFOR                    = 215
	Cobol85ParserFOREGROUND_COLOR       = 216
	Cobol85ParserFOREGROUND_COLOUR      = 217
	Cobol85ParserFROM                   = 218
	Cobol85ParserFULL                   = 219
	Cobol85ParserFUNCTION               = 220
	Cobol85ParserFUNCTIONNAME           = 221
	Cobol85ParserFUNCTION_POINTER       = 222
	Cobol85ParserGENERATE               = 223
	Cobol85ParserGOBACK                 = 224
	Cobol85ParserGIVING                 = 225
	Cobol85ParserGLOBAL                 = 226
	Cobol85ParserGO                     = 227
	Cobol85ParserGREATER                = 228
	Cobol85ParserGRID                   = 229
	Cobol85ParserGROUP                  = 230
	Cobol85ParserHEADING                = 231
	Cobol85ParserHIGHLIGHT              = 232
	Cobol85ParserHIGH_VALUE             = 233
	Cobol85ParserHIGH_VALUES            = 234
	Cobol85ParserI_O                    = 235
	Cobol85ParserI_O_CONTROL            = 236
	Cobol85ParserID                     = 237
	Cobol85ParserIDENTIFICATION         = 238
	Cobol85ParserIF                     = 239
	Cobol85ParserIMPLICIT               = 240
	Cobol85ParserIMPORT                 = 241
	Cobol85ParserIN                     = 242
	Cobol85ParserINDEX                  = 243
	Cobol85ParserINDEXED                = 244
	Cobol85ParserINDICATE               = 245
	Cobol85ParserINITIAL                = 246
	Cobol85ParserINITIALIZE             = 247
	Cobol85ParserINITIATE               = 248
	Cobol85ParserINPUT                  = 249
	Cobol85ParserINPUT_OUTPUT           = 250
	Cobol85ParserINSPECT                = 251
	Cobol85ParserINSTALLATION           = 252
	Cobol85ParserINTEGER                = 253
	Cobol85ParserINTO                   = 254
	Cobol85ParserINVALID                = 255
	Cobol85ParserINVOKE                 = 256
	Cobol85ParserIS                     = 257
	Cobol85ParserJUST                   = 258
	Cobol85ParserJUSTIFIED              = 259
	Cobol85ParserKANJI                  = 260
	Cobol85ParserKEPT                   = 261
	Cobol85ParserKEY                    = 262
	Cobol85ParserLABEL                  = 263
	Cobol85ParserLANGUAGE               = 264
	Cobol85ParserLAST                   = 265
	Cobol85ParserLB                     = 266
	Cobol85ParserLD                     = 267
	Cobol85ParserLEADING                = 268
	Cobol85ParserLEFT                   = 269
	Cobol85ParserLEFTLINE               = 270
	Cobol85ParserLENGTH                 = 271
	Cobol85ParserLENGTH_CHECK           = 272
	Cobol85ParserLESS                   = 273
	Cobol85ParserLIB                    = 274
	Cobol85ParserLIBACCESS              = 275
	Cobol85ParserLIBPARAMETER           = 276
	Cobol85ParserLIBRARY                = 277
	Cobol85ParserLIMIT                  = 278
	Cobol85ParserLIMITS                 = 279
	Cobol85ParserLINAGE                 = 280
	Cobol85ParserLINAGE_COUNTER         = 281
	Cobol85ParserLINE                   = 282
	Cobol85ParserLINES                  = 283
	Cobol85ParserLINE_COUNTER           = 284
	Cobol85ParserLINKAGE                = 285
	Cobol85ParserLIST                   = 286
	Cobol85ParserLOCAL                  = 287
	Cobol85ParserLOCAL_STORAGE          = 288
	Cobol85ParserLOCK                   = 289
	Cobol85ParserLONG_DATE              = 290
	Cobol85ParserLONG_TIME              = 291
	Cobol85ParserLOWER                  = 292
	Cobol85ParserLOWLIGHT               = 293
	Cobol85ParserLOW_VALUE              = 294
	Cobol85ParserLOW_VALUES             = 295
	Cobol85ParserMEMORY                 = 296
	Cobol85ParserMERGE                  = 297
	Cobol85ParserMESSAGE                = 298
	Cobol85ParserMMDDYYYY               = 299
	Cobol85ParserMODE                   = 300
	Cobol85ParserMODULES                = 301
	Cobol85ParserMORE_LABELS            = 302
	Cobol85ParserMOVE                   = 303
	Cobol85ParserMULTIPLE               = 304
	Cobol85ParserMULTIPLY               = 305
	Cobol85ParserNAMED                  = 306
	Cobol85ParserNATIONAL               = 307
	Cobol85ParserNATIVE                 = 308
	Cobol85ParserNEGATIVE               = 309
	Cobol85ParserNETWORK                = 310
	Cobol85ParserNEXT                   = 311
	Cobol85ParserNO                     = 312
	Cobol85ParserNO_ECHO                = 313
	Cobol85ParserNOSEQ                  = 314
	Cobol85ParserNOSTDTRUNC             = 315
	Cobol85ParserNOT                    = 316
	Cobol85ParserNULL                   = 317
	Cobol85ParserNULLS                  = 318
	Cobol85ParserNUMBER                 = 319
	Cobol85ParserNUMERIC                = 320
	Cobol85ParserNUMERIC_DATE           = 321
	Cobol85ParserNUMERIC_EDITED         = 322
	Cobol85ParserNUMERIC_TIME           = 323
	Cobol85ParserOBJECT_COMPUTER        = 324
	Cobol85ParserOCCURS                 = 325
	Cobol85ParserODT                    = 326
	Cobol85ParserOF                     = 327
	Cobol85ParserOFF                    = 328
	Cobol85ParserOMITTED                = 329
	Cobol85ParserON                     = 330
	Cobol85ParserOPEN                   = 331
	Cobol85ParserOPTIMIZE               = 332
	Cobol85ParserOPTIONAL               = 333
	Cobol85ParserOR                     = 334
	Cobol85ParserORDER                  = 335
	Cobol85ParserORDERLY                = 336
	Cobol85ParserORGANIZATION           = 337
	Cobol85ParserOTHER                  = 338
	Cobol85ParserOUTPUT                 = 339
	Cobol85ParserOVERFLOW               = 340
	Cobol85ParserOVERLINE               = 341
	Cobol85ParserOWN                    = 342
	Cobol85ParserPACKED_DECIMAL         = 343
	Cobol85ParserPADDING                = 344
	Cobol85ParserPAGE                   = 345
	Cobol85ParserPAGE_COUNTER           = 346
	Cobol85ParserPASSWORD               = 347
	Cobol85ParserPERFORM                = 348
	Cobol85ParserPF                     = 349
	Cobol85ParserPH                     = 350
	Cobol85ParserPIC                    = 351
	Cobol85ParserPICTURE                = 352
	Cobol85ParserPLUS                   = 353
	Cobol85ParserPOINTER                = 354
	Cobol85ParserPOSITION               = 355
	Cobol85ParserPOSITIVE               = 356
	Cobol85ParserPORT                   = 357
	Cobol85ParserPRINTER                = 358
	Cobol85ParserPRINTING               = 359
	Cobol85ParserPRIVATE                = 360
	Cobol85ParserPROCEDURE              = 361
	Cobol85ParserPROCEDURE_POINTER      = 362
	Cobol85ParserPROCEDURES             = 363
	Cobol85ParserPROCEED                = 364
	Cobol85ParserPROCESS                = 365
	Cobol85ParserPROGRAM                = 366
	Cobol85ParserPROGRAM_ID             = 367
	Cobol85ParserPROGRAM_LIBRARY        = 368
	Cobol85ParserPROMPT                 = 369
	Cobol85ParserPURGE                  = 370
	Cobol85ParserQUEUE                  = 371
	Cobol85ParserQUOTE                  = 372
	Cobol85ParserQUOTES                 = 373
	Cobol85ParserRANDOM                 = 374
	Cobol85ParserREADER                 = 375
	Cobol85ParserREMOTE                 = 376
	Cobol85ParserRD                     = 377
	Cobol85ParserREAL                   = 378
	Cobol85ParserREAD                   = 379
	Cobol85ParserRECEIVE                = 380
	Cobol85ParserRECEIVED               = 381
	Cobol85ParserRECORD                 = 382
	Cobol85ParserRECORDING              = 383
	Cobol85ParserRECORDS                = 384
	Cobol85ParserREDEFINES              = 385
	Cobol85ParserREEL                   = 386
	Cobol85ParserREF                    = 387
	Cobol85ParserREFERENCE              = 388
	Cobol85ParserREFERENCES             = 389
	Cobol85ParserRELATIVE               = 390
	Cobol85ParserRELEASE                = 391
	Cobol85ParserREMAINDER              = 392
	Cobol85ParserREMARKS                = 393
	Cobol85ParserREMOVAL                = 394
	Cobol85ParserREMOVE                 = 395
	Cobol85ParserRENAMES                = 396
	Cobol85ParserREPLACE                = 397
	Cobol85ParserREPLACING              = 398
	Cobol85ParserREPORT                 = 399
	Cobol85ParserREPORTING              = 400
	Cobol85ParserREPORTS                = 401
	Cobol85ParserREQUIRED               = 402
	Cobol85ParserRERUN                  = 403
	Cobol85ParserRESERVE                = 404
	Cobol85ParserREVERSE_VIDEO          = 405
	Cobol85ParserRESET                  = 406
	Cobol85ParserRETURN                 = 407
	Cobol85ParserRETURN_CODE            = 408
	Cobol85ParserREVERSED               = 409
	Cobol85ParserREWIND                 = 410
	Cobol85ParserREWRITE                = 411
	Cobol85ParserRF                     = 412
	Cobol85ParserRH                     = 413
	Cobol85ParserRIGHT                  = 414
	Cobol85ParserROUNDED                = 415
	Cobol85ParserRUN                    = 416
	Cobol85ParserSAME                   = 417
	Cobol85ParserSAVE                   = 418
	Cobol85ParserSCREEN                 = 419
	Cobol85ParserSD                     = 420
	Cobol85ParserSEARCH                 = 421
	Cobol85ParserSECTION                = 422
	Cobol85ParserSECURE                 = 423
	Cobol85ParserSECURITY               = 424
	Cobol85ParserSEGMENT                = 425
	Cobol85ParserSEGMENT_LIMIT          = 426
	Cobol85ParserSELECT                 = 427
	Cobol85ParserSEND                   = 428
	Cobol85ParserSENTENCE               = 429
	Cobol85ParserSEPARATE               = 430
	Cobol85ParserSEQUENCE               = 431
	Cobol85ParserSEQUENTIAL             = 432
	Cobol85ParserSET                    = 433
	Cobol85ParserSHARED                 = 434
	Cobol85ParserSHAREDBYALL            = 435
	Cobol85ParserSHAREDBYRUNUNIT        = 436
	Cobol85ParserSHARING                = 437
	Cobol85ParserSHIFT_IN               = 438
	Cobol85ParserSHIFT_OUT              = 439
	Cobol85ParserSHORT_DATE             = 440
	Cobol85ParserSIGN                   = 441
	Cobol85ParserSIZE                   = 442
	Cobol85ParserSORT                   = 443
	Cobol85ParserSORT_CONTROL           = 444
	Cobol85ParserSORT_CORE_SIZE         = 445
	Cobol85ParserSORT_FILE_SIZE         = 446
	Cobol85ParserSORT_MERGE             = 447
	Cobol85ParserSORT_MESSAGE           = 448
	Cobol85ParserSORT_MODE_SIZE         = 449
	Cobol85ParserSORT_RETURN            = 450
	Cobol85ParserSOURCE                 = 451
	Cobol85ParserSOURCE_COMPUTER        = 452
	Cobol85ParserSP                     = 453
	Cobol85ParserSPACE                  = 454
	Cobol85ParserSPACES                 = 455
	Cobol85ParserSPECIAL_NAMES          = 456
	Cobol85ParserSTANDARD               = 457
	Cobol85ParserSTANDARD_1             = 458
	Cobol85ParserSTANDARD_2             = 459
	Cobol85ParserSTART                  = 460
	Cobol85ParserSTATUS                 = 461
	Cobol85ParserSTOP                   = 462
	Cobol85ParserSTRING                 = 463
	Cobol85ParserSUB_QUEUE_1            = 464
	Cobol85ParserSUB_QUEUE_2            = 465
	Cobol85ParserSUB_QUEUE_3            = 466
	Cobol85ParserSUBTRACT               = 467
	Cobol85ParserSUM                    = 468
	Cobol85ParserSUPPRESS               = 469
	Cobol85ParserSYMBOL                 = 470
	Cobol85ParserSYMBOLIC               = 471
	Cobol85ParserSYNC                   = 472
	Cobol85ParserSYNCHRONIZED           = 473
	Cobol85ParserTABLE                  = 474
	Cobol85ParserTALLY                  = 475
	Cobol85ParserTALLYING               = 476
	Cobol85ParserTASK                   = 477
	Cobol85ParserTAPE                   = 478
	Cobol85ParserTERMINAL               = 479
	Cobol85ParserTERMINATE              = 480
	Cobol85ParserTEST                   = 481
	Cobol85ParserTEXT                   = 482
	Cobol85ParserTHAN                   = 483
	Cobol85ParserTHEN                   = 484
	Cobol85ParserTHREAD                 = 485
	Cobol85ParserTHREAD_LOCAL           = 486
	Cobol85ParserTHROUGH                = 487
	Cobol85ParserTHRU                   = 488
	Cobol85ParserTIME                   = 489
	Cobol85ParserTIMER                  = 490
	Cobol85ParserTIMES                  = 491
	Cobol85ParserTITLE                  = 492
	Cobol85ParserTO                     = 493
	Cobol85ParserTODAYS_DATE            = 494
	Cobol85ParserTODAYS_NAME            = 495
	Cobol85ParserTOP                    = 496
	Cobol85ParserTRAILING               = 497
	Cobol85ParserTRUE                   = 498
	Cobol85ParserTRUNCATED              = 499
	Cobol85ParserTYPE                   = 500
	Cobol85ParserTYPEDEF                = 501
	Cobol85ParserUNDERLINE              = 502
	Cobol85ParserUNIT                   = 503
	Cobol85ParserUNSTRING               = 504
	Cobol85ParserUNTIL                  = 505
	Cobol85ParserUP                     = 506
	Cobol85ParserUPON                   = 507
	Cobol85ParserUSAGE                  = 508
	Cobol85ParserUSE                    = 509
	Cobol85ParserUSING                  = 510
	Cobol85ParserVALUE                  = 511
	Cobol85ParserVALUES                 = 512
	Cobol85ParserVARYING                = 513
	Cobol85ParserVIRTUAL                = 514
	Cobol85ParserWAIT                   = 515
	Cobol85ParserWHEN                   = 516
	Cobol85ParserWHEN_COMPILED          = 517
	Cobol85ParserWITH                   = 518
	Cobol85ParserWORDS                  = 519
	Cobol85ParserWORKING_STORAGE        = 520
	Cobol85ParserWRITE                  = 521
	Cobol85ParserXOPTS                  = 522
	Cobol85ParserYEAR                   = 523
	Cobol85ParserYYYYMMDD               = 524
	Cobol85ParserYYYYDDD                = 525
	Cobol85ParserZERO                   = 526
	Cobol85ParserZERO_FILL              = 527
	Cobol85ParserZEROS                  = 528
	Cobol85ParserZEROES                 = 529
	Cobol85ParserAMPCHAR                = 530
	Cobol85ParserASTERISKCHAR           = 531
	Cobol85ParserDOUBLEASTERISKCHAR     = 532
	Cobol85ParserCOLONCHAR              = 533
	Cobol85ParserCOMMACHAR              = 534
	Cobol85ParserCOMMENTENTRYTAG        = 535
	Cobol85ParserCOMMENTTAG             = 536
	Cobol85ParserDOLLARCHAR             = 537
	Cobol85ParserDOUBLEQUOTE            = 538
	Cobol85ParserDOT_FS                 = 539
	Cobol85ParserDOT                    = 540
	Cobol85ParserEQUALCHAR              = 541
	Cobol85ParserEXECCICSTAG            = 542
	Cobol85ParserEXECSQLTAG             = 543
	Cobol85ParserEXECSQLIMSTAG          = 544
	Cobol85ParserLESSTHANCHAR           = 545
	Cobol85ParserLESSTHANOREQUAL        = 546
	Cobol85ParserLPARENCHAR             = 547
	Cobol85ParserMINUSCHAR              = 548
	Cobol85ParserMORETHANCHAR           = 549
	Cobol85ParserMORETHANOREQUAL        = 550
	Cobol85ParserPLUSCHAR               = 551
	Cobol85ParserSINGLEQUOTE            = 552
	Cobol85ParserRPARENCHAR             = 553
	Cobol85ParserSLASHCHAR              = 554
	Cobol85ParserNONNUMERICLITERAL      = 555
	Cobol85ParserLEVEL_NUMBER_66        = 556
	Cobol85ParserLEVEL_NUMBER_77        = 557
	Cobol85ParserLEVEL_NUMBER_88        = 558
	Cobol85ParserINTEGERLITERAL         = 559
	Cobol85ParserNUMERICLITERAL         = 560
	Cobol85ParserIDENTIFIER             = 561
	Cobol85ParserNEWLINE                = 562
	Cobol85ParserEXECCICSLINE           = 563
	Cobol85ParserEXECSQLIMSLINE         = 564
	Cobol85ParserEXECSQLLINE            = 565
	Cobol85ParserCOMMENTENTRYLINE       = 566
	Cobol85ParserCOMMENTLINE            = 567
	Cobol85ParserWS                     = 568
	Cobol85ParserSEPARATOR              = 569
)

// Cobol85Parser rules.
const (
	Cobol85ParserRULE_startRule                                     = 0
	Cobol85ParserRULE_compilationUnit                               = 1
	Cobol85ParserRULE_programUnit                                   = 2
	Cobol85ParserRULE_endProgramStatement                           = 3
	Cobol85ParserRULE_compilerOptions                               = 4
	Cobol85ParserRULE_compilerOption                                = 5
	Cobol85ParserRULE_compilerSubOption                             = 6
	Cobol85ParserRULE_identificationDivision                        = 7
	Cobol85ParserRULE_identificationDivisionBody                    = 8
	Cobol85ParserRULE_programIdParagraph                            = 9
	Cobol85ParserRULE_authorParagraph                               = 10
	Cobol85ParserRULE_installationParagraph                         = 11
	Cobol85ParserRULE_dateWrittenParagraph                          = 12
	Cobol85ParserRULE_dateCompiledParagraph                         = 13
	Cobol85ParserRULE_securityParagraph                             = 14
	Cobol85ParserRULE_remarksParagraph                              = 15
	Cobol85ParserRULE_environmentDivision                           = 16
	Cobol85ParserRULE_environmentDivisionBody                       = 17
	Cobol85ParserRULE_configurationSection                          = 18
	Cobol85ParserRULE_configurationSectionParagraph                 = 19
	Cobol85ParserRULE_sourceComputerParagraph                       = 20
	Cobol85ParserRULE_objectComputerParagraph                       = 21
	Cobol85ParserRULE_objectComputerClause                          = 22
	Cobol85ParserRULE_memorySizeClause                              = 23
	Cobol85ParserRULE_diskSizeClause                                = 24
	Cobol85ParserRULE_collatingSequenceClause                       = 25
	Cobol85ParserRULE_collatingSequenceClauseAlphanumeric           = 26
	Cobol85ParserRULE_collatingSequenceClauseNational               = 27
	Cobol85ParserRULE_segmentLimitClause                            = 28
	Cobol85ParserRULE_characterSetClause                            = 29
	Cobol85ParserRULE_specialNamesParagraph                         = 30
	Cobol85ParserRULE_specialNameClause                             = 31
	Cobol85ParserRULE_alphabetClause                                = 32
	Cobol85ParserRULE_alphabetClauseFormat1                         = 33
	Cobol85ParserRULE_alphabetLiterals                              = 34
	Cobol85ParserRULE_alphabetThrough                               = 35
	Cobol85ParserRULE_alphabetAlso                                  = 36
	Cobol85ParserRULE_alphabetClauseFormat2                         = 37
	Cobol85ParserRULE_channelClause                                 = 38
	Cobol85ParserRULE_classClause                                   = 39
	Cobol85ParserRULE_classClauseThrough                            = 40
	Cobol85ParserRULE_classClauseFrom                               = 41
	Cobol85ParserRULE_classClauseTo                                 = 42
	Cobol85ParserRULE_currencySignClause                            = 43
	Cobol85ParserRULE_decimalPointClause                            = 44
	Cobol85ParserRULE_defaultComputationalSignClause                = 45
	Cobol85ParserRULE_defaultDisplaySignClause                      = 46
	Cobol85ParserRULE_environmentSwitchNameClause                   = 47
	Cobol85ParserRULE_environmentSwitchNameSpecialNamesStatusPhrase = 48
	Cobol85ParserRULE_odtClause                                     = 49
	Cobol85ParserRULE_reserveNetworkClause                          = 50
	Cobol85ParserRULE_symbolicCharactersClause                      = 51
	Cobol85ParserRULE_symbolicCharacters                            = 52
	Cobol85ParserRULE_inputOutputSection                            = 53
	Cobol85ParserRULE_inputOutputSectionParagraph                   = 54
	Cobol85ParserRULE_fileControlParagraph                          = 55
	Cobol85ParserRULE_fileControlEntry                              = 56
	Cobol85ParserRULE_selectClause                                  = 57
	Cobol85ParserRULE_fileControlClause                             = 58
	Cobol85ParserRULE_assignClause                                  = 59
	Cobol85ParserRULE_reserveClause                                 = 60
	Cobol85ParserRULE_organizationClause                            = 61
	Cobol85ParserRULE_paddingCharacterClause                        = 62
	Cobol85ParserRULE_recordDelimiterClause                         = 63
	Cobol85ParserRULE_accessModeClause                              = 64
	Cobol85ParserRULE_recordKeyClause                               = 65
	Cobol85ParserRULE_alternateRecordKeyClause                      = 66
	Cobol85ParserRULE_passwordClause                                = 67
	Cobol85ParserRULE_fileStatusClause                              = 68
	Cobol85ParserRULE_relativeKeyClause                             = 69
	Cobol85ParserRULE_ioControlParagraph                            = 70
	Cobol85ParserRULE_ioControlClause                               = 71
	Cobol85ParserRULE_rerunClause                                   = 72
	Cobol85ParserRULE_rerunEveryRecords                             = 73
	Cobol85ParserRULE_rerunEveryOf                                  = 74
	Cobol85ParserRULE_rerunEveryClock                               = 75
	Cobol85ParserRULE_sameClause                                    = 76
	Cobol85ParserRULE_multipleFileClause                            = 77
	Cobol85ParserRULE_multipleFilePosition                          = 78
	Cobol85ParserRULE_commitmentControlClause                       = 79
	Cobol85ParserRULE_dataDivision                                  = 80
	Cobol85ParserRULE_dataDivisionBody                              = 81
	Cobol85ParserRULE_fileSection                                   = 82
	Cobol85ParserRULE_fileDescriptionEntry                          = 83
	Cobol85ParserRULE_fileDescriptionEntryClause                    = 84
	Cobol85ParserRULE_externalClause                                = 85
	Cobol85ParserRULE_globalClause                                  = 86
	Cobol85ParserRULE_blockContainsClause                           = 87
	Cobol85ParserRULE_blockContainsTo                               = 88
	Cobol85ParserRULE_recordContainsClause                          = 89
	Cobol85ParserRULE_recordContainsClauseFormat1                   = 90
	Cobol85ParserRULE_recordContainsClauseFormat2                   = 91
	Cobol85ParserRULE_recordContainsClauseFormat3                   = 92
	Cobol85ParserRULE_recordContainsTo                              = 93
	Cobol85ParserRULE_labelRecordsClause                            = 94
	Cobol85ParserRULE_valueOfClause                                 = 95
	Cobol85ParserRULE_valuePair                                     = 96
	Cobol85ParserRULE_dataRecordsClause                             = 97
	Cobol85ParserRULE_linageClause                                  = 98
	Cobol85ParserRULE_linageAt                                      = 99
	Cobol85ParserRULE_linageFootingAt                               = 100
	Cobol85ParserRULE_linageLinesAtTop                              = 101
	Cobol85ParserRULE_linageLinesAtBottom                           = 102
	Cobol85ParserRULE_recordingModeClause                           = 103
	Cobol85ParserRULE_modeStatement                                 = 104
	Cobol85ParserRULE_codeSetClause                                 = 105
	Cobol85ParserRULE_reportClause                                  = 106
	Cobol85ParserRULE_dataBaseSection                               = 107
	Cobol85ParserRULE_dataBaseSectionEntry                          = 108
	Cobol85ParserRULE_workingStorageSection                         = 109
	Cobol85ParserRULE_linkageSection                                = 110
	Cobol85ParserRULE_communicationSection                          = 111
	Cobol85ParserRULE_communicationDescriptionEntry                 = 112
	Cobol85ParserRULE_communicationDescriptionEntryFormat1          = 113
	Cobol85ParserRULE_communicationDescriptionEntryFormat2          = 114
	Cobol85ParserRULE_communicationDescriptionEntryFormat3          = 115
	Cobol85ParserRULE_destinationCountClause                        = 116
	Cobol85ParserRULE_destinationTableClause                        = 117
	Cobol85ParserRULE_endKeyClause                                  = 118
	Cobol85ParserRULE_errorKeyClause                                = 119
	Cobol85ParserRULE_messageCountClause                            = 120
	Cobol85ParserRULE_messageDateClause                             = 121
	Cobol85ParserRULE_messageTimeClause                             = 122
	Cobol85ParserRULE_statusKeyClause                               = 123
	Cobol85ParserRULE_symbolicDestinationClause                     = 124
	Cobol85ParserRULE_symbolicQueueClause                           = 125
	Cobol85ParserRULE_symbolicSourceClause                          = 126
	Cobol85ParserRULE_symbolicTerminalClause                        = 127
	Cobol85ParserRULE_symbolicSubQueueClause                        = 128
	Cobol85ParserRULE_textLengthClause                              = 129
	Cobol85ParserRULE_localStorageSection                           = 130
	Cobol85ParserRULE_screenSection                                 = 131
	Cobol85ParserRULE_screenDescriptionEntry                        = 132
	Cobol85ParserRULE_screenDescriptionBlankClause                  = 133
	Cobol85ParserRULE_screenDescriptionBellClause                   = 134
	Cobol85ParserRULE_screenDescriptionBlinkClause                  = 135
	Cobol85ParserRULE_screenDescriptionEraseClause                  = 136
	Cobol85ParserRULE_screenDescriptionLightClause                  = 137
	Cobol85ParserRULE_screenDescriptionGridClause                   = 138
	Cobol85ParserRULE_screenDescriptionReverseVideoClause           = 139
	Cobol85ParserRULE_screenDescriptionUnderlineClause              = 140
	Cobol85ParserRULE_screenDescriptionSizeClause                   = 141
	Cobol85ParserRULE_screenDescriptionLineClause                   = 142
	Cobol85ParserRULE_screenDescriptionColumnClause                 = 143
	Cobol85ParserRULE_screenDescriptionForegroundColorClause        = 144
	Cobol85ParserRULE_screenDescriptionBackgroundColorClause        = 145
	Cobol85ParserRULE_screenDescriptionControlClause                = 146
	Cobol85ParserRULE_screenDescriptionValueClause                  = 147
	Cobol85ParserRULE_screenDescriptionPictureClause                = 148
	Cobol85ParserRULE_screenDescriptionFromClause                   = 149
	Cobol85ParserRULE_screenDescriptionToClause                     = 150
	Cobol85ParserRULE_screenDescriptionUsingClause                  = 151
	Cobol85ParserRULE_screenDescriptionUsageClause                  = 152
	Cobol85ParserRULE_screenDescriptionBlankWhenZeroClause          = 153
	Cobol85ParserRULE_screenDescriptionJustifiedClause              = 154
	Cobol85ParserRULE_screenDescriptionSignClause                   = 155
	Cobol85ParserRULE_screenDescriptionAutoClause                   = 156
	Cobol85ParserRULE_screenDescriptionSecureClause                 = 157
	Cobol85ParserRULE_screenDescriptionRequiredClause               = 158
	Cobol85ParserRULE_screenDescriptionPromptClause                 = 159
	Cobol85ParserRULE_screenDescriptionPromptOccursClause           = 160
	Cobol85ParserRULE_screenDescriptionFullClause                   = 161
	Cobol85ParserRULE_screenDescriptionZeroFillClause               = 162
	Cobol85ParserRULE_reportSection                                 = 163
	Cobol85ParserRULE_reportDescription                             = 164
	Cobol85ParserRULE_reportDescriptionEntry                        = 165
	Cobol85ParserRULE_reportDescriptionGlobalClause                 = 166
	Cobol85ParserRULE_reportDescriptionPageLimitClause              = 167
	Cobol85ParserRULE_reportDescriptionHeadingClause                = 168
	Cobol85ParserRULE_reportDescriptionFirstDetailClause            = 169
	Cobol85ParserRULE_reportDescriptionLastDetailClause             = 170
	Cobol85ParserRULE_reportDescriptionFootingClause                = 171
	Cobol85ParserRULE_reportGroupDescriptionEntry                   = 172
	Cobol85ParserRULE_reportGroupDescriptionEntryFormat1            = 173
	Cobol85ParserRULE_reportGroupDescriptionEntryFormat2            = 174
	Cobol85ParserRULE_reportGroupDescriptionEntryFormat3            = 175
	Cobol85ParserRULE_reportGroupBlankWhenZeroClause                = 176
	Cobol85ParserRULE_reportGroupColumnNumberClause                 = 177
	Cobol85ParserRULE_reportGroupIndicateClause                     = 178
	Cobol85ParserRULE_reportGroupJustifiedClause                    = 179
	Cobol85ParserRULE_reportGroupLineNumberClause                   = 180
	Cobol85ParserRULE_reportGroupLineNumberNextPage                 = 181
	Cobol85ParserRULE_reportGroupLineNumberPlus                     = 182
	Cobol85ParserRULE_reportGroupNextGroupClause                    = 183
	Cobol85ParserRULE_reportGroupNextGroupPlus                      = 184
	Cobol85ParserRULE_reportGroupNextGroupNextPage                  = 185
	Cobol85ParserRULE_reportGroupPictureClause                      = 186
	Cobol85ParserRULE_reportGroupResetClause                        = 187
	Cobol85ParserRULE_reportGroupSignClause                         = 188
	Cobol85ParserRULE_reportGroupSourceClause                       = 189
	Cobol85ParserRULE_reportGroupSumClause                          = 190
	Cobol85ParserRULE_reportGroupTypeClause                         = 191
	Cobol85ParserRULE_reportGroupTypeReportHeading                  = 192
	Cobol85ParserRULE_reportGroupTypePageHeading                    = 193
	Cobol85ParserRULE_reportGroupTypeControlHeading                 = 194
	Cobol85ParserRULE_reportGroupTypeDetail                         = 195
	Cobol85ParserRULE_reportGroupTypeControlFooting                 = 196
	Cobol85ParserRULE_reportGroupUsageClause                        = 197
	Cobol85ParserRULE_reportGroupTypePageFooting                    = 198
	Cobol85ParserRULE_reportGroupTypeReportFooting                  = 199
	Cobol85ParserRULE_reportGroupValueClause                        = 200
	Cobol85ParserRULE_programLibrarySection                         = 201
	Cobol85ParserRULE_libraryDescriptionEntry                       = 202
	Cobol85ParserRULE_libraryDescriptionEntryFormat1                = 203
	Cobol85ParserRULE_libraryDescriptionEntryFormat2                = 204
	Cobol85ParserRULE_libraryAttributeClauseFormat1                 = 205
	Cobol85ParserRULE_libraryAttributeClauseFormat2                 = 206
	Cobol85ParserRULE_libraryAttributeFunction                      = 207
	Cobol85ParserRULE_libraryAttributeParameter                     = 208
	Cobol85ParserRULE_libraryAttributeTitle                         = 209
	Cobol85ParserRULE_libraryEntryProcedureClauseFormat1            = 210
	Cobol85ParserRULE_libraryEntryProcedureClauseFormat2            = 211
	Cobol85ParserRULE_libraryEntryProcedureForClause                = 212
	Cobol85ParserRULE_libraryEntryProcedureGivingClause             = 213
	Cobol85ParserRULE_libraryEntryProcedureUsingClause              = 214
	Cobol85ParserRULE_libraryEntryProcedureUsingName                = 215
	Cobol85ParserRULE_libraryEntryProcedureWithClause               = 216
	Cobol85ParserRULE_libraryEntryProcedureWithName                 = 217
	Cobol85ParserRULE_libraryIsCommonClause                         = 218
	Cobol85ParserRULE_libraryIsGlobalClause                         = 219
	Cobol85ParserRULE_dataDescriptionEntry                          = 220
	Cobol85ParserRULE_dataDescriptionEntryFormat1                   = 221
	Cobol85ParserRULE_dataDescriptionEntryFormat2                   = 222
	Cobol85ParserRULE_dataDescriptionEntryFormat3                   = 223
	Cobol85ParserRULE_dataDescriptionEntryExecSql                   = 224
	Cobol85ParserRULE_dataAlignedClause                             = 225
	Cobol85ParserRULE_dataBlankWhenZeroClause                       = 226
	Cobol85ParserRULE_dataCommonOwnLocalClause                      = 227
	Cobol85ParserRULE_dataExternalClause                            = 228
	Cobol85ParserRULE_dataGlobalClause                              = 229
	Cobol85ParserRULE_dataIntegerStringClause                       = 230
	Cobol85ParserRULE_dataJustifiedClause                           = 231
	Cobol85ParserRULE_dataOccursClause                              = 232
	Cobol85ParserRULE_dataOccursTo                                  = 233
	Cobol85ParserRULE_dataOccursSort                                = 234
	Cobol85ParserRULE_dataPictureClause                             = 235
	Cobol85ParserRULE_pictureString                                 = 236
	Cobol85ParserRULE_pictureChars                                  = 237
	Cobol85ParserRULE_pictureCharsKeyword                           = 238
	Cobol85ParserRULE_pictureCardinality                            = 239
	Cobol85ParserRULE_dataReceivedByClause                          = 240
	Cobol85ParserRULE_dataRecordAreaClause                          = 241
	Cobol85ParserRULE_dataRedefinesClause                           = 242
	Cobol85ParserRULE_dataRenamesClause                             = 243
	Cobol85ParserRULE_dataSignClause                                = 244
	Cobol85ParserRULE_dataSynchronizedClause                        = 245
	Cobol85ParserRULE_dataThreadLocalClause                         = 246
	Cobol85ParserRULE_dataTypeClause                                = 247
	Cobol85ParserRULE_dataTypeDefClause                             = 248
	Cobol85ParserRULE_dataUsageClause                               = 249
	Cobol85ParserRULE_dataUsingClause                               = 250
	Cobol85ParserRULE_dataValueClause                               = 251
	Cobol85ParserRULE_dataValueInterval                             = 252
	Cobol85ParserRULE_dataValueIntervalFrom                         = 253
	Cobol85ParserRULE_dataValueIntervalTo                           = 254
	Cobol85ParserRULE_dataWithLowerBoundsClause                     = 255
	Cobol85ParserRULE_procedureDivision                             = 256
	Cobol85ParserRULE_procedureDivisionUsingClause                  = 257
	Cobol85ParserRULE_procedureDivisionGivingClause                 = 258
	Cobol85ParserRULE_procedureDeclaratives                         = 259
	Cobol85ParserRULE_procedureDeclarative                          = 260
	Cobol85ParserRULE_procedureSectionHeader                        = 261
	Cobol85ParserRULE_procedureDivisionBody                         = 262
	Cobol85ParserRULE_procedureSection                              = 263
	Cobol85ParserRULE_paragraphs                                    = 264
	Cobol85ParserRULE_paragraph                                     = 265
	Cobol85ParserRULE_sentence                                      = 266
	Cobol85ParserRULE_statement                                     = 267
	Cobol85ParserRULE_acceptStatement                               = 268
	Cobol85ParserRULE_acceptFromDateStatement                       = 269
	Cobol85ParserRULE_acceptFromMnemonicStatement                   = 270
	Cobol85ParserRULE_acceptFromEscapeKeyStatement                  = 271
	Cobol85ParserRULE_acceptMessageCountStatement                   = 272
	Cobol85ParserRULE_addStatement                                  = 273
	Cobol85ParserRULE_addToStatement                                = 274
	Cobol85ParserRULE_addToGivingStatement                          = 275
	Cobol85ParserRULE_addCorrespondingStatement                     = 276
	Cobol85ParserRULE_addFrom                                       = 277
	Cobol85ParserRULE_addTo                                         = 278
	Cobol85ParserRULE_addGiving                                     = 279
	Cobol85ParserRULE_alteredGoTo                                   = 280
	Cobol85ParserRULE_alterStatement                                = 281
	Cobol85ParserRULE_alterProceedTo                                = 282
	Cobol85ParserRULE_callStatement                                 = 283
	Cobol85ParserRULE_callUsingPhrase                               = 284
	Cobol85ParserRULE_callUsingParameter                            = 285
	Cobol85ParserRULE_callByReferencePhrase                         = 286
	Cobol85ParserRULE_callByReference                               = 287
	Cobol85ParserRULE_callByValuePhrase                             = 288
	Cobol85ParserRULE_callByValue                                   = 289
	Cobol85ParserRULE_callByContentPhrase                           = 290
	Cobol85ParserRULE_callByContent                                 = 291
	Cobol85ParserRULE_callGivingPhrase                              = 292
	Cobol85ParserRULE_cancelStatement                               = 293
	Cobol85ParserRULE_cancelCall                                    = 294
	Cobol85ParserRULE_closeStatement                                = 295
	Cobol85ParserRULE_closeFile                                     = 296
	Cobol85ParserRULE_closeReelUnitStatement                        = 297
	Cobol85ParserRULE_closeRelativeStatement                        = 298
	Cobol85ParserRULE_closePortFileIOStatement                      = 299
	Cobol85ParserRULE_closePortFileIOUsing                          = 300
	Cobol85ParserRULE_closePortFileIOUsingCloseDisposition          = 301
	Cobol85ParserRULE_closePortFileIOUsingAssociatedData            = 302
	Cobol85ParserRULE_closePortFileIOUsingAssociatedDataLength      = 303
	Cobol85ParserRULE_computeStatement                              = 304
	Cobol85ParserRULE_computeStore                                  = 305
	Cobol85ParserRULE_continueStatement                             = 306
	Cobol85ParserRULE_deleteStatement                               = 307
	Cobol85ParserRULE_disableStatement                              = 308
	Cobol85ParserRULE_displayStatement                              = 309
	Cobol85ParserRULE_displayOperand                                = 310
	Cobol85ParserRULE_displayAt                                     = 311
	Cobol85ParserRULE_displayUpon                                   = 312
	Cobol85ParserRULE_displayWith                                   = 313
	Cobol85ParserRULE_divideStatement                               = 314
	Cobol85ParserRULE_divideIntoStatement                           = 315
	Cobol85ParserRULE_divideIntoGivingStatement                     = 316
	Cobol85ParserRULE_divideByGivingStatement                       = 317
	Cobol85ParserRULE_divideGivingPhrase                            = 318
	Cobol85ParserRULE_divideGiving                                  = 319
	Cobol85ParserRULE_divideRemainder                               = 320
	Cobol85ParserRULE_enableStatement                               = 321
	Cobol85ParserRULE_entryStatement                                = 322
	Cobol85ParserRULE_evaluateStatement                             = 323
	Cobol85ParserRULE_evaluateSelect                                = 324
	Cobol85ParserRULE_evaluateAlsoSelect                            = 325
	Cobol85ParserRULE_evaluateWhenPhrase                            = 326
	Cobol85ParserRULE_evaluateWhen                                  = 327
	Cobol85ParserRULE_evaluateCondition                             = 328
	Cobol85ParserRULE_evaluateThrough                               = 329
	Cobol85ParserRULE_evaluateAlsoCondition                         = 330
	Cobol85ParserRULE_evaluateWhenOther                             = 331
	Cobol85ParserRULE_evaluateValue                                 = 332
	Cobol85ParserRULE_execCicsStatement                             = 333
	Cobol85ParserRULE_execSqlStatement                              = 334
	Cobol85ParserRULE_execSqlImsStatement                           = 335
	Cobol85ParserRULE_exhibitStatement                              = 336
	Cobol85ParserRULE_exhibitOperand                                = 337
	Cobol85ParserRULE_exitStatement                                 = 338
	Cobol85ParserRULE_generateStatement                             = 339
	Cobol85ParserRULE_gobackStatement                               = 340
	Cobol85ParserRULE_goToStatement                                 = 341
	Cobol85ParserRULE_goToStatementSimple                           = 342
	Cobol85ParserRULE_goToDependingOnStatement                      = 343
	Cobol85ParserRULE_ifStatement                                   = 344
	Cobol85ParserRULE_ifThen                                        = 345
	Cobol85ParserRULE_ifElse                                        = 346
	Cobol85ParserRULE_initializeStatement                           = 347
	Cobol85ParserRULE_initializeReplacingPhrase                     = 348
	Cobol85ParserRULE_initializeReplacingBy                         = 349
	Cobol85ParserRULE_initiateStatement                             = 350
	Cobol85ParserRULE_inspectStatement                              = 351
	Cobol85ParserRULE_inspectTallyingPhrase                         = 352
	Cobol85ParserRULE_inspectReplacingPhrase                        = 353
	Cobol85ParserRULE_inspectTallyingReplacingPhrase                = 354
	Cobol85ParserRULE_inspectConvertingPhrase                       = 355
	Cobol85ParserRULE_inspectFor                                    = 356
	Cobol85ParserRULE_inspectCharacters                             = 357
	Cobol85ParserRULE_inspectReplacingCharacters                    = 358
	Cobol85ParserRULE_inspectAllLeadings                            = 359
	Cobol85ParserRULE_inspectReplacingAllLeadings                   = 360
	Cobol85ParserRULE_inspectAllLeading                             = 361
	Cobol85ParserRULE_inspectReplacingAllLeading                    = 362
	Cobol85ParserRULE_inspectBy                                     = 363
	Cobol85ParserRULE_inspectTo                                     = 364
	Cobol85ParserRULE_inspectBeforeAfter                            = 365
	Cobol85ParserRULE_mergeStatement                                = 366
	Cobol85ParserRULE_mergeOnKeyClause                              = 367
	Cobol85ParserRULE_mergeCollatingSequencePhrase                  = 368
	Cobol85ParserRULE_mergeCollatingAlphanumeric                    = 369
	Cobol85ParserRULE_mergeCollatingNational                        = 370
	Cobol85ParserRULE_mergeUsing                                    = 371
	Cobol85ParserRULE_mergeOutputProcedurePhrase                    = 372
	Cobol85ParserRULE_mergeOutputThrough                            = 373
	Cobol85ParserRULE_mergeGivingPhrase                             = 374
	Cobol85ParserRULE_mergeGiving                                   = 375
	Cobol85ParserRULE_moveStatement                                 = 376
	Cobol85ParserRULE_moveToStatement                               = 377
	Cobol85ParserRULE_moveToSendingArea                             = 378
	Cobol85ParserRULE_moveCorrespondingToStatement                  = 379
	Cobol85ParserRULE_multiplyStatement                             = 380
	Cobol85ParserRULE_multiplyRegular                               = 381
	Cobol85ParserRULE_multiplyRegularOperand                        = 382
	Cobol85ParserRULE_multiplyGiving                                = 383
	Cobol85ParserRULE_multiplyGivingOperand                         = 384
	Cobol85ParserRULE_multiplyGivingResult                          = 385
	Cobol85ParserRULE_openStatement                                 = 386
	Cobol85ParserRULE_openInputStatement                            = 387
	Cobol85ParserRULE_openInput                                     = 388
	Cobol85ParserRULE_openOutputStatement                           = 389
	Cobol85ParserRULE_openOutput                                    = 390
	Cobol85ParserRULE_openIOStatement                               = 391
	Cobol85ParserRULE_openExtendStatement                           = 392
	Cobol85ParserRULE_performStatement                              = 393
	Cobol85ParserRULE_performInlineStatement                        = 394
	Cobol85ParserRULE_performProcedureStatement                     = 395
	Cobol85ParserRULE_performType                                   = 396
	Cobol85ParserRULE_performTimes                                  = 397
	Cobol85ParserRULE_performUntil                                  = 398
	Cobol85ParserRULE_performVarying                                = 399
	Cobol85ParserRULE_performVaryingClause                          = 400
	Cobol85ParserRULE_performVaryingPhrase                          = 401
	Cobol85ParserRULE_performAfter                                  = 402
	Cobol85ParserRULE_performFrom                                   = 403
	Cobol85ParserRULE_performBy                                     = 404
	Cobol85ParserRULE_performTestClause                             = 405
	Cobol85ParserRULE_purgeStatement                                = 406
	Cobol85ParserRULE_readStatement                                 = 407
	Cobol85ParserRULE_readInto                                      = 408
	Cobol85ParserRULE_readWith                                      = 409
	Cobol85ParserRULE_readKey                                       = 410
	Cobol85ParserRULE_receiveStatement                              = 411
	Cobol85ParserRULE_receiveFromStatement                          = 412
	Cobol85ParserRULE_receiveFrom                                   = 413
	Cobol85ParserRULE_receiveIntoStatement                          = 414
	Cobol85ParserRULE_receiveNoData                                 = 415
	Cobol85ParserRULE_receiveWithData                               = 416
	Cobol85ParserRULE_receiveBefore                                 = 417
	Cobol85ParserRULE_receiveWith                                   = 418
	Cobol85ParserRULE_receiveThread                                 = 419
	Cobol85ParserRULE_receiveSize                                   = 420
	Cobol85ParserRULE_receiveStatus                                 = 421
	Cobol85ParserRULE_releaseStatement                              = 422
	Cobol85ParserRULE_returnStatement                               = 423
	Cobol85ParserRULE_returnInto                                    = 424
	Cobol85ParserRULE_rewriteStatement                              = 425
	Cobol85ParserRULE_rewriteFrom                                   = 426
	Cobol85ParserRULE_searchStatement                               = 427
	Cobol85ParserRULE_searchVarying                                 = 428
	Cobol85ParserRULE_searchWhen                                    = 429
	Cobol85ParserRULE_sendStatement                                 = 430
	Cobol85ParserRULE_sendStatementSync                             = 431
	Cobol85ParserRULE_sendStatementAsync                            = 432
	Cobol85ParserRULE_sendFromPhrase                                = 433
	Cobol85ParserRULE_sendWithPhrase                                = 434
	Cobol85ParserRULE_sendReplacingPhrase                           = 435
	Cobol85ParserRULE_sendAdvancingPhrase                           = 436
	Cobol85ParserRULE_sendAdvancingPage                             = 437
	Cobol85ParserRULE_sendAdvancingLines                            = 438
	Cobol85ParserRULE_sendAdvancingMnemonic                         = 439
	Cobol85ParserRULE_setStatement                                  = 440
	Cobol85ParserRULE_setToStatement                                = 441
	Cobol85ParserRULE_setUpDownByStatement                          = 442
	Cobol85ParserRULE_setTo                                         = 443
	Cobol85ParserRULE_setToValue                                    = 444
	Cobol85ParserRULE_setByValue                                    = 445
	Cobol85ParserRULE_sortStatement                                 = 446
	Cobol85ParserRULE_sortOnKeyClause                               = 447
	Cobol85ParserRULE_sortDuplicatesPhrase                          = 448
	Cobol85ParserRULE_sortCollatingSequencePhrase                   = 449
	Cobol85ParserRULE_sortCollatingAlphanumeric                     = 450
	Cobol85ParserRULE_sortCollatingNational                         = 451
	Cobol85ParserRULE_sortInputProcedurePhrase                      = 452
	Cobol85ParserRULE_sortInputThrough                              = 453
	Cobol85ParserRULE_sortUsing                                     = 454
	Cobol85ParserRULE_sortOutputProcedurePhrase                     = 455
	Cobol85ParserRULE_sortOutputThrough                             = 456
	Cobol85ParserRULE_sortGivingPhrase                              = 457
	Cobol85ParserRULE_sortGiving                                    = 458
	Cobol85ParserRULE_startStatement                                = 459
	Cobol85ParserRULE_startKey                                      = 460
	Cobol85ParserRULE_stopStatement                                 = 461
	Cobol85ParserRULE_stringStatement                               = 462
	Cobol85ParserRULE_stringSendingPhrase                           = 463
	Cobol85ParserRULE_stringSending                                 = 464
	Cobol85ParserRULE_stringDelimitedByPhrase                       = 465
	Cobol85ParserRULE_stringForPhrase                               = 466
	Cobol85ParserRULE_stringIntoPhrase                              = 467
	Cobol85ParserRULE_stringWithPointerPhrase                       = 468
	Cobol85ParserRULE_subtractStatement                             = 469
	Cobol85ParserRULE_subtractFromStatement                         = 470
	Cobol85ParserRULE_subtractFromGivingStatement                   = 471
	Cobol85ParserRULE_subtractCorrespondingStatement                = 472
	Cobol85ParserRULE_subtractSubtrahend                            = 473
	Cobol85ParserRULE_subtractMinuend                               = 474
	Cobol85ParserRULE_subtractMinuendGiving                         = 475
	Cobol85ParserRULE_subtractGiving                                = 476
	Cobol85ParserRULE_subtractMinuendCorresponding                  = 477
	Cobol85ParserRULE_terminateStatement                            = 478
	Cobol85ParserRULE_unstringStatement                             = 479
	Cobol85ParserRULE_unstringSendingPhrase                         = 480
	Cobol85ParserRULE_unstringDelimitedByPhrase                     = 481
	Cobol85ParserRULE_unstringOrAllPhrase                           = 482
	Cobol85ParserRULE_unstringIntoPhrase                            = 483
	Cobol85ParserRULE_unstringInto                                  = 484
	Cobol85ParserRULE_unstringDelimiterIn                           = 485
	Cobol85ParserRULE_unstringCountIn                               = 486
	Cobol85ParserRULE_unstringWithPointerPhrase                     = 487
	Cobol85ParserRULE_unstringTallyingPhrase                        = 488
	Cobol85ParserRULE_useStatement                                  = 489
	Cobol85ParserRULE_useAfterClause                                = 490
	Cobol85ParserRULE_useAfterOn                                    = 491
	Cobol85ParserRULE_useDebugClause                                = 492
	Cobol85ParserRULE_useDebugOn                                    = 493
	Cobol85ParserRULE_writeStatement                                = 494
	Cobol85ParserRULE_writeFromPhrase                               = 495
	Cobol85ParserRULE_writeAdvancingPhrase                          = 496
	Cobol85ParserRULE_writeAdvancingPage                            = 497
	Cobol85ParserRULE_writeAdvancingLines                           = 498
	Cobol85ParserRULE_writeAdvancingMnemonic                        = 499
	Cobol85ParserRULE_writeAtEndOfPagePhrase                        = 500
	Cobol85ParserRULE_writeNotAtEndOfPagePhrase                     = 501
	Cobol85ParserRULE_atEndPhrase                                   = 502
	Cobol85ParserRULE_notAtEndPhrase                                = 503
	Cobol85ParserRULE_invalidKeyPhrase                              = 504
	Cobol85ParserRULE_notInvalidKeyPhrase                           = 505
	Cobol85ParserRULE_onOverflowPhrase                              = 506
	Cobol85ParserRULE_notOnOverflowPhrase                           = 507
	Cobol85ParserRULE_onSizeErrorPhrase                             = 508
	Cobol85ParserRULE_notOnSizeErrorPhrase                          = 509
	Cobol85ParserRULE_onExceptionClause                             = 510
	Cobol85ParserRULE_notOnExceptionClause                          = 511
	Cobol85ParserRULE_arithmeticExpression                          = 512
	Cobol85ParserRULE_plusMinus                                     = 513
	Cobol85ParserRULE_multDivs                                      = 514
	Cobol85ParserRULE_multDiv                                       = 515
	Cobol85ParserRULE_powers                                        = 516
	Cobol85ParserRULE_power                                         = 517
	Cobol85ParserRULE_basis                                         = 518
	Cobol85ParserRULE_condition                                     = 519
	Cobol85ParserRULE_andOrCondition                                = 520
	Cobol85ParserRULE_combinableCondition                           = 521
	Cobol85ParserRULE_simpleCondition                               = 522
	Cobol85ParserRULE_classCondition                                = 523
	Cobol85ParserRULE_conditionNameReference                        = 524
	Cobol85ParserRULE_conditionNameSubscriptReference               = 525
	Cobol85ParserRULE_relationCondition                             = 526
	Cobol85ParserRULE_relationSignCondition                         = 527
	Cobol85ParserRULE_relationArithmeticComparison                  = 528
	Cobol85ParserRULE_relationCombinedComparison                    = 529
	Cobol85ParserRULE_relationCombinedCondition                     = 530
	Cobol85ParserRULE_relationalOperator                            = 531
	Cobol85ParserRULE_abbreviation                                  = 532
	Cobol85ParserRULE_identifier                                    = 533
	Cobol85ParserRULE_tableCall                                     = 534
	Cobol85ParserRULE_functionCall                                  = 535
	Cobol85ParserRULE_referenceModifier                             = 536
	Cobol85ParserRULE_characterPosition                             = 537
	Cobol85ParserRULE_length                                        = 538
	Cobol85ParserRULE_subscript                                     = 539
	Cobol85ParserRULE_argument                                      = 540
	Cobol85ParserRULE_qualifiedDataName                             = 541
	Cobol85ParserRULE_qualifiedDataNameFormat1                      = 542
	Cobol85ParserRULE_qualifiedDataNameFormat2                      = 543
	Cobol85ParserRULE_qualifiedDataNameFormat3                      = 544
	Cobol85ParserRULE_qualifiedDataNameFormat4                      = 545
	Cobol85ParserRULE_qualifiedInData                               = 546
	Cobol85ParserRULE_inData                                        = 547
	Cobol85ParserRULE_inFile                                        = 548
	Cobol85ParserRULE_inMnemonic                                    = 549
	Cobol85ParserRULE_inSection                                     = 550
	Cobol85ParserRULE_inLibrary                                     = 551
	Cobol85ParserRULE_inTable                                       = 552
	Cobol85ParserRULE_alphabetName                                  = 553
	Cobol85ParserRULE_assignmentName                                = 554
	Cobol85ParserRULE_basisName                                     = 555
	Cobol85ParserRULE_cdName                                        = 556
	Cobol85ParserRULE_className                                     = 557
	Cobol85ParserRULE_computerName                                  = 558
	Cobol85ParserRULE_conditionName                                 = 559
	Cobol85ParserRULE_dataName                                      = 560
	Cobol85ParserRULE_dataDescName                                  = 561
	Cobol85ParserRULE_environmentName                               = 562
	Cobol85ParserRULE_fileName                                      = 563
	Cobol85ParserRULE_functionName                                  = 564
	Cobol85ParserRULE_indexName                                     = 565
	Cobol85ParserRULE_languageName                                  = 566
	Cobol85ParserRULE_libraryName                                   = 567
	Cobol85ParserRULE_localName                                     = 568
	Cobol85ParserRULE_mnemonicName                                  = 569
	Cobol85ParserRULE_paragraphName                                 = 570
	Cobol85ParserRULE_procedureName                                 = 571
	Cobol85ParserRULE_programName                                   = 572
	Cobol85ParserRULE_recordName                                    = 573
	Cobol85ParserRULE_reportName                                    = 574
	Cobol85ParserRULE_routineName                                   = 575
	Cobol85ParserRULE_screenName                                    = 576
	Cobol85ParserRULE_sectionName                                   = 577
	Cobol85ParserRULE_systemName                                    = 578
	Cobol85ParserRULE_symbolicCharacter                             = 579
	Cobol85ParserRULE_textName                                      = 580
	Cobol85ParserRULE_cobolWord                                     = 581
	Cobol85ParserRULE_literal                                       = 582
	Cobol85ParserRULE_booleanLiteral                                = 583
	Cobol85ParserRULE_numericLiteral                                = 584
	Cobol85ParserRULE_integerLiteral                                = 585
	Cobol85ParserRULE_cicsDfhRespLiteral                            = 586
	Cobol85ParserRULE_cicsDfhValueLiteral                           = 587
	Cobol85ParserRULE_figurativeConstant                            = 588
	Cobol85ParserRULE_specialRegister                               = 589
	Cobol85ParserRULE_commentEntry                                  = 590
)

// IStartRuleContext is an interface to support dynamic dispatch.
type IStartRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartRuleContext differentiates from other interfaces.
	IsStartRuleContext()
}

type StartRuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartRuleContext() *StartRuleContext {
	var p = new(StartRuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_startRule
	return p
}

func (*StartRuleContext) IsStartRuleContext() {}

func NewStartRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartRuleContext {
	var p = new(StartRuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_startRule

	return p
}

func (s *StartRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *StartRuleContext) CompilationUnit() ICompilationUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompilationUnitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompilationUnitContext)
}

func (s *StartRuleContext) EOF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOF, 0)
}

func (s *StartRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStartRule(s)
	}
}

func (s *StartRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStartRule(s)
	}
}

func (s *StartRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStartRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StartRule() (localctx IStartRuleContext) {
	localctx = NewStartRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, Cobol85ParserRULE_startRule)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1182)
		p.CompilationUnit()
	}
	{
		p.SetState(1183)
		p.Match(Cobol85ParserEOF)
	}

	return localctx
}

// ICompilationUnitContext is an interface to support dynamic dispatch.
type ICompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompilationUnitContext differentiates from other interfaces.
	IsCompilationUnitContext()
}

type CompilationUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilationUnitContext() *CompilationUnitContext {
	var p = new(CompilationUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_compilationUnit
	return p
}

func (*CompilationUnitContext) IsCompilationUnitContext() {}

func NewCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilationUnitContext {
	var p = new(CompilationUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_compilationUnit

	return p
}

func (s *CompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilationUnitContext) AllProgramUnit() []IProgramUnitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProgramUnitContext)(nil)).Elem())
	var tst = make([]IProgramUnitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProgramUnitContext)
		}
	}

	return tst
}

func (s *CompilationUnitContext) ProgramUnit(i int) IProgramUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramUnitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProgramUnitContext)
}

func (s *CompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilationUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCompilationUnit(s)
	}
}

func (s *CompilationUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCompilationUnit(s)
	}
}

func (s *CompilationUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCompilationUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CompilationUnit() (localctx ICompilationUnitContext) {
	localctx = NewCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, Cobol85ParserRULE_compilationUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1186)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserID || _la == Cobol85ParserIDENTIFICATION || _la == Cobol85ParserPROCESS {
		{
			p.SetState(1185)
			p.ProgramUnit()
		}

		p.SetState(1188)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProgramUnitContext is an interface to support dynamic dispatch.
type IProgramUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramUnitContext differentiates from other interfaces.
	IsProgramUnitContext()
}

type ProgramUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramUnitContext() *ProgramUnitContext {
	var p = new(ProgramUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_programUnit
	return p
}

func (*ProgramUnitContext) IsProgramUnitContext() {}

func NewProgramUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramUnitContext {
	var p = new(ProgramUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_programUnit

	return p
}

func (s *ProgramUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramUnitContext) IdentificationDivision() IIdentificationDivisionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentificationDivisionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentificationDivisionContext)
}

func (s *ProgramUnitContext) CompilerOptions() ICompilerOptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompilerOptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompilerOptionsContext)
}

func (s *ProgramUnitContext) EnvironmentDivision() IEnvironmentDivisionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnvironmentDivisionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnvironmentDivisionContext)
}

func (s *ProgramUnitContext) DataDivision() IDataDivisionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDivisionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDivisionContext)
}

func (s *ProgramUnitContext) ProcedureDivision() IProcedureDivisionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDivisionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionContext)
}

func (s *ProgramUnitContext) AllProgramUnit() []IProgramUnitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProgramUnitContext)(nil)).Elem())
	var tst = make([]IProgramUnitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProgramUnitContext)
		}
	}

	return tst
}

func (s *ProgramUnitContext) ProgramUnit(i int) IProgramUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramUnitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProgramUnitContext)
}

func (s *ProgramUnitContext) EndProgramStatement() IEndProgramStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndProgramStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndProgramStatementContext)
}

func (s *ProgramUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProgramUnit(s)
	}
}

func (s *ProgramUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProgramUnit(s)
	}
}

func (s *ProgramUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProgramUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProgramUnit() (localctx IProgramUnitContext) {
	localctx = NewProgramUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, Cobol85ParserRULE_programUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1191)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPROCESS {
		{
			p.SetState(1190)
			p.CompilerOptions()
		}

	}
	{
		p.SetState(1193)
		p.IdentificationDivision()
	}
	p.SetState(1195)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserENVIRONMENT {
		{
			p.SetState(1194)
			p.EnvironmentDivision()
		}

	}
	p.SetState(1198)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDATA {
		{
			p.SetState(1197)
			p.DataDivision()
		}

	}
	p.SetState(1201)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPROCEDURE {
		{
			p.SetState(1200)
			p.ProcedureDivision()
		}

	}
	p.SetState(1206)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1203)
				p.ProgramUnit()
			}

		}
		p.SetState(1208)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())
	}
	p.SetState(1210)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1209)
			p.EndProgramStatement()
		}

	}

	return localctx
}

// IEndProgramStatementContext is an interface to support dynamic dispatch.
type IEndProgramStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndProgramStatementContext differentiates from other interfaces.
	IsEndProgramStatementContext()
}

type EndProgramStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndProgramStatementContext() *EndProgramStatementContext {
	var p = new(EndProgramStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_endProgramStatement
	return p
}

func (*EndProgramStatementContext) IsEndProgramStatementContext() {}

func NewEndProgramStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndProgramStatementContext {
	var p = new(EndProgramStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_endProgramStatement

	return p
}

func (s *EndProgramStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EndProgramStatementContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *EndProgramStatementContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM, 0)
}

func (s *EndProgramStatementContext) ProgramName() IProgramNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgramNameContext)
}

func (s *EndProgramStatementContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *EndProgramStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndProgramStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndProgramStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEndProgramStatement(s)
	}
}

func (s *EndProgramStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEndProgramStatement(s)
	}
}

func (s *EndProgramStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEndProgramStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EndProgramStatement() (localctx IEndProgramStatementContext) {
	localctx = NewEndProgramStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, Cobol85ParserRULE_endProgramStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1212)
		p.Match(Cobol85ParserEND)
	}
	{
		p.SetState(1213)
		p.Match(Cobol85ParserPROGRAM)
	}
	{
		p.SetState(1214)
		p.ProgramName()
	}
	{
		p.SetState(1215)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// ICompilerOptionsContext is an interface to support dynamic dispatch.
type ICompilerOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompilerOptionsContext differentiates from other interfaces.
	IsCompilerOptionsContext()
}

type CompilerOptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilerOptionsContext() *CompilerOptionsContext {
	var p = new(CompilerOptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_compilerOptions
	return p
}

func (*CompilerOptionsContext) IsCompilerOptionsContext() {}

func NewCompilerOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilerOptionsContext {
	var p = new(CompilerOptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_compilerOptions

	return p
}

func (s *CompilerOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilerOptionsContext) AllPROCESS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserPROCESS)
}

func (s *CompilerOptionsContext) PROCESS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCESS, i)
}

func (s *CompilerOptionsContext) AllCompilerOption() []ICompilerOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICompilerOptionContext)(nil)).Elem())
	var tst = make([]ICompilerOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICompilerOptionContext)
		}
	}

	return tst
}

func (s *CompilerOptionsContext) CompilerOption(i int) ICompilerOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompilerOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICompilerOptionContext)
}

func (s *CompilerOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilerOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilerOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCompilerOptions(s)
	}
}

func (s *CompilerOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCompilerOptions(s)
	}
}

func (s *CompilerOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCompilerOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CompilerOptions() (localctx ICompilerOptionsContext) {
	localctx = NewCompilerOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, Cobol85ParserRULE_compilerOptions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1223)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserPROCESS {
		{
			p.SetState(1217)
			p.Match(Cobol85ParserPROCESS)
		}
		p.SetState(1219)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == Cobol85ParserAPOST || _la == Cobol85ParserARITH || _la == Cobol85ParserCODEPAGE || _la == Cobol85ParserDBCS || _la == Cobol85ParserLIB || (((_la-314)&-(0x1f+1)) == 0 && ((1<<uint((_la-314)))&((1<<(Cobol85ParserNOSEQ-314))|(1<<(Cobol85ParserNOSTDTRUNC-314))|(1<<(Cobol85ParserOPTIMIZE-314)))) != 0) || _la == Cobol85ParserXOPTS {
			{
				p.SetState(1218)
				p.CompilerOption()
			}

			p.SetState(1221)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(1225)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICompilerOptionContext is an interface to support dynamic dispatch.
type ICompilerOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompilerOptionContext differentiates from other interfaces.
	IsCompilerOptionContext()
}

type CompilerOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilerOptionContext() *CompilerOptionContext {
	var p = new(CompilerOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_compilerOption
	return p
}

func (*CompilerOptionContext) IsCompilerOptionContext() {}

func NewCompilerOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilerOptionContext {
	var p = new(CompilerOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_compilerOption

	return p
}

func (s *CompilerOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilerOptionContext) APOST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAPOST, 0)
}

func (s *CompilerOptionContext) ARITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARITH, 0)
}

func (s *CompilerOptionContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *CompilerOptionContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTEND, 0)
}

func (s *CompilerOptionContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *CompilerOptionContext) CODEPAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCODEPAGE, 0)
}

func (s *CompilerOptionContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CompilerOptionContext) DBCS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDBCS, 0)
}

func (s *CompilerOptionContext) LIB() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIB, 0)
}

func (s *CompilerOptionContext) NOSEQ() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOSEQ, 0)
}

func (s *CompilerOptionContext) NOSTDTRUNC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOSTDTRUNC, 0)
}

func (s *CompilerOptionContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOPTIMIZE, 0)
}

func (s *CompilerOptionContext) FULL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFULL, 0)
}

func (s *CompilerOptionContext) XOPTS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserXOPTS, 0)
}

func (s *CompilerOptionContext) AllCompilerSubOption() []ICompilerSubOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICompilerSubOptionContext)(nil)).Elem())
	var tst = make([]ICompilerSubOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICompilerSubOptionContext)
		}
	}

	return tst
}

func (s *CompilerOptionContext) CompilerSubOption(i int) ICompilerSubOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompilerSubOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICompilerSubOptionContext)
}

func (s *CompilerOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilerOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilerOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCompilerOption(s)
	}
}

func (s *CompilerOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCompilerOption(s)
	}
}

func (s *CompilerOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCompilerOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CompilerOption() (localctx ICompilerOptionContext) {
	localctx = NewCompilerOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, Cobol85ParserRULE_compilerOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1254)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserAPOST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1227)
			p.Match(Cobol85ParserAPOST)
		}

	case Cobol85ParserARITH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1228)
			p.Match(Cobol85ParserARITH)
		}
		{
			p.SetState(1229)
			p.Match(Cobol85ParserLPARENCHAR)
		}
		{
			p.SetState(1230)
			p.Match(Cobol85ParserEXTEND)
		}
		{
			p.SetState(1231)
			p.Match(Cobol85ParserRPARENCHAR)
		}

	case Cobol85ParserCODEPAGE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1232)
			p.Match(Cobol85ParserCODEPAGE)
		}
		{
			p.SetState(1233)
			p.Match(Cobol85ParserLPARENCHAR)
		}
		{
			p.SetState(1234)
			p.Literal()
		}
		{
			p.SetState(1235)
			p.Match(Cobol85ParserRPARENCHAR)
		}

	case Cobol85ParserDBCS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1237)
			p.Match(Cobol85ParserDBCS)
		}

	case Cobol85ParserLIB:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1238)
			p.Match(Cobol85ParserLIB)
		}

	case Cobol85ParserNOSEQ:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1239)
			p.Match(Cobol85ParserNOSEQ)
		}

	case Cobol85ParserNOSTDTRUNC:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1240)
			p.Match(Cobol85ParserNOSTDTRUNC)
		}

	case Cobol85ParserOPTIMIZE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1241)
			p.Match(Cobol85ParserOPTIMIZE)
		}
		{
			p.SetState(1242)
			p.Match(Cobol85ParserLPARENCHAR)
		}
		{
			p.SetState(1243)
			p.Match(Cobol85ParserFULL)
		}
		{
			p.SetState(1244)
			p.Match(Cobol85ParserRPARENCHAR)
		}

	case Cobol85ParserXOPTS:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1245)
			p.Match(Cobol85ParserXOPTS)
		}
		{
			p.SetState(1246)
			p.Match(Cobol85ParserLPARENCHAR)
		}
		p.SetState(1248)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == Cobol85ParserAPOST || _la == Cobol85ParserSP {
			{
				p.SetState(1247)
				p.CompilerSubOption()
			}

			p.SetState(1250)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1252)
			p.Match(Cobol85ParserRPARENCHAR)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICompilerSubOptionContext is an interface to support dynamic dispatch.
type ICompilerSubOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompilerSubOptionContext differentiates from other interfaces.
	IsCompilerSubOptionContext()
}

type CompilerSubOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilerSubOptionContext() *CompilerSubOptionContext {
	var p = new(CompilerSubOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_compilerSubOption
	return p
}

func (*CompilerSubOptionContext) IsCompilerSubOptionContext() {}

func NewCompilerSubOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilerSubOptionContext {
	var p = new(CompilerSubOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_compilerSubOption

	return p
}

func (s *CompilerSubOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilerSubOptionContext) SP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSP, 0)
}

func (s *CompilerSubOptionContext) APOST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAPOST, 0)
}

func (s *CompilerSubOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilerSubOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilerSubOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCompilerSubOption(s)
	}
}

func (s *CompilerSubOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCompilerSubOption(s)
	}
}

func (s *CompilerSubOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCompilerSubOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CompilerSubOption() (localctx ICompilerSubOptionContext) {
	localctx = NewCompilerSubOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, Cobol85ParserRULE_compilerSubOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1256)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserAPOST || _la == Cobol85ParserSP) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IIdentificationDivisionContext is an interface to support dynamic dispatch.
type IIdentificationDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentificationDivisionContext differentiates from other interfaces.
	IsIdentificationDivisionContext()
}

type IdentificationDivisionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentificationDivisionContext() *IdentificationDivisionContext {
	var p = new(IdentificationDivisionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_identificationDivision
	return p
}

func (*IdentificationDivisionContext) IsIdentificationDivisionContext() {}

func NewIdentificationDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentificationDivisionContext {
	var p = new(IdentificationDivisionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_identificationDivision

	return p
}

func (s *IdentificationDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentificationDivisionContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDIVISION, 0)
}

func (s *IdentificationDivisionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *IdentificationDivisionContext) ProgramIdParagraph() IProgramIdParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramIdParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgramIdParagraphContext)
}

func (s *IdentificationDivisionContext) IDENTIFICATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIDENTIFICATION, 0)
}

func (s *IdentificationDivisionContext) ID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserID, 0)
}

func (s *IdentificationDivisionContext) AllIdentificationDivisionBody() []IIdentificationDivisionBodyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentificationDivisionBodyContext)(nil)).Elem())
	var tst = make([]IIdentificationDivisionBodyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentificationDivisionBodyContext)
		}
	}

	return tst
}

func (s *IdentificationDivisionContext) IdentificationDivisionBody(i int) IIdentificationDivisionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentificationDivisionBodyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentificationDivisionBodyContext)
}

func (s *IdentificationDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentificationDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentificationDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIdentificationDivision(s)
	}
}

func (s *IdentificationDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIdentificationDivision(s)
	}
}

func (s *IdentificationDivisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIdentificationDivision(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IdentificationDivision() (localctx IIdentificationDivisionContext) {
	localctx = NewIdentificationDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, Cobol85ParserRULE_identificationDivision)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1258)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserID || _la == Cobol85ParserIDENTIFICATION) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1259)
		p.Match(Cobol85ParserDIVISION)
	}
	{
		p.SetState(1260)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(1261)
		p.ProgramIdParagraph()
	}
	p.SetState(1265)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAUTHOR || _la == Cobol85ParserDATE_COMPILED || _la == Cobol85ParserDATE_WRITTEN || _la == Cobol85ParserINSTALLATION || _la == Cobol85ParserREMARKS || _la == Cobol85ParserSECURITY {
		{
			p.SetState(1262)
			p.IdentificationDivisionBody()
		}

		p.SetState(1267)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIdentificationDivisionBodyContext is an interface to support dynamic dispatch.
type IIdentificationDivisionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentificationDivisionBodyContext differentiates from other interfaces.
	IsIdentificationDivisionBodyContext()
}

type IdentificationDivisionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentificationDivisionBodyContext() *IdentificationDivisionBodyContext {
	var p = new(IdentificationDivisionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_identificationDivisionBody
	return p
}

func (*IdentificationDivisionBodyContext) IsIdentificationDivisionBodyContext() {}

func NewIdentificationDivisionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentificationDivisionBodyContext {
	var p = new(IdentificationDivisionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_identificationDivisionBody

	return p
}

func (s *IdentificationDivisionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentificationDivisionBodyContext) AuthorParagraph() IAuthorParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAuthorParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAuthorParagraphContext)
}

func (s *IdentificationDivisionBodyContext) InstallationParagraph() IInstallationParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstallationParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstallationParagraphContext)
}

func (s *IdentificationDivisionBodyContext) DateWrittenParagraph() IDateWrittenParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDateWrittenParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDateWrittenParagraphContext)
}

func (s *IdentificationDivisionBodyContext) DateCompiledParagraph() IDateCompiledParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDateCompiledParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDateCompiledParagraphContext)
}

func (s *IdentificationDivisionBodyContext) SecurityParagraph() ISecurityParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISecurityParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISecurityParagraphContext)
}

func (s *IdentificationDivisionBodyContext) RemarksParagraph() IRemarksParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRemarksParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRemarksParagraphContext)
}

func (s *IdentificationDivisionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentificationDivisionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentificationDivisionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIdentificationDivisionBody(s)
	}
}

func (s *IdentificationDivisionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIdentificationDivisionBody(s)
	}
}

func (s *IdentificationDivisionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIdentificationDivisionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IdentificationDivisionBody() (localctx IIdentificationDivisionBodyContext) {
	localctx = NewIdentificationDivisionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, Cobol85ParserRULE_identificationDivisionBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1274)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserAUTHOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1268)
			p.AuthorParagraph()
		}

	case Cobol85ParserINSTALLATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1269)
			p.InstallationParagraph()
		}

	case Cobol85ParserDATE_WRITTEN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1270)
			p.DateWrittenParagraph()
		}

	case Cobol85ParserDATE_COMPILED:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1271)
			p.DateCompiledParagraph()
		}

	case Cobol85ParserSECURITY:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1272)
			p.SecurityParagraph()
		}

	case Cobol85ParserREMARKS:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1273)
			p.RemarksParagraph()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProgramIdParagraphContext is an interface to support dynamic dispatch.
type IProgramIdParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramIdParagraphContext differentiates from other interfaces.
	IsProgramIdParagraphContext()
}

type ProgramIdParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramIdParagraphContext() *ProgramIdParagraphContext {
	var p = new(ProgramIdParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_programIdParagraph
	return p
}

func (*ProgramIdParagraphContext) IsProgramIdParagraphContext() {}

func NewProgramIdParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramIdParagraphContext {
	var p = new(ProgramIdParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_programIdParagraph

	return p
}

func (s *ProgramIdParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramIdParagraphContext) PROGRAM_ID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM_ID, 0)
}

func (s *ProgramIdParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *ProgramIdParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *ProgramIdParagraphContext) ProgramName() IProgramNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgramNameContext)
}

func (s *ProgramIdParagraphContext) COMMON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMON, 0)
}

func (s *ProgramIdParagraphContext) INITIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIAL, 0)
}

func (s *ProgramIdParagraphContext) LIBRARY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBRARY, 0)
}

func (s *ProgramIdParagraphContext) DEFINITION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFINITION, 0)
}

func (s *ProgramIdParagraphContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ProgramIdParagraphContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM, 0)
}

func (s *ProgramIdParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramIdParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramIdParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProgramIdParagraph(s)
	}
}

func (s *ProgramIdParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProgramIdParagraph(s)
	}
}

func (s *ProgramIdParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProgramIdParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProgramIdParagraph() (localctx IProgramIdParagraphContext) {
	localctx = NewProgramIdParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, Cobol85ParserRULE_programIdParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1276)
		p.Match(Cobol85ParserPROGRAM_ID)
	}
	{
		p.SetState(1277)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(1278)
		p.ProgramName()
	}
	p.SetState(1286)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMON || _la == Cobol85ParserDEFINITION || (((_la-246)&-(0x1f+1)) == 0 && ((1<<uint((_la-246)))&((1<<(Cobol85ParserINITIAL-246))|(1<<(Cobol85ParserIS-246))|(1<<(Cobol85ParserLIBRARY-246)))) != 0) {
		p.SetState(1280)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1279)
				p.Match(Cobol85ParserIS)
			}

		}
		p.SetState(1282)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCOMMON || _la == Cobol85ParserDEFINITION || _la == Cobol85ParserINITIAL || _la == Cobol85ParserLIBRARY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		p.SetState(1284)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserPROGRAM {
			{
				p.SetState(1283)
				p.Match(Cobol85ParserPROGRAM)
			}

		}

	}
	{
		p.SetState(1288)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IAuthorParagraphContext is an interface to support dynamic dispatch.
type IAuthorParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAuthorParagraphContext differentiates from other interfaces.
	IsAuthorParagraphContext()
}

type AuthorParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthorParagraphContext() *AuthorParagraphContext {
	var p = new(AuthorParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_authorParagraph
	return p
}

func (*AuthorParagraphContext) IsAuthorParagraphContext() {}

func NewAuthorParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthorParagraphContext {
	var p = new(AuthorParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_authorParagraph

	return p
}

func (s *AuthorParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthorParagraphContext) AUTHOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAUTHOR, 0)
}

func (s *AuthorParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *AuthorParagraphContext) CommentEntry() ICommentEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentEntryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *AuthorParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthorParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AuthorParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAuthorParagraph(s)
	}
}

func (s *AuthorParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAuthorParagraph(s)
	}
}

func (s *AuthorParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAuthorParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AuthorParagraph() (localctx IAuthorParagraphContext) {
	localctx = NewAuthorParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, Cobol85ParserRULE_authorParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1290)
		p.Match(Cobol85ParserAUTHOR)
	}
	{
		p.SetState(1291)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1293)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1292)
			p.CommentEntry()
		}

	}

	return localctx
}

// IInstallationParagraphContext is an interface to support dynamic dispatch.
type IInstallationParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstallationParagraphContext differentiates from other interfaces.
	IsInstallationParagraphContext()
}

type InstallationParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstallationParagraphContext() *InstallationParagraphContext {
	var p = new(InstallationParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_installationParagraph
	return p
}

func (*InstallationParagraphContext) IsInstallationParagraphContext() {}

func NewInstallationParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstallationParagraphContext {
	var p = new(InstallationParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_installationParagraph

	return p
}

func (s *InstallationParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *InstallationParagraphContext) INSTALLATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINSTALLATION, 0)
}

func (s *InstallationParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *InstallationParagraphContext) CommentEntry() ICommentEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentEntryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *InstallationParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstallationParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstallationParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInstallationParagraph(s)
	}
}

func (s *InstallationParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInstallationParagraph(s)
	}
}

func (s *InstallationParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInstallationParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InstallationParagraph() (localctx IInstallationParagraphContext) {
	localctx = NewInstallationParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, Cobol85ParserRULE_installationParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1295)
		p.Match(Cobol85ParserINSTALLATION)
	}
	{
		p.SetState(1296)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1298)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1297)
			p.CommentEntry()
		}

	}

	return localctx
}

// IDateWrittenParagraphContext is an interface to support dynamic dispatch.
type IDateWrittenParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDateWrittenParagraphContext differentiates from other interfaces.
	IsDateWrittenParagraphContext()
}

type DateWrittenParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateWrittenParagraphContext() *DateWrittenParagraphContext {
	var p = new(DateWrittenParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dateWrittenParagraph
	return p
}

func (*DateWrittenParagraphContext) IsDateWrittenParagraphContext() {}

func NewDateWrittenParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateWrittenParagraphContext {
	var p = new(DateWrittenParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dateWrittenParagraph

	return p
}

func (s *DateWrittenParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *DateWrittenParagraphContext) DATE_WRITTEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE_WRITTEN, 0)
}

func (s *DateWrittenParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DateWrittenParagraphContext) CommentEntry() ICommentEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentEntryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *DateWrittenParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateWrittenParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateWrittenParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDateWrittenParagraph(s)
	}
}

func (s *DateWrittenParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDateWrittenParagraph(s)
	}
}

func (s *DateWrittenParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDateWrittenParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DateWrittenParagraph() (localctx IDateWrittenParagraphContext) {
	localctx = NewDateWrittenParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, Cobol85ParserRULE_dateWrittenParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1300)
		p.Match(Cobol85ParserDATE_WRITTEN)
	}
	{
		p.SetState(1301)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1303)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1302)
			p.CommentEntry()
		}

	}

	return localctx
}

// IDateCompiledParagraphContext is an interface to support dynamic dispatch.
type IDateCompiledParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDateCompiledParagraphContext differentiates from other interfaces.
	IsDateCompiledParagraphContext()
}

type DateCompiledParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateCompiledParagraphContext() *DateCompiledParagraphContext {
	var p = new(DateCompiledParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dateCompiledParagraph
	return p
}

func (*DateCompiledParagraphContext) IsDateCompiledParagraphContext() {}

func NewDateCompiledParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateCompiledParagraphContext {
	var p = new(DateCompiledParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dateCompiledParagraph

	return p
}

func (s *DateCompiledParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *DateCompiledParagraphContext) DATE_COMPILED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE_COMPILED, 0)
}

func (s *DateCompiledParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DateCompiledParagraphContext) CommentEntry() ICommentEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentEntryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *DateCompiledParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateCompiledParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateCompiledParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDateCompiledParagraph(s)
	}
}

func (s *DateCompiledParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDateCompiledParagraph(s)
	}
}

func (s *DateCompiledParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDateCompiledParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DateCompiledParagraph() (localctx IDateCompiledParagraphContext) {
	localctx = NewDateCompiledParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, Cobol85ParserRULE_dateCompiledParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1305)
		p.Match(Cobol85ParserDATE_COMPILED)
	}
	{
		p.SetState(1306)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1308)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1307)
			p.CommentEntry()
		}

	}

	return localctx
}

// ISecurityParagraphContext is an interface to support dynamic dispatch.
type ISecurityParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSecurityParagraphContext differentiates from other interfaces.
	IsSecurityParagraphContext()
}

type SecurityParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySecurityParagraphContext() *SecurityParagraphContext {
	var p = new(SecurityParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_securityParagraph
	return p
}

func (*SecurityParagraphContext) IsSecurityParagraphContext() {}

func NewSecurityParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SecurityParagraphContext {
	var p = new(SecurityParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_securityParagraph

	return p
}

func (s *SecurityParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *SecurityParagraphContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECURITY, 0)
}

func (s *SecurityParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *SecurityParagraphContext) CommentEntry() ICommentEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentEntryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *SecurityParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SecurityParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SecurityParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSecurityParagraph(s)
	}
}

func (s *SecurityParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSecurityParagraph(s)
	}
}

func (s *SecurityParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSecurityParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SecurityParagraph() (localctx ISecurityParagraphContext) {
	localctx = NewSecurityParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, Cobol85ParserRULE_securityParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1310)
		p.Match(Cobol85ParserSECURITY)
	}
	{
		p.SetState(1311)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1313)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1312)
			p.CommentEntry()
		}

	}

	return localctx
}

// IRemarksParagraphContext is an interface to support dynamic dispatch.
type IRemarksParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRemarksParagraphContext differentiates from other interfaces.
	IsRemarksParagraphContext()
}

type RemarksParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemarksParagraphContext() *RemarksParagraphContext {
	var p = new(RemarksParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_remarksParagraph
	return p
}

func (*RemarksParagraphContext) IsRemarksParagraphContext() {}

func NewRemarksParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemarksParagraphContext {
	var p = new(RemarksParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_remarksParagraph

	return p
}

func (s *RemarksParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *RemarksParagraphContext) REMARKS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMARKS, 0)
}

func (s *RemarksParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *RemarksParagraphContext) CommentEntry() ICommentEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentEntryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *RemarksParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemarksParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemarksParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRemarksParagraph(s)
	}
}

func (s *RemarksParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRemarksParagraph(s)
	}
}

func (s *RemarksParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRemarksParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RemarksParagraph() (localctx IRemarksParagraphContext) {
	localctx = NewRemarksParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, Cobol85ParserRULE_remarksParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1315)
		p.Match(Cobol85ParserREMARKS)
	}
	{
		p.SetState(1316)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1318)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1317)
			p.CommentEntry()
		}

	}

	return localctx
}

// IEnvironmentDivisionContext is an interface to support dynamic dispatch.
type IEnvironmentDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnvironmentDivisionContext differentiates from other interfaces.
	IsEnvironmentDivisionContext()
}

type EnvironmentDivisionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnvironmentDivisionContext() *EnvironmentDivisionContext {
	var p = new(EnvironmentDivisionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_environmentDivision
	return p
}

func (*EnvironmentDivisionContext) IsEnvironmentDivisionContext() {}

func NewEnvironmentDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnvironmentDivisionContext {
	var p = new(EnvironmentDivisionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_environmentDivision

	return p
}

func (s *EnvironmentDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *EnvironmentDivisionContext) ENVIRONMENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENVIRONMENT, 0)
}

func (s *EnvironmentDivisionContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDIVISION, 0)
}

func (s *EnvironmentDivisionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *EnvironmentDivisionContext) AllEnvironmentDivisionBody() []IEnvironmentDivisionBodyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnvironmentDivisionBodyContext)(nil)).Elem())
	var tst = make([]IEnvironmentDivisionBodyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnvironmentDivisionBodyContext)
		}
	}

	return tst
}

func (s *EnvironmentDivisionContext) EnvironmentDivisionBody(i int) IEnvironmentDivisionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnvironmentDivisionBodyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnvironmentDivisionBodyContext)
}

func (s *EnvironmentDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnvironmentDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnvironmentDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnvironmentDivision(s)
	}
}

func (s *EnvironmentDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnvironmentDivision(s)
	}
}

func (s *EnvironmentDivisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEnvironmentDivision(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EnvironmentDivision() (localctx IEnvironmentDivisionContext) {
	localctx = NewEnvironmentDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, Cobol85ParserRULE_environmentDivision)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1320)
		p.Match(Cobol85ParserENVIRONMENT)
	}
	{
		p.SetState(1321)
		p.Match(Cobol85ParserDIVISION)
	}
	{
		p.SetState(1322)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1326)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserCONFIGURATION || _la == Cobol85ParserINPUT_OUTPUT || _la == Cobol85ParserSPECIAL_NAMES {
		{
			p.SetState(1323)
			p.EnvironmentDivisionBody()
		}

		p.SetState(1328)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEnvironmentDivisionBodyContext is an interface to support dynamic dispatch.
type IEnvironmentDivisionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnvironmentDivisionBodyContext differentiates from other interfaces.
	IsEnvironmentDivisionBodyContext()
}

type EnvironmentDivisionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnvironmentDivisionBodyContext() *EnvironmentDivisionBodyContext {
	var p = new(EnvironmentDivisionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_environmentDivisionBody
	return p
}

func (*EnvironmentDivisionBodyContext) IsEnvironmentDivisionBodyContext() {}

func NewEnvironmentDivisionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnvironmentDivisionBodyContext {
	var p = new(EnvironmentDivisionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_environmentDivisionBody

	return p
}

func (s *EnvironmentDivisionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *EnvironmentDivisionBodyContext) ConfigurationSection() IConfigurationSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfigurationSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConfigurationSectionContext)
}

func (s *EnvironmentDivisionBodyContext) SpecialNamesParagraph() ISpecialNamesParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecialNamesParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecialNamesParagraphContext)
}

func (s *EnvironmentDivisionBodyContext) InputOutputSection() IInputOutputSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInputOutputSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInputOutputSectionContext)
}

func (s *EnvironmentDivisionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnvironmentDivisionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnvironmentDivisionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnvironmentDivisionBody(s)
	}
}

func (s *EnvironmentDivisionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnvironmentDivisionBody(s)
	}
}

func (s *EnvironmentDivisionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEnvironmentDivisionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EnvironmentDivisionBody() (localctx IEnvironmentDivisionBodyContext) {
	localctx = NewEnvironmentDivisionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, Cobol85ParserRULE_environmentDivisionBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1332)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserCONFIGURATION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1329)
			p.ConfigurationSection()
		}

	case Cobol85ParserSPECIAL_NAMES:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1330)
			p.SpecialNamesParagraph()
		}

	case Cobol85ParserINPUT_OUTPUT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1331)
			p.InputOutputSection()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConfigurationSectionContext is an interface to support dynamic dispatch.
type IConfigurationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfigurationSectionContext differentiates from other interfaces.
	IsConfigurationSectionContext()
}

type ConfigurationSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfigurationSectionContext() *ConfigurationSectionContext {
	var p = new(ConfigurationSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_configurationSection
	return p
}

func (*ConfigurationSectionContext) IsConfigurationSectionContext() {}

func NewConfigurationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConfigurationSectionContext {
	var p = new(ConfigurationSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_configurationSection

	return p
}

func (s *ConfigurationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConfigurationSectionContext) CONFIGURATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONFIGURATION, 0)
}

func (s *ConfigurationSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *ConfigurationSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ConfigurationSectionContext) AllConfigurationSectionParagraph() []IConfigurationSectionParagraphContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConfigurationSectionParagraphContext)(nil)).Elem())
	var tst = make([]IConfigurationSectionParagraphContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConfigurationSectionParagraphContext)
		}
	}

	return tst
}

func (s *ConfigurationSectionContext) ConfigurationSectionParagraph(i int) IConfigurationSectionParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfigurationSectionParagraphContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConfigurationSectionParagraphContext)
}

func (s *ConfigurationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConfigurationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConfigurationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterConfigurationSection(s)
	}
}

func (s *ConfigurationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitConfigurationSection(s)
	}
}

func (s *ConfigurationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitConfigurationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ConfigurationSection() (localctx IConfigurationSectionContext) {
	localctx = NewConfigurationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, Cobol85ParserRULE_configurationSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1334)
		p.Match(Cobol85ParserCONFIGURATION)
	}
	{
		p.SetState(1335)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(1336)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1340)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserOBJECT_COMPUTER || _la == Cobol85ParserSOURCE_COMPUTER {
		{
			p.SetState(1337)
			p.ConfigurationSectionParagraph()
		}

		p.SetState(1342)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IConfigurationSectionParagraphContext is an interface to support dynamic dispatch.
type IConfigurationSectionParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfigurationSectionParagraphContext differentiates from other interfaces.
	IsConfigurationSectionParagraphContext()
}

type ConfigurationSectionParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfigurationSectionParagraphContext() *ConfigurationSectionParagraphContext {
	var p = new(ConfigurationSectionParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_configurationSectionParagraph
	return p
}

func (*ConfigurationSectionParagraphContext) IsConfigurationSectionParagraphContext() {}

func NewConfigurationSectionParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConfigurationSectionParagraphContext {
	var p = new(ConfigurationSectionParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_configurationSectionParagraph

	return p
}

func (s *ConfigurationSectionParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *ConfigurationSectionParagraphContext) SourceComputerParagraph() ISourceComputerParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceComputerParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceComputerParagraphContext)
}

func (s *ConfigurationSectionParagraphContext) ObjectComputerParagraph() IObjectComputerParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectComputerParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectComputerParagraphContext)
}

func (s *ConfigurationSectionParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConfigurationSectionParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConfigurationSectionParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterConfigurationSectionParagraph(s)
	}
}

func (s *ConfigurationSectionParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitConfigurationSectionParagraph(s)
	}
}

func (s *ConfigurationSectionParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitConfigurationSectionParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ConfigurationSectionParagraph() (localctx IConfigurationSectionParagraphContext) {
	localctx = NewConfigurationSectionParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, Cobol85ParserRULE_configurationSectionParagraph)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1345)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserSOURCE_COMPUTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1343)
			p.SourceComputerParagraph()
		}

	case Cobol85ParserOBJECT_COMPUTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1344)
			p.ObjectComputerParagraph()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISourceComputerParagraphContext is an interface to support dynamic dispatch.
type ISourceComputerParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourceComputerParagraphContext differentiates from other interfaces.
	IsSourceComputerParagraphContext()
}

type SourceComputerParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceComputerParagraphContext() *SourceComputerParagraphContext {
	var p = new(SourceComputerParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sourceComputerParagraph
	return p
}

func (*SourceComputerParagraphContext) IsSourceComputerParagraphContext() {}

func NewSourceComputerParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceComputerParagraphContext {
	var p = new(SourceComputerParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sourceComputerParagraph

	return p
}

func (s *SourceComputerParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceComputerParagraphContext) SOURCE_COMPUTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSOURCE_COMPUTER, 0)
}

func (s *SourceComputerParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *SourceComputerParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *SourceComputerParagraphContext) ComputerName() IComputerNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputerNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputerNameContext)
}

func (s *SourceComputerParagraphContext) DEBUGGING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUGGING, 0)
}

func (s *SourceComputerParagraphContext) MODE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMODE, 0)
}

func (s *SourceComputerParagraphContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *SourceComputerParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceComputerParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceComputerParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSourceComputerParagraph(s)
	}
}

func (s *SourceComputerParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSourceComputerParagraph(s)
	}
}

func (s *SourceComputerParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSourceComputerParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SourceComputerParagraph() (localctx ISourceComputerParagraphContext) {
	localctx = NewSourceComputerParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, Cobol85ParserRULE_sourceComputerParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1347)
		p.Match(Cobol85ParserSOURCE_COMPUTER)
	}
	{
		p.SetState(1348)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(1349)
		p.ComputerName()
	}
	p.SetState(1355)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDEBUGGING || _la == Cobol85ParserWITH {
		p.SetState(1351)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(1350)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(1353)
			p.Match(Cobol85ParserDEBUGGING)
		}
		{
			p.SetState(1354)
			p.Match(Cobol85ParserMODE)
		}

	}
	{
		p.SetState(1357)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IObjectComputerParagraphContext is an interface to support dynamic dispatch.
type IObjectComputerParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectComputerParagraphContext differentiates from other interfaces.
	IsObjectComputerParagraphContext()
}

type ObjectComputerParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectComputerParagraphContext() *ObjectComputerParagraphContext {
	var p = new(ObjectComputerParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_objectComputerParagraph
	return p
}

func (*ObjectComputerParagraphContext) IsObjectComputerParagraphContext() {}

func NewObjectComputerParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectComputerParagraphContext {
	var p = new(ObjectComputerParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_objectComputerParagraph

	return p
}

func (s *ObjectComputerParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectComputerParagraphContext) OBJECT_COMPUTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOBJECT_COMPUTER, 0)
}

func (s *ObjectComputerParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *ObjectComputerParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *ObjectComputerParagraphContext) ComputerName() IComputerNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputerNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputerNameContext)
}

func (s *ObjectComputerParagraphContext) AllObjectComputerClause() []IObjectComputerClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IObjectComputerClauseContext)(nil)).Elem())
	var tst = make([]IObjectComputerClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IObjectComputerClauseContext)
		}
	}

	return tst
}

func (s *ObjectComputerParagraphContext) ObjectComputerClause(i int) IObjectComputerClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectComputerClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IObjectComputerClauseContext)
}

func (s *ObjectComputerParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectComputerParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectComputerParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterObjectComputerParagraph(s)
	}
}

func (s *ObjectComputerParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitObjectComputerParagraph(s)
	}
}

func (s *ObjectComputerParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitObjectComputerParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ObjectComputerParagraph() (localctx IObjectComputerParagraphContext) {
	localctx = NewObjectComputerParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, Cobol85ParserRULE_objectComputerParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1359)
		p.Match(Cobol85ParserOBJECT_COMPUTER)
	}
	{
		p.SetState(1360)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(1361)
		p.ComputerName()
	}
	p.SetState(1365)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserCHARACTER || _la == Cobol85ParserCOLLATING || _la == Cobol85ParserDISK || _la == Cobol85ParserMEMORY || _la == Cobol85ParserPROGRAM || _la == Cobol85ParserSEGMENT_LIMIT || _la == Cobol85ParserSEQUENCE {
		{
			p.SetState(1362)
			p.ObjectComputerClause()
		}

		p.SetState(1367)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1368)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IObjectComputerClauseContext is an interface to support dynamic dispatch.
type IObjectComputerClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectComputerClauseContext differentiates from other interfaces.
	IsObjectComputerClauseContext()
}

type ObjectComputerClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectComputerClauseContext() *ObjectComputerClauseContext {
	var p = new(ObjectComputerClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_objectComputerClause
	return p
}

func (*ObjectComputerClauseContext) IsObjectComputerClauseContext() {}

func NewObjectComputerClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectComputerClauseContext {
	var p = new(ObjectComputerClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_objectComputerClause

	return p
}

func (s *ObjectComputerClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectComputerClauseContext) MemorySizeClause() IMemorySizeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemorySizeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemorySizeClauseContext)
}

func (s *ObjectComputerClauseContext) DiskSizeClause() IDiskSizeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDiskSizeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDiskSizeClauseContext)
}

func (s *ObjectComputerClauseContext) CollatingSequenceClause() ICollatingSequenceClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollatingSequenceClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollatingSequenceClauseContext)
}

func (s *ObjectComputerClauseContext) SegmentLimitClause() ISegmentLimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISegmentLimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISegmentLimitClauseContext)
}

func (s *ObjectComputerClauseContext) CharacterSetClause() ICharacterSetClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharacterSetClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharacterSetClauseContext)
}

func (s *ObjectComputerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectComputerClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectComputerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterObjectComputerClause(s)
	}
}

func (s *ObjectComputerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitObjectComputerClause(s)
	}
}

func (s *ObjectComputerClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitObjectComputerClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ObjectComputerClause() (localctx IObjectComputerClauseContext) {
	localctx = NewObjectComputerClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, Cobol85ParserRULE_objectComputerClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1375)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserMEMORY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1370)
			p.MemorySizeClause()
		}

	case Cobol85ParserDISK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1371)
			p.DiskSizeClause()
		}

	case Cobol85ParserCOLLATING, Cobol85ParserPROGRAM, Cobol85ParserSEQUENCE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1372)
			p.CollatingSequenceClause()
		}

	case Cobol85ParserSEGMENT_LIMIT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1373)
			p.SegmentLimitClause()
		}

	case Cobol85ParserCHARACTER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1374)
			p.CharacterSetClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMemorySizeClauseContext is an interface to support dynamic dispatch.
type IMemorySizeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemorySizeClauseContext differentiates from other interfaces.
	IsMemorySizeClauseContext()
}

type MemorySizeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemorySizeClauseContext() *MemorySizeClauseContext {
	var p = new(MemorySizeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_memorySizeClause
	return p
}

func (*MemorySizeClauseContext) IsMemorySizeClauseContext() {}

func NewMemorySizeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemorySizeClauseContext {
	var p = new(MemorySizeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_memorySizeClause

	return p
}

func (s *MemorySizeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MemorySizeClauseContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMEMORY, 0)
}

func (s *MemorySizeClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *MemorySizeClauseContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *MemorySizeClauseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *MemorySizeClauseContext) WORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWORDS, 0)
}

func (s *MemorySizeClauseContext) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *MemorySizeClauseContext) MODULES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMODULES, 0)
}

func (s *MemorySizeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemorySizeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemorySizeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMemorySizeClause(s)
	}
}

func (s *MemorySizeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMemorySizeClause(s)
	}
}

func (s *MemorySizeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMemorySizeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MemorySizeClause() (localctx IMemorySizeClauseContext) {
	localctx = NewMemorySizeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, Cobol85ParserRULE_memorySizeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1377)
		p.Match(Cobol85ParserMEMORY)
	}
	p.SetState(1379)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIZE {
		{
			p.SetState(1378)
			p.Match(Cobol85ParserSIZE)
		}

	}
	p.SetState(1383)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(1381)
			p.IntegerLiteral()
		}

	case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(1382)
			p.CobolWord()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1386)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTERS || _la == Cobol85ParserMODULES || _la == Cobol85ParserWORDS {
		p.SetState(1385)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCHARACTERS || _la == Cobol85ParserMODULES || _la == Cobol85ParserWORDS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// IDiskSizeClauseContext is an interface to support dynamic dispatch.
type IDiskSizeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDiskSizeClauseContext differentiates from other interfaces.
	IsDiskSizeClauseContext()
}

type DiskSizeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDiskSizeClauseContext() *DiskSizeClauseContext {
	var p = new(DiskSizeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_diskSizeClause
	return p
}

func (*DiskSizeClauseContext) IsDiskSizeClauseContext() {}

func NewDiskSizeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DiskSizeClauseContext {
	var p = new(DiskSizeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_diskSizeClause

	return p
}

func (s *DiskSizeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DiskSizeClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISK, 0)
}

func (s *DiskSizeClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *DiskSizeClauseContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *DiskSizeClauseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *DiskSizeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DiskSizeClauseContext) WORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWORDS, 0)
}

func (s *DiskSizeClauseContext) MODULES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMODULES, 0)
}

func (s *DiskSizeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DiskSizeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DiskSizeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDiskSizeClause(s)
	}
}

func (s *DiskSizeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDiskSizeClause(s)
	}
}

func (s *DiskSizeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDiskSizeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DiskSizeClause() (localctx IDiskSizeClauseContext) {
	localctx = NewDiskSizeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, Cobol85ParserRULE_diskSizeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1388)
		p.Match(Cobol85ParserDISK)
	}
	p.SetState(1390)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIZE {
		{
			p.SetState(1389)
			p.Match(Cobol85ParserSIZE)
		}

	}
	p.SetState(1393)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1392)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1397)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(1395)
			p.IntegerLiteral()
		}

	case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(1396)
			p.CobolWord()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1400)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMODULES || _la == Cobol85ParserWORDS {
		p.SetState(1399)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserMODULES || _la == Cobol85ParserWORDS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// ICollatingSequenceClauseContext is an interface to support dynamic dispatch.
type ICollatingSequenceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollatingSequenceClauseContext differentiates from other interfaces.
	IsCollatingSequenceClauseContext()
}

type CollatingSequenceClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollatingSequenceClauseContext() *CollatingSequenceClauseContext {
	var p = new(CollatingSequenceClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClause
	return p
}

func (*CollatingSequenceClauseContext) IsCollatingSequenceClauseContext() {}

func NewCollatingSequenceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollatingSequenceClauseContext {
	var p = new(CollatingSequenceClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClause

	return p
}

func (s *CollatingSequenceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CollatingSequenceClauseContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEQUENCE, 0)
}

func (s *CollatingSequenceClauseContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM, 0)
}

func (s *CollatingSequenceClauseContext) COLLATING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLLATING, 0)
}

func (s *CollatingSequenceClauseContext) CollatingSequenceClauseAlphanumeric() ICollatingSequenceClauseAlphanumericContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollatingSequenceClauseAlphanumericContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollatingSequenceClauseAlphanumericContext)
}

func (s *CollatingSequenceClauseContext) CollatingSequenceClauseNational() ICollatingSequenceClauseNationalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollatingSequenceClauseNationalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollatingSequenceClauseNationalContext)
}

func (s *CollatingSequenceClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *CollatingSequenceClauseContext) AllAlphabetName() []IAlphabetNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem())
	var tst = make([]IAlphabetNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlphabetNameContext)
		}
	}

	return tst
}

func (s *CollatingSequenceClauseContext) AlphabetName(i int) IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *CollatingSequenceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollatingSequenceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollatingSequenceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCollatingSequenceClause(s)
	}
}

func (s *CollatingSequenceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCollatingSequenceClause(s)
	}
}

func (s *CollatingSequenceClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCollatingSequenceClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CollatingSequenceClause() (localctx ICollatingSequenceClauseContext) {
	localctx = NewCollatingSequenceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, Cobol85ParserRULE_collatingSequenceClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1403)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPROGRAM {
		{
			p.SetState(1402)
			p.Match(Cobol85ParserPROGRAM)
		}

	}
	p.SetState(1406)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOLLATING {
		{
			p.SetState(1405)
			p.Match(Cobol85ParserCOLLATING)
		}

	}
	{
		p.SetState(1408)
		p.Match(Cobol85ParserSEQUENCE)
	}

	p.SetState(1410)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1409)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1413)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1412)
				p.AlphabetName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1415)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())
	}

	p.SetState(1418)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1417)
			p.CollatingSequenceClauseAlphanumeric()
		}

	}
	p.SetState(1421)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR || _la == Cobol85ParserNATIONAL {
		{
			p.SetState(1420)
			p.CollatingSequenceClauseNational()
		}

	}

	return localctx
}

// ICollatingSequenceClauseAlphanumericContext is an interface to support dynamic dispatch.
type ICollatingSequenceClauseAlphanumericContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollatingSequenceClauseAlphanumericContext differentiates from other interfaces.
	IsCollatingSequenceClauseAlphanumericContext()
}

type CollatingSequenceClauseAlphanumericContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollatingSequenceClauseAlphanumericContext() *CollatingSequenceClauseAlphanumericContext {
	var p = new(CollatingSequenceClauseAlphanumericContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClauseAlphanumeric
	return p
}

func (*CollatingSequenceClauseAlphanumericContext) IsCollatingSequenceClauseAlphanumericContext() {}

func NewCollatingSequenceClauseAlphanumericContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollatingSequenceClauseAlphanumericContext {
	var p = new(CollatingSequenceClauseAlphanumericContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClauseAlphanumeric

	return p
}

func (s *CollatingSequenceClauseAlphanumericContext) GetParser() antlr.Parser { return s.parser }

func (s *CollatingSequenceClauseAlphanumericContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *CollatingSequenceClauseAlphanumericContext) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *CollatingSequenceClauseAlphanumericContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CollatingSequenceClauseAlphanumericContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *CollatingSequenceClauseAlphanumericContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollatingSequenceClauseAlphanumericContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollatingSequenceClauseAlphanumericContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCollatingSequenceClauseAlphanumeric(s)
	}
}

func (s *CollatingSequenceClauseAlphanumericContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCollatingSequenceClauseAlphanumeric(s)
	}
}

func (s *CollatingSequenceClauseAlphanumericContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCollatingSequenceClauseAlphanumeric(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CollatingSequenceClauseAlphanumeric() (localctx ICollatingSequenceClauseAlphanumericContext) {
	localctx = NewCollatingSequenceClauseAlphanumericContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, Cobol85ParserRULE_collatingSequenceClauseAlphanumeric)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1424)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1423)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(1426)
		p.Match(Cobol85ParserALPHANUMERIC)
	}
	p.SetState(1428)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1427)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1430)
		p.AlphabetName()
	}

	return localctx
}

// ICollatingSequenceClauseNationalContext is an interface to support dynamic dispatch.
type ICollatingSequenceClauseNationalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollatingSequenceClauseNationalContext differentiates from other interfaces.
	IsCollatingSequenceClauseNationalContext()
}

type CollatingSequenceClauseNationalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollatingSequenceClauseNationalContext() *CollatingSequenceClauseNationalContext {
	var p = new(CollatingSequenceClauseNationalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClauseNational
	return p
}

func (*CollatingSequenceClauseNationalContext) IsCollatingSequenceClauseNationalContext() {}

func NewCollatingSequenceClauseNationalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollatingSequenceClauseNationalContext {
	var p = new(CollatingSequenceClauseNationalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClauseNational

	return p
}

func (s *CollatingSequenceClauseNationalContext) GetParser() antlr.Parser { return s.parser }

func (s *CollatingSequenceClauseNationalContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *CollatingSequenceClauseNationalContext) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *CollatingSequenceClauseNationalContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CollatingSequenceClauseNationalContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *CollatingSequenceClauseNationalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollatingSequenceClauseNationalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollatingSequenceClauseNationalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCollatingSequenceClauseNational(s)
	}
}

func (s *CollatingSequenceClauseNationalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCollatingSequenceClauseNational(s)
	}
}

func (s *CollatingSequenceClauseNationalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCollatingSequenceClauseNational(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CollatingSequenceClauseNational() (localctx ICollatingSequenceClauseNationalContext) {
	localctx = NewCollatingSequenceClauseNationalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, Cobol85ParserRULE_collatingSequenceClauseNational)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1433)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1432)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(1435)
		p.Match(Cobol85ParserNATIONAL)
	}
	p.SetState(1437)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1436)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1439)
		p.AlphabetName()
	}

	return localctx
}

// ISegmentLimitClauseContext is an interface to support dynamic dispatch.
type ISegmentLimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSegmentLimitClauseContext differentiates from other interfaces.
	IsSegmentLimitClauseContext()
}

type SegmentLimitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySegmentLimitClauseContext() *SegmentLimitClauseContext {
	var p = new(SegmentLimitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_segmentLimitClause
	return p
}

func (*SegmentLimitClauseContext) IsSegmentLimitClauseContext() {}

func NewSegmentLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SegmentLimitClauseContext {
	var p = new(SegmentLimitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_segmentLimitClause

	return p
}

func (s *SegmentLimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SegmentLimitClauseContext) SEGMENT_LIMIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEGMENT_LIMIT, 0)
}

func (s *SegmentLimitClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *SegmentLimitClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SegmentLimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SegmentLimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SegmentLimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSegmentLimitClause(s)
	}
}

func (s *SegmentLimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSegmentLimitClause(s)
	}
}

func (s *SegmentLimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSegmentLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SegmentLimitClause() (localctx ISegmentLimitClauseContext) {
	localctx = NewSegmentLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, Cobol85ParserRULE_segmentLimitClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1441)
		p.Match(Cobol85ParserSEGMENT_LIMIT)
	}
	p.SetState(1443)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1442)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1445)
		p.IntegerLiteral()
	}

	return localctx
}

// ICharacterSetClauseContext is an interface to support dynamic dispatch.
type ICharacterSetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharacterSetClauseContext differentiates from other interfaces.
	IsCharacterSetClauseContext()
}

type CharacterSetClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacterSetClauseContext() *CharacterSetClauseContext {
	var p = new(CharacterSetClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_characterSetClause
	return p
}

func (*CharacterSetClauseContext) IsCharacterSetClauseContext() {}

func NewCharacterSetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharacterSetClauseContext {
	var p = new(CharacterSetClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_characterSetClause

	return p
}

func (s *CharacterSetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CharacterSetClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *CharacterSetClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSET, 0)
}

func (s *CharacterSetClauseContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *CharacterSetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharacterSetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharacterSetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCharacterSetClause(s)
	}
}

func (s *CharacterSetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCharacterSetClause(s)
	}
}

func (s *CharacterSetClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCharacterSetClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CharacterSetClause() (localctx ICharacterSetClauseContext) {
	localctx = NewCharacterSetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, Cobol85ParserRULE_characterSetClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1447)
		p.Match(Cobol85ParserCHARACTER)
	}
	{
		p.SetState(1448)
		p.Match(Cobol85ParserSET)
	}
	{
		p.SetState(1449)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// ISpecialNamesParagraphContext is an interface to support dynamic dispatch.
type ISpecialNamesParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecialNamesParagraphContext differentiates from other interfaces.
	IsSpecialNamesParagraphContext()
}

type SpecialNamesParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialNamesParagraphContext() *SpecialNamesParagraphContext {
	var p = new(SpecialNamesParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_specialNamesParagraph
	return p
}

func (*SpecialNamesParagraphContext) IsSpecialNamesParagraphContext() {}

func NewSpecialNamesParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialNamesParagraphContext {
	var p = new(SpecialNamesParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_specialNamesParagraph

	return p
}

func (s *SpecialNamesParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialNamesParagraphContext) SPECIAL_NAMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSPECIAL_NAMES, 0)
}

func (s *SpecialNamesParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *SpecialNamesParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *SpecialNamesParagraphContext) AllSpecialNameClause() []ISpecialNameClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecialNameClauseContext)(nil)).Elem())
	var tst = make([]ISpecialNameClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecialNameClauseContext)
		}
	}

	return tst
}

func (s *SpecialNamesParagraphContext) SpecialNameClause(i int) ISpecialNameClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecialNameClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecialNameClauseContext)
}

func (s *SpecialNamesParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialNamesParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialNamesParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSpecialNamesParagraph(s)
	}
}

func (s *SpecialNamesParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSpecialNamesParagraph(s)
	}
}

func (s *SpecialNamesParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSpecialNamesParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SpecialNamesParagraph() (localctx ISpecialNamesParagraphContext) {
	localctx = NewSpecialNamesParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, Cobol85ParserRULE_specialNamesParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1451)
		p.Match(Cobol85ParserSPECIAL_NAMES)
	}
	{
		p.SetState(1452)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1460)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
		p.SetState(1454)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserALPHABET)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(Cobol85ParserCLASS-66))|(1<<(Cobol85ParserCLOSE_DISPOSITION-66))|(1<<(Cobol85ParserCOBOL-66))|(1<<(Cobol85ParserCODEPAGE-66))|(1<<(Cobol85ParserCOMMITMENT-66)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(Cobol85ParserCONTROL_POINT-101))|(1<<(Cobol85ParserCONVENTION-101))|(1<<(Cobol85ParserCRUNCH-101))|(1<<(Cobol85ParserCURRENCY-101))|(1<<(Cobol85ParserCURSOR-101))|(1<<(Cobol85ParserDECIMAL_POINT-101))|(1<<(Cobol85ParserDEFAULT-101))|(1<<(Cobol85ParserDEFAULT_DISPLAY-101)))) != 0) || (((_la-133)&-(0x1f+1)) == 0 && ((1<<uint((_la-133)))&((1<<(Cobol85ParserDEFINITION-133))|(1<<(Cobol85ParserDFHRESP-133))|(1<<(Cobol85ParserDFHVALUE-133))|(1<<(Cobol85ParserDISK-133))|(1<<(Cobol85ParserDONTCARE-133))|(1<<(Cobol85ParserDOUBLE-133))|(1<<(Cobol85ParserEBCDIC-133))|(1<<(Cobol85ParserEMPTY_CHECK-133)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOFF-321))|(1<<(Cobol85ParserON-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserRESERVE-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserSYMBOLIC-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
			{
				p.SetState(1453)
				p.SpecialNameClause()
			}

			p.SetState(1456)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1458)
			p.Match(Cobol85ParserDOT_FS)
		}

	}

	return localctx
}

// ISpecialNameClauseContext is an interface to support dynamic dispatch.
type ISpecialNameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecialNameClauseContext differentiates from other interfaces.
	IsSpecialNameClauseContext()
}

type SpecialNameClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialNameClauseContext() *SpecialNameClauseContext {
	var p = new(SpecialNameClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_specialNameClause
	return p
}

func (*SpecialNameClauseContext) IsSpecialNameClauseContext() {}

func NewSpecialNameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialNameClauseContext {
	var p = new(SpecialNameClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_specialNameClause

	return p
}

func (s *SpecialNameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialNameClauseContext) ChannelClause() IChannelClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChannelClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChannelClauseContext)
}

func (s *SpecialNameClauseContext) OdtClause() IOdtClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOdtClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOdtClauseContext)
}

func (s *SpecialNameClauseContext) AlphabetClause() IAlphabetClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetClauseContext)
}

func (s *SpecialNameClauseContext) ClassClause() IClassClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassClauseContext)
}

func (s *SpecialNameClauseContext) CurrencySignClause() ICurrencySignClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICurrencySignClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICurrencySignClauseContext)
}

func (s *SpecialNameClauseContext) DecimalPointClause() IDecimalPointClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecimalPointClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecimalPointClauseContext)
}

func (s *SpecialNameClauseContext) SymbolicCharactersClause() ISymbolicCharactersClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicCharactersClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolicCharactersClauseContext)
}

func (s *SpecialNameClauseContext) EnvironmentSwitchNameClause() IEnvironmentSwitchNameClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnvironmentSwitchNameClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnvironmentSwitchNameClauseContext)
}

func (s *SpecialNameClauseContext) DefaultDisplaySignClause() IDefaultDisplaySignClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefaultDisplaySignClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefaultDisplaySignClauseContext)
}

func (s *SpecialNameClauseContext) DefaultComputationalSignClause() IDefaultComputationalSignClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefaultComputationalSignClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefaultComputationalSignClauseContext)
}

func (s *SpecialNameClauseContext) ReserveNetworkClause() IReserveNetworkClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReserveNetworkClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReserveNetworkClauseContext)
}

func (s *SpecialNameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialNameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialNameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSpecialNameClause(s)
	}
}

func (s *SpecialNameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSpecialNameClause(s)
	}
}

func (s *SpecialNameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSpecialNameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SpecialNameClause() (localctx ISpecialNameClauseContext) {
	localctx = NewSpecialNameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, Cobol85ParserRULE_specialNameClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1473)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1462)
			p.ChannelClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1463)
			p.OdtClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1464)
			p.AlphabetClause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1465)
			p.ClassClause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1466)
			p.CurrencySignClause()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1467)
			p.DecimalPointClause()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1468)
			p.SymbolicCharactersClause()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1469)
			p.EnvironmentSwitchNameClause()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1470)
			p.DefaultDisplaySignClause()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1471)
			p.DefaultComputationalSignClause()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1472)
			p.ReserveNetworkClause()
		}

	}

	return localctx
}

// IAlphabetClauseContext is an interface to support dynamic dispatch.
type IAlphabetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetClauseContext differentiates from other interfaces.
	IsAlphabetClauseContext()
}

type AlphabetClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetClauseContext() *AlphabetClauseContext {
	var p = new(AlphabetClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetClause
	return p
}

func (*AlphabetClauseContext) IsAlphabetClauseContext() {}

func NewAlphabetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetClauseContext {
	var p = new(AlphabetClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetClause

	return p
}

func (s *AlphabetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetClauseContext) AlphabetClauseFormat1() IAlphabetClauseFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetClauseFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetClauseFormat1Context)
}

func (s *AlphabetClauseContext) AlphabetClauseFormat2() IAlphabetClauseFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetClauseFormat2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetClauseFormat2Context)
}

func (s *AlphabetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetClause(s)
	}
}

func (s *AlphabetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetClause(s)
	}
}

func (s *AlphabetClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlphabetClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlphabetClause() (localctx IAlphabetClauseContext) {
	localctx = NewAlphabetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, Cobol85ParserRULE_alphabetClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1477)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1475)
			p.AlphabetClauseFormat1()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1476)
			p.AlphabetClauseFormat2()
		}

	}

	return localctx
}

// IAlphabetClauseFormat1Context is an interface to support dynamic dispatch.
type IAlphabetClauseFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetClauseFormat1Context differentiates from other interfaces.
	IsAlphabetClauseFormat1Context()
}

type AlphabetClauseFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetClauseFormat1Context() *AlphabetClauseFormat1Context {
	var p = new(AlphabetClauseFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetClauseFormat1
	return p
}

func (*AlphabetClauseFormat1Context) IsAlphabetClauseFormat1Context() {}

func NewAlphabetClauseFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetClauseFormat1Context {
	var p = new(AlphabetClauseFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetClauseFormat1

	return p
}

func (s *AlphabetClauseFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetClauseFormat1Context) ALPHABET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABET, 0)
}

func (s *AlphabetClauseFormat1Context) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *AlphabetClauseFormat1Context) EBCDIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEBCDIC, 0)
}

func (s *AlphabetClauseFormat1Context) ASCII() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASCII, 0)
}

func (s *AlphabetClauseFormat1Context) STANDARD_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTANDARD_1, 0)
}

func (s *AlphabetClauseFormat1Context) STANDARD_2() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTANDARD_2, 0)
}

func (s *AlphabetClauseFormat1Context) NATIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIVE, 0)
}

func (s *AlphabetClauseFormat1Context) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *AlphabetClauseFormat1Context) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *AlphabetClauseFormat1Context) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *AlphabetClauseFormat1Context) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *AlphabetClauseFormat1Context) AllAlphabetLiterals() []IAlphabetLiteralsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlphabetLiteralsContext)(nil)).Elem())
	var tst = make([]IAlphabetLiteralsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlphabetLiteralsContext)
		}
	}

	return tst
}

func (s *AlphabetClauseFormat1Context) AlphabetLiterals(i int) IAlphabetLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetLiteralsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlphabetLiteralsContext)
}

func (s *AlphabetClauseFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetClauseFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetClauseFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetClauseFormat1(s)
	}
}

func (s *AlphabetClauseFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetClauseFormat1(s)
	}
}

func (s *AlphabetClauseFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlphabetClauseFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlphabetClauseFormat1() (localctx IAlphabetClauseFormat1Context) {
	localctx = NewAlphabetClauseFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, Cobol85ParserRULE_alphabetClauseFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1479)
		p.Match(Cobol85ParserALPHABET)
	}
	{
		p.SetState(1480)
		p.AlphabetName()
	}
	p.SetState(1483)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1481)
			p.Match(Cobol85ParserFOR)
		}
		{
			p.SetState(1482)
			p.Match(Cobol85ParserALPHANUMERIC)
		}

	}
	p.SetState(1486)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1485)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1499)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1488)
			p.Match(Cobol85ParserEBCDIC)
		}

	case 2:
		{
			p.SetState(1489)
			p.Match(Cobol85ParserASCII)
		}

	case 3:
		{
			p.SetState(1490)
			p.Match(Cobol85ParserSTANDARD_1)
		}

	case 4:
		{
			p.SetState(1491)
			p.Match(Cobol85ParserSTANDARD_2)
		}

	case 5:
		{
			p.SetState(1492)
			p.Match(Cobol85ParserNATIVE)
		}

	case 6:
		{
			p.SetState(1493)
			p.CobolWord()
		}

	case 7:
		p.SetState(1495)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1494)
					p.AlphabetLiterals()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1497)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IAlphabetLiteralsContext is an interface to support dynamic dispatch.
type IAlphabetLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetLiteralsContext differentiates from other interfaces.
	IsAlphabetLiteralsContext()
}

type AlphabetLiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetLiteralsContext() *AlphabetLiteralsContext {
	var p = new(AlphabetLiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetLiterals
	return p
}

func (*AlphabetLiteralsContext) IsAlphabetLiteralsContext() {}

func NewAlphabetLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetLiteralsContext {
	var p = new(AlphabetLiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetLiterals

	return p
}

func (s *AlphabetLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetLiteralsContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AlphabetLiteralsContext) AlphabetThrough() IAlphabetThroughContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetThroughContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetThroughContext)
}

func (s *AlphabetLiteralsContext) AllAlphabetAlso() []IAlphabetAlsoContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlphabetAlsoContext)(nil)).Elem())
	var tst = make([]IAlphabetAlsoContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlphabetAlsoContext)
		}
	}

	return tst
}

func (s *AlphabetLiteralsContext) AlphabetAlso(i int) IAlphabetAlsoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetAlsoContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlphabetAlsoContext)
}

func (s *AlphabetLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetLiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetLiterals(s)
	}
}

func (s *AlphabetLiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetLiterals(s)
	}
}

func (s *AlphabetLiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlphabetLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlphabetLiterals() (localctx IAlphabetLiteralsContext) {
	localctx = NewAlphabetLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, Cobol85ParserRULE_alphabetLiterals)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1501)
		p.Literal()
	}
	p.SetState(1508)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserTHROUGH, Cobol85ParserTHRU:
		{
			p.SetState(1502)
			p.AlphabetThrough()
		}

	case Cobol85ParserALSO:
		p.SetState(1504)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == Cobol85ParserALSO {
			{
				p.SetState(1503)
				p.AlphabetAlso()
			}

			p.SetState(1506)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case Cobol85ParserABORT, Cobol85ParserALL, Cobol85ParserALPHABET, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLASS, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURRENCY, Cobol85ParserCURSOR, Cobol85ParserDECIMAL_POINT, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFALSE, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserHIGH_VALUE, Cobol85ParserHIGH_VALUES, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserLOW_VALUE, Cobol85ParserLOW_VALUES, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNULL, Cobol85ParserNULLS, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOFF, Cobol85ParserON, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserQUOTE, Cobol85ParserQUOTES, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserRESERVE, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSPACE, Cobol85ParserSPACES, Cobol85ParserSYMBOL, Cobol85ParserSYMBOLIC, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUE, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO, Cobol85ParserZERO_FILL, Cobol85ParserZEROS, Cobol85ParserZEROES, Cobol85ParserDOT_FS, Cobol85ParserNONNUMERICLITERAL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserNUMERICLITERAL, Cobol85ParserIDENTIFIER:

	default:
	}

	return localctx
}

// IAlphabetThroughContext is an interface to support dynamic dispatch.
type IAlphabetThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetThroughContext differentiates from other interfaces.
	IsAlphabetThroughContext()
}

type AlphabetThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetThroughContext() *AlphabetThroughContext {
	var p = new(AlphabetThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetThrough
	return p
}

func (*AlphabetThroughContext) IsAlphabetThroughContext() {}

func NewAlphabetThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetThroughContext {
	var p = new(AlphabetThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetThrough

	return p
}

func (s *AlphabetThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetThroughContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AlphabetThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *AlphabetThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *AlphabetThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetThrough(s)
	}
}

func (s *AlphabetThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetThrough(s)
	}
}

func (s *AlphabetThroughContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlphabetThrough(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlphabetThrough() (localctx IAlphabetThroughContext) {
	localctx = NewAlphabetThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, Cobol85ParserRULE_alphabetThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1510)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1511)
		p.Literal()
	}

	return localctx
}

// IAlphabetAlsoContext is an interface to support dynamic dispatch.
type IAlphabetAlsoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetAlsoContext differentiates from other interfaces.
	IsAlphabetAlsoContext()
}

type AlphabetAlsoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetAlsoContext() *AlphabetAlsoContext {
	var p = new(AlphabetAlsoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetAlso
	return p
}

func (*AlphabetAlsoContext) IsAlphabetAlsoContext() {}

func NewAlphabetAlsoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetAlsoContext {
	var p = new(AlphabetAlsoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetAlso

	return p
}

func (s *AlphabetAlsoContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetAlsoContext) ALSO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALSO, 0)
}

func (s *AlphabetAlsoContext) AllLiteral() []ILiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILiteralContext)(nil)).Elem())
	var tst = make([]ILiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILiteralContext)
		}
	}

	return tst
}

func (s *AlphabetAlsoContext) Literal(i int) ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AlphabetAlsoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetAlsoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetAlsoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetAlso(s)
	}
}

func (s *AlphabetAlsoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetAlso(s)
	}
}

func (s *AlphabetAlsoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlphabetAlso(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlphabetAlso() (localctx IAlphabetAlsoContext) {
	localctx = NewAlphabetAlsoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, Cobol85ParserRULE_alphabetAlso)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1513)
		p.Match(Cobol85ParserALSO)
	}
	p.SetState(1515)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1514)
				p.Literal()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1517)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext())
	}

	return localctx
}

// IAlphabetClauseFormat2Context is an interface to support dynamic dispatch.
type IAlphabetClauseFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetClauseFormat2Context differentiates from other interfaces.
	IsAlphabetClauseFormat2Context()
}

type AlphabetClauseFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetClauseFormat2Context() *AlphabetClauseFormat2Context {
	var p = new(AlphabetClauseFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetClauseFormat2
	return p
}

func (*AlphabetClauseFormat2Context) IsAlphabetClauseFormat2Context() {}

func NewAlphabetClauseFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetClauseFormat2Context {
	var p = new(AlphabetClauseFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetClauseFormat2

	return p
}

func (s *AlphabetClauseFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetClauseFormat2Context) ALPHABET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABET, 0)
}

func (s *AlphabetClauseFormat2Context) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *AlphabetClauseFormat2Context) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *AlphabetClauseFormat2Context) NATIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIVE, 0)
}

func (s *AlphabetClauseFormat2Context) CCSVERSION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCCSVERSION, 0)
}

func (s *AlphabetClauseFormat2Context) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AlphabetClauseFormat2Context) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *AlphabetClauseFormat2Context) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *AlphabetClauseFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetClauseFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetClauseFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetClauseFormat2(s)
	}
}

func (s *AlphabetClauseFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetClauseFormat2(s)
	}
}

func (s *AlphabetClauseFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlphabetClauseFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlphabetClauseFormat2() (localctx IAlphabetClauseFormat2Context) {
	localctx = NewAlphabetClauseFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, Cobol85ParserRULE_alphabetClauseFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1519)
		p.Match(Cobol85ParserALPHABET)
	}
	{
		p.SetState(1520)
		p.AlphabetName()
	}
	p.SetState(1522)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1521)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(1524)
		p.Match(Cobol85ParserNATIONAL)
	}
	p.SetState(1526)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1525)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1531)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNATIVE:
		{
			p.SetState(1528)
			p.Match(Cobol85ParserNATIVE)
		}

	case Cobol85ParserCCSVERSION:
		{
			p.SetState(1529)
			p.Match(Cobol85ParserCCSVERSION)
		}
		{
			p.SetState(1530)
			p.Literal()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IChannelClauseContext is an interface to support dynamic dispatch.
type IChannelClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChannelClauseContext differentiates from other interfaces.
	IsChannelClauseContext()
}

type ChannelClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChannelClauseContext() *ChannelClauseContext {
	var p = new(ChannelClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_channelClause
	return p
}

func (*ChannelClauseContext) IsChannelClauseContext() {}

func NewChannelClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelClauseContext {
	var p = new(ChannelClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_channelClause

	return p
}

func (s *ChannelClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelClauseContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHANNEL, 0)
}

func (s *ChannelClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ChannelClauseContext) MnemonicName() IMnemonicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMnemonicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *ChannelClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ChannelClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChannelClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterChannelClause(s)
	}
}

func (s *ChannelClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitChannelClause(s)
	}
}

func (s *ChannelClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitChannelClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ChannelClause() (localctx IChannelClauseContext) {
	localctx = NewChannelClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, Cobol85ParserRULE_channelClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1533)
		p.Match(Cobol85ParserCHANNEL)
	}
	{
		p.SetState(1534)
		p.IntegerLiteral()
	}
	p.SetState(1536)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1535)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1538)
		p.MnemonicName()
	}

	return localctx
}

// IClassClauseContext is an interface to support dynamic dispatch.
type IClassClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassClauseContext differentiates from other interfaces.
	IsClassClauseContext()
}

type ClassClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassClauseContext() *ClassClauseContext {
	var p = new(ClassClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_classClause
	return p
}

func (*ClassClauseContext) IsClassClauseContext() {}

func NewClassClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassClauseContext {
	var p = new(ClassClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_classClause

	return p
}

func (s *ClassClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassClauseContext) CLASS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCLASS, 0)
}

func (s *ClassClauseContext) ClassName() IClassNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *ClassClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ClassClauseContext) AllClassClauseThrough() []IClassClauseThroughContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassClauseThroughContext)(nil)).Elem())
	var tst = make([]IClassClauseThroughContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassClauseThroughContext)
		}
	}

	return tst
}

func (s *ClassClauseContext) ClassClauseThrough(i int) IClassClauseThroughContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassClauseThroughContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassClauseThroughContext)
}

func (s *ClassClauseContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *ClassClauseContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *ClassClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *ClassClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassClause(s)
	}
}

func (s *ClassClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassClause(s)
	}
}

func (s *ClassClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClassClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClassClause() (localctx IClassClauseContext) {
	localctx = NewClassClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, Cobol85ParserRULE_classClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1540)
		p.Match(Cobol85ParserCLASS)
	}
	{
		p.SetState(1541)
		p.ClassName()
	}
	p.SetState(1546)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
		p.SetState(1543)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFOR {
			{
				p.SetState(1542)
				p.Match(Cobol85ParserFOR)
			}

		}
		p.SetState(1545)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserALPHANUMERIC || _la == Cobol85ParserNATIONAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	p.SetState(1549)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1548)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1552)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1551)
				p.ClassClauseThrough()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1554)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())
	}

	return localctx
}

// IClassClauseThroughContext is an interface to support dynamic dispatch.
type IClassClauseThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassClauseThroughContext differentiates from other interfaces.
	IsClassClauseThroughContext()
}

type ClassClauseThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassClauseThroughContext() *ClassClauseThroughContext {
	var p = new(ClassClauseThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_classClauseThrough
	return p
}

func (*ClassClauseThroughContext) IsClassClauseThroughContext() {}

func NewClassClauseThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassClauseThroughContext {
	var p = new(ClassClauseThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_classClauseThrough

	return p
}

func (s *ClassClauseThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassClauseThroughContext) ClassClauseFrom() IClassClauseFromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassClauseFromContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassClauseFromContext)
}

func (s *ClassClauseThroughContext) ClassClauseTo() IClassClauseToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassClauseToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassClauseToContext)
}

func (s *ClassClauseThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *ClassClauseThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *ClassClauseThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassClauseThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassClauseThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassClauseThrough(s)
	}
}

func (s *ClassClauseThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassClauseThrough(s)
	}
}

func (s *ClassClauseThroughContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClassClauseThrough(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClassClauseThrough() (localctx IClassClauseThroughContext) {
	localctx = NewClassClauseThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, Cobol85ParserRULE_classClauseThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1556)
		p.ClassClauseFrom()
	}
	p.SetState(1559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		p.SetState(1557)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(1558)
			p.ClassClauseTo()
		}

	}

	return localctx
}

// IClassClauseFromContext is an interface to support dynamic dispatch.
type IClassClauseFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassClauseFromContext differentiates from other interfaces.
	IsClassClauseFromContext()
}

type ClassClauseFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassClauseFromContext() *ClassClauseFromContext {
	var p = new(ClassClauseFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_classClauseFrom
	return p
}

func (*ClassClauseFromContext) IsClassClauseFromContext() {}

func NewClassClauseFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassClauseFromContext {
	var p = new(ClassClauseFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_classClauseFrom

	return p
}

func (s *ClassClauseFromContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassClauseFromContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassClauseFromContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ClassClauseFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassClauseFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassClauseFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassClauseFrom(s)
	}
}

func (s *ClassClauseFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassClauseFrom(s)
	}
}

func (s *ClassClauseFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClassClauseFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClassClauseFrom() (localctx IClassClauseFromContext) {
	localctx = NewClassClauseFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, Cobol85ParserRULE_classClauseFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1563)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1561)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1562)
			p.Literal()
		}

	}

	return localctx
}

// IClassClauseToContext is an interface to support dynamic dispatch.
type IClassClauseToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassClauseToContext differentiates from other interfaces.
	IsClassClauseToContext()
}

type ClassClauseToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassClauseToContext() *ClassClauseToContext {
	var p = new(ClassClauseToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_classClauseTo
	return p
}

func (*ClassClauseToContext) IsClassClauseToContext() {}

func NewClassClauseToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassClauseToContext {
	var p = new(ClassClauseToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_classClauseTo

	return p
}

func (s *ClassClauseToContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassClauseToContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassClauseToContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ClassClauseToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassClauseToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassClauseToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassClauseTo(s)
	}
}

func (s *ClassClauseToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassClauseTo(s)
	}
}

func (s *ClassClauseToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClassClauseTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClassClauseTo() (localctx IClassClauseToContext) {
	localctx = NewClassClauseToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, Cobol85ParserRULE_classClauseTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1567)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1565)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1566)
			p.Literal()
		}

	}

	return localctx
}

// ICurrencySignClauseContext is an interface to support dynamic dispatch.
type ICurrencySignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCurrencySignClauseContext differentiates from other interfaces.
	IsCurrencySignClauseContext()
}

type CurrencySignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCurrencySignClauseContext() *CurrencySignClauseContext {
	var p = new(CurrencySignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_currencySignClause
	return p
}

func (*CurrencySignClauseContext) IsCurrencySignClauseContext() {}

func NewCurrencySignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CurrencySignClauseContext {
	var p = new(CurrencySignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_currencySignClause

	return p
}

func (s *CurrencySignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CurrencySignClauseContext) CURRENCY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCURRENCY, 0)
}

func (s *CurrencySignClauseContext) AllLiteral() []ILiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILiteralContext)(nil)).Elem())
	var tst = make([]ILiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILiteralContext)
		}
	}

	return tst
}

func (s *CurrencySignClauseContext) Literal(i int) ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CurrencySignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *CurrencySignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *CurrencySignClauseContext) PICTURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPICTURE, 0)
}

func (s *CurrencySignClauseContext) SYMBOL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOL, 0)
}

func (s *CurrencySignClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *CurrencySignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrencySignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CurrencySignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCurrencySignClause(s)
	}
}

func (s *CurrencySignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCurrencySignClause(s)
	}
}

func (s *CurrencySignClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCurrencySignClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CurrencySignClause() (localctx ICurrencySignClauseContext) {
	localctx = NewCurrencySignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, Cobol85ParserRULE_currencySignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1569)
		p.Match(Cobol85ParserCURRENCY)
	}
	p.SetState(1571)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIGN {
		{
			p.SetState(1570)
			p.Match(Cobol85ParserSIGN)
		}

	}
	p.SetState(1574)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1573)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1576)
		p.Literal()
	}
	p.SetState(1583)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPICTURE || _la == Cobol85ParserWITH {
		p.SetState(1578)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(1577)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(1580)
			p.Match(Cobol85ParserPICTURE)
		}
		{
			p.SetState(1581)
			p.Match(Cobol85ParserSYMBOL)
		}
		{
			p.SetState(1582)
			p.Literal()
		}

	}

	return localctx
}

// IDecimalPointClauseContext is an interface to support dynamic dispatch.
type IDecimalPointClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecimalPointClauseContext differentiates from other interfaces.
	IsDecimalPointClauseContext()
}

type DecimalPointClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalPointClauseContext() *DecimalPointClauseContext {
	var p = new(DecimalPointClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_decimalPointClause
	return p
}

func (*DecimalPointClauseContext) IsDecimalPointClauseContext() {}

func NewDecimalPointClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalPointClauseContext {
	var p = new(DecimalPointClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_decimalPointClause

	return p
}

func (s *DecimalPointClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalPointClauseContext) DECIMAL_POINT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDECIMAL_POINT, 0)
}

func (s *DecimalPointClauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMA, 0)
}

func (s *DecimalPointClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DecimalPointClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalPointClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalPointClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDecimalPointClause(s)
	}
}

func (s *DecimalPointClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDecimalPointClause(s)
	}
}

func (s *DecimalPointClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDecimalPointClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DecimalPointClause() (localctx IDecimalPointClauseContext) {
	localctx = NewDecimalPointClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, Cobol85ParserRULE_decimalPointClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1585)
		p.Match(Cobol85ParserDECIMAL_POINT)
	}
	p.SetState(1587)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1586)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1589)
		p.Match(Cobol85ParserCOMMA)
	}

	return localctx
}

// IDefaultComputationalSignClauseContext is an interface to support dynamic dispatch.
type IDefaultComputationalSignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultComputationalSignClauseContext differentiates from other interfaces.
	IsDefaultComputationalSignClauseContext()
}

type DefaultComputationalSignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultComputationalSignClauseContext() *DefaultComputationalSignClauseContext {
	var p = new(DefaultComputationalSignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_defaultComputationalSignClause
	return p
}

func (*DefaultComputationalSignClauseContext) IsDefaultComputationalSignClauseContext() {}

func NewDefaultComputationalSignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultComputationalSignClauseContext {
	var p = new(DefaultComputationalSignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_defaultComputationalSignClause

	return p
}

func (s *DefaultComputationalSignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultComputationalSignClauseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFAULT, 0)
}

func (s *DefaultComputationalSignClauseContext) SEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEPARATE, 0)
}

func (s *DefaultComputationalSignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *DefaultComputationalSignClauseContext) COMPUTATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL, 0)
}

func (s *DefaultComputationalSignClauseContext) COMP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP, 0)
}

func (s *DefaultComputationalSignClauseContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *DefaultComputationalSignClauseContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRAILING, 0)
}

func (s *DefaultComputationalSignClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *DefaultComputationalSignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DefaultComputationalSignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultComputationalSignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultComputationalSignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDefaultComputationalSignClause(s)
	}
}

func (s *DefaultComputationalSignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDefaultComputationalSignClause(s)
	}
}

func (s *DefaultComputationalSignClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDefaultComputationalSignClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DefaultComputationalSignClause() (localctx IDefaultComputationalSignClauseContext) {
	localctx = NewDefaultComputationalSignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, Cobol85ParserRULE_defaultComputationalSignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1591)
		p.Match(Cobol85ParserDEFAULT)
	}
	p.SetState(1593)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMP || _la == Cobol85ParserCOMPUTATIONAL {
		p.SetState(1592)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCOMP || _la == Cobol85ParserCOMPUTATIONAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	p.SetState(1599)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIGN {
		{
			p.SetState(1595)
			p.Match(Cobol85ParserSIGN)
		}
		p.SetState(1597)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1596)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	p.SetState(1602)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING {
		p.SetState(1601)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	{
		p.SetState(1604)
		p.Match(Cobol85ParserSEPARATE)
	}
	p.SetState(1606)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTER {
		{
			p.SetState(1605)
			p.Match(Cobol85ParserCHARACTER)
		}

	}

	return localctx
}

// IDefaultDisplaySignClauseContext is an interface to support dynamic dispatch.
type IDefaultDisplaySignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultDisplaySignClauseContext differentiates from other interfaces.
	IsDefaultDisplaySignClauseContext()
}

type DefaultDisplaySignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultDisplaySignClauseContext() *DefaultDisplaySignClauseContext {
	var p = new(DefaultDisplaySignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_defaultDisplaySignClause
	return p
}

func (*DefaultDisplaySignClauseContext) IsDefaultDisplaySignClauseContext() {}

func NewDefaultDisplaySignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultDisplaySignClauseContext {
	var p = new(DefaultDisplaySignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_defaultDisplaySignClause

	return p
}

func (s *DefaultDisplaySignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultDisplaySignClauseContext) DEFAULT_DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFAULT_DISPLAY, 0)
}

func (s *DefaultDisplaySignClauseContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *DefaultDisplaySignClauseContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRAILING, 0)
}

func (s *DefaultDisplaySignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *DefaultDisplaySignClauseContext) SEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEPARATE, 0)
}

func (s *DefaultDisplaySignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DefaultDisplaySignClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *DefaultDisplaySignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultDisplaySignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultDisplaySignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDefaultDisplaySignClause(s)
	}
}

func (s *DefaultDisplaySignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDefaultDisplaySignClause(s)
	}
}

func (s *DefaultDisplaySignClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDefaultDisplaySignClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DefaultDisplaySignClause() (localctx IDefaultDisplaySignClauseContext) {
	localctx = NewDefaultDisplaySignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, Cobol85ParserRULE_defaultDisplaySignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1608)
		p.Match(Cobol85ParserDEFAULT_DISPLAY)
	}
	p.SetState(1613)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIGN {
		{
			p.SetState(1609)
			p.Match(Cobol85ParserSIGN)
		}
		p.SetState(1611)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1610)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	p.SetState(1615)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(1620)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSEPARATE {
		{
			p.SetState(1616)
			p.Match(Cobol85ParserSEPARATE)
		}
		p.SetState(1618)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserCHARACTER {
			{
				p.SetState(1617)
				p.Match(Cobol85ParserCHARACTER)
			}

		}

	}

	return localctx
}

// IEnvironmentSwitchNameClauseContext is an interface to support dynamic dispatch.
type IEnvironmentSwitchNameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnvironmentSwitchNameClauseContext differentiates from other interfaces.
	IsEnvironmentSwitchNameClauseContext()
}

type EnvironmentSwitchNameClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnvironmentSwitchNameClauseContext() *EnvironmentSwitchNameClauseContext {
	var p = new(EnvironmentSwitchNameClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_environmentSwitchNameClause
	return p
}

func (*EnvironmentSwitchNameClauseContext) IsEnvironmentSwitchNameClauseContext() {}

func NewEnvironmentSwitchNameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnvironmentSwitchNameClauseContext {
	var p = new(EnvironmentSwitchNameClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_environmentSwitchNameClause

	return p
}

func (s *EnvironmentSwitchNameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *EnvironmentSwitchNameClauseContext) EnvironmentName() IEnvironmentNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnvironmentNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnvironmentNameContext)
}

func (s *EnvironmentSwitchNameClauseContext) MnemonicName() IMnemonicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMnemonicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *EnvironmentSwitchNameClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *EnvironmentSwitchNameClauseContext) EnvironmentSwitchNameSpecialNamesStatusPhrase() IEnvironmentSwitchNameSpecialNamesStatusPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnvironmentSwitchNameSpecialNamesStatusPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnvironmentSwitchNameSpecialNamesStatusPhraseContext)
}

func (s *EnvironmentSwitchNameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnvironmentSwitchNameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnvironmentSwitchNameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnvironmentSwitchNameClause(s)
	}
}

func (s *EnvironmentSwitchNameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnvironmentSwitchNameClause(s)
	}
}

func (s *EnvironmentSwitchNameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEnvironmentSwitchNameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EnvironmentSwitchNameClause() (localctx IEnvironmentSwitchNameClauseContext) {
	localctx = NewEnvironmentSwitchNameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, Cobol85ParserRULE_environmentSwitchNameClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1631)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1622)
			p.EnvironmentName()
		}
		p.SetState(1624)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1623)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(1626)
			p.MnemonicName()
		}
		p.SetState(1628)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1627)
				p.EnvironmentSwitchNameSpecialNamesStatusPhrase()
			}

		}

	case Cobol85ParserOFF, Cobol85ParserON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1630)
			p.EnvironmentSwitchNameSpecialNamesStatusPhrase()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnvironmentSwitchNameSpecialNamesStatusPhraseContext is an interface to support dynamic dispatch.
type IEnvironmentSwitchNameSpecialNamesStatusPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnvironmentSwitchNameSpecialNamesStatusPhraseContext differentiates from other interfaces.
	IsEnvironmentSwitchNameSpecialNamesStatusPhraseContext()
}

type EnvironmentSwitchNameSpecialNamesStatusPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnvironmentSwitchNameSpecialNamesStatusPhraseContext() *EnvironmentSwitchNameSpecialNamesStatusPhraseContext {
	var p = new(EnvironmentSwitchNameSpecialNamesStatusPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_environmentSwitchNameSpecialNamesStatusPhrase
	return p
}

func (*EnvironmentSwitchNameSpecialNamesStatusPhraseContext) IsEnvironmentSwitchNameSpecialNamesStatusPhraseContext() {
}

func NewEnvironmentSwitchNameSpecialNamesStatusPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnvironmentSwitchNameSpecialNamesStatusPhraseContext {
	var p = new(EnvironmentSwitchNameSpecialNamesStatusPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_environmentSwitchNameSpecialNamesStatusPhrase

	return p
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) AllCondition() []IConditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConditionContext)(nil)).Elem())
	var tst = make([]IConditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConditionContext)
		}
	}

	return tst
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) Condition(i int) IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) AllSTATUS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserSTATUS)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) STATUS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTATUS, i)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) AllIS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserIS)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) IS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, i)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) OFF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOFF, 0)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnvironmentSwitchNameSpecialNamesStatusPhrase(s)
	}
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnvironmentSwitchNameSpecialNamesStatusPhrase(s)
	}
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEnvironmentSwitchNameSpecialNamesStatusPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EnvironmentSwitchNameSpecialNamesStatusPhrase() (localctx IEnvironmentSwitchNameSpecialNamesStatusPhraseContext) {
	localctx = NewEnvironmentSwitchNameSpecialNamesStatusPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, Cobol85ParserRULE_environmentSwitchNameSpecialNamesStatusPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1669)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1633)
			p.Match(Cobol85ParserON)
		}
		p.SetState(1635)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserSTATUS {
			{
				p.SetState(1634)
				p.Match(Cobol85ParserSTATUS)
			}

		}
		p.SetState(1638)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1637)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(1640)
			p.Condition()
		}
		p.SetState(1649)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1641)
				p.Match(Cobol85ParserOFF)
			}
			p.SetState(1643)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserSTATUS {
				{
					p.SetState(1642)
					p.Match(Cobol85ParserSTATUS)
				}

			}
			p.SetState(1646)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserIS {
				{
					p.SetState(1645)
					p.Match(Cobol85ParserIS)
				}

			}
			{
				p.SetState(1648)
				p.Condition()
			}

		}

	case Cobol85ParserOFF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1651)
			p.Match(Cobol85ParserOFF)
		}
		p.SetState(1653)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserSTATUS {
			{
				p.SetState(1652)
				p.Match(Cobol85ParserSTATUS)
			}

		}
		p.SetState(1656)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1655)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(1658)
			p.Condition()
		}
		p.SetState(1667)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1659)
				p.Match(Cobol85ParserON)
			}
			p.SetState(1661)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserSTATUS {
				{
					p.SetState(1660)
					p.Match(Cobol85ParserSTATUS)
				}

			}
			p.SetState(1664)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserIS {
				{
					p.SetState(1663)
					p.Match(Cobol85ParserIS)
				}

			}
			{
				p.SetState(1666)
				p.Condition()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOdtClauseContext is an interface to support dynamic dispatch.
type IOdtClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOdtClauseContext differentiates from other interfaces.
	IsOdtClauseContext()
}

type OdtClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOdtClauseContext() *OdtClauseContext {
	var p = new(OdtClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_odtClause
	return p
}

func (*OdtClauseContext) IsOdtClauseContext() {}

func NewOdtClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OdtClauseContext {
	var p = new(OdtClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_odtClause

	return p
}

func (s *OdtClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OdtClauseContext) ODT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserODT, 0)
}

func (s *OdtClauseContext) MnemonicName() IMnemonicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMnemonicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *OdtClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *OdtClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OdtClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OdtClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOdtClause(s)
	}
}

func (s *OdtClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOdtClause(s)
	}
}

func (s *OdtClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOdtClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OdtClause() (localctx IOdtClauseContext) {
	localctx = NewOdtClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, Cobol85ParserRULE_odtClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1671)
		p.Match(Cobol85ParserODT)
	}
	p.SetState(1673)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1672)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1675)
		p.MnemonicName()
	}

	return localctx
}

// IReserveNetworkClauseContext is an interface to support dynamic dispatch.
type IReserveNetworkClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReserveNetworkClauseContext differentiates from other interfaces.
	IsReserveNetworkClauseContext()
}

type ReserveNetworkClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReserveNetworkClauseContext() *ReserveNetworkClauseContext {
	var p = new(ReserveNetworkClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reserveNetworkClause
	return p
}

func (*ReserveNetworkClauseContext) IsReserveNetworkClauseContext() {}

func NewReserveNetworkClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReserveNetworkClauseContext {
	var p = new(ReserveNetworkClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reserveNetworkClause

	return p
}

func (s *ReserveNetworkClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReserveNetworkClauseContext) RESERVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRESERVE, 0)
}

func (s *ReserveNetworkClauseContext) NETWORK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNETWORK, 0)
}

func (s *ReserveNetworkClauseContext) WORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWORDS, 0)
}

func (s *ReserveNetworkClauseContext) LIST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIST, 0)
}

func (s *ReserveNetworkClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReserveNetworkClauseContext) CAPABLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCAPABLE, 0)
}

func (s *ReserveNetworkClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReserveNetworkClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReserveNetworkClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReserveNetworkClause(s)
	}
}

func (s *ReserveNetworkClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReserveNetworkClause(s)
	}
}

func (s *ReserveNetworkClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReserveNetworkClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReserveNetworkClause() (localctx IReserveNetworkClauseContext) {
	localctx = NewReserveNetworkClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, Cobol85ParserRULE_reserveNetworkClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1677)
		p.Match(Cobol85ParserRESERVE)
	}
	p.SetState(1679)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWORDS {
		{
			p.SetState(1678)
			p.Match(Cobol85ParserWORDS)
		}

	}
	p.SetState(1682)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLIST {
		{
			p.SetState(1681)
			p.Match(Cobol85ParserLIST)
		}

	}
	p.SetState(1685)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1684)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1687)
		p.Match(Cobol85ParserNETWORK)
	}
	p.SetState(1689)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1688)
			p.Match(Cobol85ParserCAPABLE)
		}

	}

	return localctx
}

// ISymbolicCharactersClauseContext is an interface to support dynamic dispatch.
type ISymbolicCharactersClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicCharactersClauseContext differentiates from other interfaces.
	IsSymbolicCharactersClauseContext()
}

type SymbolicCharactersClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicCharactersClauseContext() *SymbolicCharactersClauseContext {
	var p = new(SymbolicCharactersClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicCharactersClause
	return p
}

func (*SymbolicCharactersClauseContext) IsSymbolicCharactersClauseContext() {}

func NewSymbolicCharactersClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicCharactersClauseContext {
	var p = new(SymbolicCharactersClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicCharactersClause

	return p
}

func (s *SymbolicCharactersClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicCharactersClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicCharactersClauseContext) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *SymbolicCharactersClauseContext) AllSymbolicCharacters() []ISymbolicCharactersContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolicCharactersContext)(nil)).Elem())
	var tst = make([]ISymbolicCharactersContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolicCharactersContext)
		}
	}

	return tst
}

func (s *SymbolicCharactersClauseContext) SymbolicCharacters(i int) ISymbolicCharactersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicCharactersContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolicCharactersContext)
}

func (s *SymbolicCharactersClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *SymbolicCharactersClauseContext) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *SymbolicCharactersClauseContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *SymbolicCharactersClauseContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *SymbolicCharactersClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *SymbolicCharactersClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicCharactersClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicCharactersClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicCharactersClause(s)
	}
}

func (s *SymbolicCharactersClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicCharactersClause(s)
	}
}

func (s *SymbolicCharactersClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSymbolicCharactersClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SymbolicCharactersClause() (localctx ISymbolicCharactersClauseContext) {
	localctx = NewSymbolicCharactersClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, Cobol85ParserRULE_symbolicCharactersClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1691)
		p.Match(Cobol85ParserSYMBOLIC)
	}
	p.SetState(1693)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTERS {
		{
			p.SetState(1692)
			p.Match(Cobol85ParserCHARACTERS)
		}

	}
	p.SetState(1699)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) == 1 {
		p.SetState(1696)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFOR {
			{
				p.SetState(1695)
				p.Match(Cobol85ParserFOR)
			}

		}
		p.SetState(1698)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserALPHANUMERIC || _la == Cobol85ParserNATIONAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	p.SetState(1702)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1701)
				p.SymbolicCharacters()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1704)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext())
	}
	p.SetState(1708)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(1706)
			p.Match(Cobol85ParserIN)
		}
		{
			p.SetState(1707)
			p.AlphabetName()
		}

	}

	return localctx
}

// ISymbolicCharactersContext is an interface to support dynamic dispatch.
type ISymbolicCharactersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicCharactersContext differentiates from other interfaces.
	IsSymbolicCharactersContext()
}

type SymbolicCharactersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicCharactersContext() *SymbolicCharactersContext {
	var p = new(SymbolicCharactersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicCharacters
	return p
}

func (*SymbolicCharactersContext) IsSymbolicCharactersContext() {}

func NewSymbolicCharactersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicCharactersContext {
	var p = new(SymbolicCharactersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicCharacters

	return p
}

func (s *SymbolicCharactersContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicCharactersContext) AllSymbolicCharacter() []ISymbolicCharacterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolicCharacterContext)(nil)).Elem())
	var tst = make([]ISymbolicCharacterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolicCharacterContext)
		}
	}

	return tst
}

func (s *SymbolicCharactersContext) SymbolicCharacter(i int) ISymbolicCharacterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicCharacterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolicCharacterContext)
}

func (s *SymbolicCharactersContext) AllIntegerLiteral() []IIntegerLiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem())
	var tst = make([]IIntegerLiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntegerLiteralContext)
		}
	}

	return tst
}

func (s *SymbolicCharactersContext) IntegerLiteral(i int) IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *SymbolicCharactersContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicCharactersContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *SymbolicCharactersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicCharactersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicCharactersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicCharacters(s)
	}
}

func (s *SymbolicCharactersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicCharacters(s)
	}
}

func (s *SymbolicCharactersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSymbolicCharacters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SymbolicCharacters() (localctx ISymbolicCharactersContext) {
	localctx = NewSymbolicCharactersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, Cobol85ParserRULE_symbolicCharacters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1711)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(1710)
			p.SymbolicCharacter()
		}

		p.SetState(1713)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1716)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserARE || _la == Cobol85ParserIS {
		p.SetState(1715)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserARE || _la == Cobol85ParserIS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	p.SetState(1719)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556)))) != 0) {
		{
			p.SetState(1718)
			p.IntegerLiteral()
		}

		p.SetState(1721)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInputOutputSectionContext is an interface to support dynamic dispatch.
type IInputOutputSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInputOutputSectionContext differentiates from other interfaces.
	IsInputOutputSectionContext()
}

type InputOutputSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInputOutputSectionContext() *InputOutputSectionContext {
	var p = new(InputOutputSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inputOutputSection
	return p
}

func (*InputOutputSectionContext) IsInputOutputSectionContext() {}

func NewInputOutputSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InputOutputSectionContext {
	var p = new(InputOutputSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inputOutputSection

	return p
}

func (s *InputOutputSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *InputOutputSectionContext) INPUT_OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT_OUTPUT, 0)
}

func (s *InputOutputSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *InputOutputSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *InputOutputSectionContext) AllInputOutputSectionParagraph() []IInputOutputSectionParagraphContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInputOutputSectionParagraphContext)(nil)).Elem())
	var tst = make([]IInputOutputSectionParagraphContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInputOutputSectionParagraphContext)
		}
	}

	return tst
}

func (s *InputOutputSectionContext) InputOutputSectionParagraph(i int) IInputOutputSectionParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInputOutputSectionParagraphContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInputOutputSectionParagraphContext)
}

func (s *InputOutputSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InputOutputSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InputOutputSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInputOutputSection(s)
	}
}

func (s *InputOutputSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInputOutputSection(s)
	}
}

func (s *InputOutputSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInputOutputSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InputOutputSection() (localctx IInputOutputSectionContext) {
	localctx = NewInputOutputSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, Cobol85ParserRULE_inputOutputSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1723)
		p.Match(Cobol85ParserINPUT_OUTPUT)
	}
	{
		p.SetState(1724)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(1725)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1729)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserFILE_CONTROL || _la == Cobol85ParserI_O_CONTROL {
		{
			p.SetState(1726)
			p.InputOutputSectionParagraph()
		}

		p.SetState(1731)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInputOutputSectionParagraphContext is an interface to support dynamic dispatch.
type IInputOutputSectionParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInputOutputSectionParagraphContext differentiates from other interfaces.
	IsInputOutputSectionParagraphContext()
}

type InputOutputSectionParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInputOutputSectionParagraphContext() *InputOutputSectionParagraphContext {
	var p = new(InputOutputSectionParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inputOutputSectionParagraph
	return p
}

func (*InputOutputSectionParagraphContext) IsInputOutputSectionParagraphContext() {}

func NewInputOutputSectionParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InputOutputSectionParagraphContext {
	var p = new(InputOutputSectionParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inputOutputSectionParagraph

	return p
}

func (s *InputOutputSectionParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *InputOutputSectionParagraphContext) FileControlParagraph() IFileControlParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileControlParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileControlParagraphContext)
}

func (s *InputOutputSectionParagraphContext) IoControlParagraph() IIoControlParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIoControlParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIoControlParagraphContext)
}

func (s *InputOutputSectionParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InputOutputSectionParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InputOutputSectionParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInputOutputSectionParagraph(s)
	}
}

func (s *InputOutputSectionParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInputOutputSectionParagraph(s)
	}
}

func (s *InputOutputSectionParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInputOutputSectionParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InputOutputSectionParagraph() (localctx IInputOutputSectionParagraphContext) {
	localctx = NewInputOutputSectionParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, Cobol85ParserRULE_inputOutputSectionParagraph)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1734)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserFILE_CONTROL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1732)
			p.FileControlParagraph()
		}

	case Cobol85ParserI_O_CONTROL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1733)
			p.IoControlParagraph()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFileControlParagraphContext is an interface to support dynamic dispatch.
type IFileControlParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileControlParagraphContext differentiates from other interfaces.
	IsFileControlParagraphContext()
}

type FileControlParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileControlParagraphContext() *FileControlParagraphContext {
	var p = new(FileControlParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileControlParagraph
	return p
}

func (*FileControlParagraphContext) IsFileControlParagraphContext() {}

func NewFileControlParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileControlParagraphContext {
	var p = new(FileControlParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileControlParagraph

	return p
}

func (s *FileControlParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *FileControlParagraphContext) FILE_CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILE_CONTROL, 0)
}

func (s *FileControlParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *FileControlParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *FileControlParagraphContext) AllFileControlEntry() []IFileControlEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileControlEntryContext)(nil)).Elem())
	var tst = make([]IFileControlEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileControlEntryContext)
		}
	}

	return tst
}

func (s *FileControlParagraphContext) FileControlEntry(i int) IFileControlEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileControlEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileControlEntryContext)
}

func (s *FileControlParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileControlParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileControlParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileControlParagraph(s)
	}
}

func (s *FileControlParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileControlParagraph(s)
	}
}

func (s *FileControlParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFileControlParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FileControlParagraph() (localctx IFileControlParagraphContext) {
	localctx = NewFileControlParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, Cobol85ParserRULE_fileControlParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1736)
		p.Match(Cobol85ParserFILE_CONTROL)
	}
	p.SetState(1743)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1738)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserDOT_FS {
				{
					p.SetState(1737)
					p.Match(Cobol85ParserDOT_FS)
				}

			}
			{
				p.SetState(1740)
				p.FileControlEntry()
			}

		}
		p.SetState(1745)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext())
	}
	{
		p.SetState(1746)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IFileControlEntryContext is an interface to support dynamic dispatch.
type IFileControlEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileControlEntryContext differentiates from other interfaces.
	IsFileControlEntryContext()
}

type FileControlEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileControlEntryContext() *FileControlEntryContext {
	var p = new(FileControlEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileControlEntry
	return p
}

func (*FileControlEntryContext) IsFileControlEntryContext() {}

func NewFileControlEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileControlEntryContext {
	var p = new(FileControlEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileControlEntry

	return p
}

func (s *FileControlEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *FileControlEntryContext) SelectClause() ISelectClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *FileControlEntryContext) AllFileControlClause() []IFileControlClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileControlClauseContext)(nil)).Elem())
	var tst = make([]IFileControlClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileControlClauseContext)
		}
	}

	return tst
}

func (s *FileControlEntryContext) FileControlClause(i int) IFileControlClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileControlClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileControlClauseContext)
}

func (s *FileControlEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileControlEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileControlEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileControlEntry(s)
	}
}

func (s *FileControlEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileControlEntry(s)
	}
}

func (s *FileControlEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFileControlEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FileControlEntry() (localctx IFileControlEntryContext) {
	localctx = NewFileControlEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, Cobol85ParserRULE_fileControlEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1748)
		p.SelectClause()
	}
	p.SetState(1752)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserACCESS)|(1<<Cobol85ParserALTERNATE)|(1<<Cobol85ParserASSIGN))) != 0) || _la == Cobol85ParserBINARY || _la == Cobol85ParserFILE || _la == Cobol85ParserINDEXED || _la == Cobol85ParserLINE || (((_la-337)&-(0x1f+1)) == 0 && ((1<<uint((_la-337)))&((1<<(Cobol85ParserORGANIZATION-337))|(1<<(Cobol85ParserPADDING-337))|(1<<(Cobol85ParserPASSWORD-337)))) != 0) || (((_la-382)&-(0x1f+1)) == 0 && ((1<<uint((_la-382)))&((1<<(Cobol85ParserRECORD-382))|(1<<(Cobol85ParserRELATIVE-382))|(1<<(Cobol85ParserRESERVE-382)))) != 0) || _la == Cobol85ParserSEQUENTIAL || _la == Cobol85ParserSTATUS {
		{
			p.SetState(1749)
			p.FileControlClause()
		}

		p.SetState(1754)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISelectClauseContext is an interface to support dynamic dispatch.
type ISelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectClauseContext differentiates from other interfaces.
	IsSelectClauseContext()
}

type SelectClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectClauseContext() *SelectClauseContext {
	var p = new(SelectClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_selectClause
	return p
}

func (*SelectClauseContext) IsSelectClauseContext() {}

func NewSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectClauseContext {
	var p = new(SelectClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_selectClause

	return p
}

func (s *SelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectClauseContext) SELECT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSELECT, 0)
}

func (s *SelectClauseContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *SelectClauseContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOPTIONAL, 0)
}

func (s *SelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSelectClause(s)
	}
}

func (s *SelectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSelectClause(s)
	}
}

func (s *SelectClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSelectClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SelectClause() (localctx ISelectClauseContext) {
	localctx = NewSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, Cobol85ParserRULE_selectClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1755)
		p.Match(Cobol85ParserSELECT)
	}
	p.SetState(1757)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOPTIONAL {
		{
			p.SetState(1756)
			p.Match(Cobol85ParserOPTIONAL)
		}

	}
	{
		p.SetState(1759)
		p.FileName()
	}

	return localctx
}

// IFileControlClauseContext is an interface to support dynamic dispatch.
type IFileControlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileControlClauseContext differentiates from other interfaces.
	IsFileControlClauseContext()
}

type FileControlClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileControlClauseContext() *FileControlClauseContext {
	var p = new(FileControlClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileControlClause
	return p
}

func (*FileControlClauseContext) IsFileControlClauseContext() {}

func NewFileControlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileControlClauseContext {
	var p = new(FileControlClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileControlClause

	return p
}

func (s *FileControlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FileControlClauseContext) AssignClause() IAssignClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignClauseContext)
}

func (s *FileControlClauseContext) ReserveClause() IReserveClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReserveClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReserveClauseContext)
}

func (s *FileControlClauseContext) OrganizationClause() IOrganizationClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrganizationClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrganizationClauseContext)
}

func (s *FileControlClauseContext) PaddingCharacterClause() IPaddingCharacterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPaddingCharacterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPaddingCharacterClauseContext)
}

func (s *FileControlClauseContext) RecordDelimiterClause() IRecordDelimiterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordDelimiterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordDelimiterClauseContext)
}

func (s *FileControlClauseContext) AccessModeClause() IAccessModeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccessModeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccessModeClauseContext)
}

func (s *FileControlClauseContext) RecordKeyClause() IRecordKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordKeyClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordKeyClauseContext)
}

func (s *FileControlClauseContext) AlternateRecordKeyClause() IAlternateRecordKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternateRecordKeyClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternateRecordKeyClauseContext)
}

func (s *FileControlClauseContext) FileStatusClause() IFileStatusClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileStatusClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileStatusClauseContext)
}

func (s *FileControlClauseContext) PasswordClause() IPasswordClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPasswordClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPasswordClauseContext)
}

func (s *FileControlClauseContext) RelativeKeyClause() IRelativeKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelativeKeyClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelativeKeyClauseContext)
}

func (s *FileControlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileControlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileControlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileControlClause(s)
	}
}

func (s *FileControlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileControlClause(s)
	}
}

func (s *FileControlClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFileControlClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FileControlClause() (localctx IFileControlClauseContext) {
	localctx = NewFileControlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, Cobol85ParserRULE_fileControlClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1772)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1761)
			p.AssignClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1762)
			p.ReserveClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1763)
			p.OrganizationClause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1764)
			p.PaddingCharacterClause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1765)
			p.RecordDelimiterClause()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1766)
			p.AccessModeClause()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1767)
			p.RecordKeyClause()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1768)
			p.AlternateRecordKeyClause()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1769)
			p.FileStatusClause()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1770)
			p.PasswordClause()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1771)
			p.RelativeKeyClause()
		}

	}

	return localctx
}

// IAssignClauseContext is an interface to support dynamic dispatch.
type IAssignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignClauseContext differentiates from other interfaces.
	IsAssignClauseContext()
}

type AssignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignClauseContext() *AssignClauseContext {
	var p = new(AssignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_assignClause
	return p
}

func (*AssignClauseContext) IsAssignClauseContext() {}

func NewAssignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignClauseContext {
	var p = new(AssignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_assignClause

	return p
}

func (s *AssignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignClauseContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASSIGN, 0)
}

func (s *AssignClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISK, 0)
}

func (s *AssignClauseContext) PORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPORT, 0)
}

func (s *AssignClauseContext) PRINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPRINTER, 0)
}

func (s *AssignClauseContext) READER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREADER, 0)
}

func (s *AssignClauseContext) REMOTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOTE, 0)
}

func (s *AssignClauseContext) TAPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTAPE, 0)
}

func (s *AssignClauseContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVIRTUAL, 0)
}

func (s *AssignClauseContext) AssignmentName() IAssignmentNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentNameContext)
}

func (s *AssignClauseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AssignClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *AssignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAssignClause(s)
	}
}

func (s *AssignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAssignClause(s)
	}
}

func (s *AssignClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAssignClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AssignClause() (localctx IAssignClauseContext) {
	localctx = NewAssignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, Cobol85ParserRULE_assignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1774)
		p.Match(Cobol85ParserASSIGN)
	}
	p.SetState(1776)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(1775)
			p.Match(Cobol85ParserTO)
		}

	}
	p.SetState(1787)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1778)
			p.Match(Cobol85ParserDISK)
		}

	case 2:
		{
			p.SetState(1779)
			p.Match(Cobol85ParserPORT)
		}

	case 3:
		{
			p.SetState(1780)
			p.Match(Cobol85ParserPRINTER)
		}

	case 4:
		{
			p.SetState(1781)
			p.Match(Cobol85ParserREADER)
		}

	case 5:
		{
			p.SetState(1782)
			p.Match(Cobol85ParserREMOTE)
		}

	case 6:
		{
			p.SetState(1783)
			p.Match(Cobol85ParserTAPE)
		}

	case 7:
		{
			p.SetState(1784)
			p.Match(Cobol85ParserVIRTUAL)
		}

	case 8:
		{
			p.SetState(1785)
			p.AssignmentName()
		}

	case 9:
		{
			p.SetState(1786)
			p.Literal()
		}

	}

	return localctx
}

// IReserveClauseContext is an interface to support dynamic dispatch.
type IReserveClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReserveClauseContext differentiates from other interfaces.
	IsReserveClauseContext()
}

type ReserveClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReserveClauseContext() *ReserveClauseContext {
	var p = new(ReserveClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reserveClause
	return p
}

func (*ReserveClauseContext) IsReserveClauseContext() {}

func NewReserveClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReserveClauseContext {
	var p = new(ReserveClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reserveClause

	return p
}

func (s *ReserveClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReserveClauseContext) RESERVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRESERVE, 0)
}

func (s *ReserveClauseContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *ReserveClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReserveClauseContext) ALTERNATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALTERNATE, 0)
}

func (s *ReserveClauseContext) AREA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAREA, 0)
}

func (s *ReserveClauseContext) AREAS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAREAS, 0)
}

func (s *ReserveClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReserveClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReserveClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReserveClause(s)
	}
}

func (s *ReserveClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReserveClause(s)
	}
}

func (s *ReserveClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReserveClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReserveClause() (localctx IReserveClauseContext) {
	localctx = NewReserveClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, Cobol85ParserRULE_reserveClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1789)
		p.Match(Cobol85ParserRESERVE)
	}
	p.SetState(1792)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNO:
		{
			p.SetState(1790)
			p.Match(Cobol85ParserNO)
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(1791)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1795)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1794)
			p.Match(Cobol85ParserALTERNATE)
		}

	}
	p.SetState(1798)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAREA || _la == Cobol85ParserAREAS {
		p.SetState(1797)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserAREA || _la == Cobol85ParserAREAS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// IOrganizationClauseContext is an interface to support dynamic dispatch.
type IOrganizationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrganizationClauseContext differentiates from other interfaces.
	IsOrganizationClauseContext()
}

type OrganizationClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrganizationClauseContext() *OrganizationClauseContext {
	var p = new(OrganizationClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_organizationClause
	return p
}

func (*OrganizationClauseContext) IsOrganizationClauseContext() {}

func NewOrganizationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrganizationClauseContext {
	var p = new(OrganizationClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_organizationClause

	return p
}

func (s *OrganizationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrganizationClauseContext) SEQUENTIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEQUENTIAL, 0)
}

func (s *OrganizationClauseContext) RELATIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRELATIVE, 0)
}

func (s *OrganizationClauseContext) INDEXED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINDEXED, 0)
}

func (s *OrganizationClauseContext) ORGANIZATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserORGANIZATION, 0)
}

func (s *OrganizationClauseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *OrganizationClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *OrganizationClauseContext) BINARY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBINARY, 0)
}

func (s *OrganizationClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *OrganizationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrganizationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrganizationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOrganizationClause(s)
	}
}

func (s *OrganizationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOrganizationClause(s)
	}
}

func (s *OrganizationClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOrganizationClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OrganizationClause() (localctx IOrganizationClauseContext) {
	localctx = NewOrganizationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, Cobol85ParserRULE_organizationClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1804)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserORGANIZATION {
		{
			p.SetState(1800)
			p.Match(Cobol85ParserORGANIZATION)
		}
		p.SetState(1802)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1801)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	p.SetState(1811)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1806)
			p.Match(Cobol85ParserLINE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1807)
			p.Match(Cobol85ParserRECORD)
		}
		{
			p.SetState(1808)
			p.Match(Cobol85ParserBINARY)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(1809)
			p.Match(Cobol85ParserRECORD)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(1810)
			p.Match(Cobol85ParserBINARY)
		}

	}
	p.SetState(1813)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserINDEXED || _la == Cobol85ParserRELATIVE || _la == Cobol85ParserSEQUENTIAL) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IPaddingCharacterClauseContext is an interface to support dynamic dispatch.
type IPaddingCharacterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPaddingCharacterClauseContext differentiates from other interfaces.
	IsPaddingCharacterClauseContext()
}

type PaddingCharacterClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPaddingCharacterClauseContext() *PaddingCharacterClauseContext {
	var p = new(PaddingCharacterClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_paddingCharacterClause
	return p
}

func (*PaddingCharacterClauseContext) IsPaddingCharacterClauseContext() {}

func NewPaddingCharacterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PaddingCharacterClauseContext {
	var p = new(PaddingCharacterClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_paddingCharacterClause

	return p
}

func (s *PaddingCharacterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PaddingCharacterClauseContext) PADDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPADDING, 0)
}

func (s *PaddingCharacterClauseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *PaddingCharacterClauseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PaddingCharacterClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *PaddingCharacterClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *PaddingCharacterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PaddingCharacterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PaddingCharacterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPaddingCharacterClause(s)
	}
}

func (s *PaddingCharacterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPaddingCharacterClause(s)
	}
}

func (s *PaddingCharacterClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPaddingCharacterClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PaddingCharacterClause() (localctx IPaddingCharacterClauseContext) {
	localctx = NewPaddingCharacterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, Cobol85ParserRULE_paddingCharacterClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1815)
		p.Match(Cobol85ParserPADDING)
	}
	p.SetState(1817)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTER {
		{
			p.SetState(1816)
			p.Match(Cobol85ParserCHARACTER)
		}

	}
	p.SetState(1820)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1819)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1824)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1822)
			p.QualifiedDataName()
		}

	case 2:
		{
			p.SetState(1823)
			p.Literal()
		}

	}

	return localctx
}

// IRecordDelimiterClauseContext is an interface to support dynamic dispatch.
type IRecordDelimiterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordDelimiterClauseContext differentiates from other interfaces.
	IsRecordDelimiterClauseContext()
}

type RecordDelimiterClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordDelimiterClauseContext() *RecordDelimiterClauseContext {
	var p = new(RecordDelimiterClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordDelimiterClause
	return p
}

func (*RecordDelimiterClauseContext) IsRecordDelimiterClauseContext() {}

func NewRecordDelimiterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordDelimiterClauseContext {
	var p = new(RecordDelimiterClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordDelimiterClause

	return p
}

func (s *RecordDelimiterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordDelimiterClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *RecordDelimiterClauseContext) DELIMITER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDELIMITER, 0)
}

func (s *RecordDelimiterClauseContext) STANDARD_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTANDARD_1, 0)
}

func (s *RecordDelimiterClauseContext) IMPLICIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIMPLICIT, 0)
}

func (s *RecordDelimiterClauseContext) AssignmentName() IAssignmentNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentNameContext)
}

func (s *RecordDelimiterClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RecordDelimiterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordDelimiterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordDelimiterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordDelimiterClause(s)
	}
}

func (s *RecordDelimiterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordDelimiterClause(s)
	}
}

func (s *RecordDelimiterClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordDelimiterClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordDelimiterClause() (localctx IRecordDelimiterClauseContext) {
	localctx = NewRecordDelimiterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, Cobol85ParserRULE_recordDelimiterClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1826)
		p.Match(Cobol85ParserRECORD)
	}
	{
		p.SetState(1827)
		p.Match(Cobol85ParserDELIMITER)
	}
	p.SetState(1829)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1828)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1834)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1831)
			p.Match(Cobol85ParserSTANDARD_1)
		}

	case 2:
		{
			p.SetState(1832)
			p.Match(Cobol85ParserIMPLICIT)
		}

	case 3:
		{
			p.SetState(1833)
			p.AssignmentName()
		}

	}

	return localctx
}

// IAccessModeClauseContext is an interface to support dynamic dispatch.
type IAccessModeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAccessModeClauseContext differentiates from other interfaces.
	IsAccessModeClauseContext()
}

type AccessModeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessModeClauseContext() *AccessModeClauseContext {
	var p = new(AccessModeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_accessModeClause
	return p
}

func (*AccessModeClauseContext) IsAccessModeClauseContext() {}

func NewAccessModeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessModeClauseContext {
	var p = new(AccessModeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_accessModeClause

	return p
}

func (s *AccessModeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessModeClauseContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserACCESS, 0)
}

func (s *AccessModeClauseContext) SEQUENTIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEQUENTIAL, 0)
}

func (s *AccessModeClauseContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRANDOM, 0)
}

func (s *AccessModeClauseContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDYNAMIC, 0)
}

func (s *AccessModeClauseContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXCLUSIVE, 0)
}

func (s *AccessModeClauseContext) MODE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMODE, 0)
}

func (s *AccessModeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *AccessModeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessModeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessModeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAccessModeClause(s)
	}
}

func (s *AccessModeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAccessModeClause(s)
	}
}

func (s *AccessModeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAccessModeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AccessModeClause() (localctx IAccessModeClauseContext) {
	localctx = NewAccessModeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, Cobol85ParserRULE_accessModeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1836)
		p.Match(Cobol85ParserACCESS)
	}
	p.SetState(1838)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMODE {
		{
			p.SetState(1837)
			p.Match(Cobol85ParserMODE)
		}

	}
	p.SetState(1841)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1840)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1843)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserDYNAMIC || _la == Cobol85ParserEXCLUSIVE || _la == Cobol85ParserRANDOM || _la == Cobol85ParserSEQUENTIAL) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IRecordKeyClauseContext is an interface to support dynamic dispatch.
type IRecordKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordKeyClauseContext differentiates from other interfaces.
	IsRecordKeyClauseContext()
}

type RecordKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordKeyClauseContext() *RecordKeyClauseContext {
	var p = new(RecordKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordKeyClause
	return p
}

func (*RecordKeyClauseContext) IsRecordKeyClauseContext() {}

func NewRecordKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordKeyClauseContext {
	var p = new(RecordKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordKeyClause

	return p
}

func (s *RecordKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordKeyClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *RecordKeyClauseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *RecordKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *RecordKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RecordKeyClauseContext) PasswordClause() IPasswordClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPasswordClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPasswordClauseContext)
}

func (s *RecordKeyClauseContext) DUPLICATES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDUPLICATES, 0)
}

func (s *RecordKeyClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *RecordKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordKeyClause(s)
	}
}

func (s *RecordKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordKeyClause(s)
	}
}

func (s *RecordKeyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordKeyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordKeyClause() (localctx IRecordKeyClauseContext) {
	localctx = NewRecordKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, Cobol85ParserRULE_recordKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1845)
		p.Match(Cobol85ParserRECORD)
	}
	p.SetState(1847)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(1846)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(1850)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1849)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1852)
		p.QualifiedDataName()
	}
	p.SetState(1854)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1853)
			p.PasswordClause()
		}

	}
	p.SetState(1860)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDUPLICATES || _la == Cobol85ParserWITH {
		p.SetState(1857)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(1856)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(1859)
			p.Match(Cobol85ParserDUPLICATES)
		}

	}

	return localctx
}

// IAlternateRecordKeyClauseContext is an interface to support dynamic dispatch.
type IAlternateRecordKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlternateRecordKeyClauseContext differentiates from other interfaces.
	IsAlternateRecordKeyClauseContext()
}

type AlternateRecordKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlternateRecordKeyClauseContext() *AlternateRecordKeyClauseContext {
	var p = new(AlternateRecordKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alternateRecordKeyClause
	return p
}

func (*AlternateRecordKeyClauseContext) IsAlternateRecordKeyClauseContext() {}

func NewAlternateRecordKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlternateRecordKeyClauseContext {
	var p = new(AlternateRecordKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alternateRecordKeyClause

	return p
}

func (s *AlternateRecordKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlternateRecordKeyClauseContext) ALTERNATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALTERNATE, 0)
}

func (s *AlternateRecordKeyClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *AlternateRecordKeyClauseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *AlternateRecordKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *AlternateRecordKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *AlternateRecordKeyClauseContext) PasswordClause() IPasswordClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPasswordClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPasswordClauseContext)
}

func (s *AlternateRecordKeyClauseContext) DUPLICATES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDUPLICATES, 0)
}

func (s *AlternateRecordKeyClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *AlternateRecordKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlternateRecordKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlternateRecordKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlternateRecordKeyClause(s)
	}
}

func (s *AlternateRecordKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlternateRecordKeyClause(s)
	}
}

func (s *AlternateRecordKeyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlternateRecordKeyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlternateRecordKeyClause() (localctx IAlternateRecordKeyClauseContext) {
	localctx = NewAlternateRecordKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, Cobol85ParserRULE_alternateRecordKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1862)
		p.Match(Cobol85ParserALTERNATE)
	}
	{
		p.SetState(1863)
		p.Match(Cobol85ParserRECORD)
	}
	p.SetState(1865)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(1864)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(1868)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1867)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1870)
		p.QualifiedDataName()
	}
	p.SetState(1872)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1871)
			p.PasswordClause()
		}

	}
	p.SetState(1878)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDUPLICATES || _la == Cobol85ParserWITH {
		p.SetState(1875)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(1874)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(1877)
			p.Match(Cobol85ParserDUPLICATES)
		}

	}

	return localctx
}

// IPasswordClauseContext is an interface to support dynamic dispatch.
type IPasswordClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPasswordClauseContext differentiates from other interfaces.
	IsPasswordClauseContext()
}

type PasswordClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPasswordClauseContext() *PasswordClauseContext {
	var p = new(PasswordClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_passwordClause
	return p
}

func (*PasswordClauseContext) IsPasswordClauseContext() {}

func NewPasswordClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PasswordClauseContext {
	var p = new(PasswordClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_passwordClause

	return p
}

func (s *PasswordClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PasswordClauseContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPASSWORD, 0)
}

func (s *PasswordClauseContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *PasswordClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *PasswordClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PasswordClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPasswordClause(s)
	}
}

func (s *PasswordClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPasswordClause(s)
	}
}

func (s *PasswordClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPasswordClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PasswordClause() (localctx IPasswordClauseContext) {
	localctx = NewPasswordClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, Cobol85ParserRULE_passwordClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1880)
		p.Match(Cobol85ParserPASSWORD)
	}
	p.SetState(1882)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1881)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1884)
		p.DataName()
	}

	return localctx
}

// IFileStatusClauseContext is an interface to support dynamic dispatch.
type IFileStatusClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileStatusClauseContext differentiates from other interfaces.
	IsFileStatusClauseContext()
}

type FileStatusClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileStatusClauseContext() *FileStatusClauseContext {
	var p = new(FileStatusClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileStatusClause
	return p
}

func (*FileStatusClauseContext) IsFileStatusClauseContext() {}

func NewFileStatusClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileStatusClauseContext {
	var p = new(FileStatusClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileStatusClause

	return p
}

func (s *FileStatusClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FileStatusClauseContext) STATUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTATUS, 0)
}

func (s *FileStatusClauseContext) AllQualifiedDataName() []IQualifiedDataNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem())
	var tst = make([]IQualifiedDataNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedDataNameContext)
		}
	}

	return tst
}

func (s *FileStatusClauseContext) QualifiedDataName(i int) IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *FileStatusClauseContext) FILE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILE, 0)
}

func (s *FileStatusClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *FileStatusClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileStatusClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileStatusClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileStatusClause(s)
	}
}

func (s *FileStatusClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileStatusClause(s)
	}
}

func (s *FileStatusClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFileStatusClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FileStatusClause() (localctx IFileStatusClauseContext) {
	localctx = NewFileStatusClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, Cobol85ParserRULE_fileStatusClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1887)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFILE {
		{
			p.SetState(1886)
			p.Match(Cobol85ParserFILE)
		}

	}
	{
		p.SetState(1889)
		p.Match(Cobol85ParserSTATUS)
	}
	p.SetState(1891)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1890)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1893)
		p.QualifiedDataName()
	}
	p.SetState(1895)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1894)
			p.QualifiedDataName()
		}

	}

	return localctx
}

// IRelativeKeyClauseContext is an interface to support dynamic dispatch.
type IRelativeKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelativeKeyClauseContext differentiates from other interfaces.
	IsRelativeKeyClauseContext()
}

type RelativeKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelativeKeyClauseContext() *RelativeKeyClauseContext {
	var p = new(RelativeKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relativeKeyClause
	return p
}

func (*RelativeKeyClauseContext) IsRelativeKeyClauseContext() {}

func NewRelativeKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelativeKeyClauseContext {
	var p = new(RelativeKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relativeKeyClause

	return p
}

func (s *RelativeKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RelativeKeyClauseContext) RELATIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRELATIVE, 0)
}

func (s *RelativeKeyClauseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *RelativeKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *RelativeKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RelativeKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelativeKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelativeKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelativeKeyClause(s)
	}
}

func (s *RelativeKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelativeKeyClause(s)
	}
}

func (s *RelativeKeyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRelativeKeyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RelativeKeyClause() (localctx IRelativeKeyClauseContext) {
	localctx = NewRelativeKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, Cobol85ParserRULE_relativeKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1897)
		p.Match(Cobol85ParserRELATIVE)
	}
	p.SetState(1899)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(1898)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(1902)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1901)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1904)
		p.QualifiedDataName()
	}

	return localctx
}

// IIoControlParagraphContext is an interface to support dynamic dispatch.
type IIoControlParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIoControlParagraphContext differentiates from other interfaces.
	IsIoControlParagraphContext()
}

type IoControlParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIoControlParagraphContext() *IoControlParagraphContext {
	var p = new(IoControlParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_ioControlParagraph
	return p
}

func (*IoControlParagraphContext) IsIoControlParagraphContext() {}

func NewIoControlParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IoControlParagraphContext {
	var p = new(IoControlParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_ioControlParagraph

	return p
}

func (s *IoControlParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *IoControlParagraphContext) I_O_CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O_CONTROL, 0)
}

func (s *IoControlParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *IoControlParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *IoControlParagraphContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *IoControlParagraphContext) AllIoControlClause() []IIoControlClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIoControlClauseContext)(nil)).Elem())
	var tst = make([]IIoControlClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIoControlClauseContext)
		}
	}

	return tst
}

func (s *IoControlParagraphContext) IoControlClause(i int) IIoControlClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIoControlClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIoControlClauseContext)
}

func (s *IoControlParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IoControlParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IoControlParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIoControlParagraph(s)
	}
}

func (s *IoControlParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIoControlParagraph(s)
	}
}

func (s *IoControlParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIoControlParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IoControlParagraph() (localctx IIoControlParagraphContext) {
	localctx = NewIoControlParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, Cobol85ParserRULE_ioControlParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1906)
		p.Match(Cobol85ParserI_O_CONTROL)
	}
	{
		p.SetState(1907)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1911)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 149, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1908)
			p.FileName()
		}
		{
			p.SetState(1909)
			p.Match(Cobol85ParserDOT_FS)
		}

	}
	p.SetState(1920)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMITMENT || _la == Cobol85ParserMULTIPLE || _la == Cobol85ParserRERUN || _la == Cobol85ParserSAME || _la == Cobol85ParserDOT_FS {
		p.SetState(1916)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Cobol85ParserCOMMITMENT || _la == Cobol85ParserMULTIPLE || _la == Cobol85ParserRERUN || _la == Cobol85ParserSAME {
			{
				p.SetState(1913)
				p.IoControlClause()
			}

			p.SetState(1918)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1919)
			p.Match(Cobol85ParserDOT_FS)
		}

	}

	return localctx
}

// IIoControlClauseContext is an interface to support dynamic dispatch.
type IIoControlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIoControlClauseContext differentiates from other interfaces.
	IsIoControlClauseContext()
}

type IoControlClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIoControlClauseContext() *IoControlClauseContext {
	var p = new(IoControlClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_ioControlClause
	return p
}

func (*IoControlClauseContext) IsIoControlClauseContext() {}

func NewIoControlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IoControlClauseContext {
	var p = new(IoControlClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_ioControlClause

	return p
}

func (s *IoControlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IoControlClauseContext) RerunClause() IRerunClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRerunClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRerunClauseContext)
}

func (s *IoControlClauseContext) SameClause() ISameClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISameClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISameClauseContext)
}

func (s *IoControlClauseContext) MultipleFileClause() IMultipleFileClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultipleFileClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultipleFileClauseContext)
}

func (s *IoControlClauseContext) CommitmentControlClause() ICommitmentControlClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommitmentControlClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommitmentControlClauseContext)
}

func (s *IoControlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IoControlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IoControlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIoControlClause(s)
	}
}

func (s *IoControlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIoControlClause(s)
	}
}

func (s *IoControlClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIoControlClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IoControlClause() (localctx IIoControlClauseContext) {
	localctx = NewIoControlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, Cobol85ParserRULE_ioControlClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1926)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserRERUN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1922)
			p.RerunClause()
		}

	case Cobol85ParserSAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1923)
			p.SameClause()
		}

	case Cobol85ParserMULTIPLE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1924)
			p.MultipleFileClause()
		}

	case Cobol85ParserCOMMITMENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1925)
			p.CommitmentControlClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRerunClauseContext is an interface to support dynamic dispatch.
type IRerunClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRerunClauseContext differentiates from other interfaces.
	IsRerunClauseContext()
}

type RerunClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRerunClauseContext() *RerunClauseContext {
	var p = new(RerunClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rerunClause
	return p
}

func (*RerunClauseContext) IsRerunClauseContext() {}

func NewRerunClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RerunClauseContext {
	var p = new(RerunClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rerunClause

	return p
}

func (s *RerunClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RerunClauseContext) RERUN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRERUN, 0)
}

func (s *RerunClauseContext) EVERY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEVERY, 0)
}

func (s *RerunClauseContext) RerunEveryRecords() IRerunEveryRecordsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRerunEveryRecordsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRerunEveryRecordsContext)
}

func (s *RerunClauseContext) RerunEveryOf() IRerunEveryOfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRerunEveryOfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRerunEveryOfContext)
}

func (s *RerunClauseContext) RerunEveryClock() IRerunEveryClockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRerunEveryClockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRerunEveryClockContext)
}

func (s *RerunClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *RerunClauseContext) AssignmentName() IAssignmentNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentNameContext)
}

func (s *RerunClauseContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *RerunClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RerunClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RerunClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRerunClause(s)
	}
}

func (s *RerunClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRerunClause(s)
	}
}

func (s *RerunClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRerunClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RerunClause() (localctx IRerunClauseContext) {
	localctx = NewRerunClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, Cobol85ParserRULE_rerunClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1928)
		p.Match(Cobol85ParserRERUN)
	}
	p.SetState(1934)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(1929)
			p.Match(Cobol85ParserON)
		}
		p.SetState(1932)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1930)
				p.AssignmentName()
			}

		case 2:
			{
				p.SetState(1931)
				p.FileName()
			}

		}

	}
	{
		p.SetState(1936)
		p.Match(Cobol85ParserEVERY)
	}
	p.SetState(1940)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1937)
			p.RerunEveryRecords()
		}

	case 2:
		{
			p.SetState(1938)
			p.RerunEveryOf()
		}

	case 3:
		{
			p.SetState(1939)
			p.RerunEveryClock()
		}

	}

	return localctx
}

// IRerunEveryRecordsContext is an interface to support dynamic dispatch.
type IRerunEveryRecordsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRerunEveryRecordsContext differentiates from other interfaces.
	IsRerunEveryRecordsContext()
}

type RerunEveryRecordsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRerunEveryRecordsContext() *RerunEveryRecordsContext {
	var p = new(RerunEveryRecordsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rerunEveryRecords
	return p
}

func (*RerunEveryRecordsContext) IsRerunEveryRecordsContext() {}

func NewRerunEveryRecordsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RerunEveryRecordsContext {
	var p = new(RerunEveryRecordsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rerunEveryRecords

	return p
}

func (s *RerunEveryRecordsContext) GetParser() antlr.Parser { return s.parser }

func (s *RerunEveryRecordsContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RerunEveryRecordsContext) RECORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORDS, 0)
}

func (s *RerunEveryRecordsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RerunEveryRecordsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RerunEveryRecordsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRerunEveryRecords(s)
	}
}

func (s *RerunEveryRecordsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRerunEveryRecords(s)
	}
}

func (s *RerunEveryRecordsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRerunEveryRecords(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RerunEveryRecords() (localctx IRerunEveryRecordsContext) {
	localctx = NewRerunEveryRecordsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, Cobol85ParserRULE_rerunEveryRecords)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1942)
		p.IntegerLiteral()
	}
	{
		p.SetState(1943)
		p.Match(Cobol85ParserRECORDS)
	}

	return localctx
}

// IRerunEveryOfContext is an interface to support dynamic dispatch.
type IRerunEveryOfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRerunEveryOfContext differentiates from other interfaces.
	IsRerunEveryOfContext()
}

type RerunEveryOfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRerunEveryOfContext() *RerunEveryOfContext {
	var p = new(RerunEveryOfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rerunEveryOf
	return p
}

func (*RerunEveryOfContext) IsRerunEveryOfContext() {}

func NewRerunEveryOfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RerunEveryOfContext {
	var p = new(RerunEveryOfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rerunEveryOf

	return p
}

func (s *RerunEveryOfContext) GetParser() antlr.Parser { return s.parser }

func (s *RerunEveryOfContext) AllOF() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserOF)
}

func (s *RerunEveryOfContext) OF(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, i)
}

func (s *RerunEveryOfContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *RerunEveryOfContext) REEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREEL, 0)
}

func (s *RerunEveryOfContext) UNIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNIT, 0)
}

func (s *RerunEveryOfContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *RerunEveryOfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RerunEveryOfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RerunEveryOfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRerunEveryOf(s)
	}
}

func (s *RerunEveryOfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRerunEveryOf(s)
	}
}

func (s *RerunEveryOfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRerunEveryOf(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RerunEveryOf() (localctx IRerunEveryOfContext) {
	localctx = NewRerunEveryOfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, Cobol85ParserRULE_rerunEveryOf)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1946)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserEND {
		{
			p.SetState(1945)
			p.Match(Cobol85ParserEND)
		}

	}
	p.SetState(1949)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOF {
		{
			p.SetState(1948)
			p.Match(Cobol85ParserOF)
		}

	}
	p.SetState(1951)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserREEL || _la == Cobol85ParserUNIT) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(1952)
		p.Match(Cobol85ParserOF)
	}
	{
		p.SetState(1953)
		p.FileName()
	}

	return localctx
}

// IRerunEveryClockContext is an interface to support dynamic dispatch.
type IRerunEveryClockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRerunEveryClockContext differentiates from other interfaces.
	IsRerunEveryClockContext()
}

type RerunEveryClockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRerunEveryClockContext() *RerunEveryClockContext {
	var p = new(RerunEveryClockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rerunEveryClock
	return p
}

func (*RerunEveryClockContext) IsRerunEveryClockContext() {}

func NewRerunEveryClockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RerunEveryClockContext {
	var p = new(RerunEveryClockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rerunEveryClock

	return p
}

func (s *RerunEveryClockContext) GetParser() antlr.Parser { return s.parser }

func (s *RerunEveryClockContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RerunEveryClockContext) CLOCK_UNITS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCLOCK_UNITS, 0)
}

func (s *RerunEveryClockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RerunEveryClockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RerunEveryClockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRerunEveryClock(s)
	}
}

func (s *RerunEveryClockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRerunEveryClock(s)
	}
}

func (s *RerunEveryClockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRerunEveryClock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RerunEveryClock() (localctx IRerunEveryClockContext) {
	localctx = NewRerunEveryClockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, Cobol85ParserRULE_rerunEveryClock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1955)
		p.IntegerLiteral()
	}
	p.SetState(1957)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCLOCK_UNITS {
		{
			p.SetState(1956)
			p.Match(Cobol85ParserCLOCK_UNITS)
		}

	}

	return localctx
}

// ISameClauseContext is an interface to support dynamic dispatch.
type ISameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSameClauseContext differentiates from other interfaces.
	IsSameClauseContext()
}

type SameClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySameClauseContext() *SameClauseContext {
	var p = new(SameClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sameClause
	return p
}

func (*SameClauseContext) IsSameClauseContext() {}

func NewSameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SameClauseContext {
	var p = new(SameClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sameClause

	return p
}

func (s *SameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SameClauseContext) SAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSAME, 0)
}

func (s *SameClauseContext) AREA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAREA, 0)
}

func (s *SameClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *SameClauseContext) AllFileName() []IFileNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileNameContext)(nil)).Elem())
	var tst = make([]IFileNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileNameContext)
		}
	}

	return tst
}

func (s *SameClauseContext) FileName(i int) IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *SameClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *SameClauseContext) SORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT, 0)
}

func (s *SameClauseContext) SORT_MERGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_MERGE, 0)
}

func (s *SameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSameClause(s)
	}
}

func (s *SameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSameClause(s)
	}
}

func (s *SameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SameClause() (localctx ISameClauseContext) {
	localctx = NewSameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, Cobol85ParserRULE_sameClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1959)
		p.Match(Cobol85ParserSAME)
	}
	p.SetState(1961)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRECORD || _la == Cobol85ParserSORT || _la == Cobol85ParserSORT_MERGE {
		p.SetState(1960)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserRECORD || _la == Cobol85ParserSORT || _la == Cobol85ParserSORT_MERGE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	p.SetState(1964)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAREA {
		{
			p.SetState(1963)
			p.Match(Cobol85ParserAREA)
		}

	}
	p.SetState(1967)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1966)
			p.Match(Cobol85ParserFOR)
		}

	}
	p.SetState(1970)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1969)
				p.FileName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1972)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 162, p.GetParserRuleContext())
	}

	return localctx
}

// IMultipleFileClauseContext is an interface to support dynamic dispatch.
type IMultipleFileClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultipleFileClauseContext differentiates from other interfaces.
	IsMultipleFileClauseContext()
}

type MultipleFileClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultipleFileClauseContext() *MultipleFileClauseContext {
	var p = new(MultipleFileClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multipleFileClause
	return p
}

func (*MultipleFileClauseContext) IsMultipleFileClauseContext() {}

func NewMultipleFileClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleFileClauseContext {
	var p = new(MultipleFileClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multipleFileClause

	return p
}

func (s *MultipleFileClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleFileClauseContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMULTIPLE, 0)
}

func (s *MultipleFileClauseContext) FILE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILE, 0)
}

func (s *MultipleFileClauseContext) TAPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTAPE, 0)
}

func (s *MultipleFileClauseContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTAINS, 0)
}

func (s *MultipleFileClauseContext) AllMultipleFilePosition() []IMultipleFilePositionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultipleFilePositionContext)(nil)).Elem())
	var tst = make([]IMultipleFilePositionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultipleFilePositionContext)
		}
	}

	return tst
}

func (s *MultipleFileClauseContext) MultipleFilePosition(i int) IMultipleFilePositionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultipleFilePositionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultipleFilePositionContext)
}

func (s *MultipleFileClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleFileClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipleFileClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultipleFileClause(s)
	}
}

func (s *MultipleFileClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultipleFileClause(s)
	}
}

func (s *MultipleFileClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultipleFileClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultipleFileClause() (localctx IMultipleFileClauseContext) {
	localctx = NewMultipleFileClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, Cobol85ParserRULE_multipleFileClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1974)
		p.Match(Cobol85ParserMULTIPLE)
	}
	{
		p.SetState(1975)
		p.Match(Cobol85ParserFILE)
	}
	p.SetState(1977)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTAPE {
		{
			p.SetState(1976)
			p.Match(Cobol85ParserTAPE)
		}

	}
	p.SetState(1980)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCONTAINS {
		{
			p.SetState(1979)
			p.Match(Cobol85ParserCONTAINS)
		}

	}
	p.SetState(1983)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1982)
				p.MultipleFilePosition()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1985)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 165, p.GetParserRuleContext())
	}

	return localctx
}

// IMultipleFilePositionContext is an interface to support dynamic dispatch.
type IMultipleFilePositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultipleFilePositionContext differentiates from other interfaces.
	IsMultipleFilePositionContext()
}

type MultipleFilePositionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultipleFilePositionContext() *MultipleFilePositionContext {
	var p = new(MultipleFilePositionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multipleFilePosition
	return p
}

func (*MultipleFilePositionContext) IsMultipleFilePositionContext() {}

func NewMultipleFilePositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleFilePositionContext {
	var p = new(MultipleFilePositionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multipleFilePosition

	return p
}

func (s *MultipleFilePositionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleFilePositionContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *MultipleFilePositionContext) POSITION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPOSITION, 0)
}

func (s *MultipleFilePositionContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *MultipleFilePositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleFilePositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipleFilePositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultipleFilePosition(s)
	}
}

func (s *MultipleFilePositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultipleFilePosition(s)
	}
}

func (s *MultipleFilePositionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultipleFilePosition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultipleFilePosition() (localctx IMultipleFilePositionContext) {
	localctx = NewMultipleFilePositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, Cobol85ParserRULE_multipleFilePosition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1987)
		p.FileName()
	}
	p.SetState(1990)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPOSITION {
		{
			p.SetState(1988)
			p.Match(Cobol85ParserPOSITION)
		}
		{
			p.SetState(1989)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// ICommitmentControlClauseContext is an interface to support dynamic dispatch.
type ICommitmentControlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommitmentControlClauseContext differentiates from other interfaces.
	IsCommitmentControlClauseContext()
}

type CommitmentControlClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommitmentControlClauseContext() *CommitmentControlClauseContext {
	var p = new(CommitmentControlClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_commitmentControlClause
	return p
}

func (*CommitmentControlClauseContext) IsCommitmentControlClauseContext() {}

func NewCommitmentControlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommitmentControlClauseContext {
	var p = new(CommitmentControlClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_commitmentControlClause

	return p
}

func (s *CommitmentControlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CommitmentControlClauseContext) COMMITMENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMITMENT, 0)
}

func (s *CommitmentControlClauseContext) CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL, 0)
}

func (s *CommitmentControlClauseContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *CommitmentControlClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CommitmentControlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitmentControlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommitmentControlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommitmentControlClause(s)
	}
}

func (s *CommitmentControlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommitmentControlClause(s)
	}
}

func (s *CommitmentControlClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCommitmentControlClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CommitmentControlClause() (localctx ICommitmentControlClauseContext) {
	localctx = NewCommitmentControlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, Cobol85ParserRULE_commitmentControlClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1992)
		p.Match(Cobol85ParserCOMMITMENT)
	}
	{
		p.SetState(1993)
		p.Match(Cobol85ParserCONTROL)
	}
	p.SetState(1995)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1994)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(1997)
		p.FileName()
	}

	return localctx
}

// IDataDivisionContext is an interface to support dynamic dispatch.
type IDataDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDivisionContext differentiates from other interfaces.
	IsDataDivisionContext()
}

type DataDivisionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDivisionContext() *DataDivisionContext {
	var p = new(DataDivisionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDivision
	return p
}

func (*DataDivisionContext) IsDataDivisionContext() {}

func NewDataDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDivisionContext {
	var p = new(DataDivisionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDivision

	return p
}

func (s *DataDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDivisionContext) DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA, 0)
}

func (s *DataDivisionContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDIVISION, 0)
}

func (s *DataDivisionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataDivisionContext) DataDivisionBody() IDataDivisionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDivisionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDivisionBodyContext)
}

func (s *DataDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDivision(s)
	}
}

func (s *DataDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDivision(s)
	}
}

func (s *DataDivisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataDivision(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataDivision() (localctx IDataDivisionContext) {
	localctx = NewDataDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, Cobol85ParserRULE_dataDivision)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1999)
		p.Match(Cobol85ParserDATA)
	}
	{
		p.SetState(2000)
		p.Match(Cobol85ParserDIVISION)
	}
	{
		p.SetState(2001)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(2002)
		p.DataDivisionBody()
	}

	return localctx
}

// IDataDivisionBodyContext is an interface to support dynamic dispatch.
type IDataDivisionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDivisionBodyContext differentiates from other interfaces.
	IsDataDivisionBodyContext()
}

type DataDivisionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDivisionBodyContext() *DataDivisionBodyContext {
	var p = new(DataDivisionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDivisionBody
	return p
}

func (*DataDivisionBodyContext) IsDataDivisionBodyContext() {}

func NewDataDivisionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDivisionBodyContext {
	var p = new(DataDivisionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDivisionBody

	return p
}

func (s *DataDivisionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDivisionBodyContext) FileSection() IFileSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileSectionContext)
}

func (s *DataDivisionBodyContext) DataBaseSection() IDataBaseSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataBaseSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataBaseSectionContext)
}

func (s *DataDivisionBodyContext) WorkingStorageSection() IWorkingStorageSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWorkingStorageSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWorkingStorageSectionContext)
}

func (s *DataDivisionBodyContext) LinkageSection() ILinkageSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinkageSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinkageSectionContext)
}

func (s *DataDivisionBodyContext) CommunicationSection() ICommunicationSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommunicationSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommunicationSectionContext)
}

func (s *DataDivisionBodyContext) LocalStorageSection() ILocalStorageSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalStorageSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalStorageSectionContext)
}

func (s *DataDivisionBodyContext) ScreenSection() IScreenSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScreenSectionContext)
}

func (s *DataDivisionBodyContext) ReportSection() IReportSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportSectionContext)
}

func (s *DataDivisionBodyContext) ProgramLibrarySection() IProgramLibrarySectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramLibrarySectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgramLibrarySectionContext)
}

func (s *DataDivisionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDivisionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDivisionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDivisionBody(s)
	}
}

func (s *DataDivisionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDivisionBody(s)
	}
}

func (s *DataDivisionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataDivisionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataDivisionBody() (localctx IDataDivisionBodyContext) {
	localctx = NewDataDivisionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, Cobol85ParserRULE_dataDivisionBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2005)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFILE {
		{
			p.SetState(2004)
			p.FileSection()
		}

	}
	p.SetState(2008)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDATA_BASE {
		{
			p.SetState(2007)
			p.DataBaseSection()
		}

	}
	p.SetState(2011)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWORKING_STORAGE {
		{
			p.SetState(2010)
			p.WorkingStorageSection()
		}

	}
	p.SetState(2014)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINKAGE {
		{
			p.SetState(2013)
			p.LinkageSection()
		}

	}
	p.SetState(2017)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMUNICATION {
		{
			p.SetState(2016)
			p.CommunicationSection()
		}

	}
	p.SetState(2020)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLOCAL_STORAGE {
		{
			p.SetState(2019)
			p.LocalStorageSection()
		}

	}
	p.SetState(2023)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSCREEN {
		{
			p.SetState(2022)
			p.ScreenSection()
		}

	}
	p.SetState(2026)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserREPORT {
		{
			p.SetState(2025)
			p.ReportSection()
		}

	}
	p.SetState(2029)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPROGRAM_LIBRARY {
		{
			p.SetState(2028)
			p.ProgramLibrarySection()
		}

	}

	return localctx
}

// IFileSectionContext is an interface to support dynamic dispatch.
type IFileSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileSectionContext differentiates from other interfaces.
	IsFileSectionContext()
}

type FileSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileSectionContext() *FileSectionContext {
	var p = new(FileSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileSection
	return p
}

func (*FileSectionContext) IsFileSectionContext() {}

func NewFileSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileSectionContext {
	var p = new(FileSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileSection

	return p
}

func (s *FileSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *FileSectionContext) FILE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILE, 0)
}

func (s *FileSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *FileSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *FileSectionContext) AllFileDescriptionEntry() []IFileDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileDescriptionEntryContext)(nil)).Elem())
	var tst = make([]IFileDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileDescriptionEntryContext)
		}
	}

	return tst
}

func (s *FileSectionContext) FileDescriptionEntry(i int) IFileDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileDescriptionEntryContext)
}

func (s *FileSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileSection(s)
	}
}

func (s *FileSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileSection(s)
	}
}

func (s *FileSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFileSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FileSection() (localctx IFileSectionContext) {
	localctx = NewFileSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, Cobol85ParserRULE_fileSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2031)
		p.Match(Cobol85ParserFILE)
	}
	{
		p.SetState(2032)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2033)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2037)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserFD || _la == Cobol85ParserSD {
		{
			p.SetState(2034)
			p.FileDescriptionEntry()
		}

		p.SetState(2039)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFileDescriptionEntryContext is an interface to support dynamic dispatch.
type IFileDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileDescriptionEntryContext differentiates from other interfaces.
	IsFileDescriptionEntryContext()
}

type FileDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileDescriptionEntryContext() *FileDescriptionEntryContext {
	var p = new(FileDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileDescriptionEntry
	return p
}

func (*FileDescriptionEntryContext) IsFileDescriptionEntryContext() {}

func NewFileDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileDescriptionEntryContext {
	var p = new(FileDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileDescriptionEntry

	return p
}

func (s *FileDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *FileDescriptionEntryContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *FileDescriptionEntryContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *FileDescriptionEntryContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *FileDescriptionEntryContext) FD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFD, 0)
}

func (s *FileDescriptionEntryContext) SD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSD, 0)
}

func (s *FileDescriptionEntryContext) AllFileDescriptionEntryClause() []IFileDescriptionEntryClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileDescriptionEntryClauseContext)(nil)).Elem())
	var tst = make([]IFileDescriptionEntryClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileDescriptionEntryClauseContext)
		}
	}

	return tst
}

func (s *FileDescriptionEntryContext) FileDescriptionEntryClause(i int) IFileDescriptionEntryClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileDescriptionEntryClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileDescriptionEntryClauseContext)
}

func (s *FileDescriptionEntryContext) AllDataDescriptionEntry() []IDataDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem())
	var tst = make([]IDataDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataDescriptionEntryContext)
		}
	}

	return tst
}

func (s *FileDescriptionEntryContext) DataDescriptionEntry(i int) IDataDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryContext)
}

func (s *FileDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileDescriptionEntry(s)
	}
}

func (s *FileDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileDescriptionEntry(s)
	}
}

func (s *FileDescriptionEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFileDescriptionEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FileDescriptionEntry() (localctx IFileDescriptionEntryContext) {
	localctx = NewFileDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, Cobol85ParserRULE_fileDescriptionEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2040)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserFD || _la == Cobol85ParserSD) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(2041)
		p.FileName()
	}
	p.SetState(2048)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2043)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserDOT_FS {
				{
					p.SetState(2042)
					p.Match(Cobol85ParserDOT_FS)
				}

			}
			{
				p.SetState(2045)
				p.FileDescriptionEntryClause()
			}

		}
		p.SetState(2050)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext())
	}
	{
		p.SetState(2051)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2055)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserEXECSQLLINE-556)))) != 0 {
		{
			p.SetState(2052)
			p.DataDescriptionEntry()
		}

		p.SetState(2057)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFileDescriptionEntryClauseContext is an interface to support dynamic dispatch.
type IFileDescriptionEntryClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileDescriptionEntryClauseContext differentiates from other interfaces.
	IsFileDescriptionEntryClauseContext()
}

type FileDescriptionEntryClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileDescriptionEntryClauseContext() *FileDescriptionEntryClauseContext {
	var p = new(FileDescriptionEntryClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileDescriptionEntryClause
	return p
}

func (*FileDescriptionEntryClauseContext) IsFileDescriptionEntryClauseContext() {}

func NewFileDescriptionEntryClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileDescriptionEntryClauseContext {
	var p = new(FileDescriptionEntryClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileDescriptionEntryClause

	return p
}

func (s *FileDescriptionEntryClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FileDescriptionEntryClauseContext) ExternalClause() IExternalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExternalClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExternalClauseContext)
}

func (s *FileDescriptionEntryClauseContext) GlobalClause() IGlobalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobalClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobalClauseContext)
}

func (s *FileDescriptionEntryClauseContext) BlockContainsClause() IBlockContainsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContainsClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContainsClauseContext)
}

func (s *FileDescriptionEntryClauseContext) RecordContainsClause() IRecordContainsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordContainsClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordContainsClauseContext)
}

func (s *FileDescriptionEntryClauseContext) LabelRecordsClause() ILabelRecordsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabelRecordsClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabelRecordsClauseContext)
}

func (s *FileDescriptionEntryClauseContext) ValueOfClause() IValueOfClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueOfClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueOfClauseContext)
}

func (s *FileDescriptionEntryClauseContext) DataRecordsClause() IDataRecordsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataRecordsClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataRecordsClauseContext)
}

func (s *FileDescriptionEntryClauseContext) LinageClause() ILinageClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinageClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinageClauseContext)
}

func (s *FileDescriptionEntryClauseContext) CodeSetClause() ICodeSetClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeSetClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeSetClauseContext)
}

func (s *FileDescriptionEntryClauseContext) ReportClause() IReportClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportClauseContext)
}

func (s *FileDescriptionEntryClauseContext) RecordingModeClause() IRecordingModeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordingModeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordingModeClauseContext)
}

func (s *FileDescriptionEntryClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileDescriptionEntryClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileDescriptionEntryClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileDescriptionEntryClause(s)
	}
}

func (s *FileDescriptionEntryClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileDescriptionEntryClause(s)
	}
}

func (s *FileDescriptionEntryClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFileDescriptionEntryClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FileDescriptionEntryClause() (localctx IFileDescriptionEntryClauseContext) {
	localctx = NewFileDescriptionEntryClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, Cobol85ParserRULE_fileDescriptionEntryClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2069)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 181, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2058)
			p.ExternalClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2059)
			p.GlobalClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2060)
			p.BlockContainsClause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2061)
			p.RecordContainsClause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2062)
			p.LabelRecordsClause()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2063)
			p.ValueOfClause()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2064)
			p.DataRecordsClause()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2065)
			p.LinageClause()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2066)
			p.CodeSetClause()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2067)
			p.ReportClause()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2068)
			p.RecordingModeClause()
		}

	}

	return localctx
}

// IExternalClauseContext is an interface to support dynamic dispatch.
type IExternalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternalClauseContext differentiates from other interfaces.
	IsExternalClauseContext()
}

type ExternalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalClauseContext() *ExternalClauseContext {
	var p = new(ExternalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_externalClause
	return p
}

func (*ExternalClauseContext) IsExternalClauseContext() {}

func NewExternalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalClauseContext {
	var p = new(ExternalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_externalClause

	return p
}

func (s *ExternalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalClauseContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTERNAL, 0)
}

func (s *ExternalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ExternalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExternalClause(s)
	}
}

func (s *ExternalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExternalClause(s)
	}
}

func (s *ExternalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitExternalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ExternalClause() (localctx IExternalClauseContext) {
	localctx = NewExternalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, Cobol85ParserRULE_externalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2072)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2071)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2074)
		p.Match(Cobol85ParserEXTERNAL)
	}

	return localctx
}

// IGlobalClauseContext is an interface to support dynamic dispatch.
type IGlobalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalClauseContext differentiates from other interfaces.
	IsGlobalClauseContext()
}

type GlobalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalClauseContext() *GlobalClauseContext {
	var p = new(GlobalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_globalClause
	return p
}

func (*GlobalClauseContext) IsGlobalClauseContext() {}

func NewGlobalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalClauseContext {
	var p = new(GlobalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_globalClause

	return p
}

func (s *GlobalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGLOBAL, 0)
}

func (s *GlobalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *GlobalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGlobalClause(s)
	}
}

func (s *GlobalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGlobalClause(s)
	}
}

func (s *GlobalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitGlobalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) GlobalClause() (localctx IGlobalClauseContext) {
	localctx = NewGlobalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, Cobol85ParserRULE_globalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2077)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2076)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2079)
		p.Match(Cobol85ParserGLOBAL)
	}

	return localctx
}

// IBlockContainsClauseContext is an interface to support dynamic dispatch.
type IBlockContainsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContainsClauseContext differentiates from other interfaces.
	IsBlockContainsClauseContext()
}

type BlockContainsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContainsClauseContext() *BlockContainsClauseContext {
	var p = new(BlockContainsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_blockContainsClause
	return p
}

func (*BlockContainsClauseContext) IsBlockContainsClauseContext() {}

func NewBlockContainsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContainsClauseContext {
	var p = new(BlockContainsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_blockContainsClause

	return p
}

func (s *BlockContainsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContainsClauseContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLOCK, 0)
}

func (s *BlockContainsClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *BlockContainsClauseContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTAINS, 0)
}

func (s *BlockContainsClauseContext) BlockContainsTo() IBlockContainsToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContainsToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContainsToContext)
}

func (s *BlockContainsClauseContext) RECORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORDS, 0)
}

func (s *BlockContainsClauseContext) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *BlockContainsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContainsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContainsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterBlockContainsClause(s)
	}
}

func (s *BlockContainsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitBlockContainsClause(s)
	}
}

func (s *BlockContainsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitBlockContainsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) BlockContainsClause() (localctx IBlockContainsClauseContext) {
	localctx = NewBlockContainsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, Cobol85ParserRULE_blockContainsClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2081)
		p.Match(Cobol85ParserBLOCK)
	}
	p.SetState(2083)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCONTAINS {
		{
			p.SetState(2082)
			p.Match(Cobol85ParserCONTAINS)
		}

	}
	{
		p.SetState(2085)
		p.IntegerLiteral()
	}
	p.SetState(2087)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(2086)
			p.BlockContainsTo()
		}

	}
	p.SetState(2090)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTERS || _la == Cobol85ParserRECORDS {
		p.SetState(2089)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCHARACTERS || _la == Cobol85ParserRECORDS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// IBlockContainsToContext is an interface to support dynamic dispatch.
type IBlockContainsToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContainsToContext differentiates from other interfaces.
	IsBlockContainsToContext()
}

type BlockContainsToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContainsToContext() *BlockContainsToContext {
	var p = new(BlockContainsToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_blockContainsTo
	return p
}

func (*BlockContainsToContext) IsBlockContainsToContext() {}

func NewBlockContainsToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContainsToContext {
	var p = new(BlockContainsToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_blockContainsTo

	return p
}

func (s *BlockContainsToContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContainsToContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *BlockContainsToContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *BlockContainsToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContainsToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContainsToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterBlockContainsTo(s)
	}
}

func (s *BlockContainsToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitBlockContainsTo(s)
	}
}

func (s *BlockContainsToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitBlockContainsTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) BlockContainsTo() (localctx IBlockContainsToContext) {
	localctx = NewBlockContainsToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, Cobol85ParserRULE_blockContainsTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2092)
		p.Match(Cobol85ParserTO)
	}
	{
		p.SetState(2093)
		p.IntegerLiteral()
	}

	return localctx
}

// IRecordContainsClauseContext is an interface to support dynamic dispatch.
type IRecordContainsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordContainsClauseContext differentiates from other interfaces.
	IsRecordContainsClauseContext()
}

type RecordContainsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordContainsClauseContext() *RecordContainsClauseContext {
	var p = new(RecordContainsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordContainsClause
	return p
}

func (*RecordContainsClauseContext) IsRecordContainsClauseContext() {}

func NewRecordContainsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordContainsClauseContext {
	var p = new(RecordContainsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordContainsClause

	return p
}

func (s *RecordContainsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordContainsClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *RecordContainsClauseContext) RecordContainsClauseFormat1() IRecordContainsClauseFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordContainsClauseFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordContainsClauseFormat1Context)
}

func (s *RecordContainsClauseContext) RecordContainsClauseFormat2() IRecordContainsClauseFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordContainsClauseFormat2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordContainsClauseFormat2Context)
}

func (s *RecordContainsClauseContext) RecordContainsClauseFormat3() IRecordContainsClauseFormat3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordContainsClauseFormat3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordContainsClauseFormat3Context)
}

func (s *RecordContainsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordContainsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordContainsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordContainsClause(s)
	}
}

func (s *RecordContainsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordContainsClause(s)
	}
}

func (s *RecordContainsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordContainsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordContainsClause() (localctx IRecordContainsClauseContext) {
	localctx = NewRecordContainsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, Cobol85ParserRULE_recordContainsClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2095)
		p.Match(Cobol85ParserRECORD)
	}
	p.SetState(2099)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 187, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2096)
			p.RecordContainsClauseFormat1()
		}

	case 2:
		{
			p.SetState(2097)
			p.RecordContainsClauseFormat2()
		}

	case 3:
		{
			p.SetState(2098)
			p.RecordContainsClauseFormat3()
		}

	}

	return localctx
}

// IRecordContainsClauseFormat1Context is an interface to support dynamic dispatch.
type IRecordContainsClauseFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordContainsClauseFormat1Context differentiates from other interfaces.
	IsRecordContainsClauseFormat1Context()
}

type RecordContainsClauseFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordContainsClauseFormat1Context() *RecordContainsClauseFormat1Context {
	var p = new(RecordContainsClauseFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat1
	return p
}

func (*RecordContainsClauseFormat1Context) IsRecordContainsClauseFormat1Context() {}

func NewRecordContainsClauseFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordContainsClauseFormat1Context {
	var p = new(RecordContainsClauseFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat1

	return p
}

func (s *RecordContainsClauseFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *RecordContainsClauseFormat1Context) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RecordContainsClauseFormat1Context) CONTAINS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTAINS, 0)
}

func (s *RecordContainsClauseFormat1Context) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *RecordContainsClauseFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordContainsClauseFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordContainsClauseFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordContainsClauseFormat1(s)
	}
}

func (s *RecordContainsClauseFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordContainsClauseFormat1(s)
	}
}

func (s *RecordContainsClauseFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordContainsClauseFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordContainsClauseFormat1() (localctx IRecordContainsClauseFormat1Context) {
	localctx = NewRecordContainsClauseFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, Cobol85ParserRULE_recordContainsClauseFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2102)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCONTAINS {
		{
			p.SetState(2101)
			p.Match(Cobol85ParserCONTAINS)
		}

	}
	{
		p.SetState(2104)
		p.IntegerLiteral()
	}
	p.SetState(2106)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTERS {
		{
			p.SetState(2105)
			p.Match(Cobol85ParserCHARACTERS)
		}

	}

	return localctx
}

// IRecordContainsClauseFormat2Context is an interface to support dynamic dispatch.
type IRecordContainsClauseFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordContainsClauseFormat2Context differentiates from other interfaces.
	IsRecordContainsClauseFormat2Context()
}

type RecordContainsClauseFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordContainsClauseFormat2Context() *RecordContainsClauseFormat2Context {
	var p = new(RecordContainsClauseFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat2
	return p
}

func (*RecordContainsClauseFormat2Context) IsRecordContainsClauseFormat2Context() {}

func NewRecordContainsClauseFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordContainsClauseFormat2Context {
	var p = new(RecordContainsClauseFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat2

	return p
}

func (s *RecordContainsClauseFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *RecordContainsClauseFormat2Context) VARYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVARYING, 0)
}

func (s *RecordContainsClauseFormat2Context) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RecordContainsClauseFormat2Context) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *RecordContainsClauseFormat2Context) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *RecordContainsClauseFormat2Context) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RecordContainsClauseFormat2Context) DEPENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEPENDING, 0)
}

func (s *RecordContainsClauseFormat2Context) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *RecordContainsClauseFormat2Context) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *RecordContainsClauseFormat2Context) RecordContainsTo() IRecordContainsToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordContainsToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordContainsToContext)
}

func (s *RecordContainsClauseFormat2Context) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *RecordContainsClauseFormat2Context) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *RecordContainsClauseFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordContainsClauseFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordContainsClauseFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordContainsClauseFormat2(s)
	}
}

func (s *RecordContainsClauseFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordContainsClauseFormat2(s)
	}
}

func (s *RecordContainsClauseFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordContainsClauseFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordContainsClauseFormat2() (localctx IRecordContainsClauseFormat2Context) {
	localctx = NewRecordContainsClauseFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, Cobol85ParserRULE_recordContainsClauseFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2109)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2108)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2111)
		p.Match(Cobol85ParserVARYING)
	}
	p.SetState(2113)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(2112)
			p.Match(Cobol85ParserIN)
		}

	}
	p.SetState(2116)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIZE {
		{
			p.SetState(2115)
			p.Match(Cobol85ParserSIZE)
		}

	}
	p.SetState(2128)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFROM || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556)))) != 0) {
		p.SetState(2119)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFROM {
			{
				p.SetState(2118)
				p.Match(Cobol85ParserFROM)
			}

		}
		{
			p.SetState(2121)
			p.IntegerLiteral()
		}
		p.SetState(2123)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTO {
			{
				p.SetState(2122)
				p.RecordContainsTo()
			}

		}
		p.SetState(2126)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserCHARACTERS {
			{
				p.SetState(2125)
				p.Match(Cobol85ParserCHARACTERS)
			}

		}

	}
	p.SetState(2135)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDEPENDING {
		{
			p.SetState(2130)
			p.Match(Cobol85ParserDEPENDING)
		}
		p.SetState(2132)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserON {
			{
				p.SetState(2131)
				p.Match(Cobol85ParserON)
			}

		}
		{
			p.SetState(2134)
			p.QualifiedDataName()
		}

	}

	return localctx
}

// IRecordContainsClauseFormat3Context is an interface to support dynamic dispatch.
type IRecordContainsClauseFormat3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordContainsClauseFormat3Context differentiates from other interfaces.
	IsRecordContainsClauseFormat3Context()
}

type RecordContainsClauseFormat3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordContainsClauseFormat3Context() *RecordContainsClauseFormat3Context {
	var p = new(RecordContainsClauseFormat3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat3
	return p
}

func (*RecordContainsClauseFormat3Context) IsRecordContainsClauseFormat3Context() {}

func NewRecordContainsClauseFormat3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordContainsClauseFormat3Context {
	var p = new(RecordContainsClauseFormat3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat3

	return p
}

func (s *RecordContainsClauseFormat3Context) GetParser() antlr.Parser { return s.parser }

func (s *RecordContainsClauseFormat3Context) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RecordContainsClauseFormat3Context) RecordContainsTo() IRecordContainsToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordContainsToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordContainsToContext)
}

func (s *RecordContainsClauseFormat3Context) CONTAINS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTAINS, 0)
}

func (s *RecordContainsClauseFormat3Context) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *RecordContainsClauseFormat3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordContainsClauseFormat3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordContainsClauseFormat3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordContainsClauseFormat3(s)
	}
}

func (s *RecordContainsClauseFormat3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordContainsClauseFormat3(s)
	}
}

func (s *RecordContainsClauseFormat3Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordContainsClauseFormat3(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordContainsClauseFormat3() (localctx IRecordContainsClauseFormat3Context) {
	localctx = NewRecordContainsClauseFormat3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, Cobol85ParserRULE_recordContainsClauseFormat3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2138)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCONTAINS {
		{
			p.SetState(2137)
			p.Match(Cobol85ParserCONTAINS)
		}

	}
	{
		p.SetState(2140)
		p.IntegerLiteral()
	}
	{
		p.SetState(2141)
		p.RecordContainsTo()
	}
	p.SetState(2143)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTERS {
		{
			p.SetState(2142)
			p.Match(Cobol85ParserCHARACTERS)
		}

	}

	return localctx
}

// IRecordContainsToContext is an interface to support dynamic dispatch.
type IRecordContainsToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordContainsToContext differentiates from other interfaces.
	IsRecordContainsToContext()
}

type RecordContainsToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordContainsToContext() *RecordContainsToContext {
	var p = new(RecordContainsToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordContainsTo
	return p
}

func (*RecordContainsToContext) IsRecordContainsToContext() {}

func NewRecordContainsToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordContainsToContext {
	var p = new(RecordContainsToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordContainsTo

	return p
}

func (s *RecordContainsToContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordContainsToContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *RecordContainsToContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RecordContainsToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordContainsToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordContainsToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordContainsTo(s)
	}
}

func (s *RecordContainsToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordContainsTo(s)
	}
}

func (s *RecordContainsToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordContainsTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordContainsTo() (localctx IRecordContainsToContext) {
	localctx = NewRecordContainsToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, Cobol85ParserRULE_recordContainsTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2145)
		p.Match(Cobol85ParserTO)
	}
	{
		p.SetState(2146)
		p.IntegerLiteral()
	}

	return localctx
}

// ILabelRecordsClauseContext is an interface to support dynamic dispatch.
type ILabelRecordsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabelRecordsClauseContext differentiates from other interfaces.
	IsLabelRecordsClauseContext()
}

type LabelRecordsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelRecordsClauseContext() *LabelRecordsClauseContext {
	var p = new(LabelRecordsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_labelRecordsClause
	return p
}

func (*LabelRecordsClauseContext) IsLabelRecordsClauseContext() {}

func NewLabelRecordsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelRecordsClauseContext {
	var p = new(LabelRecordsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_labelRecordsClause

	return p
}

func (s *LabelRecordsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelRecordsClauseContext) LABEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLABEL, 0)
}

func (s *LabelRecordsClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *LabelRecordsClauseContext) RECORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORDS, 0)
}

func (s *LabelRecordsClauseContext) OMITTED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOMITTED, 0)
}

func (s *LabelRecordsClauseContext) STANDARD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTANDARD, 0)
}

func (s *LabelRecordsClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LabelRecordsClauseContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *LabelRecordsClauseContext) AllDataName() []IDataNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataNameContext)(nil)).Elem())
	var tst = make([]IDataNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataNameContext)
		}
	}

	return tst
}

func (s *LabelRecordsClauseContext) DataName(i int) IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LabelRecordsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelRecordsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelRecordsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLabelRecordsClause(s)
	}
}

func (s *LabelRecordsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLabelRecordsClause(s)
	}
}

func (s *LabelRecordsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLabelRecordsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LabelRecordsClause() (localctx ILabelRecordsClauseContext) {
	localctx = NewLabelRecordsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, Cobol85ParserRULE_labelRecordsClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2148)
		p.Match(Cobol85ParserLABEL)
	}
	p.SetState(2157)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserRECORD:
		{
			p.SetState(2149)
			p.Match(Cobol85ParserRECORD)
		}
		p.SetState(2151)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2150)
				p.Match(Cobol85ParserIS)
			}

		}

	case Cobol85ParserRECORDS:
		{
			p.SetState(2153)
			p.Match(Cobol85ParserRECORDS)
		}
		p.SetState(2155)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserARE {
			{
				p.SetState(2154)
				p.Match(Cobol85ParserARE)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2166)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserOMITTED:
		{
			p.SetState(2159)
			p.Match(Cobol85ParserOMITTED)
		}

	case Cobol85ParserSTANDARD:
		{
			p.SetState(2160)
			p.Match(Cobol85ParserSTANDARD)
		}

	case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.SetState(2162)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
			{
				p.SetState(2161)
				p.DataName()
			}

			p.SetState(2164)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IValueOfClauseContext is an interface to support dynamic dispatch.
type IValueOfClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueOfClauseContext differentiates from other interfaces.
	IsValueOfClauseContext()
}

type ValueOfClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueOfClauseContext() *ValueOfClauseContext {
	var p = new(ValueOfClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_valueOfClause
	return p
}

func (*ValueOfClauseContext) IsValueOfClauseContext() {}

func NewValueOfClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueOfClauseContext {
	var p = new(ValueOfClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_valueOfClause

	return p
}

func (s *ValueOfClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueOfClauseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUE, 0)
}

func (s *ValueOfClauseContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *ValueOfClauseContext) AllValuePair() []IValuePairContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValuePairContext)(nil)).Elem())
	var tst = make([]IValuePairContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValuePairContext)
		}
	}

	return tst
}

func (s *ValueOfClauseContext) ValuePair(i int) IValuePairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValuePairContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValuePairContext)
}

func (s *ValueOfClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueOfClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueOfClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterValueOfClause(s)
	}
}

func (s *ValueOfClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitValueOfClause(s)
	}
}

func (s *ValueOfClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitValueOfClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ValueOfClause() (localctx IValueOfClauseContext) {
	localctx = NewValueOfClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, Cobol85ParserRULE_valueOfClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2168)
		p.Match(Cobol85ParserVALUE)
	}
	{
		p.SetState(2169)
		p.Match(Cobol85ParserOF)
	}
	p.SetState(2171)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(2170)
			p.ValuePair()
		}

		p.SetState(2173)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IValuePairContext is an interface to support dynamic dispatch.
type IValuePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValuePairContext differentiates from other interfaces.
	IsValuePairContext()
}

type ValuePairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuePairContext() *ValuePairContext {
	var p = new(ValuePairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_valuePair
	return p
}

func (*ValuePairContext) IsValuePairContext() {}

func NewValuePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuePairContext {
	var p = new(ValuePairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_valuePair

	return p
}

func (s *ValuePairContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuePairContext) SystemName() ISystemNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystemNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystemNameContext)
}

func (s *ValuePairContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ValuePairContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ValuePairContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ValuePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterValuePair(s)
	}
}

func (s *ValuePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitValuePair(s)
	}
}

func (s *ValuePairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitValuePair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ValuePair() (localctx IValuePairContext) {
	localctx = NewValuePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, Cobol85ParserRULE_valuePair)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2175)
		p.SystemName()
	}
	p.SetState(2177)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2176)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2181)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2179)
			p.QualifiedDataName()
		}

	case 2:
		{
			p.SetState(2180)
			p.Literal()
		}

	}

	return localctx
}

// IDataRecordsClauseContext is an interface to support dynamic dispatch.
type IDataRecordsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataRecordsClauseContext differentiates from other interfaces.
	IsDataRecordsClauseContext()
}

type DataRecordsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataRecordsClauseContext() *DataRecordsClauseContext {
	var p = new(DataRecordsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataRecordsClause
	return p
}

func (*DataRecordsClauseContext) IsDataRecordsClauseContext() {}

func NewDataRecordsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataRecordsClauseContext {
	var p = new(DataRecordsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataRecordsClause

	return p
}

func (s *DataRecordsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataRecordsClauseContext) DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA, 0)
}

func (s *DataRecordsClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *DataRecordsClauseContext) RECORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORDS, 0)
}

func (s *DataRecordsClauseContext) AllDataName() []IDataNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataNameContext)(nil)).Elem())
	var tst = make([]IDataNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataNameContext)
		}
	}

	return tst
}

func (s *DataRecordsClauseContext) DataName(i int) IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataRecordsClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataRecordsClauseContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *DataRecordsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataRecordsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataRecordsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataRecordsClause(s)
	}
}

func (s *DataRecordsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataRecordsClause(s)
	}
}

func (s *DataRecordsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataRecordsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataRecordsClause() (localctx IDataRecordsClauseContext) {
	localctx = NewDataRecordsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, Cobol85ParserRULE_dataRecordsClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2183)
		p.Match(Cobol85ParserDATA)
	}
	p.SetState(2192)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserRECORD:
		{
			p.SetState(2184)
			p.Match(Cobol85ParserRECORD)
		}
		p.SetState(2186)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2185)
				p.Match(Cobol85ParserIS)
			}

		}

	case Cobol85ParserRECORDS:
		{
			p.SetState(2188)
			p.Match(Cobol85ParserRECORDS)
		}
		p.SetState(2190)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserARE {
			{
				p.SetState(2189)
				p.Match(Cobol85ParserARE)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2195)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(2194)
			p.DataName()
		}

		p.SetState(2197)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILinageClauseContext is an interface to support dynamic dispatch.
type ILinageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinageClauseContext differentiates from other interfaces.
	IsLinageClauseContext()
}

type LinageClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinageClauseContext() *LinageClauseContext {
	var p = new(LinageClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linageClause
	return p
}

func (*LinageClauseContext) IsLinageClauseContext() {}

func NewLinageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinageClauseContext {
	var p = new(LinageClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linageClause

	return p
}

func (s *LinageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LinageClauseContext) LINAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINAGE, 0)
}

func (s *LinageClauseContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LinageClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *LinageClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LinageClauseContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *LinageClauseContext) AllLinageAt() []ILinageAtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILinageAtContext)(nil)).Elem())
	var tst = make([]ILinageAtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILinageAtContext)
		}
	}

	return tst
}

func (s *LinageClauseContext) LinageAt(i int) ILinageAtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinageAtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILinageAtContext)
}

func (s *LinageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinageClause(s)
	}
}

func (s *LinageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinageClause(s)
	}
}

func (s *LinageClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLinageClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LinageClause() (localctx ILinageClauseContext) {
	localctx = NewLinageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, Cobol85ParserRULE_linageClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2199)
		p.Match(Cobol85ParserLINAGE)
	}
	p.SetState(2201)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2200)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2205)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2203)
			p.DataName()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2204)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2208)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 215, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2207)
			p.Match(Cobol85ParserLINES)
		}

	}
	p.SetState(2213)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAT || _la == Cobol85ParserBOTTOM || _la == Cobol85ParserFOOTING || _la == Cobol85ParserLINES || _la == Cobol85ParserTOP || _la == Cobol85ParserWITH {
		{
			p.SetState(2210)
			p.LinageAt()
		}

		p.SetState(2215)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILinageAtContext is an interface to support dynamic dispatch.
type ILinageAtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinageAtContext differentiates from other interfaces.
	IsLinageAtContext()
}

type LinageAtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinageAtContext() *LinageAtContext {
	var p = new(LinageAtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linageAt
	return p
}

func (*LinageAtContext) IsLinageAtContext() {}

func NewLinageAtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinageAtContext {
	var p = new(LinageAtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linageAt

	return p
}

func (s *LinageAtContext) GetParser() antlr.Parser { return s.parser }

func (s *LinageAtContext) LinageFootingAt() ILinageFootingAtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinageFootingAtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinageFootingAtContext)
}

func (s *LinageAtContext) LinageLinesAtTop() ILinageLinesAtTopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinageLinesAtTopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinageLinesAtTopContext)
}

func (s *LinageAtContext) LinageLinesAtBottom() ILinageLinesAtBottomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinageLinesAtBottomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinageLinesAtBottomContext)
}

func (s *LinageAtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinageAtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinageAtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinageAt(s)
	}
}

func (s *LinageAtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinageAt(s)
	}
}

func (s *LinageAtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLinageAt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LinageAt() (localctx ILinageAtContext) {
	localctx = NewLinageAtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, Cobol85ParserRULE_linageAt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2219)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 217, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2216)
			p.LinageFootingAt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2217)
			p.LinageLinesAtTop()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2218)
			p.LinageLinesAtBottom()
		}

	}

	return localctx
}

// ILinageFootingAtContext is an interface to support dynamic dispatch.
type ILinageFootingAtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinageFootingAtContext differentiates from other interfaces.
	IsLinageFootingAtContext()
}

type LinageFootingAtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinageFootingAtContext() *LinageFootingAtContext {
	var p = new(LinageFootingAtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linageFootingAt
	return p
}

func (*LinageFootingAtContext) IsLinageFootingAtContext() {}

func NewLinageFootingAtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinageFootingAtContext {
	var p = new(LinageFootingAtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linageFootingAt

	return p
}

func (s *LinageFootingAtContext) GetParser() antlr.Parser { return s.parser }

func (s *LinageFootingAtContext) FOOTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOOTING, 0)
}

func (s *LinageFootingAtContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LinageFootingAtContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *LinageFootingAtContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *LinageFootingAtContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *LinageFootingAtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinageFootingAtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinageFootingAtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinageFootingAt(s)
	}
}

func (s *LinageFootingAtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinageFootingAt(s)
	}
}

func (s *LinageFootingAtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLinageFootingAt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LinageFootingAt() (localctx ILinageFootingAtContext) {
	localctx = NewLinageFootingAtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, Cobol85ParserRULE_linageFootingAt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2222)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(2221)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(2224)
		p.Match(Cobol85ParserFOOTING)
	}
	p.SetState(2226)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(2225)
			p.Match(Cobol85ParserAT)
		}

	}
	p.SetState(2230)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2228)
			p.DataName()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2229)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILinageLinesAtTopContext is an interface to support dynamic dispatch.
type ILinageLinesAtTopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinageLinesAtTopContext differentiates from other interfaces.
	IsLinageLinesAtTopContext()
}

type LinageLinesAtTopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinageLinesAtTopContext() *LinageLinesAtTopContext {
	var p = new(LinageLinesAtTopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linageLinesAtTop
	return p
}

func (*LinageLinesAtTopContext) IsLinageLinesAtTopContext() {}

func NewLinageLinesAtTopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinageLinesAtTopContext {
	var p = new(LinageLinesAtTopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linageLinesAtTop

	return p
}

func (s *LinageLinesAtTopContext) GetParser() antlr.Parser { return s.parser }

func (s *LinageLinesAtTopContext) TOP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTOP, 0)
}

func (s *LinageLinesAtTopContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LinageLinesAtTopContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *LinageLinesAtTopContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *LinageLinesAtTopContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *LinageLinesAtTopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinageLinesAtTopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinageLinesAtTopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinageLinesAtTop(s)
	}
}

func (s *LinageLinesAtTopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinageLinesAtTop(s)
	}
}

func (s *LinageLinesAtTopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLinageLinesAtTop(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LinageLinesAtTop() (localctx ILinageLinesAtTopContext) {
	localctx = NewLinageLinesAtTopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, Cobol85ParserRULE_linageLinesAtTop)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2233)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINES {
		{
			p.SetState(2232)
			p.Match(Cobol85ParserLINES)
		}

	}
	p.SetState(2236)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(2235)
			p.Match(Cobol85ParserAT)
		}

	}
	{
		p.SetState(2238)
		p.Match(Cobol85ParserTOP)
	}
	p.SetState(2241)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2239)
			p.DataName()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2240)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILinageLinesAtBottomContext is an interface to support dynamic dispatch.
type ILinageLinesAtBottomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinageLinesAtBottomContext differentiates from other interfaces.
	IsLinageLinesAtBottomContext()
}

type LinageLinesAtBottomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinageLinesAtBottomContext() *LinageLinesAtBottomContext {
	var p = new(LinageLinesAtBottomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linageLinesAtBottom
	return p
}

func (*LinageLinesAtBottomContext) IsLinageLinesAtBottomContext() {}

func NewLinageLinesAtBottomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinageLinesAtBottomContext {
	var p = new(LinageLinesAtBottomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linageLinesAtBottom

	return p
}

func (s *LinageLinesAtBottomContext) GetParser() antlr.Parser { return s.parser }

func (s *LinageLinesAtBottomContext) BOTTOM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBOTTOM, 0)
}

func (s *LinageLinesAtBottomContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LinageLinesAtBottomContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *LinageLinesAtBottomContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *LinageLinesAtBottomContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *LinageLinesAtBottomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinageLinesAtBottomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinageLinesAtBottomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinageLinesAtBottom(s)
	}
}

func (s *LinageLinesAtBottomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinageLinesAtBottom(s)
	}
}

func (s *LinageLinesAtBottomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLinageLinesAtBottom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LinageLinesAtBottom() (localctx ILinageLinesAtBottomContext) {
	localctx = NewLinageLinesAtBottomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, Cobol85ParserRULE_linageLinesAtBottom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2244)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINES {
		{
			p.SetState(2243)
			p.Match(Cobol85ParserLINES)
		}

	}
	p.SetState(2247)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(2246)
			p.Match(Cobol85ParserAT)
		}

	}
	{
		p.SetState(2249)
		p.Match(Cobol85ParserBOTTOM)
	}
	p.SetState(2252)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2250)
			p.DataName()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2251)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRecordingModeClauseContext is an interface to support dynamic dispatch.
type IRecordingModeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordingModeClauseContext differentiates from other interfaces.
	IsRecordingModeClauseContext()
}

type RecordingModeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordingModeClauseContext() *RecordingModeClauseContext {
	var p = new(RecordingModeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordingModeClause
	return p
}

func (*RecordingModeClauseContext) IsRecordingModeClauseContext() {}

func NewRecordingModeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordingModeClauseContext {
	var p = new(RecordingModeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordingModeClause

	return p
}

func (s *RecordingModeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordingModeClauseContext) RECORDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORDING, 0)
}

func (s *RecordingModeClauseContext) ModeStatement() IModeStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModeStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModeStatementContext)
}

func (s *RecordingModeClauseContext) MODE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMODE, 0)
}

func (s *RecordingModeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RecordingModeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordingModeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordingModeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordingModeClause(s)
	}
}

func (s *RecordingModeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordingModeClause(s)
	}
}

func (s *RecordingModeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordingModeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordingModeClause() (localctx IRecordingModeClauseContext) {
	localctx = NewRecordingModeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, Cobol85ParserRULE_recordingModeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2254)
		p.Match(Cobol85ParserRECORDING)
	}
	p.SetState(2256)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMODE {
		{
			p.SetState(2255)
			p.Match(Cobol85ParserMODE)
		}

	}
	p.SetState(2259)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2258)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2261)
		p.ModeStatement()
	}

	return localctx
}

// IModeStatementContext is an interface to support dynamic dispatch.
type IModeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModeStatementContext differentiates from other interfaces.
	IsModeStatementContext()
}

type ModeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModeStatementContext() *ModeStatementContext {
	var p = new(ModeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_modeStatement
	return p
}

func (*ModeStatementContext) IsModeStatementContext() {}

func NewModeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModeStatementContext {
	var p = new(ModeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_modeStatement

	return p
}

func (s *ModeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ModeStatementContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ModeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterModeStatement(s)
	}
}

func (s *ModeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitModeStatement(s)
	}
}

func (s *ModeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitModeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ModeStatement() (localctx IModeStatementContext) {
	localctx = NewModeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, Cobol85ParserRULE_modeStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2263)
		p.CobolWord()
	}

	return localctx
}

// ICodeSetClauseContext is an interface to support dynamic dispatch.
type ICodeSetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCodeSetClauseContext differentiates from other interfaces.
	IsCodeSetClauseContext()
}

type CodeSetClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeSetClauseContext() *CodeSetClauseContext {
	var p = new(CodeSetClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_codeSetClause
	return p
}

func (*CodeSetClauseContext) IsCodeSetClauseContext() {}

func NewCodeSetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeSetClauseContext {
	var p = new(CodeSetClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_codeSetClause

	return p
}

func (s *CodeSetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeSetClauseContext) CODE_SET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCODE_SET, 0)
}

func (s *CodeSetClauseContext) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *CodeSetClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *CodeSetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeSetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeSetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCodeSetClause(s)
	}
}

func (s *CodeSetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCodeSetClause(s)
	}
}

func (s *CodeSetClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCodeSetClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CodeSetClause() (localctx ICodeSetClauseContext) {
	localctx = NewCodeSetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, Cobol85ParserRULE_codeSetClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2265)
		p.Match(Cobol85ParserCODE_SET)
	}
	p.SetState(2267)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2266)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2269)
		p.AlphabetName()
	}

	return localctx
}

// IReportClauseContext is an interface to support dynamic dispatch.
type IReportClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportClauseContext differentiates from other interfaces.
	IsReportClauseContext()
}

type ReportClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportClauseContext() *ReportClauseContext {
	var p = new(ReportClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportClause
	return p
}

func (*ReportClauseContext) IsReportClauseContext() {}

func NewReportClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportClauseContext {
	var p = new(ReportClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportClause

	return p
}

func (s *ReportClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportClauseContext) REPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPORT, 0)
}

func (s *ReportClauseContext) REPORTS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPORTS, 0)
}

func (s *ReportClauseContext) AllReportName() []IReportNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportNameContext)(nil)).Elem())
	var tst = make([]IReportNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportNameContext)
		}
	}

	return tst
}

func (s *ReportClauseContext) ReportName(i int) IReportNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportNameContext)
}

func (s *ReportClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportClauseContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *ReportClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportClause(s)
	}
}

func (s *ReportClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportClause(s)
	}
}

func (s *ReportClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportClause() (localctx IReportClauseContext) {
	localctx = NewReportClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, Cobol85ParserRULE_reportClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2279)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserREPORT:
		{
			p.SetState(2271)
			p.Match(Cobol85ParserREPORT)
		}
		p.SetState(2273)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2272)
				p.Match(Cobol85ParserIS)
			}

		}

	case Cobol85ParserREPORTS:
		{
			p.SetState(2275)
			p.Match(Cobol85ParserREPORTS)
		}
		p.SetState(2277)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserARE {
			{
				p.SetState(2276)
				p.Match(Cobol85ParserARE)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2282)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(2281)
			p.ReportName()
		}

		p.SetState(2284)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDataBaseSectionContext is an interface to support dynamic dispatch.
type IDataBaseSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataBaseSectionContext differentiates from other interfaces.
	IsDataBaseSectionContext()
}

type DataBaseSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataBaseSectionContext() *DataBaseSectionContext {
	var p = new(DataBaseSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataBaseSection
	return p
}

func (*DataBaseSectionContext) IsDataBaseSectionContext() {}

func NewDataBaseSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataBaseSectionContext {
	var p = new(DataBaseSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataBaseSection

	return p
}

func (s *DataBaseSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataBaseSectionContext) DATA_BASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA_BASE, 0)
}

func (s *DataBaseSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *DataBaseSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataBaseSectionContext) AllDataBaseSectionEntry() []IDataBaseSectionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataBaseSectionEntryContext)(nil)).Elem())
	var tst = make([]IDataBaseSectionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataBaseSectionEntryContext)
		}
	}

	return tst
}

func (s *DataBaseSectionContext) DataBaseSectionEntry(i int) IDataBaseSectionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataBaseSectionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataBaseSectionEntryContext)
}

func (s *DataBaseSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataBaseSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataBaseSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataBaseSection(s)
	}
}

func (s *DataBaseSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataBaseSection(s)
	}
}

func (s *DataBaseSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataBaseSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataBaseSection() (localctx IDataBaseSectionContext) {
	localctx = NewDataBaseSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, Cobol85ParserRULE_dataBaseSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2286)
		p.Match(Cobol85ParserDATA_BASE)
	}
	{
		p.SetState(2287)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2288)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2292)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556)))) != 0 {
		{
			p.SetState(2289)
			p.DataBaseSectionEntry()
		}

		p.SetState(2294)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDataBaseSectionEntryContext is an interface to support dynamic dispatch.
type IDataBaseSectionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataBaseSectionEntryContext differentiates from other interfaces.
	IsDataBaseSectionEntryContext()
}

type DataBaseSectionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataBaseSectionEntryContext() *DataBaseSectionEntryContext {
	var p = new(DataBaseSectionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataBaseSectionEntry
	return p
}

func (*DataBaseSectionEntryContext) IsDataBaseSectionEntryContext() {}

func NewDataBaseSectionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataBaseSectionEntryContext {
	var p = new(DataBaseSectionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataBaseSectionEntry

	return p
}

func (s *DataBaseSectionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *DataBaseSectionEntryContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *DataBaseSectionEntryContext) AllLiteral() []ILiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILiteralContext)(nil)).Elem())
	var tst = make([]ILiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILiteralContext)
		}
	}

	return tst
}

func (s *DataBaseSectionEntryContext) Literal(i int) ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DataBaseSectionEntryContext) INVOKE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINVOKE, 0)
}

func (s *DataBaseSectionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataBaseSectionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataBaseSectionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataBaseSectionEntry(s)
	}
}

func (s *DataBaseSectionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataBaseSectionEntry(s)
	}
}

func (s *DataBaseSectionEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataBaseSectionEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataBaseSectionEntry() (localctx IDataBaseSectionEntryContext) {
	localctx = NewDataBaseSectionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, Cobol85ParserRULE_dataBaseSectionEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2295)
		p.IntegerLiteral()
	}
	{
		p.SetState(2296)
		p.Literal()
	}
	{
		p.SetState(2297)
		p.Match(Cobol85ParserINVOKE)
	}
	{
		p.SetState(2298)
		p.Literal()
	}

	return localctx
}

// IWorkingStorageSectionContext is an interface to support dynamic dispatch.
type IWorkingStorageSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWorkingStorageSectionContext differentiates from other interfaces.
	IsWorkingStorageSectionContext()
}

type WorkingStorageSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkingStorageSectionContext() *WorkingStorageSectionContext {
	var p = new(WorkingStorageSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_workingStorageSection
	return p
}

func (*WorkingStorageSectionContext) IsWorkingStorageSectionContext() {}

func NewWorkingStorageSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkingStorageSectionContext {
	var p = new(WorkingStorageSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_workingStorageSection

	return p
}

func (s *WorkingStorageSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkingStorageSectionContext) WORKING_STORAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWORKING_STORAGE, 0)
}

func (s *WorkingStorageSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *WorkingStorageSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *WorkingStorageSectionContext) AllDataDescriptionEntry() []IDataDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem())
	var tst = make([]IDataDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataDescriptionEntryContext)
		}
	}

	return tst
}

func (s *WorkingStorageSectionContext) DataDescriptionEntry(i int) IDataDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryContext)
}

func (s *WorkingStorageSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkingStorageSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkingStorageSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWorkingStorageSection(s)
	}
}

func (s *WorkingStorageSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWorkingStorageSection(s)
	}
}

func (s *WorkingStorageSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWorkingStorageSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WorkingStorageSection() (localctx IWorkingStorageSectionContext) {
	localctx = NewWorkingStorageSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, Cobol85ParserRULE_workingStorageSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2300)
		p.Match(Cobol85ParserWORKING_STORAGE)
	}
	{
		p.SetState(2301)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2302)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2306)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserEXECSQLLINE-556)))) != 0 {
		{
			p.SetState(2303)
			p.DataDescriptionEntry()
		}

		p.SetState(2308)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILinkageSectionContext is an interface to support dynamic dispatch.
type ILinkageSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinkageSectionContext differentiates from other interfaces.
	IsLinkageSectionContext()
}

type LinkageSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinkageSectionContext() *LinkageSectionContext {
	var p = new(LinkageSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linkageSection
	return p
}

func (*LinkageSectionContext) IsLinkageSectionContext() {}

func NewLinkageSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinkageSectionContext {
	var p = new(LinkageSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linkageSection

	return p
}

func (s *LinkageSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *LinkageSectionContext) LINKAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINKAGE, 0)
}

func (s *LinkageSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *LinkageSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *LinkageSectionContext) AllDataDescriptionEntry() []IDataDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem())
	var tst = make([]IDataDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataDescriptionEntryContext)
		}
	}

	return tst
}

func (s *LinkageSectionContext) DataDescriptionEntry(i int) IDataDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryContext)
}

func (s *LinkageSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinkageSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinkageSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinkageSection(s)
	}
}

func (s *LinkageSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinkageSection(s)
	}
}

func (s *LinkageSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLinkageSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LinkageSection() (localctx ILinkageSectionContext) {
	localctx = NewLinkageSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, Cobol85ParserRULE_linkageSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2309)
		p.Match(Cobol85ParserLINKAGE)
	}
	{
		p.SetState(2310)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2311)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2315)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserEXECSQLLINE-556)))) != 0 {
		{
			p.SetState(2312)
			p.DataDescriptionEntry()
		}

		p.SetState(2317)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICommunicationSectionContext is an interface to support dynamic dispatch.
type ICommunicationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommunicationSectionContext differentiates from other interfaces.
	IsCommunicationSectionContext()
}

type CommunicationSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommunicationSectionContext() *CommunicationSectionContext {
	var p = new(CommunicationSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_communicationSection
	return p
}

func (*CommunicationSectionContext) IsCommunicationSectionContext() {}

func NewCommunicationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommunicationSectionContext {
	var p = new(CommunicationSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_communicationSection

	return p
}

func (s *CommunicationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *CommunicationSectionContext) COMMUNICATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMUNICATION, 0)
}

func (s *CommunicationSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *CommunicationSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *CommunicationSectionContext) AllCommunicationDescriptionEntry() []ICommunicationDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICommunicationDescriptionEntryContext)(nil)).Elem())
	var tst = make([]ICommunicationDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICommunicationDescriptionEntryContext)
		}
	}

	return tst
}

func (s *CommunicationSectionContext) CommunicationDescriptionEntry(i int) ICommunicationDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommunicationDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICommunicationDescriptionEntryContext)
}

func (s *CommunicationSectionContext) AllDataDescriptionEntry() []IDataDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem())
	var tst = make([]IDataDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataDescriptionEntryContext)
		}
	}

	return tst
}

func (s *CommunicationSectionContext) DataDescriptionEntry(i int) IDataDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryContext)
}

func (s *CommunicationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommunicationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommunicationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommunicationSection(s)
	}
}

func (s *CommunicationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommunicationSection(s)
	}
}

func (s *CommunicationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCommunicationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CommunicationSection() (localctx ICommunicationSectionContext) {
	localctx = NewCommunicationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, Cobol85ParserRULE_communicationSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2318)
		p.Match(Cobol85ParserCOMMUNICATION)
	}
	{
		p.SetState(2319)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2320)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2325)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserCD || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserEXECSQLLINE-556)))) != 0) {
		p.SetState(2323)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserCD:
			{
				p.SetState(2321)
				p.CommunicationDescriptionEntry()
			}

		case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserEXECSQLLINE:
			{
				p.SetState(2322)
				p.DataDescriptionEntry()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2327)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICommunicationDescriptionEntryContext is an interface to support dynamic dispatch.
type ICommunicationDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommunicationDescriptionEntryContext differentiates from other interfaces.
	IsCommunicationDescriptionEntryContext()
}

type CommunicationDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommunicationDescriptionEntryContext() *CommunicationDescriptionEntryContext {
	var p = new(CommunicationDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntry
	return p
}

func (*CommunicationDescriptionEntryContext) IsCommunicationDescriptionEntryContext() {}

func NewCommunicationDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommunicationDescriptionEntryContext {
	var p = new(CommunicationDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntry

	return p
}

func (s *CommunicationDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *CommunicationDescriptionEntryContext) CommunicationDescriptionEntryFormat1() ICommunicationDescriptionEntryFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommunicationDescriptionEntryFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommunicationDescriptionEntryFormat1Context)
}

func (s *CommunicationDescriptionEntryContext) CommunicationDescriptionEntryFormat2() ICommunicationDescriptionEntryFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommunicationDescriptionEntryFormat2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommunicationDescriptionEntryFormat2Context)
}

func (s *CommunicationDescriptionEntryContext) CommunicationDescriptionEntryFormat3() ICommunicationDescriptionEntryFormat3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommunicationDescriptionEntryFormat3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommunicationDescriptionEntryFormat3Context)
}

func (s *CommunicationDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommunicationDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommunicationDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommunicationDescriptionEntry(s)
	}
}

func (s *CommunicationDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommunicationDescriptionEntry(s)
	}
}

func (s *CommunicationDescriptionEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCommunicationDescriptionEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CommunicationDescriptionEntry() (localctx ICommunicationDescriptionEntryContext) {
	localctx = NewCommunicationDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, Cobol85ParserRULE_communicationDescriptionEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2331)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 239, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2328)
			p.CommunicationDescriptionEntryFormat1()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2329)
			p.CommunicationDescriptionEntryFormat2()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2330)
			p.CommunicationDescriptionEntryFormat3()
		}

	}

	return localctx
}

// ICommunicationDescriptionEntryFormat1Context is an interface to support dynamic dispatch.
type ICommunicationDescriptionEntryFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommunicationDescriptionEntryFormat1Context differentiates from other interfaces.
	IsCommunicationDescriptionEntryFormat1Context()
}

type CommunicationDescriptionEntryFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommunicationDescriptionEntryFormat1Context() *CommunicationDescriptionEntryFormat1Context {
	var p = new(CommunicationDescriptionEntryFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat1
	return p
}

func (*CommunicationDescriptionEntryFormat1Context) IsCommunicationDescriptionEntryFormat1Context() {}

func NewCommunicationDescriptionEntryFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommunicationDescriptionEntryFormat1Context {
	var p = new(CommunicationDescriptionEntryFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat1

	return p
}

func (s *CommunicationDescriptionEntryFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *CommunicationDescriptionEntryFormat1Context) CD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCD, 0)
}

func (s *CommunicationDescriptionEntryFormat1Context) CdName() ICdNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICdNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *CommunicationDescriptionEntryFormat1Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *CommunicationDescriptionEntryFormat1Context) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CommunicationDescriptionEntryFormat1Context) INITIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIAL, 0)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllDataDescName() []IDataDescNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem())
	var tst = make([]IDataDescNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataDescNameContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) DataDescName(i int) IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllSymbolicQueueClause() []ISymbolicQueueClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolicQueueClauseContext)(nil)).Elem())
	var tst = make([]ISymbolicQueueClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolicQueueClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) SymbolicQueueClause(i int) ISymbolicQueueClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicQueueClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolicQueueClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllSymbolicSubQueueClause() []ISymbolicSubQueueClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolicSubQueueClauseContext)(nil)).Elem())
	var tst = make([]ISymbolicSubQueueClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolicSubQueueClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) SymbolicSubQueueClause(i int) ISymbolicSubQueueClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicSubQueueClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolicSubQueueClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllMessageDateClause() []IMessageDateClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMessageDateClauseContext)(nil)).Elem())
	var tst = make([]IMessageDateClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMessageDateClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) MessageDateClause(i int) IMessageDateClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMessageDateClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMessageDateClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllMessageTimeClause() []IMessageTimeClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMessageTimeClauseContext)(nil)).Elem())
	var tst = make([]IMessageTimeClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMessageTimeClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) MessageTimeClause(i int) IMessageTimeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMessageTimeClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMessageTimeClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllSymbolicSourceClause() []ISymbolicSourceClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolicSourceClauseContext)(nil)).Elem())
	var tst = make([]ISymbolicSourceClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolicSourceClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) SymbolicSourceClause(i int) ISymbolicSourceClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicSourceClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolicSourceClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllTextLengthClause() []ITextLengthClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITextLengthClauseContext)(nil)).Elem())
	var tst = make([]ITextLengthClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITextLengthClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) TextLengthClause(i int) ITextLengthClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITextLengthClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITextLengthClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllEndKeyClause() []IEndKeyClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEndKeyClauseContext)(nil)).Elem())
	var tst = make([]IEndKeyClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEndKeyClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) EndKeyClause(i int) IEndKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndKeyClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEndKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllStatusKeyClause() []IStatusKeyClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatusKeyClauseContext)(nil)).Elem())
	var tst = make([]IStatusKeyClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatusKeyClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) StatusKeyClause(i int) IStatusKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatusKeyClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatusKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllMessageCountClause() []IMessageCountClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMessageCountClauseContext)(nil)).Elem())
	var tst = make([]IMessageCountClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMessageCountClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) MessageCountClause(i int) IMessageCountClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMessageCountClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMessageCountClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommunicationDescriptionEntryFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommunicationDescriptionEntryFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommunicationDescriptionEntryFormat1(s)
	}
}

func (s *CommunicationDescriptionEntryFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommunicationDescriptionEntryFormat1(s)
	}
}

func (s *CommunicationDescriptionEntryFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCommunicationDescriptionEntryFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CommunicationDescriptionEntryFormat1() (localctx ICommunicationDescriptionEntryFormat1Context) {
	localctx = NewCommunicationDescriptionEntryFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, Cobol85ParserRULE_communicationDescriptionEntryFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2333)
		p.Match(Cobol85ParserCD)
	}
	{
		p.SetState(2334)
		p.CdName()
	}
	p.SetState(2336)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(2335)
			p.Match(Cobol85ParserFOR)
		}

	}
	p.SetState(2339)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINITIAL {
		{
			p.SetState(2338)
			p.Match(Cobol85ParserINITIAL)
		}

	}
	{
		p.SetState(2341)
		p.Match(Cobol85ParserINPUT)
	}
	p.SetState(2356)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCOUNT-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141))|(1<<(Cobol85ParserEND-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184))|(1<<(Cobol85ParserFILLER-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMESSAGE-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserQUEUE-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSOURCE-434))|(1<<(Cobol85ParserSP-434))|(1<<(Cobol85ParserSTATUS-434))|(1<<(Cobol85ParserSUB_QUEUE_1-434))|(1<<(Cobol85ParserSUB_QUEUE_2-434)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSUB_QUEUE_3-466))|(1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserSYMBOLIC-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTEXT-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466)))) != 0) || (((_la-499)&-(0x1f+1)) == 0 && ((1<<uint((_la-499)))&((1<<(Cobol85ParserTRUNCATED-499))|(1<<(Cobol85ParserTYPEDEF-499))|(1<<(Cobol85ParserUNDERLINE-499))|(1<<(Cobol85ParserVIRTUAL-499))|(1<<(Cobol85ParserWAIT-499))|(1<<(Cobol85ParserXOPTS-499))|(1<<(Cobol85ParserYEAR-499))|(1<<(Cobol85ParserYYYYMMDD-499))|(1<<(Cobol85ParserYYYYDDD-499))|(1<<(Cobol85ParserZERO_FILL-499)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		p.SetState(2354)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserCOUNT, Cobol85ParserEND, Cobol85ParserMESSAGE, Cobol85ParserQUEUE, Cobol85ParserSOURCE, Cobol85ParserSTATUS, Cobol85ParserSUB_QUEUE_1, Cobol85ParserSUB_QUEUE_2, Cobol85ParserSUB_QUEUE_3, Cobol85ParserSYMBOLIC, Cobol85ParserTEXT:
			p.SetState(2351)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(2342)
					p.SymbolicQueueClause()
				}

			case 2:
				{
					p.SetState(2343)
					p.SymbolicSubQueueClause()
				}

			case 3:
				{
					p.SetState(2344)
					p.MessageDateClause()
				}

			case 4:
				{
					p.SetState(2345)
					p.MessageTimeClause()
				}

			case 5:
				{
					p.SetState(2346)
					p.SymbolicSourceClause()
				}

			case 6:
				{
					p.SetState(2347)
					p.TextLengthClause()
				}

			case 7:
				{
					p.SetState(2348)
					p.EndKeyClause()
				}

			case 8:
				{
					p.SetState(2349)
					p.StatusKeyClause()
				}

			case 9:
				{
					p.SetState(2350)
					p.MessageCountClause()
				}

			}

		case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFILLER, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
			{
				p.SetState(2353)
				p.DataDescName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2358)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2359)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// ICommunicationDescriptionEntryFormat2Context is an interface to support dynamic dispatch.
type ICommunicationDescriptionEntryFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommunicationDescriptionEntryFormat2Context differentiates from other interfaces.
	IsCommunicationDescriptionEntryFormat2Context()
}

type CommunicationDescriptionEntryFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommunicationDescriptionEntryFormat2Context() *CommunicationDescriptionEntryFormat2Context {
	var p = new(CommunicationDescriptionEntryFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat2
	return p
}

func (*CommunicationDescriptionEntryFormat2Context) IsCommunicationDescriptionEntryFormat2Context() {}

func NewCommunicationDescriptionEntryFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommunicationDescriptionEntryFormat2Context {
	var p = new(CommunicationDescriptionEntryFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat2

	return p
}

func (s *CommunicationDescriptionEntryFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *CommunicationDescriptionEntryFormat2Context) CD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCD, 0)
}

func (s *CommunicationDescriptionEntryFormat2Context) CdName() ICdNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICdNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *CommunicationDescriptionEntryFormat2Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *CommunicationDescriptionEntryFormat2Context) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllDestinationCountClause() []IDestinationCountClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDestinationCountClauseContext)(nil)).Elem())
	var tst = make([]IDestinationCountClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDestinationCountClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) DestinationCountClause(i int) IDestinationCountClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDestinationCountClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDestinationCountClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllTextLengthClause() []ITextLengthClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITextLengthClauseContext)(nil)).Elem())
	var tst = make([]ITextLengthClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITextLengthClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) TextLengthClause(i int) ITextLengthClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITextLengthClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITextLengthClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllStatusKeyClause() []IStatusKeyClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatusKeyClauseContext)(nil)).Elem())
	var tst = make([]IStatusKeyClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatusKeyClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) StatusKeyClause(i int) IStatusKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatusKeyClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatusKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllDestinationTableClause() []IDestinationTableClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDestinationTableClauseContext)(nil)).Elem())
	var tst = make([]IDestinationTableClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDestinationTableClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) DestinationTableClause(i int) IDestinationTableClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDestinationTableClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDestinationTableClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllErrorKeyClause() []IErrorKeyClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IErrorKeyClauseContext)(nil)).Elem())
	var tst = make([]IErrorKeyClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IErrorKeyClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) ErrorKeyClause(i int) IErrorKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IErrorKeyClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IErrorKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllSymbolicDestinationClause() []ISymbolicDestinationClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolicDestinationClauseContext)(nil)).Elem())
	var tst = make([]ISymbolicDestinationClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolicDestinationClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) SymbolicDestinationClause(i int) ISymbolicDestinationClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicDestinationClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolicDestinationClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommunicationDescriptionEntryFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommunicationDescriptionEntryFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommunicationDescriptionEntryFormat2(s)
	}
}

func (s *CommunicationDescriptionEntryFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommunicationDescriptionEntryFormat2(s)
	}
}

func (s *CommunicationDescriptionEntryFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCommunicationDescriptionEntryFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CommunicationDescriptionEntryFormat2() (localctx ICommunicationDescriptionEntryFormat2Context) {
	localctx = NewCommunicationDescriptionEntryFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, Cobol85ParserRULE_communicationDescriptionEntryFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2361)
		p.Match(Cobol85ParserCD)
	}
	{
		p.SetState(2362)
		p.CdName()
	}
	p.SetState(2364)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(2363)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(2366)
		p.Match(Cobol85ParserOUTPUT)
	}
	p.SetState(2375)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserDESTINATION || _la == Cobol85ParserERROR || (((_la-461)&-(0x1f+1)) == 0 && ((1<<uint((_la-461)))&((1<<(Cobol85ParserSTATUS-461))|(1<<(Cobol85ParserSYMBOLIC-461))|(1<<(Cobol85ParserTEXT-461)))) != 0) {
		p.SetState(2373)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 246, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2367)
				p.DestinationCountClause()
			}

		case 2:
			{
				p.SetState(2368)
				p.TextLengthClause()
			}

		case 3:
			{
				p.SetState(2369)
				p.StatusKeyClause()
			}

		case 4:
			{
				p.SetState(2370)
				p.DestinationTableClause()
			}

		case 5:
			{
				p.SetState(2371)
				p.ErrorKeyClause()
			}

		case 6:
			{
				p.SetState(2372)
				p.SymbolicDestinationClause()
			}

		}

		p.SetState(2377)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2378)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// ICommunicationDescriptionEntryFormat3Context is an interface to support dynamic dispatch.
type ICommunicationDescriptionEntryFormat3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommunicationDescriptionEntryFormat3Context differentiates from other interfaces.
	IsCommunicationDescriptionEntryFormat3Context()
}

type CommunicationDescriptionEntryFormat3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommunicationDescriptionEntryFormat3Context() *CommunicationDescriptionEntryFormat3Context {
	var p = new(CommunicationDescriptionEntryFormat3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat3
	return p
}

func (*CommunicationDescriptionEntryFormat3Context) IsCommunicationDescriptionEntryFormat3Context() {}

func NewCommunicationDescriptionEntryFormat3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommunicationDescriptionEntryFormat3Context {
	var p = new(CommunicationDescriptionEntryFormat3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat3

	return p
}

func (s *CommunicationDescriptionEntryFormat3Context) GetParser() antlr.Parser { return s.parser }

func (s *CommunicationDescriptionEntryFormat3Context) CD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCD, 0)
}

func (s *CommunicationDescriptionEntryFormat3Context) CdName() ICdNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICdNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) INITIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIAL, 0)
}

func (s *CommunicationDescriptionEntryFormat3Context) I_O() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O, 0)
}

func (s *CommunicationDescriptionEntryFormat3Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *CommunicationDescriptionEntryFormat3Context) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllDataDescName() []IDataDescNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem())
	var tst = make([]IDataDescNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataDescNameContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) DataDescName(i int) IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllMessageDateClause() []IMessageDateClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMessageDateClauseContext)(nil)).Elem())
	var tst = make([]IMessageDateClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMessageDateClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) MessageDateClause(i int) IMessageDateClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMessageDateClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMessageDateClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllMessageTimeClause() []IMessageTimeClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMessageTimeClauseContext)(nil)).Elem())
	var tst = make([]IMessageTimeClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMessageTimeClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) MessageTimeClause(i int) IMessageTimeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMessageTimeClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMessageTimeClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllSymbolicTerminalClause() []ISymbolicTerminalClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolicTerminalClauseContext)(nil)).Elem())
	var tst = make([]ISymbolicTerminalClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolicTerminalClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) SymbolicTerminalClause(i int) ISymbolicTerminalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicTerminalClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolicTerminalClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllTextLengthClause() []ITextLengthClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITextLengthClauseContext)(nil)).Elem())
	var tst = make([]ITextLengthClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITextLengthClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) TextLengthClause(i int) ITextLengthClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITextLengthClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITextLengthClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllEndKeyClause() []IEndKeyClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEndKeyClauseContext)(nil)).Elem())
	var tst = make([]IEndKeyClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEndKeyClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) EndKeyClause(i int) IEndKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndKeyClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEndKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllStatusKeyClause() []IStatusKeyClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatusKeyClauseContext)(nil)).Elem())
	var tst = make([]IStatusKeyClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatusKeyClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) StatusKeyClause(i int) IStatusKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatusKeyClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatusKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommunicationDescriptionEntryFormat3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommunicationDescriptionEntryFormat3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommunicationDescriptionEntryFormat3(s)
	}
}

func (s *CommunicationDescriptionEntryFormat3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommunicationDescriptionEntryFormat3(s)
	}
}

func (s *CommunicationDescriptionEntryFormat3Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCommunicationDescriptionEntryFormat3(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CommunicationDescriptionEntryFormat3() (localctx ICommunicationDescriptionEntryFormat3Context) {
	localctx = NewCommunicationDescriptionEntryFormat3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, Cobol85ParserRULE_communicationDescriptionEntryFormat3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2380)
		p.Match(Cobol85ParserCD)
	}
	{
		p.SetState(2381)
		p.CdName()
	}
	p.SetState(2383)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(2382)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(2385)
		p.Match(Cobol85ParserINITIAL)
	}
	{
		p.SetState(2386)
		p.Match(Cobol85ParserI_O)
	}
	p.SetState(2398)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141))|(1<<(Cobol85ParserEND-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184))|(1<<(Cobol85ParserFILLER-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMESSAGE-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434))|(1<<(Cobol85ParserSTATUS-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserSYMBOLIC-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTERMINAL-470))|(1<<(Cobol85ParserTEXT-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		p.SetState(2396)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserEND, Cobol85ParserMESSAGE, Cobol85ParserSTATUS, Cobol85ParserSYMBOLIC, Cobol85ParserTERMINAL, Cobol85ParserTEXT:
			p.SetState(2393)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 249, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(2387)
					p.MessageDateClause()
				}

			case 2:
				{
					p.SetState(2388)
					p.MessageTimeClause()
				}

			case 3:
				{
					p.SetState(2389)
					p.SymbolicTerminalClause()
				}

			case 4:
				{
					p.SetState(2390)
					p.TextLengthClause()
				}

			case 5:
				{
					p.SetState(2391)
					p.EndKeyClause()
				}

			case 6:
				{
					p.SetState(2392)
					p.StatusKeyClause()
				}

			}

		case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFILLER, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
			{
				p.SetState(2395)
				p.DataDescName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2400)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2401)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IDestinationCountClauseContext is an interface to support dynamic dispatch.
type IDestinationCountClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDestinationCountClauseContext differentiates from other interfaces.
	IsDestinationCountClauseContext()
}

type DestinationCountClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDestinationCountClauseContext() *DestinationCountClauseContext {
	var p = new(DestinationCountClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_destinationCountClause
	return p
}

func (*DestinationCountClauseContext) IsDestinationCountClauseContext() {}

func NewDestinationCountClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DestinationCountClauseContext {
	var p = new(DestinationCountClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_destinationCountClause

	return p
}

func (s *DestinationCountClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DestinationCountClauseContext) DESTINATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESTINATION, 0)
}

func (s *DestinationCountClauseContext) COUNT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOUNT, 0)
}

func (s *DestinationCountClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *DestinationCountClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DestinationCountClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DestinationCountClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DestinationCountClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDestinationCountClause(s)
	}
}

func (s *DestinationCountClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDestinationCountClause(s)
	}
}

func (s *DestinationCountClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDestinationCountClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DestinationCountClause() (localctx IDestinationCountClauseContext) {
	localctx = NewDestinationCountClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, Cobol85ParserRULE_destinationCountClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2403)
		p.Match(Cobol85ParserDESTINATION)
	}
	{
		p.SetState(2404)
		p.Match(Cobol85ParserCOUNT)
	}
	p.SetState(2406)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2405)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2408)
		p.DataDescName()
	}

	return localctx
}

// IDestinationTableClauseContext is an interface to support dynamic dispatch.
type IDestinationTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDestinationTableClauseContext differentiates from other interfaces.
	IsDestinationTableClauseContext()
}

type DestinationTableClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDestinationTableClauseContext() *DestinationTableClauseContext {
	var p = new(DestinationTableClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_destinationTableClause
	return p
}

func (*DestinationTableClauseContext) IsDestinationTableClauseContext() {}

func NewDestinationTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DestinationTableClauseContext {
	var p = new(DestinationTableClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_destinationTableClause

	return p
}

func (s *DestinationTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DestinationTableClauseContext) DESTINATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESTINATION, 0)
}

func (s *DestinationTableClauseContext) TABLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTABLE, 0)
}

func (s *DestinationTableClauseContext) OCCURS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOCCURS, 0)
}

func (s *DestinationTableClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *DestinationTableClauseContext) TIMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMES, 0)
}

func (s *DestinationTableClauseContext) INDEXED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINDEXED, 0)
}

func (s *DestinationTableClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *DestinationTableClauseContext) AllIndexName() []IIndexNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIndexNameContext)(nil)).Elem())
	var tst = make([]IIndexNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIndexNameContext)
		}
	}

	return tst
}

func (s *DestinationTableClauseContext) IndexName(i int) IIndexNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *DestinationTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DestinationTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DestinationTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDestinationTableClause(s)
	}
}

func (s *DestinationTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDestinationTableClause(s)
	}
}

func (s *DestinationTableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDestinationTableClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DestinationTableClause() (localctx IDestinationTableClauseContext) {
	localctx = NewDestinationTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, Cobol85ParserRULE_destinationTableClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2410)
		p.Match(Cobol85ParserDESTINATION)
	}
	{
		p.SetState(2411)
		p.Match(Cobol85ParserTABLE)
	}
	{
		p.SetState(2412)
		p.Match(Cobol85ParserOCCURS)
	}
	{
		p.SetState(2413)
		p.IntegerLiteral()
	}
	{
		p.SetState(2414)
		p.Match(Cobol85ParserTIMES)
	}
	p.SetState(2422)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINDEXED {
		{
			p.SetState(2415)
			p.Match(Cobol85ParserINDEXED)
		}
		{
			p.SetState(2416)
			p.Match(Cobol85ParserBY)
		}
		p.SetState(2418)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
			{
				p.SetState(2417)
				p.IndexName()
			}

			p.SetState(2420)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IEndKeyClauseContext is an interface to support dynamic dispatch.
type IEndKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndKeyClauseContext differentiates from other interfaces.
	IsEndKeyClauseContext()
}

type EndKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndKeyClauseContext() *EndKeyClauseContext {
	var p = new(EndKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_endKeyClause
	return p
}

func (*EndKeyClauseContext) IsEndKeyClauseContext() {}

func NewEndKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndKeyClauseContext {
	var p = new(EndKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_endKeyClause

	return p
}

func (s *EndKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *EndKeyClauseContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *EndKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *EndKeyClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *EndKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *EndKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEndKeyClause(s)
	}
}

func (s *EndKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEndKeyClause(s)
	}
}

func (s *EndKeyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEndKeyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EndKeyClause() (localctx IEndKeyClauseContext) {
	localctx = NewEndKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, Cobol85ParserRULE_endKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2424)
		p.Match(Cobol85ParserEND)
	}
	{
		p.SetState(2425)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(2427)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2426)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2429)
		p.DataDescName()
	}

	return localctx
}

// IErrorKeyClauseContext is an interface to support dynamic dispatch.
type IErrorKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsErrorKeyClauseContext differentiates from other interfaces.
	IsErrorKeyClauseContext()
}

type ErrorKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorKeyClauseContext() *ErrorKeyClauseContext {
	var p = new(ErrorKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_errorKeyClause
	return p
}

func (*ErrorKeyClauseContext) IsErrorKeyClauseContext() {}

func NewErrorKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorKeyClauseContext {
	var p = new(ErrorKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_errorKeyClause

	return p
}

func (s *ErrorKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorKeyClauseContext) ERROR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERROR, 0)
}

func (s *ErrorKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *ErrorKeyClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *ErrorKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ErrorKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterErrorKeyClause(s)
	}
}

func (s *ErrorKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitErrorKeyClause(s)
	}
}

func (s *ErrorKeyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitErrorKeyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ErrorKeyClause() (localctx IErrorKeyClauseContext) {
	localctx = NewErrorKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, Cobol85ParserRULE_errorKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2431)
		p.Match(Cobol85ParserERROR)
	}
	{
		p.SetState(2432)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(2434)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2433)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2436)
		p.DataDescName()
	}

	return localctx
}

// IMessageCountClauseContext is an interface to support dynamic dispatch.
type IMessageCountClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMessageCountClauseContext differentiates from other interfaces.
	IsMessageCountClauseContext()
}

type MessageCountClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMessageCountClauseContext() *MessageCountClauseContext {
	var p = new(MessageCountClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_messageCountClause
	return p
}

func (*MessageCountClauseContext) IsMessageCountClauseContext() {}

func NewMessageCountClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MessageCountClauseContext {
	var p = new(MessageCountClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_messageCountClause

	return p
}

func (s *MessageCountClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MessageCountClauseContext) COUNT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOUNT, 0)
}

func (s *MessageCountClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *MessageCountClauseContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMESSAGE, 0)
}

func (s *MessageCountClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MessageCountClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MessageCountClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MessageCountClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMessageCountClause(s)
	}
}

func (s *MessageCountClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMessageCountClause(s)
	}
}

func (s *MessageCountClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMessageCountClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MessageCountClause() (localctx IMessageCountClauseContext) {
	localctx = NewMessageCountClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, Cobol85ParserRULE_messageCountClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2439)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMESSAGE {
		{
			p.SetState(2438)
			p.Match(Cobol85ParserMESSAGE)
		}

	}
	{
		p.SetState(2441)
		p.Match(Cobol85ParserCOUNT)
	}
	p.SetState(2443)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2442)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2445)
		p.DataDescName()
	}

	return localctx
}

// IMessageDateClauseContext is an interface to support dynamic dispatch.
type IMessageDateClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMessageDateClauseContext differentiates from other interfaces.
	IsMessageDateClauseContext()
}

type MessageDateClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMessageDateClauseContext() *MessageDateClauseContext {
	var p = new(MessageDateClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_messageDateClause
	return p
}

func (*MessageDateClauseContext) IsMessageDateClauseContext() {}

func NewMessageDateClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MessageDateClauseContext {
	var p = new(MessageDateClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_messageDateClause

	return p
}

func (s *MessageDateClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MessageDateClauseContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMESSAGE, 0)
}

func (s *MessageDateClauseContext) DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE, 0)
}

func (s *MessageDateClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *MessageDateClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MessageDateClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MessageDateClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MessageDateClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMessageDateClause(s)
	}
}

func (s *MessageDateClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMessageDateClause(s)
	}
}

func (s *MessageDateClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMessageDateClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MessageDateClause() (localctx IMessageDateClauseContext) {
	localctx = NewMessageDateClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, Cobol85ParserRULE_messageDateClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2447)
		p.Match(Cobol85ParserMESSAGE)
	}
	{
		p.SetState(2448)
		p.Match(Cobol85ParserDATE)
	}
	p.SetState(2450)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2449)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2452)
		p.DataDescName()
	}

	return localctx
}

// IMessageTimeClauseContext is an interface to support dynamic dispatch.
type IMessageTimeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMessageTimeClauseContext differentiates from other interfaces.
	IsMessageTimeClauseContext()
}

type MessageTimeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMessageTimeClauseContext() *MessageTimeClauseContext {
	var p = new(MessageTimeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_messageTimeClause
	return p
}

func (*MessageTimeClauseContext) IsMessageTimeClauseContext() {}

func NewMessageTimeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MessageTimeClauseContext {
	var p = new(MessageTimeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_messageTimeClause

	return p
}

func (s *MessageTimeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MessageTimeClauseContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMESSAGE, 0)
}

func (s *MessageTimeClauseContext) TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIME, 0)
}

func (s *MessageTimeClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *MessageTimeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MessageTimeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MessageTimeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MessageTimeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMessageTimeClause(s)
	}
}

func (s *MessageTimeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMessageTimeClause(s)
	}
}

func (s *MessageTimeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMessageTimeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MessageTimeClause() (localctx IMessageTimeClauseContext) {
	localctx = NewMessageTimeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, Cobol85ParserRULE_messageTimeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2454)
		p.Match(Cobol85ParserMESSAGE)
	}
	{
		p.SetState(2455)
		p.Match(Cobol85ParserTIME)
	}
	p.SetState(2457)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2456)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2459)
		p.DataDescName()
	}

	return localctx
}

// IStatusKeyClauseContext is an interface to support dynamic dispatch.
type IStatusKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatusKeyClauseContext differentiates from other interfaces.
	IsStatusKeyClauseContext()
}

type StatusKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatusKeyClauseContext() *StatusKeyClauseContext {
	var p = new(StatusKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_statusKeyClause
	return p
}

func (*StatusKeyClauseContext) IsStatusKeyClauseContext() {}

func NewStatusKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatusKeyClauseContext {
	var p = new(StatusKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_statusKeyClause

	return p
}

func (s *StatusKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *StatusKeyClauseContext) STATUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTATUS, 0)
}

func (s *StatusKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *StatusKeyClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *StatusKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *StatusKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatusKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatusKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStatusKeyClause(s)
	}
}

func (s *StatusKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStatusKeyClause(s)
	}
}

func (s *StatusKeyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStatusKeyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StatusKeyClause() (localctx IStatusKeyClauseContext) {
	localctx = NewStatusKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, Cobol85ParserRULE_statusKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2461)
		p.Match(Cobol85ParserSTATUS)
	}
	{
		p.SetState(2462)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(2464)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2463)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2466)
		p.DataDescName()
	}

	return localctx
}

// ISymbolicDestinationClauseContext is an interface to support dynamic dispatch.
type ISymbolicDestinationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicDestinationClauseContext differentiates from other interfaces.
	IsSymbolicDestinationClauseContext()
}

type SymbolicDestinationClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicDestinationClauseContext() *SymbolicDestinationClauseContext {
	var p = new(SymbolicDestinationClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicDestinationClause
	return p
}

func (*SymbolicDestinationClauseContext) IsSymbolicDestinationClauseContext() {}

func NewSymbolicDestinationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicDestinationClauseContext {
	var p = new(SymbolicDestinationClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicDestinationClause

	return p
}

func (s *SymbolicDestinationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicDestinationClauseContext) DESTINATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESTINATION, 0)
}

func (s *SymbolicDestinationClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *SymbolicDestinationClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicDestinationClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicDestinationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicDestinationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicDestinationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicDestinationClause(s)
	}
}

func (s *SymbolicDestinationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicDestinationClause(s)
	}
}

func (s *SymbolicDestinationClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSymbolicDestinationClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SymbolicDestinationClause() (localctx ISymbolicDestinationClauseContext) {
	localctx = NewSymbolicDestinationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, Cobol85ParserRULE_symbolicDestinationClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSYMBOLIC {
		{
			p.SetState(2468)
			p.Match(Cobol85ParserSYMBOLIC)
		}

	}
	{
		p.SetState(2471)
		p.Match(Cobol85ParserDESTINATION)
	}
	p.SetState(2473)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2472)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2475)
		p.DataDescName()
	}

	return localctx
}

// ISymbolicQueueClauseContext is an interface to support dynamic dispatch.
type ISymbolicQueueClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicQueueClauseContext differentiates from other interfaces.
	IsSymbolicQueueClauseContext()
}

type SymbolicQueueClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicQueueClauseContext() *SymbolicQueueClauseContext {
	var p = new(SymbolicQueueClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicQueueClause
	return p
}

func (*SymbolicQueueClauseContext) IsSymbolicQueueClauseContext() {}

func NewSymbolicQueueClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicQueueClauseContext {
	var p = new(SymbolicQueueClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicQueueClause

	return p
}

func (s *SymbolicQueueClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicQueueClauseContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserQUEUE, 0)
}

func (s *SymbolicQueueClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *SymbolicQueueClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicQueueClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicQueueClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicQueueClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicQueueClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicQueueClause(s)
	}
}

func (s *SymbolicQueueClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicQueueClause(s)
	}
}

func (s *SymbolicQueueClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSymbolicQueueClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SymbolicQueueClause() (localctx ISymbolicQueueClauseContext) {
	localctx = NewSymbolicQueueClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, Cobol85ParserRULE_symbolicQueueClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2478)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSYMBOLIC {
		{
			p.SetState(2477)
			p.Match(Cobol85ParserSYMBOLIC)
		}

	}
	{
		p.SetState(2480)
		p.Match(Cobol85ParserQUEUE)
	}
	p.SetState(2482)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2481)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2484)
		p.DataDescName()
	}

	return localctx
}

// ISymbolicSourceClauseContext is an interface to support dynamic dispatch.
type ISymbolicSourceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicSourceClauseContext differentiates from other interfaces.
	IsSymbolicSourceClauseContext()
}

type SymbolicSourceClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicSourceClauseContext() *SymbolicSourceClauseContext {
	var p = new(SymbolicSourceClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicSourceClause
	return p
}

func (*SymbolicSourceClauseContext) IsSymbolicSourceClauseContext() {}

func NewSymbolicSourceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicSourceClauseContext {
	var p = new(SymbolicSourceClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicSourceClause

	return p
}

func (s *SymbolicSourceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicSourceClauseContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSOURCE, 0)
}

func (s *SymbolicSourceClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *SymbolicSourceClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicSourceClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicSourceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicSourceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicSourceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicSourceClause(s)
	}
}

func (s *SymbolicSourceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicSourceClause(s)
	}
}

func (s *SymbolicSourceClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSymbolicSourceClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SymbolicSourceClause() (localctx ISymbolicSourceClauseContext) {
	localctx = NewSymbolicSourceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, Cobol85ParserRULE_symbolicSourceClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2487)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSYMBOLIC {
		{
			p.SetState(2486)
			p.Match(Cobol85ParserSYMBOLIC)
		}

	}
	{
		p.SetState(2489)
		p.Match(Cobol85ParserSOURCE)
	}
	p.SetState(2491)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2490)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2493)
		p.DataDescName()
	}

	return localctx
}

// ISymbolicTerminalClauseContext is an interface to support dynamic dispatch.
type ISymbolicTerminalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicTerminalClauseContext differentiates from other interfaces.
	IsSymbolicTerminalClauseContext()
}

type SymbolicTerminalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicTerminalClauseContext() *SymbolicTerminalClauseContext {
	var p = new(SymbolicTerminalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicTerminalClause
	return p
}

func (*SymbolicTerminalClauseContext) IsSymbolicTerminalClauseContext() {}

func NewSymbolicTerminalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicTerminalClauseContext {
	var p = new(SymbolicTerminalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicTerminalClause

	return p
}

func (s *SymbolicTerminalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicTerminalClauseContext) TERMINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTERMINAL, 0)
}

func (s *SymbolicTerminalClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *SymbolicTerminalClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicTerminalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicTerminalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicTerminalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicTerminalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicTerminalClause(s)
	}
}

func (s *SymbolicTerminalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicTerminalClause(s)
	}
}

func (s *SymbolicTerminalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSymbolicTerminalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SymbolicTerminalClause() (localctx ISymbolicTerminalClauseContext) {
	localctx = NewSymbolicTerminalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, Cobol85ParserRULE_symbolicTerminalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2496)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSYMBOLIC {
		{
			p.SetState(2495)
			p.Match(Cobol85ParserSYMBOLIC)
		}

	}
	{
		p.SetState(2498)
		p.Match(Cobol85ParserTERMINAL)
	}
	p.SetState(2500)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2499)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2502)
		p.DataDescName()
	}

	return localctx
}

// ISymbolicSubQueueClauseContext is an interface to support dynamic dispatch.
type ISymbolicSubQueueClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicSubQueueClauseContext differentiates from other interfaces.
	IsSymbolicSubQueueClauseContext()
}

type SymbolicSubQueueClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicSubQueueClauseContext() *SymbolicSubQueueClauseContext {
	var p = new(SymbolicSubQueueClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicSubQueueClause
	return p
}

func (*SymbolicSubQueueClauseContext) IsSymbolicSubQueueClauseContext() {}

func NewSymbolicSubQueueClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicSubQueueClauseContext {
	var p = new(SymbolicSubQueueClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicSubQueueClause

	return p
}

func (s *SymbolicSubQueueClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicSubQueueClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *SymbolicSubQueueClauseContext) SUB_QUEUE_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUB_QUEUE_1, 0)
}

func (s *SymbolicSubQueueClauseContext) SUB_QUEUE_2() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUB_QUEUE_2, 0)
}

func (s *SymbolicSubQueueClauseContext) SUB_QUEUE_3() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUB_QUEUE_3, 0)
}

func (s *SymbolicSubQueueClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicSubQueueClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicSubQueueClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicSubQueueClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicSubQueueClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicSubQueueClause(s)
	}
}

func (s *SymbolicSubQueueClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicSubQueueClause(s)
	}
}

func (s *SymbolicSubQueueClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSymbolicSubQueueClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SymbolicSubQueueClause() (localctx ISymbolicSubQueueClauseContext) {
	localctx = NewSymbolicSubQueueClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, Cobol85ParserRULE_symbolicSubQueueClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2505)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSYMBOLIC {
		{
			p.SetState(2504)
			p.Match(Cobol85ParserSYMBOLIC)
		}

	}
	p.SetState(2507)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-464)&-(0x1f+1)) == 0 && ((1<<uint((_la-464)))&((1<<(Cobol85ParserSUB_QUEUE_1-464))|(1<<(Cobol85ParserSUB_QUEUE_2-464))|(1<<(Cobol85ParserSUB_QUEUE_3-464)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(2509)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2508)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2511)
		p.DataDescName()
	}

	return localctx
}

// ITextLengthClauseContext is an interface to support dynamic dispatch.
type ITextLengthClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTextLengthClauseContext differentiates from other interfaces.
	IsTextLengthClauseContext()
}

type TextLengthClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextLengthClauseContext() *TextLengthClauseContext {
	var p = new(TextLengthClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_textLengthClause
	return p
}

func (*TextLengthClauseContext) IsTextLengthClauseContext() {}

func NewTextLengthClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextLengthClauseContext {
	var p = new(TextLengthClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_textLengthClause

	return p
}

func (s *TextLengthClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TextLengthClauseContext) TEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTEXT, 0)
}

func (s *TextLengthClauseContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH, 0)
}

func (s *TextLengthClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *TextLengthClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *TextLengthClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextLengthClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextLengthClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterTextLengthClause(s)
	}
}

func (s *TextLengthClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitTextLengthClause(s)
	}
}

func (s *TextLengthClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitTextLengthClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) TextLengthClause() (localctx ITextLengthClauseContext) {
	localctx = NewTextLengthClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, Cobol85ParserRULE_textLengthClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2513)
		p.Match(Cobol85ParserTEXT)
	}
	{
		p.SetState(2514)
		p.Match(Cobol85ParserLENGTH)
	}
	p.SetState(2516)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2515)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2518)
		p.DataDescName()
	}

	return localctx
}

// ILocalStorageSectionContext is an interface to support dynamic dispatch.
type ILocalStorageSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalStorageSectionContext differentiates from other interfaces.
	IsLocalStorageSectionContext()
}

type LocalStorageSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalStorageSectionContext() *LocalStorageSectionContext {
	var p = new(LocalStorageSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_localStorageSection
	return p
}

func (*LocalStorageSectionContext) IsLocalStorageSectionContext() {}

func NewLocalStorageSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalStorageSectionContext {
	var p = new(LocalStorageSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_localStorageSection

	return p
}

func (s *LocalStorageSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalStorageSectionContext) LOCAL_STORAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCAL_STORAGE, 0)
}

func (s *LocalStorageSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *LocalStorageSectionContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *LocalStorageSectionContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *LocalStorageSectionContext) LD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLD, 0)
}

func (s *LocalStorageSectionContext) LocalName() ILocalNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalNameContext)
}

func (s *LocalStorageSectionContext) AllDataDescriptionEntry() []IDataDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem())
	var tst = make([]IDataDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataDescriptionEntryContext)
		}
	}

	return tst
}

func (s *LocalStorageSectionContext) DataDescriptionEntry(i int) IDataDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryContext)
}

func (s *LocalStorageSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalStorageSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalStorageSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLocalStorageSection(s)
	}
}

func (s *LocalStorageSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLocalStorageSection(s)
	}
}

func (s *LocalStorageSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLocalStorageSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LocalStorageSection() (localctx ILocalStorageSectionContext) {
	localctx = NewLocalStorageSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, Cobol85ParserRULE_localStorageSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2520)
		p.Match(Cobol85ParserLOCAL_STORAGE)
	}
	{
		p.SetState(2521)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2522)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2527)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLD {
		{
			p.SetState(2523)
			p.Match(Cobol85ParserLD)
		}
		{
			p.SetState(2524)
			p.LocalName()
		}
		{
			p.SetState(2525)
			p.Match(Cobol85ParserDOT_FS)
		}

	}
	p.SetState(2532)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserEXECSQLLINE-556)))) != 0 {
		{
			p.SetState(2529)
			p.DataDescriptionEntry()
		}

		p.SetState(2534)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IScreenSectionContext is an interface to support dynamic dispatch.
type IScreenSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenSectionContext differentiates from other interfaces.
	IsScreenSectionContext()
}

type ScreenSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenSectionContext() *ScreenSectionContext {
	var p = new(ScreenSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenSection
	return p
}

func (*ScreenSectionContext) IsScreenSectionContext() {}

func NewScreenSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenSectionContext {
	var p = new(ScreenSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenSection

	return p
}

func (s *ScreenSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenSectionContext) SCREEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSCREEN, 0)
}

func (s *ScreenSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *ScreenSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ScreenSectionContext) AllScreenDescriptionEntry() []IScreenDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionEntryContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionEntryContext)
		}
	}

	return tst
}

func (s *ScreenSectionContext) ScreenDescriptionEntry(i int) IScreenDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionEntryContext)
}

func (s *ScreenSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenSection(s)
	}
}

func (s *ScreenSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenSection(s)
	}
}

func (s *ScreenSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenSection() (localctx IScreenSectionContext) {
	localctx = NewScreenSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, Cobol85ParserRULE_screenSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2535)
		p.Match(Cobol85ParserSCREEN)
	}
	{
		p.SetState(2536)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2537)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2541)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserINTEGERLITERAL {
		{
			p.SetState(2538)
			p.ScreenDescriptionEntry()
		}

		p.SetState(2543)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IScreenDescriptionEntryContext is an interface to support dynamic dispatch.
type IScreenDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionEntryContext differentiates from other interfaces.
	IsScreenDescriptionEntryContext()
}

type ScreenDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionEntryContext() *ScreenDescriptionEntryContext {
	var p = new(ScreenDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionEntry
	return p
}

func (*ScreenDescriptionEntryContext) IsScreenDescriptionEntryContext() {}

func NewScreenDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionEntryContext {
	var p = new(ScreenDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionEntry

	return p
}

func (s *ScreenDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionEntryContext) INTEGERLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGERLITERAL, 0)
}

func (s *ScreenDescriptionEntryContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ScreenDescriptionEntryContext) FILLER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILLER, 0)
}

func (s *ScreenDescriptionEntryContext) ScreenName() IScreenNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScreenNameContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionBlankClause() []IScreenDescriptionBlankClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionBlankClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionBlankClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionBlankClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionBlankClause(i int) IScreenDescriptionBlankClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionBlankClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionBlankClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionBellClause() []IScreenDescriptionBellClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionBellClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionBellClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionBellClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionBellClause(i int) IScreenDescriptionBellClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionBellClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionBellClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionBlinkClause() []IScreenDescriptionBlinkClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionBlinkClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionBlinkClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionBlinkClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionBlinkClause(i int) IScreenDescriptionBlinkClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionBlinkClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionBlinkClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionEraseClause() []IScreenDescriptionEraseClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionEraseClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionEraseClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionEraseClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionEraseClause(i int) IScreenDescriptionEraseClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionEraseClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionEraseClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionLightClause() []IScreenDescriptionLightClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionLightClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionLightClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionLightClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionLightClause(i int) IScreenDescriptionLightClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionLightClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionLightClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionGridClause() []IScreenDescriptionGridClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionGridClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionGridClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionGridClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionGridClause(i int) IScreenDescriptionGridClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionGridClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionGridClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionReverseVideoClause() []IScreenDescriptionReverseVideoClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionReverseVideoClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionReverseVideoClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionReverseVideoClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionReverseVideoClause(i int) IScreenDescriptionReverseVideoClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionReverseVideoClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionReverseVideoClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionUnderlineClause() []IScreenDescriptionUnderlineClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionUnderlineClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionUnderlineClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionUnderlineClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionUnderlineClause(i int) IScreenDescriptionUnderlineClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionUnderlineClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionUnderlineClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionSizeClause() []IScreenDescriptionSizeClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionSizeClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionSizeClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionSizeClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionSizeClause(i int) IScreenDescriptionSizeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionSizeClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionSizeClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionLineClause() []IScreenDescriptionLineClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionLineClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionLineClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionLineClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionLineClause(i int) IScreenDescriptionLineClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionLineClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionLineClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionColumnClause() []IScreenDescriptionColumnClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionColumnClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionColumnClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionColumnClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionColumnClause(i int) IScreenDescriptionColumnClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionColumnClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionColumnClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionForegroundColorClause() []IScreenDescriptionForegroundColorClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionForegroundColorClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionForegroundColorClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionForegroundColorClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionForegroundColorClause(i int) IScreenDescriptionForegroundColorClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionForegroundColorClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionForegroundColorClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionBackgroundColorClause() []IScreenDescriptionBackgroundColorClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionBackgroundColorClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionBackgroundColorClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionBackgroundColorClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionBackgroundColorClause(i int) IScreenDescriptionBackgroundColorClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionBackgroundColorClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionBackgroundColorClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionControlClause() []IScreenDescriptionControlClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionControlClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionControlClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionControlClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionControlClause(i int) IScreenDescriptionControlClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionControlClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionControlClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionValueClause() []IScreenDescriptionValueClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionValueClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionValueClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionValueClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionValueClause(i int) IScreenDescriptionValueClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionValueClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionValueClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionPictureClause() []IScreenDescriptionPictureClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionPictureClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionPictureClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionPictureClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionPictureClause(i int) IScreenDescriptionPictureClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionPictureClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionPictureClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionUsageClause() []IScreenDescriptionUsageClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionUsageClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionUsageClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionUsageClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionUsageClause(i int) IScreenDescriptionUsageClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionUsageClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionUsageClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionBlankWhenZeroClause() []IScreenDescriptionBlankWhenZeroClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionBlankWhenZeroClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionBlankWhenZeroClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionBlankWhenZeroClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionBlankWhenZeroClause(i int) IScreenDescriptionBlankWhenZeroClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionBlankWhenZeroClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionBlankWhenZeroClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionJustifiedClause() []IScreenDescriptionJustifiedClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionJustifiedClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionJustifiedClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionJustifiedClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionJustifiedClause(i int) IScreenDescriptionJustifiedClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionJustifiedClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionJustifiedClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionSignClause() []IScreenDescriptionSignClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionSignClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionSignClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionSignClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionSignClause(i int) IScreenDescriptionSignClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionSignClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionSignClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionAutoClause() []IScreenDescriptionAutoClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionAutoClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionAutoClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionAutoClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionAutoClause(i int) IScreenDescriptionAutoClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionAutoClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionAutoClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionSecureClause() []IScreenDescriptionSecureClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionSecureClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionSecureClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionSecureClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionSecureClause(i int) IScreenDescriptionSecureClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionSecureClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionSecureClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionRequiredClause() []IScreenDescriptionRequiredClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionRequiredClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionRequiredClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionRequiredClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionRequiredClause(i int) IScreenDescriptionRequiredClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionRequiredClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionRequiredClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionPromptClause() []IScreenDescriptionPromptClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionPromptClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionPromptClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionPromptClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionPromptClause(i int) IScreenDescriptionPromptClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionPromptClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionPromptClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionFullClause() []IScreenDescriptionFullClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionFullClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionFullClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionFullClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionFullClause(i int) IScreenDescriptionFullClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionFullClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionFullClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionZeroFillClause() []IScreenDescriptionZeroFillClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionZeroFillClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionZeroFillClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionZeroFillClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionZeroFillClause(i int) IScreenDescriptionZeroFillClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionZeroFillClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionZeroFillClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionFromClause() []IScreenDescriptionFromClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionFromClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionFromClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionFromClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionFromClause(i int) IScreenDescriptionFromClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionFromClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionFromClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionUsingClause() []IScreenDescriptionUsingClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionUsingClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionUsingClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionUsingClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionUsingClause(i int) IScreenDescriptionUsingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionUsingClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionUsingClauseContext)
}

func (s *ScreenDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionEntry(s)
	}
}

func (s *ScreenDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionEntry(s)
	}
}

func (s *ScreenDescriptionEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionEntry() (localctx IScreenDescriptionEntryContext) {
	localctx = NewScreenDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, Cobol85ParserRULE_screenDescriptionEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2544)
		p.Match(Cobol85ParserINTEGERLITERAL)
	}
	p.SetState(2547)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 276, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2545)
			p.Match(Cobol85ParserFILLER)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 276, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(2546)
			p.ScreenName()
		}

	}
	p.SetState(2581)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(Cobol85ParserAUTO-35))|(1<<(Cobol85ParserAUTO_SKIP-35))|(1<<(Cobol85ParserBACKGROUND_COLOR-35))|(1<<(Cobol85ParserBACKGROUND_COLOUR-35))|(1<<(Cobol85ParserBEEP-35))|(1<<(Cobol85ParserBELL-35))|(1<<(Cobol85ParserBLANK-35))|(1<<(Cobol85ParserBLINK-35)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(Cobol85ParserCOL-76))|(1<<(Cobol85ParserCOLUMN-76))|(1<<(Cobol85ParserCONTROL-76)))) != 0) || _la == Cobol85ParserEMPTY_CHECK || _la == Cobol85ParserERASE || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFROM-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216)))) != 0) || (((_la-258)&-(0x1f+1)) == 0 && ((1<<uint((_la-258)))&((1<<(Cobol85ParserJUST-258))|(1<<(Cobol85ParserJUSTIFIED-258))|(1<<(Cobol85ParserLEADING-258))|(1<<(Cobol85ParserLEFTLINE-258))|(1<<(Cobol85ParserLENGTH_CHECK-258))|(1<<(Cobol85ParserLINE-258)))) != 0) || _la == Cobol85ParserLOWLIGHT || _la == Cobol85ParserNO_ECHO || (((_la-341)&-(0x1f+1)) == 0 && ((1<<uint((_la-341)))&((1<<(Cobol85ParserOVERLINE-341))|(1<<(Cobol85ParserPIC-341))|(1<<(Cobol85ParserPICTURE-341))|(1<<(Cobol85ParserPROMPT-341)))) != 0) || (((_la-402)&-(0x1f+1)) == 0 && ((1<<uint((_la-402)))&((1<<(Cobol85ParserREQUIRED-402))|(1<<(Cobol85ParserREVERSE_VIDEO-402))|(1<<(Cobol85ParserSECURE-402)))) != 0) || _la == Cobol85ParserSIGN || _la == Cobol85ParserSIZE || (((_la-497)&-(0x1f+1)) == 0 && ((1<<uint((_la-497)))&((1<<(Cobol85ParserTRAILING-497))|(1<<(Cobol85ParserUNDERLINE-497))|(1<<(Cobol85ParserUSAGE-497))|(1<<(Cobol85ParserUSING-497))|(1<<(Cobol85ParserVALUE-497))|(1<<(Cobol85ParserZERO_FILL-497)))) != 0) {
		p.SetState(2579)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 278, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2549)
				p.ScreenDescriptionBlankClause()
			}

		case 2:
			{
				p.SetState(2550)
				p.ScreenDescriptionBellClause()
			}

		case 3:
			{
				p.SetState(2551)
				p.ScreenDescriptionBlinkClause()
			}

		case 4:
			{
				p.SetState(2552)
				p.ScreenDescriptionEraseClause()
			}

		case 5:
			{
				p.SetState(2553)
				p.ScreenDescriptionLightClause()
			}

		case 6:
			{
				p.SetState(2554)
				p.ScreenDescriptionGridClause()
			}

		case 7:
			{
				p.SetState(2555)
				p.ScreenDescriptionReverseVideoClause()
			}

		case 8:
			{
				p.SetState(2556)
				p.ScreenDescriptionUnderlineClause()
			}

		case 9:
			{
				p.SetState(2557)
				p.ScreenDescriptionSizeClause()
			}

		case 10:
			{
				p.SetState(2558)
				p.ScreenDescriptionLineClause()
			}

		case 11:
			{
				p.SetState(2559)
				p.ScreenDescriptionColumnClause()
			}

		case 12:
			{
				p.SetState(2560)
				p.ScreenDescriptionForegroundColorClause()
			}

		case 13:
			{
				p.SetState(2561)
				p.ScreenDescriptionBackgroundColorClause()
			}

		case 14:
			{
				p.SetState(2562)
				p.ScreenDescriptionControlClause()
			}

		case 15:
			{
				p.SetState(2563)
				p.ScreenDescriptionValueClause()
			}

		case 16:
			{
				p.SetState(2564)
				p.ScreenDescriptionPictureClause()
			}

		case 17:
			p.SetState(2567)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Cobol85ParserFROM:
				{
					p.SetState(2565)
					p.ScreenDescriptionFromClause()
				}

			case Cobol85ParserUSING:
				{
					p.SetState(2566)
					p.ScreenDescriptionUsingClause()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		case 18:
			{
				p.SetState(2569)
				p.ScreenDescriptionUsageClause()
			}

		case 19:
			{
				p.SetState(2570)
				p.ScreenDescriptionBlankWhenZeroClause()
			}

		case 20:
			{
				p.SetState(2571)
				p.ScreenDescriptionJustifiedClause()
			}

		case 21:
			{
				p.SetState(2572)
				p.ScreenDescriptionSignClause()
			}

		case 22:
			{
				p.SetState(2573)
				p.ScreenDescriptionAutoClause()
			}

		case 23:
			{
				p.SetState(2574)
				p.ScreenDescriptionSecureClause()
			}

		case 24:
			{
				p.SetState(2575)
				p.ScreenDescriptionRequiredClause()
			}

		case 25:
			{
				p.SetState(2576)
				p.ScreenDescriptionPromptClause()
			}

		case 26:
			{
				p.SetState(2577)
				p.ScreenDescriptionFullClause()
			}

		case 27:
			{
				p.SetState(2578)
				p.ScreenDescriptionZeroFillClause()
			}

		}

		p.SetState(2583)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2584)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IScreenDescriptionBlankClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionBlankClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionBlankClauseContext differentiates from other interfaces.
	IsScreenDescriptionBlankClauseContext()
}

type ScreenDescriptionBlankClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionBlankClauseContext() *ScreenDescriptionBlankClauseContext {
	var p = new(ScreenDescriptionBlankClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlankClause
	return p
}

func (*ScreenDescriptionBlankClauseContext) IsScreenDescriptionBlankClauseContext() {}

func NewScreenDescriptionBlankClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionBlankClauseContext {
	var p = new(ScreenDescriptionBlankClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlankClause

	return p
}

func (s *ScreenDescriptionBlankClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionBlankClauseContext) BLANK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLANK, 0)
}

func (s *ScreenDescriptionBlankClauseContext) SCREEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSCREEN, 0)
}

func (s *ScreenDescriptionBlankClauseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *ScreenDescriptionBlankClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionBlankClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionBlankClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionBlankClause(s)
	}
}

func (s *ScreenDescriptionBlankClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionBlankClause(s)
	}
}

func (s *ScreenDescriptionBlankClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionBlankClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionBlankClause() (localctx IScreenDescriptionBlankClauseContext) {
	localctx = NewScreenDescriptionBlankClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, Cobol85ParserRULE_screenDescriptionBlankClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2586)
		p.Match(Cobol85ParserBLANK)
	}
	p.SetState(2587)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserLINE || _la == Cobol85ParserSCREEN) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IScreenDescriptionBellClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionBellClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionBellClauseContext differentiates from other interfaces.
	IsScreenDescriptionBellClauseContext()
}

type ScreenDescriptionBellClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionBellClauseContext() *ScreenDescriptionBellClauseContext {
	var p = new(ScreenDescriptionBellClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBellClause
	return p
}

func (*ScreenDescriptionBellClauseContext) IsScreenDescriptionBellClauseContext() {}

func NewScreenDescriptionBellClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionBellClauseContext {
	var p = new(ScreenDescriptionBellClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBellClause

	return p
}

func (s *ScreenDescriptionBellClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionBellClauseContext) BELL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBELL, 0)
}

func (s *ScreenDescriptionBellClauseContext) BEEP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEEP, 0)
}

func (s *ScreenDescriptionBellClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionBellClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionBellClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionBellClause(s)
	}
}

func (s *ScreenDescriptionBellClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionBellClause(s)
	}
}

func (s *ScreenDescriptionBellClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionBellClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionBellClause() (localctx IScreenDescriptionBellClauseContext) {
	localctx = NewScreenDescriptionBellClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, Cobol85ParserRULE_screenDescriptionBellClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2589)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserBEEP || _la == Cobol85ParserBELL) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IScreenDescriptionBlinkClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionBlinkClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionBlinkClauseContext differentiates from other interfaces.
	IsScreenDescriptionBlinkClauseContext()
}

type ScreenDescriptionBlinkClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionBlinkClauseContext() *ScreenDescriptionBlinkClauseContext {
	var p = new(ScreenDescriptionBlinkClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlinkClause
	return p
}

func (*ScreenDescriptionBlinkClauseContext) IsScreenDescriptionBlinkClauseContext() {}

func NewScreenDescriptionBlinkClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionBlinkClauseContext {
	var p = new(ScreenDescriptionBlinkClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlinkClause

	return p
}

func (s *ScreenDescriptionBlinkClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionBlinkClauseContext) BLINK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLINK, 0)
}

func (s *ScreenDescriptionBlinkClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionBlinkClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionBlinkClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionBlinkClause(s)
	}
}

func (s *ScreenDescriptionBlinkClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionBlinkClause(s)
	}
}

func (s *ScreenDescriptionBlinkClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionBlinkClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionBlinkClause() (localctx IScreenDescriptionBlinkClauseContext) {
	localctx = NewScreenDescriptionBlinkClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, Cobol85ParserRULE_screenDescriptionBlinkClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2591)
		p.Match(Cobol85ParserBLINK)
	}

	return localctx
}

// IScreenDescriptionEraseClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionEraseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionEraseClauseContext differentiates from other interfaces.
	IsScreenDescriptionEraseClauseContext()
}

type ScreenDescriptionEraseClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionEraseClauseContext() *ScreenDescriptionEraseClauseContext {
	var p = new(ScreenDescriptionEraseClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionEraseClause
	return p
}

func (*ScreenDescriptionEraseClauseContext) IsScreenDescriptionEraseClauseContext() {}

func NewScreenDescriptionEraseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionEraseClauseContext {
	var p = new(ScreenDescriptionEraseClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionEraseClause

	return p
}

func (s *ScreenDescriptionEraseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionEraseClauseContext) ERASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERASE, 0)
}

func (s *ScreenDescriptionEraseClauseContext) EOL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOL, 0)
}

func (s *ScreenDescriptionEraseClauseContext) EOS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOS, 0)
}

func (s *ScreenDescriptionEraseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionEraseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionEraseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionEraseClause(s)
	}
}

func (s *ScreenDescriptionEraseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionEraseClause(s)
	}
}

func (s *ScreenDescriptionEraseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionEraseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionEraseClause() (localctx IScreenDescriptionEraseClauseContext) {
	localctx = NewScreenDescriptionEraseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, Cobol85ParserRULE_screenDescriptionEraseClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2593)
		p.Match(Cobol85ParserERASE)
	}
	p.SetState(2594)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserEOL || _la == Cobol85ParserEOS) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IScreenDescriptionLightClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionLightClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionLightClauseContext differentiates from other interfaces.
	IsScreenDescriptionLightClauseContext()
}

type ScreenDescriptionLightClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionLightClauseContext() *ScreenDescriptionLightClauseContext {
	var p = new(ScreenDescriptionLightClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionLightClause
	return p
}

func (*ScreenDescriptionLightClauseContext) IsScreenDescriptionLightClauseContext() {}

func NewScreenDescriptionLightClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionLightClauseContext {
	var p = new(ScreenDescriptionLightClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionLightClause

	return p
}

func (s *ScreenDescriptionLightClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionLightClauseContext) HIGHLIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHIGHLIGHT, 0)
}

func (s *ScreenDescriptionLightClauseContext) LOWLIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOWLIGHT, 0)
}

func (s *ScreenDescriptionLightClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionLightClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionLightClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionLightClause(s)
	}
}

func (s *ScreenDescriptionLightClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionLightClause(s)
	}
}

func (s *ScreenDescriptionLightClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionLightClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionLightClause() (localctx IScreenDescriptionLightClauseContext) {
	localctx = NewScreenDescriptionLightClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, Cobol85ParserRULE_screenDescriptionLightClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2596)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserHIGHLIGHT || _la == Cobol85ParserLOWLIGHT) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IScreenDescriptionGridClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionGridClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionGridClauseContext differentiates from other interfaces.
	IsScreenDescriptionGridClauseContext()
}

type ScreenDescriptionGridClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionGridClauseContext() *ScreenDescriptionGridClauseContext {
	var p = new(ScreenDescriptionGridClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionGridClause
	return p
}

func (*ScreenDescriptionGridClauseContext) IsScreenDescriptionGridClauseContext() {}

func NewScreenDescriptionGridClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionGridClauseContext {
	var p = new(ScreenDescriptionGridClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionGridClause

	return p
}

func (s *ScreenDescriptionGridClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionGridClauseContext) GRID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGRID, 0)
}

func (s *ScreenDescriptionGridClauseContext) LEFTLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEFTLINE, 0)
}

func (s *ScreenDescriptionGridClauseContext) OVERLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOVERLINE, 0)
}

func (s *ScreenDescriptionGridClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionGridClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionGridClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionGridClause(s)
	}
}

func (s *ScreenDescriptionGridClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionGridClause(s)
	}
}

func (s *ScreenDescriptionGridClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionGridClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionGridClause() (localctx IScreenDescriptionGridClauseContext) {
	localctx = NewScreenDescriptionGridClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, Cobol85ParserRULE_screenDescriptionGridClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2598)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserGRID || _la == Cobol85ParserLEFTLINE || _la == Cobol85ParserOVERLINE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IScreenDescriptionReverseVideoClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionReverseVideoClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionReverseVideoClauseContext differentiates from other interfaces.
	IsScreenDescriptionReverseVideoClauseContext()
}

type ScreenDescriptionReverseVideoClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionReverseVideoClauseContext() *ScreenDescriptionReverseVideoClauseContext {
	var p = new(ScreenDescriptionReverseVideoClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionReverseVideoClause
	return p
}

func (*ScreenDescriptionReverseVideoClauseContext) IsScreenDescriptionReverseVideoClauseContext() {}

func NewScreenDescriptionReverseVideoClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionReverseVideoClauseContext {
	var p = new(ScreenDescriptionReverseVideoClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionReverseVideoClause

	return p
}

func (s *ScreenDescriptionReverseVideoClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionReverseVideoClauseContext) REVERSE_VIDEO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREVERSE_VIDEO, 0)
}

func (s *ScreenDescriptionReverseVideoClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionReverseVideoClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionReverseVideoClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionReverseVideoClause(s)
	}
}

func (s *ScreenDescriptionReverseVideoClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionReverseVideoClause(s)
	}
}

func (s *ScreenDescriptionReverseVideoClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionReverseVideoClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionReverseVideoClause() (localctx IScreenDescriptionReverseVideoClauseContext) {
	localctx = NewScreenDescriptionReverseVideoClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, Cobol85ParserRULE_screenDescriptionReverseVideoClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2600)
		p.Match(Cobol85ParserREVERSE_VIDEO)
	}

	return localctx
}

// IScreenDescriptionUnderlineClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionUnderlineClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionUnderlineClauseContext differentiates from other interfaces.
	IsScreenDescriptionUnderlineClauseContext()
}

type ScreenDescriptionUnderlineClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionUnderlineClauseContext() *ScreenDescriptionUnderlineClauseContext {
	var p = new(ScreenDescriptionUnderlineClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUnderlineClause
	return p
}

func (*ScreenDescriptionUnderlineClauseContext) IsScreenDescriptionUnderlineClauseContext() {}

func NewScreenDescriptionUnderlineClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionUnderlineClauseContext {
	var p = new(ScreenDescriptionUnderlineClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUnderlineClause

	return p
}

func (s *ScreenDescriptionUnderlineClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionUnderlineClauseContext) UNDERLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNDERLINE, 0)
}

func (s *ScreenDescriptionUnderlineClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionUnderlineClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionUnderlineClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionUnderlineClause(s)
	}
}

func (s *ScreenDescriptionUnderlineClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionUnderlineClause(s)
	}
}

func (s *ScreenDescriptionUnderlineClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionUnderlineClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionUnderlineClause() (localctx IScreenDescriptionUnderlineClauseContext) {
	localctx = NewScreenDescriptionUnderlineClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, Cobol85ParserRULE_screenDescriptionUnderlineClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2602)
		p.Match(Cobol85ParserUNDERLINE)
	}

	return localctx
}

// IScreenDescriptionSizeClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionSizeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionSizeClauseContext differentiates from other interfaces.
	IsScreenDescriptionSizeClauseContext()
}

type ScreenDescriptionSizeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionSizeClauseContext() *ScreenDescriptionSizeClauseContext {
	var p = new(ScreenDescriptionSizeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSizeClause
	return p
}

func (*ScreenDescriptionSizeClauseContext) IsScreenDescriptionSizeClauseContext() {}

func NewScreenDescriptionSizeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionSizeClauseContext {
	var p = new(ScreenDescriptionSizeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSizeClause

	return p
}

func (s *ScreenDescriptionSizeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionSizeClauseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *ScreenDescriptionSizeClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionSizeClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionSizeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionSizeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionSizeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionSizeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionSizeClause(s)
	}
}

func (s *ScreenDescriptionSizeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionSizeClause(s)
	}
}

func (s *ScreenDescriptionSizeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionSizeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionSizeClause() (localctx IScreenDescriptionSizeClauseContext) {
	localctx = NewScreenDescriptionSizeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, Cobol85ParserRULE_screenDescriptionSizeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2604)
		p.Match(Cobol85ParserSIZE)
	}
	p.SetState(2606)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2605)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2610)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 281, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2608)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2609)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IScreenDescriptionLineClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionLineClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionLineClauseContext differentiates from other interfaces.
	IsScreenDescriptionLineClauseContext()
}

type ScreenDescriptionLineClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionLineClauseContext() *ScreenDescriptionLineClauseContext {
	var p = new(ScreenDescriptionLineClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionLineClause
	return p
}

func (*ScreenDescriptionLineClauseContext) IsScreenDescriptionLineClauseContext() {}

func NewScreenDescriptionLineClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionLineClauseContext {
	var p = new(ScreenDescriptionLineClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionLineClause

	return p
}

func (s *ScreenDescriptionLineClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionLineClauseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *ScreenDescriptionLineClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionLineClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionLineClauseContext) PLUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUS, 0)
}

func (s *ScreenDescriptionLineClauseContext) PLUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUSCHAR, 0)
}

func (s *ScreenDescriptionLineClauseContext) MINUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMINUSCHAR, 0)
}

func (s *ScreenDescriptionLineClauseContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMBER, 0)
}

func (s *ScreenDescriptionLineClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionLineClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionLineClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionLineClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionLineClause(s)
	}
}

func (s *ScreenDescriptionLineClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionLineClause(s)
	}
}

func (s *ScreenDescriptionLineClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionLineClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionLineClause() (localctx IScreenDescriptionLineClauseContext) {
	localctx = NewScreenDescriptionLineClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, Cobol85ParserRULE_screenDescriptionLineClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2612)
		p.Match(Cobol85ParserLINE)
	}
	p.SetState(2620)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS || _la == Cobol85ParserNUMBER || _la == Cobol85ParserPLUS || _la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR {
		p.SetState(2614)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserNUMBER {
			{
				p.SetState(2613)
				p.Match(Cobol85ParserNUMBER)
			}

		}
		p.SetState(2617)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2616)
				p.Match(Cobol85ParserIS)
			}

		}
		p.SetState(2619)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserPLUS || _la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	p.SetState(2624)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 285, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2622)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2623)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IScreenDescriptionColumnClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionColumnClauseContext differentiates from other interfaces.
	IsScreenDescriptionColumnClauseContext()
}

type ScreenDescriptionColumnClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionColumnClauseContext() *ScreenDescriptionColumnClauseContext {
	var p = new(ScreenDescriptionColumnClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionColumnClause
	return p
}

func (*ScreenDescriptionColumnClauseContext) IsScreenDescriptionColumnClauseContext() {}

func NewScreenDescriptionColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionColumnClauseContext {
	var p = new(ScreenDescriptionColumnClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionColumnClause

	return p
}

func (s *ScreenDescriptionColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLUMN, 0)
}

func (s *ScreenDescriptionColumnClauseContext) COL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOL, 0)
}

func (s *ScreenDescriptionColumnClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionColumnClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionColumnClauseContext) PLUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUS, 0)
}

func (s *ScreenDescriptionColumnClauseContext) PLUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUSCHAR, 0)
}

func (s *ScreenDescriptionColumnClauseContext) MINUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMINUSCHAR, 0)
}

func (s *ScreenDescriptionColumnClauseContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMBER, 0)
}

func (s *ScreenDescriptionColumnClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionColumnClause(s)
	}
}

func (s *ScreenDescriptionColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionColumnClause(s)
	}
}

func (s *ScreenDescriptionColumnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionColumnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionColumnClause() (localctx IScreenDescriptionColumnClauseContext) {
	localctx = NewScreenDescriptionColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, Cobol85ParserRULE_screenDescriptionColumnClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2626)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserCOL || _la == Cobol85ParserCOLUMN) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(2634)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS || _la == Cobol85ParserNUMBER || _la == Cobol85ParserPLUS || _la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR {
		p.SetState(2628)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserNUMBER {
			{
				p.SetState(2627)
				p.Match(Cobol85ParserNUMBER)
			}

		}
		p.SetState(2631)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2630)
				p.Match(Cobol85ParserIS)
			}

		}
		p.SetState(2633)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserPLUS || _la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	p.SetState(2638)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 289, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2636)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2637)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IScreenDescriptionForegroundColorClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionForegroundColorClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionForegroundColorClauseContext differentiates from other interfaces.
	IsScreenDescriptionForegroundColorClauseContext()
}

type ScreenDescriptionForegroundColorClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionForegroundColorClauseContext() *ScreenDescriptionForegroundColorClauseContext {
	var p = new(ScreenDescriptionForegroundColorClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionForegroundColorClause
	return p
}

func (*ScreenDescriptionForegroundColorClauseContext) IsScreenDescriptionForegroundColorClauseContext() {
}

func NewScreenDescriptionForegroundColorClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionForegroundColorClauseContext {
	var p = new(ScreenDescriptionForegroundColorClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionForegroundColorClause

	return p
}

func (s *ScreenDescriptionForegroundColorClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionForegroundColorClauseContext) FOREGROUND_COLOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOREGROUND_COLOR, 0)
}

func (s *ScreenDescriptionForegroundColorClauseContext) FOREGROUND_COLOUR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOREGROUND_COLOUR, 0)
}

func (s *ScreenDescriptionForegroundColorClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionForegroundColorClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionForegroundColorClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionForegroundColorClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionForegroundColorClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionForegroundColorClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionForegroundColorClause(s)
	}
}

func (s *ScreenDescriptionForegroundColorClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionForegroundColorClause(s)
	}
}

func (s *ScreenDescriptionForegroundColorClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionForegroundColorClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionForegroundColorClause() (localctx IScreenDescriptionForegroundColorClauseContext) {
	localctx = NewScreenDescriptionForegroundColorClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, Cobol85ParserRULE_screenDescriptionForegroundColorClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2640)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserFOREGROUND_COLOR || _la == Cobol85ParserFOREGROUND_COLOUR) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(2642)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2641)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2646)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 291, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2644)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2645)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IScreenDescriptionBackgroundColorClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionBackgroundColorClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionBackgroundColorClauseContext differentiates from other interfaces.
	IsScreenDescriptionBackgroundColorClauseContext()
}

type ScreenDescriptionBackgroundColorClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionBackgroundColorClauseContext() *ScreenDescriptionBackgroundColorClauseContext {
	var p = new(ScreenDescriptionBackgroundColorClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBackgroundColorClause
	return p
}

func (*ScreenDescriptionBackgroundColorClauseContext) IsScreenDescriptionBackgroundColorClauseContext() {
}

func NewScreenDescriptionBackgroundColorClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionBackgroundColorClauseContext {
	var p = new(ScreenDescriptionBackgroundColorClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBackgroundColorClause

	return p
}

func (s *ScreenDescriptionBackgroundColorClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionBackgroundColorClauseContext) BACKGROUND_COLOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBACKGROUND_COLOR, 0)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) BACKGROUND_COLOUR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBACKGROUND_COLOUR, 0)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionBackgroundColorClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionBackgroundColorClause(s)
	}
}

func (s *ScreenDescriptionBackgroundColorClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionBackgroundColorClause(s)
	}
}

func (s *ScreenDescriptionBackgroundColorClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionBackgroundColorClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionBackgroundColorClause() (localctx IScreenDescriptionBackgroundColorClauseContext) {
	localctx = NewScreenDescriptionBackgroundColorClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, Cobol85ParserRULE_screenDescriptionBackgroundColorClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2648)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserBACKGROUND_COLOR || _la == Cobol85ParserBACKGROUND_COLOUR) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(2650)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2649)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2654)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 293, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2652)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2653)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IScreenDescriptionControlClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionControlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionControlClauseContext differentiates from other interfaces.
	IsScreenDescriptionControlClauseContext()
}

type ScreenDescriptionControlClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionControlClauseContext() *ScreenDescriptionControlClauseContext {
	var p = new(ScreenDescriptionControlClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionControlClause
	return p
}

func (*ScreenDescriptionControlClauseContext) IsScreenDescriptionControlClauseContext() {}

func NewScreenDescriptionControlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionControlClauseContext {
	var p = new(ScreenDescriptionControlClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionControlClause

	return p
}

func (s *ScreenDescriptionControlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionControlClauseContext) CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL, 0)
}

func (s *ScreenDescriptionControlClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionControlClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionControlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionControlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionControlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionControlClause(s)
	}
}

func (s *ScreenDescriptionControlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionControlClause(s)
	}
}

func (s *ScreenDescriptionControlClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionControlClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionControlClause() (localctx IScreenDescriptionControlClauseContext) {
	localctx = NewScreenDescriptionControlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, Cobol85ParserRULE_screenDescriptionControlClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2656)
		p.Match(Cobol85ParserCONTROL)
	}
	p.SetState(2658)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2657)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2660)
		p.Identifier()
	}

	return localctx
}

// IScreenDescriptionValueClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionValueClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionValueClauseContext differentiates from other interfaces.
	IsScreenDescriptionValueClauseContext()
}

type ScreenDescriptionValueClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionValueClauseContext() *ScreenDescriptionValueClauseContext {
	var p = new(ScreenDescriptionValueClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionValueClause
	return p
}

func (*ScreenDescriptionValueClauseContext) IsScreenDescriptionValueClauseContext() {}

func NewScreenDescriptionValueClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionValueClauseContext {
	var p = new(ScreenDescriptionValueClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionValueClause

	return p
}

func (s *ScreenDescriptionValueClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionValueClauseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ScreenDescriptionValueClauseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUE, 0)
}

func (s *ScreenDescriptionValueClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionValueClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionValueClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionValueClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionValueClause(s)
	}
}

func (s *ScreenDescriptionValueClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionValueClause(s)
	}
}

func (s *ScreenDescriptionValueClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionValueClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionValueClause() (localctx IScreenDescriptionValueClauseContext) {
	localctx = NewScreenDescriptionValueClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, Cobol85ParserRULE_screenDescriptionValueClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2662)
		p.Match(Cobol85ParserVALUE)
	}
	p.SetState(2664)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2663)
			p.Match(Cobol85ParserIS)
		}

	}

	{
		p.SetState(2666)
		p.Literal()
	}

	return localctx
}

// IScreenDescriptionPictureClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionPictureClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionPictureClauseContext differentiates from other interfaces.
	IsScreenDescriptionPictureClauseContext()
}

type ScreenDescriptionPictureClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionPictureClauseContext() *ScreenDescriptionPictureClauseContext {
	var p = new(ScreenDescriptionPictureClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPictureClause
	return p
}

func (*ScreenDescriptionPictureClauseContext) IsScreenDescriptionPictureClauseContext() {}

func NewScreenDescriptionPictureClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionPictureClauseContext {
	var p = new(ScreenDescriptionPictureClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPictureClause

	return p
}

func (s *ScreenDescriptionPictureClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionPictureClauseContext) PictureString() IPictureStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPictureStringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPictureStringContext)
}

func (s *ScreenDescriptionPictureClauseContext) PICTURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPICTURE, 0)
}

func (s *ScreenDescriptionPictureClauseContext) PIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPIC, 0)
}

func (s *ScreenDescriptionPictureClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionPictureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionPictureClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionPictureClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionPictureClause(s)
	}
}

func (s *ScreenDescriptionPictureClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionPictureClause(s)
	}
}

func (s *ScreenDescriptionPictureClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionPictureClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionPictureClause() (localctx IScreenDescriptionPictureClauseContext) {
	localctx = NewScreenDescriptionPictureClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, Cobol85ParserRULE_screenDescriptionPictureClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2668)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserPIC || _la == Cobol85ParserPICTURE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(2670)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2669)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2672)
		p.PictureString()
	}

	return localctx
}

// IScreenDescriptionFromClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionFromClauseContext differentiates from other interfaces.
	IsScreenDescriptionFromClauseContext()
}

type ScreenDescriptionFromClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionFromClauseContext() *ScreenDescriptionFromClauseContext {
	var p = new(ScreenDescriptionFromClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionFromClause
	return p
}

func (*ScreenDescriptionFromClauseContext) IsScreenDescriptionFromClauseContext() {}

func NewScreenDescriptionFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionFromClauseContext {
	var p = new(ScreenDescriptionFromClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionFromClause

	return p
}

func (s *ScreenDescriptionFromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionFromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *ScreenDescriptionFromClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionFromClauseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ScreenDescriptionFromClauseContext) ScreenDescriptionToClause() IScreenDescriptionToClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionToClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionToClauseContext)
}

func (s *ScreenDescriptionFromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionFromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionFromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionFromClause(s)
	}
}

func (s *ScreenDescriptionFromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionFromClause(s)
	}
}

func (s *ScreenDescriptionFromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionFromClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionFromClause() (localctx IScreenDescriptionFromClauseContext) {
	localctx = NewScreenDescriptionFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, Cobol85ParserRULE_screenDescriptionFromClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2674)
		p.Match(Cobol85ParserFROM)
	}
	p.SetState(2677)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 297, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2675)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2676)
			p.Literal()
		}

	}
	p.SetState(2680)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(2679)
			p.ScreenDescriptionToClause()
		}

	}

	return localctx
}

// IScreenDescriptionToClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionToClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionToClauseContext differentiates from other interfaces.
	IsScreenDescriptionToClauseContext()
}

type ScreenDescriptionToClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionToClauseContext() *ScreenDescriptionToClauseContext {
	var p = new(ScreenDescriptionToClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionToClause
	return p
}

func (*ScreenDescriptionToClauseContext) IsScreenDescriptionToClauseContext() {}

func NewScreenDescriptionToClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionToClauseContext {
	var p = new(ScreenDescriptionToClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionToClause

	return p
}

func (s *ScreenDescriptionToClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionToClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *ScreenDescriptionToClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionToClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionToClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionToClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionToClause(s)
	}
}

func (s *ScreenDescriptionToClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionToClause(s)
	}
}

func (s *ScreenDescriptionToClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionToClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionToClause() (localctx IScreenDescriptionToClauseContext) {
	localctx = NewScreenDescriptionToClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, Cobol85ParserRULE_screenDescriptionToClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2682)
		p.Match(Cobol85ParserTO)
	}
	{
		p.SetState(2683)
		p.Identifier()
	}

	return localctx
}

// IScreenDescriptionUsingClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionUsingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionUsingClauseContext differentiates from other interfaces.
	IsScreenDescriptionUsingClauseContext()
}

type ScreenDescriptionUsingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionUsingClauseContext() *ScreenDescriptionUsingClauseContext {
	var p = new(ScreenDescriptionUsingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUsingClause
	return p
}

func (*ScreenDescriptionUsingClauseContext) IsScreenDescriptionUsingClauseContext() {}

func NewScreenDescriptionUsingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionUsingClauseContext {
	var p = new(ScreenDescriptionUsingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUsingClause

	return p
}

func (s *ScreenDescriptionUsingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionUsingClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *ScreenDescriptionUsingClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionUsingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionUsingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionUsingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionUsingClause(s)
	}
}

func (s *ScreenDescriptionUsingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionUsingClause(s)
	}
}

func (s *ScreenDescriptionUsingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionUsingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionUsingClause() (localctx IScreenDescriptionUsingClauseContext) {
	localctx = NewScreenDescriptionUsingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, Cobol85ParserRULE_screenDescriptionUsingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2685)
		p.Match(Cobol85ParserUSING)
	}
	{
		p.SetState(2686)
		p.Identifier()
	}

	return localctx
}

// IScreenDescriptionUsageClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionUsageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionUsageClauseContext differentiates from other interfaces.
	IsScreenDescriptionUsageClauseContext()
}

type ScreenDescriptionUsageClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionUsageClauseContext() *ScreenDescriptionUsageClauseContext {
	var p = new(ScreenDescriptionUsageClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUsageClause
	return p
}

func (*ScreenDescriptionUsageClauseContext) IsScreenDescriptionUsageClauseContext() {}

func NewScreenDescriptionUsageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionUsageClauseContext {
	var p = new(ScreenDescriptionUsageClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUsageClause

	return p
}

func (s *ScreenDescriptionUsageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionUsageClauseContext) DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY, 0)
}

func (s *ScreenDescriptionUsageClauseContext) DISPLAY_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY_1, 0)
}

func (s *ScreenDescriptionUsageClauseContext) USAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSAGE, 0)
}

func (s *ScreenDescriptionUsageClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionUsageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionUsageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionUsageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionUsageClause(s)
	}
}

func (s *ScreenDescriptionUsageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionUsageClause(s)
	}
}

func (s *ScreenDescriptionUsageClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionUsageClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionUsageClause() (localctx IScreenDescriptionUsageClauseContext) {
	localctx = NewScreenDescriptionUsageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, Cobol85ParserRULE_screenDescriptionUsageClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2688)
		p.Match(Cobol85ParserUSAGE)
	}
	p.SetState(2690)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2689)
			p.Match(Cobol85ParserIS)
		}

	}

	p.SetState(2692)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserDISPLAY || _la == Cobol85ParserDISPLAY_1) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IScreenDescriptionBlankWhenZeroClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionBlankWhenZeroClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionBlankWhenZeroClauseContext differentiates from other interfaces.
	IsScreenDescriptionBlankWhenZeroClauseContext()
}

type ScreenDescriptionBlankWhenZeroClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionBlankWhenZeroClauseContext() *ScreenDescriptionBlankWhenZeroClauseContext {
	var p = new(ScreenDescriptionBlankWhenZeroClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlankWhenZeroClause
	return p
}

func (*ScreenDescriptionBlankWhenZeroClauseContext) IsScreenDescriptionBlankWhenZeroClauseContext() {}

func NewScreenDescriptionBlankWhenZeroClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionBlankWhenZeroClauseContext {
	var p = new(ScreenDescriptionBlankWhenZeroClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlankWhenZeroClause

	return p
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionBlankWhenZeroClauseContext) BLANK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLANK, 0)
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionBlankWhenZeroClause(s)
	}
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionBlankWhenZeroClause(s)
	}
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionBlankWhenZeroClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionBlankWhenZeroClause() (localctx IScreenDescriptionBlankWhenZeroClauseContext) {
	localctx = NewScreenDescriptionBlankWhenZeroClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, Cobol85ParserRULE_screenDescriptionBlankWhenZeroClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2694)
		p.Match(Cobol85ParserBLANK)
	}
	p.SetState(2696)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWHEN {
		{
			p.SetState(2695)
			p.Match(Cobol85ParserWHEN)
		}

	}
	{
		p.SetState(2698)
		p.Match(Cobol85ParserZERO)
	}

	return localctx
}

// IScreenDescriptionJustifiedClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionJustifiedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionJustifiedClauseContext differentiates from other interfaces.
	IsScreenDescriptionJustifiedClauseContext()
}

type ScreenDescriptionJustifiedClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionJustifiedClauseContext() *ScreenDescriptionJustifiedClauseContext {
	var p = new(ScreenDescriptionJustifiedClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionJustifiedClause
	return p
}

func (*ScreenDescriptionJustifiedClauseContext) IsScreenDescriptionJustifiedClauseContext() {}

func NewScreenDescriptionJustifiedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionJustifiedClauseContext {
	var p = new(ScreenDescriptionJustifiedClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionJustifiedClause

	return p
}

func (s *ScreenDescriptionJustifiedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionJustifiedClauseContext) JUSTIFIED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUSTIFIED, 0)
}

func (s *ScreenDescriptionJustifiedClauseContext) JUST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUST, 0)
}

func (s *ScreenDescriptionJustifiedClauseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRIGHT, 0)
}

func (s *ScreenDescriptionJustifiedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionJustifiedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionJustifiedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionJustifiedClause(s)
	}
}

func (s *ScreenDescriptionJustifiedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionJustifiedClause(s)
	}
}

func (s *ScreenDescriptionJustifiedClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionJustifiedClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionJustifiedClause() (localctx IScreenDescriptionJustifiedClauseContext) {
	localctx = NewScreenDescriptionJustifiedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, Cobol85ParserRULE_screenDescriptionJustifiedClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2700)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserJUST || _la == Cobol85ParserJUSTIFIED) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(2702)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRIGHT {
		{
			p.SetState(2701)
			p.Match(Cobol85ParserRIGHT)
		}

	}

	return localctx
}

// IScreenDescriptionSignClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionSignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionSignClauseContext differentiates from other interfaces.
	IsScreenDescriptionSignClauseContext()
}

type ScreenDescriptionSignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionSignClauseContext() *ScreenDescriptionSignClauseContext {
	var p = new(ScreenDescriptionSignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSignClause
	return p
}

func (*ScreenDescriptionSignClauseContext) IsScreenDescriptionSignClauseContext() {}

func NewScreenDescriptionSignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionSignClauseContext {
	var p = new(ScreenDescriptionSignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSignClause

	return p
}

func (s *ScreenDescriptionSignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionSignClauseContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *ScreenDescriptionSignClauseContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRAILING, 0)
}

func (s *ScreenDescriptionSignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *ScreenDescriptionSignClauseContext) SEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEPARATE, 0)
}

func (s *ScreenDescriptionSignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionSignClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *ScreenDescriptionSignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionSignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionSignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionSignClause(s)
	}
}

func (s *ScreenDescriptionSignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionSignClause(s)
	}
}

func (s *ScreenDescriptionSignClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionSignClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionSignClause() (localctx IScreenDescriptionSignClauseContext) {
	localctx = NewScreenDescriptionSignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, Cobol85ParserRULE_screenDescriptionSignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2708)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIGN {
		{
			p.SetState(2704)
			p.Match(Cobol85ParserSIGN)
		}
		p.SetState(2706)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2705)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	p.SetState(2710)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(2715)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSEPARATE {
		{
			p.SetState(2711)
			p.Match(Cobol85ParserSEPARATE)
		}
		p.SetState(2713)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserCHARACTER {
			{
				p.SetState(2712)
				p.Match(Cobol85ParserCHARACTER)
			}

		}

	}

	return localctx
}

// IScreenDescriptionAutoClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionAutoClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionAutoClauseContext differentiates from other interfaces.
	IsScreenDescriptionAutoClauseContext()
}

type ScreenDescriptionAutoClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionAutoClauseContext() *ScreenDescriptionAutoClauseContext {
	var p = new(ScreenDescriptionAutoClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionAutoClause
	return p
}

func (*ScreenDescriptionAutoClauseContext) IsScreenDescriptionAutoClauseContext() {}

func NewScreenDescriptionAutoClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionAutoClauseContext {
	var p = new(ScreenDescriptionAutoClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionAutoClause

	return p
}

func (s *ScreenDescriptionAutoClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionAutoClauseContext) AUTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAUTO, 0)
}

func (s *ScreenDescriptionAutoClauseContext) AUTO_SKIP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAUTO_SKIP, 0)
}

func (s *ScreenDescriptionAutoClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionAutoClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionAutoClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionAutoClause(s)
	}
}

func (s *ScreenDescriptionAutoClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionAutoClause(s)
	}
}

func (s *ScreenDescriptionAutoClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionAutoClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionAutoClause() (localctx IScreenDescriptionAutoClauseContext) {
	localctx = NewScreenDescriptionAutoClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, Cobol85ParserRULE_screenDescriptionAutoClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2717)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserAUTO || _la == Cobol85ParserAUTO_SKIP) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IScreenDescriptionSecureClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionSecureClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionSecureClauseContext differentiates from other interfaces.
	IsScreenDescriptionSecureClauseContext()
}

type ScreenDescriptionSecureClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionSecureClauseContext() *ScreenDescriptionSecureClauseContext {
	var p = new(ScreenDescriptionSecureClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSecureClause
	return p
}

func (*ScreenDescriptionSecureClauseContext) IsScreenDescriptionSecureClauseContext() {}

func NewScreenDescriptionSecureClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionSecureClauseContext {
	var p = new(ScreenDescriptionSecureClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSecureClause

	return p
}

func (s *ScreenDescriptionSecureClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionSecureClauseContext) SECURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECURE, 0)
}

func (s *ScreenDescriptionSecureClauseContext) NO_ECHO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO_ECHO, 0)
}

func (s *ScreenDescriptionSecureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionSecureClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionSecureClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionSecureClause(s)
	}
}

func (s *ScreenDescriptionSecureClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionSecureClause(s)
	}
}

func (s *ScreenDescriptionSecureClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionSecureClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionSecureClause() (localctx IScreenDescriptionSecureClauseContext) {
	localctx = NewScreenDescriptionSecureClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, Cobol85ParserRULE_screenDescriptionSecureClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2719)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserNO_ECHO || _la == Cobol85ParserSECURE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IScreenDescriptionRequiredClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionRequiredClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionRequiredClauseContext differentiates from other interfaces.
	IsScreenDescriptionRequiredClauseContext()
}

type ScreenDescriptionRequiredClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionRequiredClauseContext() *ScreenDescriptionRequiredClauseContext {
	var p = new(ScreenDescriptionRequiredClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionRequiredClause
	return p
}

func (*ScreenDescriptionRequiredClauseContext) IsScreenDescriptionRequiredClauseContext() {}

func NewScreenDescriptionRequiredClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionRequiredClauseContext {
	var p = new(ScreenDescriptionRequiredClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionRequiredClause

	return p
}

func (s *ScreenDescriptionRequiredClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionRequiredClauseContext) REQUIRED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREQUIRED, 0)
}

func (s *ScreenDescriptionRequiredClauseContext) EMPTY_CHECK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEMPTY_CHECK, 0)
}

func (s *ScreenDescriptionRequiredClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionRequiredClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionRequiredClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionRequiredClause(s)
	}
}

func (s *ScreenDescriptionRequiredClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionRequiredClause(s)
	}
}

func (s *ScreenDescriptionRequiredClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionRequiredClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionRequiredClause() (localctx IScreenDescriptionRequiredClauseContext) {
	localctx = NewScreenDescriptionRequiredClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, Cobol85ParserRULE_screenDescriptionRequiredClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2721)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserEMPTY_CHECK || _la == Cobol85ParserREQUIRED) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IScreenDescriptionPromptClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionPromptClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionPromptClauseContext differentiates from other interfaces.
	IsScreenDescriptionPromptClauseContext()
}

type ScreenDescriptionPromptClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionPromptClauseContext() *ScreenDescriptionPromptClauseContext {
	var p = new(ScreenDescriptionPromptClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPromptClause
	return p
}

func (*ScreenDescriptionPromptClauseContext) IsScreenDescriptionPromptClauseContext() {}

func NewScreenDescriptionPromptClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionPromptClauseContext {
	var p = new(ScreenDescriptionPromptClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPromptClause

	return p
}

func (s *ScreenDescriptionPromptClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionPromptClauseContext) PROMPT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROMPT, 0)
}

func (s *ScreenDescriptionPromptClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionPromptClauseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ScreenDescriptionPromptClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *ScreenDescriptionPromptClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionPromptClauseContext) ScreenDescriptionPromptOccursClause() IScreenDescriptionPromptOccursClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionPromptOccursClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionPromptOccursClauseContext)
}

func (s *ScreenDescriptionPromptClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionPromptClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionPromptClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionPromptClause(s)
	}
}

func (s *ScreenDescriptionPromptClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionPromptClause(s)
	}
}

func (s *ScreenDescriptionPromptClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionPromptClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionPromptClause() (localctx IScreenDescriptionPromptClauseContext) {
	localctx = NewScreenDescriptionPromptClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, Cobol85ParserRULE_screenDescriptionPromptClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2723)
		p.Match(Cobol85ParserPROMPT)
	}
	p.SetState(2725)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTER {
		{
			p.SetState(2724)
			p.Match(Cobol85ParserCHARACTER)
		}

	}
	p.SetState(2728)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2727)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2732)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 308, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2730)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2731)
			p.Literal()
		}

	}
	p.SetState(2735)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOCCURS {
		{
			p.SetState(2734)
			p.ScreenDescriptionPromptOccursClause()
		}

	}

	return localctx
}

// IScreenDescriptionPromptOccursClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionPromptOccursClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionPromptOccursClauseContext differentiates from other interfaces.
	IsScreenDescriptionPromptOccursClauseContext()
}

type ScreenDescriptionPromptOccursClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionPromptOccursClauseContext() *ScreenDescriptionPromptOccursClauseContext {
	var p = new(ScreenDescriptionPromptOccursClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPromptOccursClause
	return p
}

func (*ScreenDescriptionPromptOccursClauseContext) IsScreenDescriptionPromptOccursClauseContext() {}

func NewScreenDescriptionPromptOccursClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionPromptOccursClauseContext {
	var p = new(ScreenDescriptionPromptOccursClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPromptOccursClause

	return p
}

func (s *ScreenDescriptionPromptOccursClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionPromptOccursClauseContext) OCCURS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOCCURS, 0)
}

func (s *ScreenDescriptionPromptOccursClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionPromptOccursClauseContext) TIMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMES, 0)
}

func (s *ScreenDescriptionPromptOccursClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionPromptOccursClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionPromptOccursClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionPromptOccursClause(s)
	}
}

func (s *ScreenDescriptionPromptOccursClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionPromptOccursClause(s)
	}
}

func (s *ScreenDescriptionPromptOccursClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionPromptOccursClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionPromptOccursClause() (localctx IScreenDescriptionPromptOccursClauseContext) {
	localctx = NewScreenDescriptionPromptOccursClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, Cobol85ParserRULE_screenDescriptionPromptOccursClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2737)
		p.Match(Cobol85ParserOCCURS)
	}
	{
		p.SetState(2738)
		p.IntegerLiteral()
	}
	p.SetState(2740)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTIMES {
		{
			p.SetState(2739)
			p.Match(Cobol85ParserTIMES)
		}

	}

	return localctx
}

// IScreenDescriptionFullClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionFullClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionFullClauseContext differentiates from other interfaces.
	IsScreenDescriptionFullClauseContext()
}

type ScreenDescriptionFullClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionFullClauseContext() *ScreenDescriptionFullClauseContext {
	var p = new(ScreenDescriptionFullClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionFullClause
	return p
}

func (*ScreenDescriptionFullClauseContext) IsScreenDescriptionFullClauseContext() {}

func NewScreenDescriptionFullClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionFullClauseContext {
	var p = new(ScreenDescriptionFullClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionFullClause

	return p
}

func (s *ScreenDescriptionFullClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionFullClauseContext) FULL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFULL, 0)
}

func (s *ScreenDescriptionFullClauseContext) LENGTH_CHECK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH_CHECK, 0)
}

func (s *ScreenDescriptionFullClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionFullClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionFullClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionFullClause(s)
	}
}

func (s *ScreenDescriptionFullClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionFullClause(s)
	}
}

func (s *ScreenDescriptionFullClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionFullClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionFullClause() (localctx IScreenDescriptionFullClauseContext) {
	localctx = NewScreenDescriptionFullClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, Cobol85ParserRULE_screenDescriptionFullClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2742)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserFULL || _la == Cobol85ParserLENGTH_CHECK) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IScreenDescriptionZeroFillClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionZeroFillClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionZeroFillClauseContext differentiates from other interfaces.
	IsScreenDescriptionZeroFillClauseContext()
}

type ScreenDescriptionZeroFillClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionZeroFillClauseContext() *ScreenDescriptionZeroFillClauseContext {
	var p = new(ScreenDescriptionZeroFillClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionZeroFillClause
	return p
}

func (*ScreenDescriptionZeroFillClauseContext) IsScreenDescriptionZeroFillClauseContext() {}

func NewScreenDescriptionZeroFillClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionZeroFillClauseContext {
	var p = new(ScreenDescriptionZeroFillClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionZeroFillClause

	return p
}

func (s *ScreenDescriptionZeroFillClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionZeroFillClauseContext) ZERO_FILL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO_FILL, 0)
}

func (s *ScreenDescriptionZeroFillClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionZeroFillClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionZeroFillClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionZeroFillClause(s)
	}
}

func (s *ScreenDescriptionZeroFillClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionZeroFillClause(s)
	}
}

func (s *ScreenDescriptionZeroFillClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionZeroFillClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionZeroFillClause() (localctx IScreenDescriptionZeroFillClauseContext) {
	localctx = NewScreenDescriptionZeroFillClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, Cobol85ParserRULE_screenDescriptionZeroFillClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2744)
		p.Match(Cobol85ParserZERO_FILL)
	}

	return localctx
}

// IReportSectionContext is an interface to support dynamic dispatch.
type IReportSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportSectionContext differentiates from other interfaces.
	IsReportSectionContext()
}

type ReportSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportSectionContext() *ReportSectionContext {
	var p = new(ReportSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportSection
	return p
}

func (*ReportSectionContext) IsReportSectionContext() {}

func NewReportSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportSectionContext {
	var p = new(ReportSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportSection

	return p
}

func (s *ReportSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportSectionContext) REPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPORT, 0)
}

func (s *ReportSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *ReportSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ReportSectionContext) AllReportDescription() []IReportDescriptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportDescriptionContext)(nil)).Elem())
	var tst = make([]IReportDescriptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportDescriptionContext)
		}
	}

	return tst
}

func (s *ReportSectionContext) ReportDescription(i int) IReportDescriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportDescriptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionContext)
}

func (s *ReportSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportSection(s)
	}
}

func (s *ReportSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportSection(s)
	}
}

func (s *ReportSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportSection() (localctx IReportSectionContext) {
	localctx = NewReportSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, Cobol85ParserRULE_reportSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2746)
		p.Match(Cobol85ParserREPORT)
	}
	{
		p.SetState(2747)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2748)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2752)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserRD {
		{
			p.SetState(2749)
			p.ReportDescription()
		}

		p.SetState(2754)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IReportDescriptionContext is an interface to support dynamic dispatch.
type IReportDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionContext differentiates from other interfaces.
	IsReportDescriptionContext()
}

type ReportDescriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionContext() *ReportDescriptionContext {
	var p = new(ReportDescriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescription
	return p
}

func (*ReportDescriptionContext) IsReportDescriptionContext() {}

func NewReportDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionContext {
	var p = new(ReportDescriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescription

	return p
}

func (s *ReportDescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionContext) ReportDescriptionEntry() IReportDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportDescriptionEntryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionEntryContext)
}

func (s *ReportDescriptionContext) AllReportGroupDescriptionEntry() []IReportGroupDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupDescriptionEntryContext)(nil)).Elem())
	var tst = make([]IReportGroupDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupDescriptionEntryContext)
		}
	}

	return tst
}

func (s *ReportDescriptionContext) ReportGroupDescriptionEntry(i int) IReportGroupDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupDescriptionEntryContext)
}

func (s *ReportDescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescription(s)
	}
}

func (s *ReportDescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescription(s)
	}
}

func (s *ReportDescriptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportDescription(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportDescription() (localctx IReportDescriptionContext) {
	localctx = NewReportDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, Cobol85ParserRULE_reportDescription)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2755)
		p.ReportDescriptionEntry()
	}
	p.SetState(2757)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556)))) != 0) {
		{
			p.SetState(2756)
			p.ReportGroupDescriptionEntry()
		}

		p.SetState(2759)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IReportDescriptionEntryContext is an interface to support dynamic dispatch.
type IReportDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionEntryContext differentiates from other interfaces.
	IsReportDescriptionEntryContext()
}

type ReportDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionEntryContext() *ReportDescriptionEntryContext {
	var p = new(ReportDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionEntry
	return p
}

func (*ReportDescriptionEntryContext) IsReportDescriptionEntryContext() {}

func NewReportDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionEntryContext {
	var p = new(ReportDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionEntry

	return p
}

func (s *ReportDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionEntryContext) RD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRD, 0)
}

func (s *ReportDescriptionEntryContext) ReportName() IReportNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportNameContext)
}

func (s *ReportDescriptionEntryContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionGlobalClause() IReportDescriptionGlobalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportDescriptionGlobalClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionGlobalClauseContext)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionPageLimitClause() IReportDescriptionPageLimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportDescriptionPageLimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionPageLimitClauseContext)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionHeadingClause() IReportDescriptionHeadingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportDescriptionHeadingClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionHeadingClauseContext)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionFirstDetailClause() IReportDescriptionFirstDetailClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportDescriptionFirstDetailClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionFirstDetailClauseContext)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionLastDetailClause() IReportDescriptionLastDetailClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportDescriptionLastDetailClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionLastDetailClauseContext)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionFootingClause() IReportDescriptionFootingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportDescriptionFootingClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionFootingClauseContext)
}

func (s *ReportDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionEntry(s)
	}
}

func (s *ReportDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionEntry(s)
	}
}

func (s *ReportDescriptionEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportDescriptionEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionEntry() (localctx IReportDescriptionEntryContext) {
	localctx = NewReportDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, Cobol85ParserRULE_reportDescriptionEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2761)
		p.Match(Cobol85ParserRD)
	}
	{
		p.SetState(2762)
		p.ReportName()
	}
	p.SetState(2764)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGLOBAL || _la == Cobol85ParserIS {
		{
			p.SetState(2763)
			p.ReportDescriptionGlobalClause()
		}

	}
	p.SetState(2779)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPAGE {
		{
			p.SetState(2766)
			p.ReportDescriptionPageLimitClause()
		}
		p.SetState(2768)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserHEADING {
			{
				p.SetState(2767)
				p.ReportDescriptionHeadingClause()
			}

		}
		p.SetState(2771)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFIRST {
			{
				p.SetState(2770)
				p.ReportDescriptionFirstDetailClause()
			}

		}
		p.SetState(2774)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserLAST {
			{
				p.SetState(2773)
				p.ReportDescriptionLastDetailClause()
			}

		}
		p.SetState(2777)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFOOTING {
			{
				p.SetState(2776)
				p.ReportDescriptionFootingClause()
			}

		}

	}
	{
		p.SetState(2781)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IReportDescriptionGlobalClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionGlobalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionGlobalClauseContext differentiates from other interfaces.
	IsReportDescriptionGlobalClauseContext()
}

type ReportDescriptionGlobalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionGlobalClauseContext() *ReportDescriptionGlobalClauseContext {
	var p = new(ReportDescriptionGlobalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionGlobalClause
	return p
}

func (*ReportDescriptionGlobalClauseContext) IsReportDescriptionGlobalClauseContext() {}

func NewReportDescriptionGlobalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionGlobalClauseContext {
	var p = new(ReportDescriptionGlobalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionGlobalClause

	return p
}

func (s *ReportDescriptionGlobalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionGlobalClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGLOBAL, 0)
}

func (s *ReportDescriptionGlobalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportDescriptionGlobalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionGlobalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionGlobalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionGlobalClause(s)
	}
}

func (s *ReportDescriptionGlobalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionGlobalClause(s)
	}
}

func (s *ReportDescriptionGlobalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportDescriptionGlobalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionGlobalClause() (localctx IReportDescriptionGlobalClauseContext) {
	localctx = NewReportDescriptionGlobalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, Cobol85ParserRULE_reportDescriptionGlobalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2784)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2783)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2786)
		p.Match(Cobol85ParserGLOBAL)
	}

	return localctx
}

// IReportDescriptionPageLimitClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionPageLimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionPageLimitClauseContext differentiates from other interfaces.
	IsReportDescriptionPageLimitClauseContext()
}

type ReportDescriptionPageLimitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionPageLimitClauseContext() *ReportDescriptionPageLimitClauseContext {
	var p = new(ReportDescriptionPageLimitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionPageLimitClause
	return p
}

func (*ReportDescriptionPageLimitClauseContext) IsReportDescriptionPageLimitClauseContext() {}

func NewReportDescriptionPageLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionPageLimitClauseContext {
	var p = new(ReportDescriptionPageLimitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionPageLimitClause

	return p
}

func (s *ReportDescriptionPageLimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionPageLimitClauseContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportDescriptionPageLimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIMIT, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) LIMITS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIMITS, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionPageLimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionPageLimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionPageLimitClause(s)
	}
}

func (s *ReportDescriptionPageLimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionPageLimitClause(s)
	}
}

func (s *ReportDescriptionPageLimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportDescriptionPageLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionPageLimitClause() (localctx IReportDescriptionPageLimitClauseContext) {
	localctx = NewReportDescriptionPageLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, Cobol85ParserRULE_reportDescriptionPageLimitClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2788)
		p.Match(Cobol85ParserPAGE)
	}
	p.SetState(2797)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLIMIT:
		{
			p.SetState(2789)
			p.Match(Cobol85ParserLIMIT)
		}
		p.SetState(2791)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2790)
				p.Match(Cobol85ParserIS)
			}

		}

	case Cobol85ParserLIMITS:
		{
			p.SetState(2793)
			p.Match(Cobol85ParserLIMITS)
		}
		p.SetState(2795)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserARE {
			{
				p.SetState(2794)
				p.Match(Cobol85ParserARE)
			}

		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:

	default:
	}
	{
		p.SetState(2799)
		p.IntegerLiteral()
	}
	p.SetState(2801)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINE || _la == Cobol85ParserLINES {
		p.SetState(2800)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserLINE || _la == Cobol85ParserLINES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// IReportDescriptionHeadingClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionHeadingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionHeadingClauseContext differentiates from other interfaces.
	IsReportDescriptionHeadingClauseContext()
}

type ReportDescriptionHeadingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionHeadingClauseContext() *ReportDescriptionHeadingClauseContext {
	var p = new(ReportDescriptionHeadingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionHeadingClause
	return p
}

func (*ReportDescriptionHeadingClauseContext) IsReportDescriptionHeadingClauseContext() {}

func NewReportDescriptionHeadingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionHeadingClauseContext {
	var p = new(ReportDescriptionHeadingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionHeadingClause

	return p
}

func (s *ReportDescriptionHeadingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionHeadingClauseContext) HEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHEADING, 0)
}

func (s *ReportDescriptionHeadingClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportDescriptionHeadingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionHeadingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionHeadingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionHeadingClause(s)
	}
}

func (s *ReportDescriptionHeadingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionHeadingClause(s)
	}
}

func (s *ReportDescriptionHeadingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportDescriptionHeadingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionHeadingClause() (localctx IReportDescriptionHeadingClauseContext) {
	localctx = NewReportDescriptionHeadingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, Cobol85ParserRULE_reportDescriptionHeadingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2803)
		p.Match(Cobol85ParserHEADING)
	}
	{
		p.SetState(2804)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportDescriptionFirstDetailClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionFirstDetailClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionFirstDetailClauseContext differentiates from other interfaces.
	IsReportDescriptionFirstDetailClauseContext()
}

type ReportDescriptionFirstDetailClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionFirstDetailClauseContext() *ReportDescriptionFirstDetailClauseContext {
	var p = new(ReportDescriptionFirstDetailClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionFirstDetailClause
	return p
}

func (*ReportDescriptionFirstDetailClauseContext) IsReportDescriptionFirstDetailClauseContext() {}

func NewReportDescriptionFirstDetailClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionFirstDetailClauseContext {
	var p = new(ReportDescriptionFirstDetailClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionFirstDetailClause

	return p
}

func (s *ReportDescriptionFirstDetailClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionFirstDetailClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFIRST, 0)
}

func (s *ReportDescriptionFirstDetailClauseContext) DETAIL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDETAIL, 0)
}

func (s *ReportDescriptionFirstDetailClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportDescriptionFirstDetailClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionFirstDetailClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionFirstDetailClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionFirstDetailClause(s)
	}
}

func (s *ReportDescriptionFirstDetailClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionFirstDetailClause(s)
	}
}

func (s *ReportDescriptionFirstDetailClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportDescriptionFirstDetailClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionFirstDetailClause() (localctx IReportDescriptionFirstDetailClauseContext) {
	localctx = NewReportDescriptionFirstDetailClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, Cobol85ParserRULE_reportDescriptionFirstDetailClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2806)
		p.Match(Cobol85ParserFIRST)
	}
	{
		p.SetState(2807)
		p.Match(Cobol85ParserDETAIL)
	}
	{
		p.SetState(2808)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportDescriptionLastDetailClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionLastDetailClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionLastDetailClauseContext differentiates from other interfaces.
	IsReportDescriptionLastDetailClauseContext()
}

type ReportDescriptionLastDetailClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionLastDetailClauseContext() *ReportDescriptionLastDetailClauseContext {
	var p = new(ReportDescriptionLastDetailClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionLastDetailClause
	return p
}

func (*ReportDescriptionLastDetailClauseContext) IsReportDescriptionLastDetailClauseContext() {}

func NewReportDescriptionLastDetailClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionLastDetailClauseContext {
	var p = new(ReportDescriptionLastDetailClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionLastDetailClause

	return p
}

func (s *ReportDescriptionLastDetailClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionLastDetailClauseContext) LAST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLAST, 0)
}

func (s *ReportDescriptionLastDetailClauseContext) DETAIL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDETAIL, 0)
}

func (s *ReportDescriptionLastDetailClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportDescriptionLastDetailClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionLastDetailClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionLastDetailClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionLastDetailClause(s)
	}
}

func (s *ReportDescriptionLastDetailClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionLastDetailClause(s)
	}
}

func (s *ReportDescriptionLastDetailClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportDescriptionLastDetailClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionLastDetailClause() (localctx IReportDescriptionLastDetailClauseContext) {
	localctx = NewReportDescriptionLastDetailClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, Cobol85ParserRULE_reportDescriptionLastDetailClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2810)
		p.Match(Cobol85ParserLAST)
	}
	{
		p.SetState(2811)
		p.Match(Cobol85ParserDETAIL)
	}
	{
		p.SetState(2812)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportDescriptionFootingClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionFootingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionFootingClauseContext differentiates from other interfaces.
	IsReportDescriptionFootingClauseContext()
}

type ReportDescriptionFootingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionFootingClauseContext() *ReportDescriptionFootingClauseContext {
	var p = new(ReportDescriptionFootingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionFootingClause
	return p
}

func (*ReportDescriptionFootingClauseContext) IsReportDescriptionFootingClauseContext() {}

func NewReportDescriptionFootingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionFootingClauseContext {
	var p = new(ReportDescriptionFootingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionFootingClause

	return p
}

func (s *ReportDescriptionFootingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionFootingClauseContext) FOOTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOOTING, 0)
}

func (s *ReportDescriptionFootingClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportDescriptionFootingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionFootingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionFootingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionFootingClause(s)
	}
}

func (s *ReportDescriptionFootingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionFootingClause(s)
	}
}

func (s *ReportDescriptionFootingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportDescriptionFootingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionFootingClause() (localctx IReportDescriptionFootingClauseContext) {
	localctx = NewReportDescriptionFootingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, Cobol85ParserRULE_reportDescriptionFootingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2814)
		p.Match(Cobol85ParserFOOTING)
	}
	{
		p.SetState(2815)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportGroupDescriptionEntryContext is an interface to support dynamic dispatch.
type IReportGroupDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupDescriptionEntryContext differentiates from other interfaces.
	IsReportGroupDescriptionEntryContext()
}

type ReportGroupDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupDescriptionEntryContext() *ReportGroupDescriptionEntryContext {
	var p = new(ReportGroupDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntry
	return p
}

func (*ReportGroupDescriptionEntryContext) IsReportGroupDescriptionEntryContext() {}

func NewReportGroupDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupDescriptionEntryContext {
	var p = new(ReportGroupDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntry

	return p
}

func (s *ReportGroupDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupDescriptionEntryContext) ReportGroupDescriptionEntryFormat1() IReportGroupDescriptionEntryFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupDescriptionEntryFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupDescriptionEntryFormat1Context)
}

func (s *ReportGroupDescriptionEntryContext) ReportGroupDescriptionEntryFormat2() IReportGroupDescriptionEntryFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupDescriptionEntryFormat2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupDescriptionEntryFormat2Context)
}

func (s *ReportGroupDescriptionEntryContext) ReportGroupDescriptionEntryFormat3() IReportGroupDescriptionEntryFormat3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupDescriptionEntryFormat3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupDescriptionEntryFormat3Context)
}

func (s *ReportGroupDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupDescriptionEntry(s)
	}
}

func (s *ReportGroupDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupDescriptionEntry(s)
	}
}

func (s *ReportGroupDescriptionEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupDescriptionEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupDescriptionEntry() (localctx IReportGroupDescriptionEntryContext) {
	localctx = NewReportGroupDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, Cobol85ParserRULE_reportGroupDescriptionEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2820)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 324, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2817)
			p.ReportGroupDescriptionEntryFormat1()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2818)
			p.ReportGroupDescriptionEntryFormat2()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2819)
			p.ReportGroupDescriptionEntryFormat3()
		}

	}

	return localctx
}

// IReportGroupDescriptionEntryFormat1Context is an interface to support dynamic dispatch.
type IReportGroupDescriptionEntryFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupDescriptionEntryFormat1Context differentiates from other interfaces.
	IsReportGroupDescriptionEntryFormat1Context()
}

type ReportGroupDescriptionEntryFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupDescriptionEntryFormat1Context() *ReportGroupDescriptionEntryFormat1Context {
	var p = new(ReportGroupDescriptionEntryFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat1
	return p
}

func (*ReportGroupDescriptionEntryFormat1Context) IsReportGroupDescriptionEntryFormat1Context() {}

func NewReportGroupDescriptionEntryFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupDescriptionEntryFormat1Context {
	var p = new(ReportGroupDescriptionEntryFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat1

	return p
}

func (s *ReportGroupDescriptionEntryFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupDescriptionEntryFormat1Context) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) ReportGroupTypeClause() IReportGroupTypeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupTypeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ReportGroupDescriptionEntryFormat1Context) ReportGroupLineNumberClause() IReportGroupLineNumberClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupLineNumberClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupLineNumberClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) ReportGroupNextGroupClause() IReportGroupNextGroupClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupNextGroupClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupNextGroupClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) ReportGroupUsageClause() IReportGroupUsageClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupUsageClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupUsageClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupDescriptionEntryFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupDescriptionEntryFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupDescriptionEntryFormat1(s)
	}
}

func (s *ReportGroupDescriptionEntryFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupDescriptionEntryFormat1(s)
	}
}

func (s *ReportGroupDescriptionEntryFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupDescriptionEntryFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupDescriptionEntryFormat1() (localctx IReportGroupDescriptionEntryFormat1Context) {
	localctx = NewReportGroupDescriptionEntryFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, Cobol85ParserRULE_reportGroupDescriptionEntryFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2822)
		p.IntegerLiteral()
	}
	{
		p.SetState(2823)
		p.DataName()
	}
	p.SetState(2825)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS || _la == Cobol85ParserLINE || _la == Cobol85ParserNUMBER || _la == Cobol85ParserPLUS || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556)))) != 0) {
		{
			p.SetState(2824)
			p.ReportGroupLineNumberClause()
		}

	}
	p.SetState(2828)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNEXT {
		{
			p.SetState(2827)
			p.ReportGroupNextGroupClause()
		}

	}
	{
		p.SetState(2830)
		p.ReportGroupTypeClause()
	}
	p.SetState(2832)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDISPLAY || _la == Cobol85ParserDISPLAY_1 || _la == Cobol85ParserUSAGE {
		{
			p.SetState(2831)
			p.ReportGroupUsageClause()
		}

	}
	{
		p.SetState(2834)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IReportGroupDescriptionEntryFormat2Context is an interface to support dynamic dispatch.
type IReportGroupDescriptionEntryFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupDescriptionEntryFormat2Context differentiates from other interfaces.
	IsReportGroupDescriptionEntryFormat2Context()
}

type ReportGroupDescriptionEntryFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupDescriptionEntryFormat2Context() *ReportGroupDescriptionEntryFormat2Context {
	var p = new(ReportGroupDescriptionEntryFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat2
	return p
}

func (*ReportGroupDescriptionEntryFormat2Context) IsReportGroupDescriptionEntryFormat2Context() {}

func NewReportGroupDescriptionEntryFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupDescriptionEntryFormat2Context {
	var p = new(ReportGroupDescriptionEntryFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat2

	return p
}

func (s *ReportGroupDescriptionEntryFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupDescriptionEntryFormat2Context) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupDescriptionEntryFormat2Context) ReportGroupUsageClause() IReportGroupUsageClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupUsageClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupUsageClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat2Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ReportGroupDescriptionEntryFormat2Context) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupDescriptionEntryFormat2Context) ReportGroupLineNumberClause() IReportGroupLineNumberClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupLineNumberClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupLineNumberClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupDescriptionEntryFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupDescriptionEntryFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupDescriptionEntryFormat2(s)
	}
}

func (s *ReportGroupDescriptionEntryFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupDescriptionEntryFormat2(s)
	}
}

func (s *ReportGroupDescriptionEntryFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupDescriptionEntryFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupDescriptionEntryFormat2() (localctx IReportGroupDescriptionEntryFormat2Context) {
	localctx = NewReportGroupDescriptionEntryFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, Cobol85ParserRULE_reportGroupDescriptionEntryFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2836)
		p.IntegerLiteral()
	}
	p.SetState(2838)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(2837)
			p.DataName()
		}

	}
	p.SetState(2841)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS || _la == Cobol85ParserLINE || _la == Cobol85ParserNUMBER || _la == Cobol85ParserPLUS || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556)))) != 0) {
		{
			p.SetState(2840)
			p.ReportGroupLineNumberClause()
		}

	}
	{
		p.SetState(2843)
		p.ReportGroupUsageClause()
	}
	{
		p.SetState(2844)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IReportGroupDescriptionEntryFormat3Context is an interface to support dynamic dispatch.
type IReportGroupDescriptionEntryFormat3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupDescriptionEntryFormat3Context differentiates from other interfaces.
	IsReportGroupDescriptionEntryFormat3Context()
}

type ReportGroupDescriptionEntryFormat3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupDescriptionEntryFormat3Context() *ReportGroupDescriptionEntryFormat3Context {
	var p = new(ReportGroupDescriptionEntryFormat3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat3
	return p
}

func (*ReportGroupDescriptionEntryFormat3Context) IsReportGroupDescriptionEntryFormat3Context() {}

func NewReportGroupDescriptionEntryFormat3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupDescriptionEntryFormat3Context {
	var p = new(ReportGroupDescriptionEntryFormat3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat3

	return p
}

func (s *ReportGroupDescriptionEntryFormat3Context) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupDescriptionEntryFormat3Context) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ReportGroupDescriptionEntryFormat3Context) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupPictureClause() []IReportGroupPictureClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupPictureClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupPictureClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupPictureClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupPictureClause(i int) IReportGroupPictureClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupPictureClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupPictureClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupUsageClause() []IReportGroupUsageClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupUsageClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupUsageClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupUsageClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupUsageClause(i int) IReportGroupUsageClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupUsageClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupUsageClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupSignClause() []IReportGroupSignClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupSignClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupSignClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupSignClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupSignClause(i int) IReportGroupSignClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupSignClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupSignClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupJustifiedClause() []IReportGroupJustifiedClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupJustifiedClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupJustifiedClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupJustifiedClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupJustifiedClause(i int) IReportGroupJustifiedClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupJustifiedClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupJustifiedClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupBlankWhenZeroClause() []IReportGroupBlankWhenZeroClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupBlankWhenZeroClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupBlankWhenZeroClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupBlankWhenZeroClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupBlankWhenZeroClause(i int) IReportGroupBlankWhenZeroClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupBlankWhenZeroClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupBlankWhenZeroClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupLineNumberClause() []IReportGroupLineNumberClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupLineNumberClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupLineNumberClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupLineNumberClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupLineNumberClause(i int) IReportGroupLineNumberClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupLineNumberClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupLineNumberClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupColumnNumberClause() []IReportGroupColumnNumberClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupColumnNumberClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupColumnNumberClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupColumnNumberClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupColumnNumberClause(i int) IReportGroupColumnNumberClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupColumnNumberClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupColumnNumberClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupIndicateClause() []IReportGroupIndicateClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupIndicateClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupIndicateClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupIndicateClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupIndicateClause(i int) IReportGroupIndicateClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupIndicateClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupIndicateClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupSourceClause() []IReportGroupSourceClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupSourceClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupSourceClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupSourceClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupSourceClause(i int) IReportGroupSourceClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupSourceClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupSourceClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupValueClause() []IReportGroupValueClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupValueClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupValueClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupValueClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupValueClause(i int) IReportGroupValueClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupValueClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupValueClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupSumClause() []IReportGroupSumClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupSumClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupSumClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupSumClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupSumClause(i int) IReportGroupSumClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupSumClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupSumClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupResetClause() []IReportGroupResetClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupResetClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupResetClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupResetClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupResetClause(i int) IReportGroupResetClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupResetClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupResetClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupDescriptionEntryFormat3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupDescriptionEntryFormat3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupDescriptionEntryFormat3(s)
	}
}

func (s *ReportGroupDescriptionEntryFormat3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupDescriptionEntryFormat3(s)
	}
}

func (s *ReportGroupDescriptionEntryFormat3Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupDescriptionEntryFormat3(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupDescriptionEntryFormat3() (localctx IReportGroupDescriptionEntryFormat3Context) {
	localctx = NewReportGroupDescriptionEntryFormat3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, Cobol85ParserRULE_reportGroupDescriptionEntryFormat3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2846)
		p.IntegerLiteral()
	}
	p.SetState(2848)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(2847)
			p.DataName()
		}

	}
	p.SetState(2866)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserBLANK || _la == Cobol85ParserCOLUMN || _la == Cobol85ParserDISPLAY || _la == Cobol85ParserDISPLAY_1 || (((_la-230)&-(0x1f+1)) == 0 && ((1<<uint((_la-230)))&((1<<(Cobol85ParserGROUP-230))|(1<<(Cobol85ParserIS-230))|(1<<(Cobol85ParserJUST-230))|(1<<(Cobol85ParserJUSTIFIED-230)))) != 0) || _la == Cobol85ParserLINE || _la == Cobol85ParserNUMBER || (((_la-351)&-(0x1f+1)) == 0 && ((1<<uint((_la-351)))&((1<<(Cobol85ParserPIC-351))|(1<<(Cobol85ParserPICTURE-351))|(1<<(Cobol85ParserPLUS-351)))) != 0) || _la == Cobol85ParserRESET || (((_la-441)&-(0x1f+1)) == 0 && ((1<<uint((_la-441)))&((1<<(Cobol85ParserSIGN-441))|(1<<(Cobol85ParserSOURCE-441))|(1<<(Cobol85ParserSUM-441)))) != 0) || _la == Cobol85ParserUSAGE || _la == Cobol85ParserVALUE || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556)))) != 0) {
		p.SetState(2864)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserPIC, Cobol85ParserPICTURE:
			{
				p.SetState(2850)
				p.ReportGroupPictureClause()
			}

		case Cobol85ParserDISPLAY, Cobol85ParserDISPLAY_1, Cobol85ParserUSAGE:
			{
				p.SetState(2851)
				p.ReportGroupUsageClause()
			}

		case Cobol85ParserSIGN:
			{
				p.SetState(2852)
				p.ReportGroupSignClause()
			}

		case Cobol85ParserJUST, Cobol85ParserJUSTIFIED:
			{
				p.SetState(2853)
				p.ReportGroupJustifiedClause()
			}

		case Cobol85ParserBLANK:
			{
				p.SetState(2854)
				p.ReportGroupBlankWhenZeroClause()
			}

		case Cobol85ParserIS, Cobol85ParserLINE, Cobol85ParserNUMBER, Cobol85ParserPLUS, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
			{
				p.SetState(2855)
				p.ReportGroupLineNumberClause()
			}

		case Cobol85ParserCOLUMN:
			{
				p.SetState(2856)
				p.ReportGroupColumnNumberClause()
			}

		case Cobol85ParserRESET, Cobol85ParserSOURCE, Cobol85ParserSUM, Cobol85ParserVALUE:
			p.SetState(2861)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Cobol85ParserSOURCE:
				{
					p.SetState(2857)
					p.ReportGroupSourceClause()
				}

			case Cobol85ParserVALUE:
				{
					p.SetState(2858)
					p.ReportGroupValueClause()
				}

			case Cobol85ParserSUM:
				{
					p.SetState(2859)
					p.ReportGroupSumClause()
				}

			case Cobol85ParserRESET:
				{
					p.SetState(2860)
					p.ReportGroupResetClause()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		case Cobol85ParserGROUP:
			{
				p.SetState(2863)
				p.ReportGroupIndicateClause()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2868)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2869)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IReportGroupBlankWhenZeroClauseContext is an interface to support dynamic dispatch.
type IReportGroupBlankWhenZeroClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupBlankWhenZeroClauseContext differentiates from other interfaces.
	IsReportGroupBlankWhenZeroClauseContext()
}

type ReportGroupBlankWhenZeroClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupBlankWhenZeroClauseContext() *ReportGroupBlankWhenZeroClauseContext {
	var p = new(ReportGroupBlankWhenZeroClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupBlankWhenZeroClause
	return p
}

func (*ReportGroupBlankWhenZeroClauseContext) IsReportGroupBlankWhenZeroClauseContext() {}

func NewReportGroupBlankWhenZeroClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupBlankWhenZeroClauseContext {
	var p = new(ReportGroupBlankWhenZeroClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupBlankWhenZeroClause

	return p
}

func (s *ReportGroupBlankWhenZeroClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupBlankWhenZeroClauseContext) BLANK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLANK, 0)
}

func (s *ReportGroupBlankWhenZeroClauseContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *ReportGroupBlankWhenZeroClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *ReportGroupBlankWhenZeroClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupBlankWhenZeroClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupBlankWhenZeroClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupBlankWhenZeroClause(s)
	}
}

func (s *ReportGroupBlankWhenZeroClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupBlankWhenZeroClause(s)
	}
}

func (s *ReportGroupBlankWhenZeroClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupBlankWhenZeroClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupBlankWhenZeroClause() (localctx IReportGroupBlankWhenZeroClauseContext) {
	localctx = NewReportGroupBlankWhenZeroClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, Cobol85ParserRULE_reportGroupBlankWhenZeroClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2871)
		p.Match(Cobol85ParserBLANK)
	}
	p.SetState(2873)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWHEN {
		{
			p.SetState(2872)
			p.Match(Cobol85ParserWHEN)
		}

	}
	{
		p.SetState(2875)
		p.Match(Cobol85ParserZERO)
	}

	return localctx
}

// IReportGroupColumnNumberClauseContext is an interface to support dynamic dispatch.
type IReportGroupColumnNumberClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupColumnNumberClauseContext differentiates from other interfaces.
	IsReportGroupColumnNumberClauseContext()
}

type ReportGroupColumnNumberClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupColumnNumberClauseContext() *ReportGroupColumnNumberClauseContext {
	var p = new(ReportGroupColumnNumberClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupColumnNumberClause
	return p
}

func (*ReportGroupColumnNumberClauseContext) IsReportGroupColumnNumberClauseContext() {}

func NewReportGroupColumnNumberClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupColumnNumberClauseContext {
	var p = new(ReportGroupColumnNumberClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupColumnNumberClause

	return p
}

func (s *ReportGroupColumnNumberClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupColumnNumberClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLUMN, 0)
}

func (s *ReportGroupColumnNumberClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupColumnNumberClauseContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMBER, 0)
}

func (s *ReportGroupColumnNumberClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupColumnNumberClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupColumnNumberClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupColumnNumberClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupColumnNumberClause(s)
	}
}

func (s *ReportGroupColumnNumberClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupColumnNumberClause(s)
	}
}

func (s *ReportGroupColumnNumberClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupColumnNumberClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupColumnNumberClause() (localctx IReportGroupColumnNumberClauseContext) {
	localctx = NewReportGroupColumnNumberClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, Cobol85ParserRULE_reportGroupColumnNumberClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2877)
		p.Match(Cobol85ParserCOLUMN)
	}
	p.SetState(2879)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNUMBER {
		{
			p.SetState(2878)
			p.Match(Cobol85ParserNUMBER)
		}

	}
	p.SetState(2882)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2881)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2884)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportGroupIndicateClauseContext is an interface to support dynamic dispatch.
type IReportGroupIndicateClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupIndicateClauseContext differentiates from other interfaces.
	IsReportGroupIndicateClauseContext()
}

type ReportGroupIndicateClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupIndicateClauseContext() *ReportGroupIndicateClauseContext {
	var p = new(ReportGroupIndicateClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupIndicateClause
	return p
}

func (*ReportGroupIndicateClauseContext) IsReportGroupIndicateClauseContext() {}

func NewReportGroupIndicateClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupIndicateClauseContext {
	var p = new(ReportGroupIndicateClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupIndicateClause

	return p
}

func (s *ReportGroupIndicateClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupIndicateClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGROUP, 0)
}

func (s *ReportGroupIndicateClauseContext) INDICATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINDICATE, 0)
}

func (s *ReportGroupIndicateClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupIndicateClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupIndicateClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupIndicateClause(s)
	}
}

func (s *ReportGroupIndicateClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupIndicateClause(s)
	}
}

func (s *ReportGroupIndicateClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupIndicateClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupIndicateClause() (localctx IReportGroupIndicateClauseContext) {
	localctx = NewReportGroupIndicateClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, Cobol85ParserRULE_reportGroupIndicateClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2886)
		p.Match(Cobol85ParserGROUP)
	}
	p.SetState(2888)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINDICATE {
		{
			p.SetState(2887)
			p.Match(Cobol85ParserINDICATE)
		}

	}

	return localctx
}

// IReportGroupJustifiedClauseContext is an interface to support dynamic dispatch.
type IReportGroupJustifiedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupJustifiedClauseContext differentiates from other interfaces.
	IsReportGroupJustifiedClauseContext()
}

type ReportGroupJustifiedClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupJustifiedClauseContext() *ReportGroupJustifiedClauseContext {
	var p = new(ReportGroupJustifiedClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupJustifiedClause
	return p
}

func (*ReportGroupJustifiedClauseContext) IsReportGroupJustifiedClauseContext() {}

func NewReportGroupJustifiedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupJustifiedClauseContext {
	var p = new(ReportGroupJustifiedClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupJustifiedClause

	return p
}

func (s *ReportGroupJustifiedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupJustifiedClauseContext) JUSTIFIED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUSTIFIED, 0)
}

func (s *ReportGroupJustifiedClauseContext) JUST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUST, 0)
}

func (s *ReportGroupJustifiedClauseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRIGHT, 0)
}

func (s *ReportGroupJustifiedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupJustifiedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupJustifiedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupJustifiedClause(s)
	}
}

func (s *ReportGroupJustifiedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupJustifiedClause(s)
	}
}

func (s *ReportGroupJustifiedClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupJustifiedClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupJustifiedClause() (localctx IReportGroupJustifiedClauseContext) {
	localctx = NewReportGroupJustifiedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, Cobol85ParserRULE_reportGroupJustifiedClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2890)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserJUST || _la == Cobol85ParserJUSTIFIED) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(2892)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRIGHT {
		{
			p.SetState(2891)
			p.Match(Cobol85ParserRIGHT)
		}

	}

	return localctx
}

// IReportGroupLineNumberClauseContext is an interface to support dynamic dispatch.
type IReportGroupLineNumberClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupLineNumberClauseContext differentiates from other interfaces.
	IsReportGroupLineNumberClauseContext()
}

type ReportGroupLineNumberClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupLineNumberClauseContext() *ReportGroupLineNumberClauseContext {
	var p = new(ReportGroupLineNumberClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberClause
	return p
}

func (*ReportGroupLineNumberClauseContext) IsReportGroupLineNumberClauseContext() {}

func NewReportGroupLineNumberClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupLineNumberClauseContext {
	var p = new(ReportGroupLineNumberClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberClause

	return p
}

func (s *ReportGroupLineNumberClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupLineNumberClauseContext) ReportGroupLineNumberNextPage() IReportGroupLineNumberNextPageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupLineNumberNextPageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupLineNumberNextPageContext)
}

func (s *ReportGroupLineNumberClauseContext) ReportGroupLineNumberPlus() IReportGroupLineNumberPlusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupLineNumberPlusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupLineNumberPlusContext)
}

func (s *ReportGroupLineNumberClauseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *ReportGroupLineNumberClauseContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMBER, 0)
}

func (s *ReportGroupLineNumberClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupLineNumberClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupLineNumberClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupLineNumberClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupLineNumberClause(s)
	}
}

func (s *ReportGroupLineNumberClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupLineNumberClause(s)
	}
}

func (s *ReportGroupLineNumberClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupLineNumberClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupLineNumberClause() (localctx IReportGroupLineNumberClauseContext) {
	localctx = NewReportGroupLineNumberClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, Cobol85ParserRULE_reportGroupLineNumberClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2895)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINE {
		{
			p.SetState(2894)
			p.Match(Cobol85ParserLINE)
		}

	}
	p.SetState(2898)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNUMBER {
		{
			p.SetState(2897)
			p.Match(Cobol85ParserNUMBER)
		}

	}
	p.SetState(2901)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2900)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2905)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2903)
			p.ReportGroupLineNumberNextPage()
		}

	case Cobol85ParserPLUS:
		{
			p.SetState(2904)
			p.ReportGroupLineNumberPlus()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupLineNumberNextPageContext is an interface to support dynamic dispatch.
type IReportGroupLineNumberNextPageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupLineNumberNextPageContext differentiates from other interfaces.
	IsReportGroupLineNumberNextPageContext()
}

type ReportGroupLineNumberNextPageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupLineNumberNextPageContext() *ReportGroupLineNumberNextPageContext {
	var p = new(ReportGroupLineNumberNextPageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberNextPage
	return p
}

func (*ReportGroupLineNumberNextPageContext) IsReportGroupLineNumberNextPageContext() {}

func NewReportGroupLineNumberNextPageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupLineNumberNextPageContext {
	var p = new(ReportGroupLineNumberNextPageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberNextPage

	return p
}

func (s *ReportGroupLineNumberNextPageContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupLineNumberNextPageContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupLineNumberNextPageContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *ReportGroupLineNumberNextPageContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *ReportGroupLineNumberNextPageContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *ReportGroupLineNumberNextPageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupLineNumberNextPageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupLineNumberNextPageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupLineNumberNextPage(s)
	}
}

func (s *ReportGroupLineNumberNextPageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupLineNumberNextPage(s)
	}
}

func (s *ReportGroupLineNumberNextPageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupLineNumberNextPage(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupLineNumberNextPage() (localctx IReportGroupLineNumberNextPageContext) {
	localctx = NewReportGroupLineNumberNextPageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, Cobol85ParserRULE_reportGroupLineNumberNextPage)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2907)
		p.IntegerLiteral()
	}
	p.SetState(2913)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 344, p.GetParserRuleContext()) == 1 {
		p.SetState(2909)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserON {
			{
				p.SetState(2908)
				p.Match(Cobol85ParserON)
			}

		}
		{
			p.SetState(2911)
			p.Match(Cobol85ParserNEXT)
		}
		{
			p.SetState(2912)
			p.Match(Cobol85ParserPAGE)
		}

	}

	return localctx
}

// IReportGroupLineNumberPlusContext is an interface to support dynamic dispatch.
type IReportGroupLineNumberPlusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupLineNumberPlusContext differentiates from other interfaces.
	IsReportGroupLineNumberPlusContext()
}

type ReportGroupLineNumberPlusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupLineNumberPlusContext() *ReportGroupLineNumberPlusContext {
	var p = new(ReportGroupLineNumberPlusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberPlus
	return p
}

func (*ReportGroupLineNumberPlusContext) IsReportGroupLineNumberPlusContext() {}

func NewReportGroupLineNumberPlusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupLineNumberPlusContext {
	var p = new(ReportGroupLineNumberPlusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberPlus

	return p
}

func (s *ReportGroupLineNumberPlusContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupLineNumberPlusContext) PLUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUS, 0)
}

func (s *ReportGroupLineNumberPlusContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupLineNumberPlusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupLineNumberPlusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupLineNumberPlusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupLineNumberPlus(s)
	}
}

func (s *ReportGroupLineNumberPlusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupLineNumberPlus(s)
	}
}

func (s *ReportGroupLineNumberPlusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupLineNumberPlus(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupLineNumberPlus() (localctx IReportGroupLineNumberPlusContext) {
	localctx = NewReportGroupLineNumberPlusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, Cobol85ParserRULE_reportGroupLineNumberPlus)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2915)
		p.Match(Cobol85ParserPLUS)
	}
	{
		p.SetState(2916)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportGroupNextGroupClauseContext is an interface to support dynamic dispatch.
type IReportGroupNextGroupClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupNextGroupClauseContext differentiates from other interfaces.
	IsReportGroupNextGroupClauseContext()
}

type ReportGroupNextGroupClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupNextGroupClauseContext() *ReportGroupNextGroupClauseContext {
	var p = new(ReportGroupNextGroupClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupClause
	return p
}

func (*ReportGroupNextGroupClauseContext) IsReportGroupNextGroupClauseContext() {}

func NewReportGroupNextGroupClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupNextGroupClauseContext {
	var p = new(ReportGroupNextGroupClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupClause

	return p
}

func (s *ReportGroupNextGroupClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupNextGroupClauseContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *ReportGroupNextGroupClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGROUP, 0)
}

func (s *ReportGroupNextGroupClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupNextGroupClauseContext) ReportGroupNextGroupNextPage() IReportGroupNextGroupNextPageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupNextGroupNextPageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupNextGroupNextPageContext)
}

func (s *ReportGroupNextGroupClauseContext) ReportGroupNextGroupPlus() IReportGroupNextGroupPlusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupNextGroupPlusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupNextGroupPlusContext)
}

func (s *ReportGroupNextGroupClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupNextGroupClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupNextGroupClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupNextGroupClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupNextGroupClause(s)
	}
}

func (s *ReportGroupNextGroupClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupNextGroupClause(s)
	}
}

func (s *ReportGroupNextGroupClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupNextGroupClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupNextGroupClause() (localctx IReportGroupNextGroupClauseContext) {
	localctx = NewReportGroupNextGroupClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, Cobol85ParserRULE_reportGroupNextGroupClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2918)
		p.Match(Cobol85ParserNEXT)
	}
	{
		p.SetState(2919)
		p.Match(Cobol85ParserGROUP)
	}
	p.SetState(2921)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2920)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2926)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2923)
			p.IntegerLiteral()
		}

	case Cobol85ParserNEXT:
		{
			p.SetState(2924)
			p.ReportGroupNextGroupNextPage()
		}

	case Cobol85ParserPLUS:
		{
			p.SetState(2925)
			p.ReportGroupNextGroupPlus()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupNextGroupPlusContext is an interface to support dynamic dispatch.
type IReportGroupNextGroupPlusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupNextGroupPlusContext differentiates from other interfaces.
	IsReportGroupNextGroupPlusContext()
}

type ReportGroupNextGroupPlusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupNextGroupPlusContext() *ReportGroupNextGroupPlusContext {
	var p = new(ReportGroupNextGroupPlusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupPlus
	return p
}

func (*ReportGroupNextGroupPlusContext) IsReportGroupNextGroupPlusContext() {}

func NewReportGroupNextGroupPlusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupNextGroupPlusContext {
	var p = new(ReportGroupNextGroupPlusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupPlus

	return p
}

func (s *ReportGroupNextGroupPlusContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupNextGroupPlusContext) PLUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUS, 0)
}

func (s *ReportGroupNextGroupPlusContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupNextGroupPlusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupNextGroupPlusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupNextGroupPlusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupNextGroupPlus(s)
	}
}

func (s *ReportGroupNextGroupPlusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupNextGroupPlus(s)
	}
}

func (s *ReportGroupNextGroupPlusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupNextGroupPlus(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupNextGroupPlus() (localctx IReportGroupNextGroupPlusContext) {
	localctx = NewReportGroupNextGroupPlusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, Cobol85ParserRULE_reportGroupNextGroupPlus)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2928)
		p.Match(Cobol85ParserPLUS)
	}
	{
		p.SetState(2929)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportGroupNextGroupNextPageContext is an interface to support dynamic dispatch.
type IReportGroupNextGroupNextPageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupNextGroupNextPageContext differentiates from other interfaces.
	IsReportGroupNextGroupNextPageContext()
}

type ReportGroupNextGroupNextPageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupNextGroupNextPageContext() *ReportGroupNextGroupNextPageContext {
	var p = new(ReportGroupNextGroupNextPageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupNextPage
	return p
}

func (*ReportGroupNextGroupNextPageContext) IsReportGroupNextGroupNextPageContext() {}

func NewReportGroupNextGroupNextPageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupNextGroupNextPageContext {
	var p = new(ReportGroupNextGroupNextPageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupNextPage

	return p
}

func (s *ReportGroupNextGroupNextPageContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupNextGroupNextPageContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *ReportGroupNextGroupNextPageContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *ReportGroupNextGroupNextPageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupNextGroupNextPageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupNextGroupNextPageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupNextGroupNextPage(s)
	}
}

func (s *ReportGroupNextGroupNextPageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupNextGroupNextPage(s)
	}
}

func (s *ReportGroupNextGroupNextPageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupNextGroupNextPage(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupNextGroupNextPage() (localctx IReportGroupNextGroupNextPageContext) {
	localctx = NewReportGroupNextGroupNextPageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, Cobol85ParserRULE_reportGroupNextGroupNextPage)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2931)
		p.Match(Cobol85ParserNEXT)
	}
	{
		p.SetState(2932)
		p.Match(Cobol85ParserPAGE)
	}

	return localctx
}

// IReportGroupPictureClauseContext is an interface to support dynamic dispatch.
type IReportGroupPictureClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupPictureClauseContext differentiates from other interfaces.
	IsReportGroupPictureClauseContext()
}

type ReportGroupPictureClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupPictureClauseContext() *ReportGroupPictureClauseContext {
	var p = new(ReportGroupPictureClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupPictureClause
	return p
}

func (*ReportGroupPictureClauseContext) IsReportGroupPictureClauseContext() {}

func NewReportGroupPictureClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupPictureClauseContext {
	var p = new(ReportGroupPictureClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupPictureClause

	return p
}

func (s *ReportGroupPictureClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupPictureClauseContext) PictureString() IPictureStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPictureStringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPictureStringContext)
}

func (s *ReportGroupPictureClauseContext) PICTURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPICTURE, 0)
}

func (s *ReportGroupPictureClauseContext) PIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPIC, 0)
}

func (s *ReportGroupPictureClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupPictureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupPictureClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupPictureClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupPictureClause(s)
	}
}

func (s *ReportGroupPictureClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupPictureClause(s)
	}
}

func (s *ReportGroupPictureClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupPictureClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupPictureClause() (localctx IReportGroupPictureClauseContext) {
	localctx = NewReportGroupPictureClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, Cobol85ParserRULE_reportGroupPictureClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2934)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserPIC || _la == Cobol85ParserPICTURE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(2936)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2935)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2938)
		p.PictureString()
	}

	return localctx
}

// IReportGroupResetClauseContext is an interface to support dynamic dispatch.
type IReportGroupResetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupResetClauseContext differentiates from other interfaces.
	IsReportGroupResetClauseContext()
}

type ReportGroupResetClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupResetClauseContext() *ReportGroupResetClauseContext {
	var p = new(ReportGroupResetClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupResetClause
	return p
}

func (*ReportGroupResetClauseContext) IsReportGroupResetClauseContext() {}

func NewReportGroupResetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupResetClauseContext {
	var p = new(ReportGroupResetClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupResetClause

	return p
}

func (s *ReportGroupResetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupResetClauseContext) RESET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRESET, 0)
}

func (s *ReportGroupResetClauseContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFINAL, 0)
}

func (s *ReportGroupResetClauseContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupResetClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *ReportGroupResetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupResetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupResetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupResetClause(s)
	}
}

func (s *ReportGroupResetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupResetClause(s)
	}
}

func (s *ReportGroupResetClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupResetClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupResetClause() (localctx IReportGroupResetClauseContext) {
	localctx = NewReportGroupResetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, Cobol85ParserRULE_reportGroupResetClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2940)
		p.Match(Cobol85ParserRESET)
	}
	p.SetState(2942)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(2941)
			p.Match(Cobol85ParserON)
		}

	}
	p.SetState(2946)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserFINAL:
		{
			p.SetState(2944)
			p.Match(Cobol85ParserFINAL)
		}

	case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2945)
			p.DataName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupSignClauseContext is an interface to support dynamic dispatch.
type IReportGroupSignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupSignClauseContext differentiates from other interfaces.
	IsReportGroupSignClauseContext()
}

type ReportGroupSignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupSignClauseContext() *ReportGroupSignClauseContext {
	var p = new(ReportGroupSignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupSignClause
	return p
}

func (*ReportGroupSignClauseContext) IsReportGroupSignClauseContext() {}

func NewReportGroupSignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupSignClauseContext {
	var p = new(ReportGroupSignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupSignClause

	return p
}

func (s *ReportGroupSignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupSignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *ReportGroupSignClauseContext) SEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEPARATE, 0)
}

func (s *ReportGroupSignClauseContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *ReportGroupSignClauseContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRAILING, 0)
}

func (s *ReportGroupSignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupSignClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *ReportGroupSignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupSignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupSignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupSignClause(s)
	}
}

func (s *ReportGroupSignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupSignClause(s)
	}
}

func (s *ReportGroupSignClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupSignClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupSignClause() (localctx IReportGroupSignClauseContext) {
	localctx = NewReportGroupSignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, Cobol85ParserRULE_reportGroupSignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2948)
		p.Match(Cobol85ParserSIGN)
	}
	p.SetState(2950)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2949)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2952)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(2953)
		p.Match(Cobol85ParserSEPARATE)
	}
	p.SetState(2955)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTER {
		{
			p.SetState(2954)
			p.Match(Cobol85ParserCHARACTER)
		}

	}

	return localctx
}

// IReportGroupSourceClauseContext is an interface to support dynamic dispatch.
type IReportGroupSourceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupSourceClauseContext differentiates from other interfaces.
	IsReportGroupSourceClauseContext()
}

type ReportGroupSourceClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupSourceClauseContext() *ReportGroupSourceClauseContext {
	var p = new(ReportGroupSourceClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupSourceClause
	return p
}

func (*ReportGroupSourceClauseContext) IsReportGroupSourceClauseContext() {}

func NewReportGroupSourceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupSourceClauseContext {
	var p = new(ReportGroupSourceClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupSourceClause

	return p
}

func (s *ReportGroupSourceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupSourceClauseContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSOURCE, 0)
}

func (s *ReportGroupSourceClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReportGroupSourceClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupSourceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupSourceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupSourceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupSourceClause(s)
	}
}

func (s *ReportGroupSourceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupSourceClause(s)
	}
}

func (s *ReportGroupSourceClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupSourceClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupSourceClause() (localctx IReportGroupSourceClauseContext) {
	localctx = NewReportGroupSourceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, Cobol85ParserRULE_reportGroupSourceClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2957)
		p.Match(Cobol85ParserSOURCE)
	}
	p.SetState(2959)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2958)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2961)
		p.Identifier()
	}

	return localctx
}

// IReportGroupSumClauseContext is an interface to support dynamic dispatch.
type IReportGroupSumClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupSumClauseContext differentiates from other interfaces.
	IsReportGroupSumClauseContext()
}

type ReportGroupSumClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupSumClauseContext() *ReportGroupSumClauseContext {
	var p = new(ReportGroupSumClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupSumClause
	return p
}

func (*ReportGroupSumClauseContext) IsReportGroupSumClauseContext() {}

func NewReportGroupSumClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupSumClauseContext {
	var p = new(ReportGroupSumClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupSumClause

	return p
}

func (s *ReportGroupSumClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupSumClauseContext) SUM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUM, 0)
}

func (s *ReportGroupSumClauseContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *ReportGroupSumClauseContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReportGroupSumClauseContext) UPON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUPON, 0)
}

func (s *ReportGroupSumClauseContext) AllDataName() []IDataNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataNameContext)(nil)).Elem())
	var tst = make([]IDataNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataNameContext)
		}
	}

	return tst
}

func (s *ReportGroupSumClauseContext) DataName(i int) IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupSumClauseContext) AllCOMMACHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserCOMMACHAR)
}

func (s *ReportGroupSumClauseContext) COMMACHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMACHAR, i)
}

func (s *ReportGroupSumClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupSumClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupSumClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupSumClause(s)
	}
}

func (s *ReportGroupSumClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupSumClause(s)
	}
}

func (s *ReportGroupSumClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupSumClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupSumClause() (localctx IReportGroupSumClauseContext) {
	localctx = NewReportGroupSumClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, Cobol85ParserRULE_reportGroupSumClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2963)
		p.Match(Cobol85ParserSUM)
	}
	{
		p.SetState(2964)
		p.Identifier()
	}
	p.SetState(2971)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 354, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2966)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserCOMMACHAR {
				{
					p.SetState(2965)
					p.Match(Cobol85ParserCOMMACHAR)
				}

			}
			{
				p.SetState(2968)
				p.Identifier()
			}

		}
		p.SetState(2973)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 354, p.GetParserRuleContext())
	}
	p.SetState(2985)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUPON {
		{
			p.SetState(2974)
			p.Match(Cobol85ParserUPON)
		}
		{
			p.SetState(2975)
			p.DataName()
		}
		p.SetState(2982)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserCOMMACHAR || _la == Cobol85ParserIDENTIFIER {
			p.SetState(2977)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserCOMMACHAR {
				{
					p.SetState(2976)
					p.Match(Cobol85ParserCOMMACHAR)
				}

			}
			{
				p.SetState(2979)
				p.DataName()
			}

			p.SetState(2984)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IReportGroupTypeClauseContext is an interface to support dynamic dispatch.
type IReportGroupTypeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeClauseContext differentiates from other interfaces.
	IsReportGroupTypeClauseContext()
}

type ReportGroupTypeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeClauseContext() *ReportGroupTypeClauseContext {
	var p = new(ReportGroupTypeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeClause
	return p
}

func (*ReportGroupTypeClauseContext) IsReportGroupTypeClauseContext() {}

func NewReportGroupTypeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeClauseContext {
	var p = new(ReportGroupTypeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeClause

	return p
}

func (s *ReportGroupTypeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeClauseContext) TYPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTYPE, 0)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypeReportHeading() IReportGroupTypeReportHeadingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupTypeReportHeadingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeReportHeadingContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypePageHeading() IReportGroupTypePageHeadingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupTypePageHeadingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypePageHeadingContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypeControlHeading() IReportGroupTypeControlHeadingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupTypeControlHeadingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeControlHeadingContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypeDetail() IReportGroupTypeDetailContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupTypeDetailContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeDetailContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypeControlFooting() IReportGroupTypeControlFootingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupTypeControlFootingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeControlFootingContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypePageFooting() IReportGroupTypePageFootingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupTypePageFootingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypePageFootingContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypeReportFooting() IReportGroupTypeReportFootingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupTypeReportFootingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeReportFootingContext)
}

func (s *ReportGroupTypeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupTypeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeClause(s)
	}
}

func (s *ReportGroupTypeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeClause(s)
	}
}

func (s *ReportGroupTypeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupTypeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeClause() (localctx IReportGroupTypeClauseContext) {
	localctx = NewReportGroupTypeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, Cobol85ParserRULE_reportGroupTypeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2987)
		p.Match(Cobol85ParserTYPE)
	}
	p.SetState(2989)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2988)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2998)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 359, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2991)
			p.ReportGroupTypeReportHeading()
		}

	case 2:
		{
			p.SetState(2992)
			p.ReportGroupTypePageHeading()
		}

	case 3:
		{
			p.SetState(2993)
			p.ReportGroupTypeControlHeading()
		}

	case 4:
		{
			p.SetState(2994)
			p.ReportGroupTypeDetail()
		}

	case 5:
		{
			p.SetState(2995)
			p.ReportGroupTypeControlFooting()
		}

	case 6:
		{
			p.SetState(2996)
			p.ReportGroupTypePageFooting()
		}

	case 7:
		{
			p.SetState(2997)
			p.ReportGroupTypeReportFooting()
		}

	}

	return localctx
}

// IReportGroupTypeReportHeadingContext is an interface to support dynamic dispatch.
type IReportGroupTypeReportHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeReportHeadingContext differentiates from other interfaces.
	IsReportGroupTypeReportHeadingContext()
}

type ReportGroupTypeReportHeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeReportHeadingContext() *ReportGroupTypeReportHeadingContext {
	var p = new(ReportGroupTypeReportHeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeReportHeading
	return p
}

func (*ReportGroupTypeReportHeadingContext) IsReportGroupTypeReportHeadingContext() {}

func NewReportGroupTypeReportHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeReportHeadingContext {
	var p = new(ReportGroupTypeReportHeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeReportHeading

	return p
}

func (s *ReportGroupTypeReportHeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeReportHeadingContext) REPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPORT, 0)
}

func (s *ReportGroupTypeReportHeadingContext) HEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHEADING, 0)
}

func (s *ReportGroupTypeReportHeadingContext) RH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRH, 0)
}

func (s *ReportGroupTypeReportHeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeReportHeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeReportHeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeReportHeading(s)
	}
}

func (s *ReportGroupTypeReportHeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeReportHeading(s)
	}
}

func (s *ReportGroupTypeReportHeadingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupTypeReportHeading(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeReportHeading() (localctx IReportGroupTypeReportHeadingContext) {
	localctx = NewReportGroupTypeReportHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, Cobol85ParserRULE_reportGroupTypeReportHeading)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3003)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserREPORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3000)
			p.Match(Cobol85ParserREPORT)
		}
		{
			p.SetState(3001)
			p.Match(Cobol85ParserHEADING)
		}

	case Cobol85ParserRH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3002)
			p.Match(Cobol85ParserRH)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupTypePageHeadingContext is an interface to support dynamic dispatch.
type IReportGroupTypePageHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypePageHeadingContext differentiates from other interfaces.
	IsReportGroupTypePageHeadingContext()
}

type ReportGroupTypePageHeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypePageHeadingContext() *ReportGroupTypePageHeadingContext {
	var p = new(ReportGroupTypePageHeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypePageHeading
	return p
}

func (*ReportGroupTypePageHeadingContext) IsReportGroupTypePageHeadingContext() {}

func NewReportGroupTypePageHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypePageHeadingContext {
	var p = new(ReportGroupTypePageHeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypePageHeading

	return p
}

func (s *ReportGroupTypePageHeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypePageHeadingContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *ReportGroupTypePageHeadingContext) HEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHEADING, 0)
}

func (s *ReportGroupTypePageHeadingContext) PH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPH, 0)
}

func (s *ReportGroupTypePageHeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypePageHeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypePageHeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypePageHeading(s)
	}
}

func (s *ReportGroupTypePageHeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypePageHeading(s)
	}
}

func (s *ReportGroupTypePageHeadingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupTypePageHeading(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypePageHeading() (localctx IReportGroupTypePageHeadingContext) {
	localctx = NewReportGroupTypePageHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, Cobol85ParserRULE_reportGroupTypePageHeading)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3008)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserPAGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3005)
			p.Match(Cobol85ParserPAGE)
		}
		{
			p.SetState(3006)
			p.Match(Cobol85ParserHEADING)
		}

	case Cobol85ParserPH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3007)
			p.Match(Cobol85ParserPH)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupTypeControlHeadingContext is an interface to support dynamic dispatch.
type IReportGroupTypeControlHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeControlHeadingContext differentiates from other interfaces.
	IsReportGroupTypeControlHeadingContext()
}

type ReportGroupTypeControlHeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeControlHeadingContext() *ReportGroupTypeControlHeadingContext {
	var p = new(ReportGroupTypeControlHeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeControlHeading
	return p
}

func (*ReportGroupTypeControlHeadingContext) IsReportGroupTypeControlHeadingContext() {}

func NewReportGroupTypeControlHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeControlHeadingContext {
	var p = new(ReportGroupTypeControlHeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeControlHeading

	return p
}

func (s *ReportGroupTypeControlHeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeControlHeadingContext) CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL, 0)
}

func (s *ReportGroupTypeControlHeadingContext) HEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHEADING, 0)
}

func (s *ReportGroupTypeControlHeadingContext) CH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCH, 0)
}

func (s *ReportGroupTypeControlHeadingContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFINAL, 0)
}

func (s *ReportGroupTypeControlHeadingContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupTypeControlHeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeControlHeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeControlHeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeControlHeading(s)
	}
}

func (s *ReportGroupTypeControlHeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeControlHeading(s)
	}
}

func (s *ReportGroupTypeControlHeadingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupTypeControlHeading(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeControlHeading() (localctx IReportGroupTypeControlHeadingContext) {
	localctx = NewReportGroupTypeControlHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, Cobol85ParserRULE_reportGroupTypeControlHeading)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3013)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserCONTROL:
		{
			p.SetState(3010)
			p.Match(Cobol85ParserCONTROL)
		}
		{
			p.SetState(3011)
			p.Match(Cobol85ParserHEADING)
		}

	case Cobol85ParserCH:
		{
			p.SetState(3012)
			p.Match(Cobol85ParserCH)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3017)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserFINAL:
		{
			p.SetState(3015)
			p.Match(Cobol85ParserFINAL)
		}

	case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(3016)
			p.DataName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupTypeDetailContext is an interface to support dynamic dispatch.
type IReportGroupTypeDetailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeDetailContext differentiates from other interfaces.
	IsReportGroupTypeDetailContext()
}

type ReportGroupTypeDetailContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeDetailContext() *ReportGroupTypeDetailContext {
	var p = new(ReportGroupTypeDetailContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeDetail
	return p
}

func (*ReportGroupTypeDetailContext) IsReportGroupTypeDetailContext() {}

func NewReportGroupTypeDetailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeDetailContext {
	var p = new(ReportGroupTypeDetailContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeDetail

	return p
}

func (s *ReportGroupTypeDetailContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeDetailContext) DETAIL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDETAIL, 0)
}

func (s *ReportGroupTypeDetailContext) DE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDE, 0)
}

func (s *ReportGroupTypeDetailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeDetailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeDetailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeDetail(s)
	}
}

func (s *ReportGroupTypeDetailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeDetail(s)
	}
}

func (s *ReportGroupTypeDetailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupTypeDetail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeDetail() (localctx IReportGroupTypeDetailContext) {
	localctx = NewReportGroupTypeDetailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, Cobol85ParserRULE_reportGroupTypeDetail)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3019)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserDE || _la == Cobol85ParserDETAIL) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IReportGroupTypeControlFootingContext is an interface to support dynamic dispatch.
type IReportGroupTypeControlFootingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeControlFootingContext differentiates from other interfaces.
	IsReportGroupTypeControlFootingContext()
}

type ReportGroupTypeControlFootingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeControlFootingContext() *ReportGroupTypeControlFootingContext {
	var p = new(ReportGroupTypeControlFootingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeControlFooting
	return p
}

func (*ReportGroupTypeControlFootingContext) IsReportGroupTypeControlFootingContext() {}

func NewReportGroupTypeControlFootingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeControlFootingContext {
	var p = new(ReportGroupTypeControlFootingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeControlFooting

	return p
}

func (s *ReportGroupTypeControlFootingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeControlFootingContext) CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL, 0)
}

func (s *ReportGroupTypeControlFootingContext) FOOTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOOTING, 0)
}

func (s *ReportGroupTypeControlFootingContext) CF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCF, 0)
}

func (s *ReportGroupTypeControlFootingContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFINAL, 0)
}

func (s *ReportGroupTypeControlFootingContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupTypeControlFootingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeControlFootingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeControlFootingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeControlFooting(s)
	}
}

func (s *ReportGroupTypeControlFootingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeControlFooting(s)
	}
}

func (s *ReportGroupTypeControlFootingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupTypeControlFooting(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeControlFooting() (localctx IReportGroupTypeControlFootingContext) {
	localctx = NewReportGroupTypeControlFootingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, Cobol85ParserRULE_reportGroupTypeControlFooting)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3024)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserCONTROL:
		{
			p.SetState(3021)
			p.Match(Cobol85ParserCONTROL)
		}
		{
			p.SetState(3022)
			p.Match(Cobol85ParserFOOTING)
		}

	case Cobol85ParserCF:
		{
			p.SetState(3023)
			p.Match(Cobol85ParserCF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3028)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserFINAL:
		{
			p.SetState(3026)
			p.Match(Cobol85ParserFINAL)
		}

	case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(3027)
			p.DataName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupUsageClauseContext is an interface to support dynamic dispatch.
type IReportGroupUsageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupUsageClauseContext differentiates from other interfaces.
	IsReportGroupUsageClauseContext()
}

type ReportGroupUsageClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupUsageClauseContext() *ReportGroupUsageClauseContext {
	var p = new(ReportGroupUsageClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupUsageClause
	return p
}

func (*ReportGroupUsageClauseContext) IsReportGroupUsageClauseContext() {}

func NewReportGroupUsageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupUsageClauseContext {
	var p = new(ReportGroupUsageClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupUsageClause

	return p
}

func (s *ReportGroupUsageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupUsageClauseContext) DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY, 0)
}

func (s *ReportGroupUsageClauseContext) DISPLAY_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY_1, 0)
}

func (s *ReportGroupUsageClauseContext) USAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSAGE, 0)
}

func (s *ReportGroupUsageClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupUsageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupUsageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupUsageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupUsageClause(s)
	}
}

func (s *ReportGroupUsageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupUsageClause(s)
	}
}

func (s *ReportGroupUsageClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupUsageClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupUsageClause() (localctx IReportGroupUsageClauseContext) {
	localctx = NewReportGroupUsageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, Cobol85ParserRULE_reportGroupUsageClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3034)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSAGE {
		{
			p.SetState(3030)
			p.Match(Cobol85ParserUSAGE)
		}
		p.SetState(3032)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(3031)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	p.SetState(3036)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserDISPLAY || _la == Cobol85ParserDISPLAY_1) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IReportGroupTypePageFootingContext is an interface to support dynamic dispatch.
type IReportGroupTypePageFootingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypePageFootingContext differentiates from other interfaces.
	IsReportGroupTypePageFootingContext()
}

type ReportGroupTypePageFootingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypePageFootingContext() *ReportGroupTypePageFootingContext {
	var p = new(ReportGroupTypePageFootingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypePageFooting
	return p
}

func (*ReportGroupTypePageFootingContext) IsReportGroupTypePageFootingContext() {}

func NewReportGroupTypePageFootingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypePageFootingContext {
	var p = new(ReportGroupTypePageFootingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypePageFooting

	return p
}

func (s *ReportGroupTypePageFootingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypePageFootingContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *ReportGroupTypePageFootingContext) FOOTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOOTING, 0)
}

func (s *ReportGroupTypePageFootingContext) PF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPF, 0)
}

func (s *ReportGroupTypePageFootingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypePageFootingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypePageFootingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypePageFooting(s)
	}
}

func (s *ReportGroupTypePageFootingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypePageFooting(s)
	}
}

func (s *ReportGroupTypePageFootingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupTypePageFooting(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypePageFooting() (localctx IReportGroupTypePageFootingContext) {
	localctx = NewReportGroupTypePageFootingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, Cobol85ParserRULE_reportGroupTypePageFooting)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3041)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserPAGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3038)
			p.Match(Cobol85ParserPAGE)
		}
		{
			p.SetState(3039)
			p.Match(Cobol85ParserFOOTING)
		}

	case Cobol85ParserPF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3040)
			p.Match(Cobol85ParserPF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupTypeReportFootingContext is an interface to support dynamic dispatch.
type IReportGroupTypeReportFootingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeReportFootingContext differentiates from other interfaces.
	IsReportGroupTypeReportFootingContext()
}

type ReportGroupTypeReportFootingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeReportFootingContext() *ReportGroupTypeReportFootingContext {
	var p = new(ReportGroupTypeReportFootingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeReportFooting
	return p
}

func (*ReportGroupTypeReportFootingContext) IsReportGroupTypeReportFootingContext() {}

func NewReportGroupTypeReportFootingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeReportFootingContext {
	var p = new(ReportGroupTypeReportFootingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeReportFooting

	return p
}

func (s *ReportGroupTypeReportFootingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeReportFootingContext) REPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPORT, 0)
}

func (s *ReportGroupTypeReportFootingContext) FOOTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOOTING, 0)
}

func (s *ReportGroupTypeReportFootingContext) RF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRF, 0)
}

func (s *ReportGroupTypeReportFootingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeReportFootingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeReportFootingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeReportFooting(s)
	}
}

func (s *ReportGroupTypeReportFootingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeReportFooting(s)
	}
}

func (s *ReportGroupTypeReportFootingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupTypeReportFooting(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeReportFooting() (localctx IReportGroupTypeReportFootingContext) {
	localctx = NewReportGroupTypeReportFootingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, Cobol85ParserRULE_reportGroupTypeReportFooting)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3046)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserREPORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3043)
			p.Match(Cobol85ParserREPORT)
		}
		{
			p.SetState(3044)
			p.Match(Cobol85ParserFOOTING)
		}

	case Cobol85ParserRF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3045)
			p.Match(Cobol85ParserRF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupValueClauseContext is an interface to support dynamic dispatch.
type IReportGroupValueClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupValueClauseContext differentiates from other interfaces.
	IsReportGroupValueClauseContext()
}

type ReportGroupValueClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupValueClauseContext() *ReportGroupValueClauseContext {
	var p = new(ReportGroupValueClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupValueClause
	return p
}

func (*ReportGroupValueClauseContext) IsReportGroupValueClauseContext() {}

func NewReportGroupValueClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupValueClauseContext {
	var p = new(ReportGroupValueClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupValueClause

	return p
}

func (s *ReportGroupValueClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupValueClauseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUE, 0)
}

func (s *ReportGroupValueClauseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ReportGroupValueClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupValueClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupValueClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupValueClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupValueClause(s)
	}
}

func (s *ReportGroupValueClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupValueClause(s)
	}
}

func (s *ReportGroupValueClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupValueClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupValueClause() (localctx IReportGroupValueClauseContext) {
	localctx = NewReportGroupValueClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, Cobol85ParserRULE_reportGroupValueClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3048)
		p.Match(Cobol85ParserVALUE)
	}
	p.SetState(3050)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3049)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3052)
		p.Literal()
	}

	return localctx
}

// IProgramLibrarySectionContext is an interface to support dynamic dispatch.
type IProgramLibrarySectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramLibrarySectionContext differentiates from other interfaces.
	IsProgramLibrarySectionContext()
}

type ProgramLibrarySectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramLibrarySectionContext() *ProgramLibrarySectionContext {
	var p = new(ProgramLibrarySectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_programLibrarySection
	return p
}

func (*ProgramLibrarySectionContext) IsProgramLibrarySectionContext() {}

func NewProgramLibrarySectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramLibrarySectionContext {
	var p = new(ProgramLibrarySectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_programLibrarySection

	return p
}

func (s *ProgramLibrarySectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramLibrarySectionContext) PROGRAM_LIBRARY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM_LIBRARY, 0)
}

func (s *ProgramLibrarySectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *ProgramLibrarySectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ProgramLibrarySectionContext) AllLibraryDescriptionEntry() []ILibraryDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibraryDescriptionEntryContext)(nil)).Elem())
	var tst = make([]ILibraryDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibraryDescriptionEntryContext)
		}
	}

	return tst
}

func (s *ProgramLibrarySectionContext) LibraryDescriptionEntry(i int) ILibraryDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibraryDescriptionEntryContext)
}

func (s *ProgramLibrarySectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramLibrarySectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramLibrarySectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProgramLibrarySection(s)
	}
}

func (s *ProgramLibrarySectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProgramLibrarySection(s)
	}
}

func (s *ProgramLibrarySectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProgramLibrarySection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProgramLibrarySection() (localctx IProgramLibrarySectionContext) {
	localctx = NewProgramLibrarySectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, Cobol85ParserRULE_programLibrarySection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3054)
		p.Match(Cobol85ParserPROGRAM_LIBRARY)
	}
	{
		p.SetState(3055)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(3056)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(3060)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserLB || _la == Cobol85ParserLD {
		{
			p.SetState(3057)
			p.LibraryDescriptionEntry()
		}

		p.SetState(3062)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILibraryDescriptionEntryContext is an interface to support dynamic dispatch.
type ILibraryDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryDescriptionEntryContext differentiates from other interfaces.
	IsLibraryDescriptionEntryContext()
}

type LibraryDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryDescriptionEntryContext() *LibraryDescriptionEntryContext {
	var p = new(LibraryDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntry
	return p
}

func (*LibraryDescriptionEntryContext) IsLibraryDescriptionEntryContext() {}

func NewLibraryDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryDescriptionEntryContext {
	var p = new(LibraryDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntry

	return p
}

func (s *LibraryDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryDescriptionEntryContext) LibraryDescriptionEntryFormat1() ILibraryDescriptionEntryFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryDescriptionEntryFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryDescriptionEntryFormat1Context)
}

func (s *LibraryDescriptionEntryContext) LibraryDescriptionEntryFormat2() ILibraryDescriptionEntryFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryDescriptionEntryFormat2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryDescriptionEntryFormat2Context)
}

func (s *LibraryDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryDescriptionEntry(s)
	}
}

func (s *LibraryDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryDescriptionEntry(s)
	}
}

func (s *LibraryDescriptionEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryDescriptionEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryDescriptionEntry() (localctx ILibraryDescriptionEntryContext) {
	localctx = NewLibraryDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, Cobol85ParserRULE_libraryDescriptionEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3065)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3063)
			p.LibraryDescriptionEntryFormat1()
		}

	case Cobol85ParserLB:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3064)
			p.LibraryDescriptionEntryFormat2()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILibraryDescriptionEntryFormat1Context is an interface to support dynamic dispatch.
type ILibraryDescriptionEntryFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryDescriptionEntryFormat1Context differentiates from other interfaces.
	IsLibraryDescriptionEntryFormat1Context()
}

type LibraryDescriptionEntryFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryDescriptionEntryFormat1Context() *LibraryDescriptionEntryFormat1Context {
	var p = new(LibraryDescriptionEntryFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntryFormat1
	return p
}

func (*LibraryDescriptionEntryFormat1Context) IsLibraryDescriptionEntryFormat1Context() {}

func NewLibraryDescriptionEntryFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryDescriptionEntryFormat1Context {
	var p = new(LibraryDescriptionEntryFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntryFormat1

	return p
}

func (s *LibraryDescriptionEntryFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryDescriptionEntryFormat1Context) LD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLD, 0)
}

func (s *LibraryDescriptionEntryFormat1Context) LibraryName() ILibraryNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryNameContext)
}

func (s *LibraryDescriptionEntryFormat1Context) EXPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXPORT, 0)
}

func (s *LibraryDescriptionEntryFormat1Context) LibraryAttributeClauseFormat1() ILibraryAttributeClauseFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryAttributeClauseFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryAttributeClauseFormat1Context)
}

func (s *LibraryDescriptionEntryFormat1Context) LibraryEntryProcedureClauseFormat1() ILibraryEntryProcedureClauseFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureClauseFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureClauseFormat1Context)
}

func (s *LibraryDescriptionEntryFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryDescriptionEntryFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryDescriptionEntryFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryDescriptionEntryFormat1(s)
	}
}

func (s *LibraryDescriptionEntryFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryDescriptionEntryFormat1(s)
	}
}

func (s *LibraryDescriptionEntryFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryDescriptionEntryFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryDescriptionEntryFormat1() (localctx ILibraryDescriptionEntryFormat1Context) {
	localctx = NewLibraryDescriptionEntryFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, Cobol85ParserRULE_libraryDescriptionEntryFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3067)
		p.Match(Cobol85ParserLD)
	}
	{
		p.SetState(3068)
		p.LibraryName()
	}
	{
		p.SetState(3069)
		p.Match(Cobol85ParserEXPORT)
	}
	p.SetState(3071)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserATTRIBUTE {
		{
			p.SetState(3070)
			p.LibraryAttributeClauseFormat1()
		}

	}
	p.SetState(3074)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserENTRY_PROCEDURE {
		{
			p.SetState(3073)
			p.LibraryEntryProcedureClauseFormat1()
		}

	}

	return localctx
}

// ILibraryDescriptionEntryFormat2Context is an interface to support dynamic dispatch.
type ILibraryDescriptionEntryFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryDescriptionEntryFormat2Context differentiates from other interfaces.
	IsLibraryDescriptionEntryFormat2Context()
}

type LibraryDescriptionEntryFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryDescriptionEntryFormat2Context() *LibraryDescriptionEntryFormat2Context {
	var p = new(LibraryDescriptionEntryFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntryFormat2
	return p
}

func (*LibraryDescriptionEntryFormat2Context) IsLibraryDescriptionEntryFormat2Context() {}

func NewLibraryDescriptionEntryFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryDescriptionEntryFormat2Context {
	var p = new(LibraryDescriptionEntryFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntryFormat2

	return p
}

func (s *LibraryDescriptionEntryFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryDescriptionEntryFormat2Context) LB() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLB, 0)
}

func (s *LibraryDescriptionEntryFormat2Context) LibraryName() ILibraryNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryNameContext)
}

func (s *LibraryDescriptionEntryFormat2Context) IMPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIMPORT, 0)
}

func (s *LibraryDescriptionEntryFormat2Context) LibraryIsGlobalClause() ILibraryIsGlobalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryIsGlobalClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryIsGlobalClauseContext)
}

func (s *LibraryDescriptionEntryFormat2Context) LibraryIsCommonClause() ILibraryIsCommonClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryIsCommonClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryIsCommonClauseContext)
}

func (s *LibraryDescriptionEntryFormat2Context) AllLibraryAttributeClauseFormat2() []ILibraryAttributeClauseFormat2Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibraryAttributeClauseFormat2Context)(nil)).Elem())
	var tst = make([]ILibraryAttributeClauseFormat2Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibraryAttributeClauseFormat2Context)
		}
	}

	return tst
}

func (s *LibraryDescriptionEntryFormat2Context) LibraryAttributeClauseFormat2(i int) ILibraryAttributeClauseFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryAttributeClauseFormat2Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibraryAttributeClauseFormat2Context)
}

func (s *LibraryDescriptionEntryFormat2Context) AllLibraryEntryProcedureClauseFormat2() []ILibraryEntryProcedureClauseFormat2Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibraryEntryProcedureClauseFormat2Context)(nil)).Elem())
	var tst = make([]ILibraryEntryProcedureClauseFormat2Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibraryEntryProcedureClauseFormat2Context)
		}
	}

	return tst
}

func (s *LibraryDescriptionEntryFormat2Context) LibraryEntryProcedureClauseFormat2(i int) ILibraryEntryProcedureClauseFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureClauseFormat2Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureClauseFormat2Context)
}

func (s *LibraryDescriptionEntryFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryDescriptionEntryFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryDescriptionEntryFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryDescriptionEntryFormat2(s)
	}
}

func (s *LibraryDescriptionEntryFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryDescriptionEntryFormat2(s)
	}
}

func (s *LibraryDescriptionEntryFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryDescriptionEntryFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryDescriptionEntryFormat2() (localctx ILibraryDescriptionEntryFormat2Context) {
	localctx = NewLibraryDescriptionEntryFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, Cobol85ParserRULE_libraryDescriptionEntryFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3076)
		p.Match(Cobol85ParserLB)
	}
	{
		p.SetState(3077)
		p.LibraryName()
	}
	{
		p.SetState(3078)
		p.Match(Cobol85ParserIMPORT)
	}
	p.SetState(3080)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 375, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3079)
			p.LibraryIsGlobalClause()
		}

	}
	p.SetState(3083)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMON || _la == Cobol85ParserIS {
		{
			p.SetState(3082)
			p.LibraryIsCommonClause()
		}

	}
	p.SetState(3089)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserATTRIBUTE || _la == Cobol85ParserENTRY_PROCEDURE {
		p.SetState(3087)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserATTRIBUTE:
			{
				p.SetState(3085)
				p.LibraryAttributeClauseFormat2()
			}

		case Cobol85ParserENTRY_PROCEDURE:
			{
				p.SetState(3086)
				p.LibraryEntryProcedureClauseFormat2()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3091)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILibraryAttributeClauseFormat1Context is an interface to support dynamic dispatch.
type ILibraryAttributeClauseFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryAttributeClauseFormat1Context differentiates from other interfaces.
	IsLibraryAttributeClauseFormat1Context()
}

type LibraryAttributeClauseFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryAttributeClauseFormat1Context() *LibraryAttributeClauseFormat1Context {
	var p = new(LibraryAttributeClauseFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeClauseFormat1
	return p
}

func (*LibraryAttributeClauseFormat1Context) IsLibraryAttributeClauseFormat1Context() {}

func NewLibraryAttributeClauseFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryAttributeClauseFormat1Context {
	var p = new(LibraryAttributeClauseFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeClauseFormat1

	return p
}

func (s *LibraryAttributeClauseFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryAttributeClauseFormat1Context) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserATTRIBUTE, 0)
}

func (s *LibraryAttributeClauseFormat1Context) SHARING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHARING, 0)
}

func (s *LibraryAttributeClauseFormat1Context) DONTCARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDONTCARE, 0)
}

func (s *LibraryAttributeClauseFormat1Context) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPRIVATE, 0)
}

func (s *LibraryAttributeClauseFormat1Context) SHAREDBYRUNUNIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHAREDBYRUNUNIT, 0)
}

func (s *LibraryAttributeClauseFormat1Context) SHAREDBYALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHAREDBYALL, 0)
}

func (s *LibraryAttributeClauseFormat1Context) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryAttributeClauseFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryAttributeClauseFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryAttributeClauseFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryAttributeClauseFormat1(s)
	}
}

func (s *LibraryAttributeClauseFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryAttributeClauseFormat1(s)
	}
}

func (s *LibraryAttributeClauseFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryAttributeClauseFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryAttributeClauseFormat1() (localctx ILibraryAttributeClauseFormat1Context) {
	localctx = NewLibraryAttributeClauseFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, Cobol85ParserRULE_libraryAttributeClauseFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3092)
		p.Match(Cobol85ParserATTRIBUTE)
	}
	p.SetState(3098)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSHARING {
		{
			p.SetState(3093)
			p.Match(Cobol85ParserSHARING)
		}
		p.SetState(3095)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(3094)
				p.Match(Cobol85ParserIS)
			}

		}
		p.SetState(3097)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserDONTCARE || _la == Cobol85ParserPRIVATE || _la == Cobol85ParserSHAREDBYALL || _la == Cobol85ParserSHAREDBYRUNUNIT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// ILibraryAttributeClauseFormat2Context is an interface to support dynamic dispatch.
type ILibraryAttributeClauseFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryAttributeClauseFormat2Context differentiates from other interfaces.
	IsLibraryAttributeClauseFormat2Context()
}

type LibraryAttributeClauseFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryAttributeClauseFormat2Context() *LibraryAttributeClauseFormat2Context {
	var p = new(LibraryAttributeClauseFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeClauseFormat2
	return p
}

func (*LibraryAttributeClauseFormat2Context) IsLibraryAttributeClauseFormat2Context() {}

func NewLibraryAttributeClauseFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryAttributeClauseFormat2Context {
	var p = new(LibraryAttributeClauseFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeClauseFormat2

	return p
}

func (s *LibraryAttributeClauseFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryAttributeClauseFormat2Context) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserATTRIBUTE, 0)
}

func (s *LibraryAttributeClauseFormat2Context) LibraryAttributeFunction() ILibraryAttributeFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryAttributeFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryAttributeFunctionContext)
}

func (s *LibraryAttributeClauseFormat2Context) LIBACCESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBACCESS, 0)
}

func (s *LibraryAttributeClauseFormat2Context) LibraryAttributeParameter() ILibraryAttributeParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryAttributeParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryAttributeParameterContext)
}

func (s *LibraryAttributeClauseFormat2Context) LibraryAttributeTitle() ILibraryAttributeTitleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryAttributeTitleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryAttributeTitleContext)
}

func (s *LibraryAttributeClauseFormat2Context) BYFUNCTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBYFUNCTION, 0)
}

func (s *LibraryAttributeClauseFormat2Context) BYTITLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBYTITLE, 0)
}

func (s *LibraryAttributeClauseFormat2Context) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryAttributeClauseFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryAttributeClauseFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryAttributeClauseFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryAttributeClauseFormat2(s)
	}
}

func (s *LibraryAttributeClauseFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryAttributeClauseFormat2(s)
	}
}

func (s *LibraryAttributeClauseFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryAttributeClauseFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryAttributeClauseFormat2() (localctx ILibraryAttributeClauseFormat2Context) {
	localctx = NewLibraryAttributeClauseFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, Cobol85ParserRULE_libraryAttributeClauseFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3100)
		p.Match(Cobol85ParserATTRIBUTE)
	}
	p.SetState(3102)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFUNCTIONNAME {
		{
			p.SetState(3101)
			p.LibraryAttributeFunction()
		}

	}
	p.SetState(3109)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLIBACCESS {
		{
			p.SetState(3104)
			p.Match(Cobol85ParserLIBACCESS)
		}
		p.SetState(3106)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(3105)
				p.Match(Cobol85ParserIS)
			}

		}
		p.SetState(3108)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserBYFUNCTION || _la == Cobol85ParserBYTITLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	p.SetState(3112)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLIBPARAMETER {
		{
			p.SetState(3111)
			p.LibraryAttributeParameter()
		}

	}
	p.SetState(3115)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTITLE {
		{
			p.SetState(3114)
			p.LibraryAttributeTitle()
		}

	}

	return localctx
}

// ILibraryAttributeFunctionContext is an interface to support dynamic dispatch.
type ILibraryAttributeFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryAttributeFunctionContext differentiates from other interfaces.
	IsLibraryAttributeFunctionContext()
}

type LibraryAttributeFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryAttributeFunctionContext() *LibraryAttributeFunctionContext {
	var p = new(LibraryAttributeFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeFunction
	return p
}

func (*LibraryAttributeFunctionContext) IsLibraryAttributeFunctionContext() {}

func NewLibraryAttributeFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryAttributeFunctionContext {
	var p = new(LibraryAttributeFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeFunction

	return p
}

func (s *LibraryAttributeFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryAttributeFunctionContext) FUNCTIONNAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFUNCTIONNAME, 0)
}

func (s *LibraryAttributeFunctionContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryAttributeFunctionContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LibraryAttributeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryAttributeFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryAttributeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryAttributeFunction(s)
	}
}

func (s *LibraryAttributeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryAttributeFunction(s)
	}
}

func (s *LibraryAttributeFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryAttributeFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryAttributeFunction() (localctx ILibraryAttributeFunctionContext) {
	localctx = NewLibraryAttributeFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, Cobol85ParserRULE_libraryAttributeFunction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3117)
		p.Match(Cobol85ParserFUNCTIONNAME)
	}
	{
		p.SetState(3118)
		p.Match(Cobol85ParserIS)
	}
	{
		p.SetState(3119)
		p.Literal()
	}

	return localctx
}

// ILibraryAttributeParameterContext is an interface to support dynamic dispatch.
type ILibraryAttributeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryAttributeParameterContext differentiates from other interfaces.
	IsLibraryAttributeParameterContext()
}

type LibraryAttributeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryAttributeParameterContext() *LibraryAttributeParameterContext {
	var p = new(LibraryAttributeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeParameter
	return p
}

func (*LibraryAttributeParameterContext) IsLibraryAttributeParameterContext() {}

func NewLibraryAttributeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryAttributeParameterContext {
	var p = new(LibraryAttributeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeParameter

	return p
}

func (s *LibraryAttributeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryAttributeParameterContext) LIBPARAMETER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBPARAMETER, 0)
}

func (s *LibraryAttributeParameterContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LibraryAttributeParameterContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryAttributeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryAttributeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryAttributeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryAttributeParameter(s)
	}
}

func (s *LibraryAttributeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryAttributeParameter(s)
	}
}

func (s *LibraryAttributeParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryAttributeParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryAttributeParameter() (localctx ILibraryAttributeParameterContext) {
	localctx = NewLibraryAttributeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, Cobol85ParserRULE_libraryAttributeParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3121)
		p.Match(Cobol85ParserLIBPARAMETER)
	}
	p.SetState(3123)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3122)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3125)
		p.Literal()
	}

	return localctx
}

// ILibraryAttributeTitleContext is an interface to support dynamic dispatch.
type ILibraryAttributeTitleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryAttributeTitleContext differentiates from other interfaces.
	IsLibraryAttributeTitleContext()
}

type LibraryAttributeTitleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryAttributeTitleContext() *LibraryAttributeTitleContext {
	var p = new(LibraryAttributeTitleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeTitle
	return p
}

func (*LibraryAttributeTitleContext) IsLibraryAttributeTitleContext() {}

func NewLibraryAttributeTitleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryAttributeTitleContext {
	var p = new(LibraryAttributeTitleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeTitle

	return p
}

func (s *LibraryAttributeTitleContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryAttributeTitleContext) TITLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTITLE, 0)
}

func (s *LibraryAttributeTitleContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LibraryAttributeTitleContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryAttributeTitleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryAttributeTitleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryAttributeTitleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryAttributeTitle(s)
	}
}

func (s *LibraryAttributeTitleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryAttributeTitle(s)
	}
}

func (s *LibraryAttributeTitleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryAttributeTitle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryAttributeTitle() (localctx ILibraryAttributeTitleContext) {
	localctx = NewLibraryAttributeTitleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, Cobol85ParserRULE_libraryAttributeTitle)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3127)
		p.Match(Cobol85ParserTITLE)
	}
	p.SetState(3129)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3128)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3131)
		p.Literal()
	}

	return localctx
}

// ILibraryEntryProcedureClauseFormat1Context is an interface to support dynamic dispatch.
type ILibraryEntryProcedureClauseFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureClauseFormat1Context differentiates from other interfaces.
	IsLibraryEntryProcedureClauseFormat1Context()
}

type LibraryEntryProcedureClauseFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureClauseFormat1Context() *LibraryEntryProcedureClauseFormat1Context {
	var p = new(LibraryEntryProcedureClauseFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureClauseFormat1
	return p
}

func (*LibraryEntryProcedureClauseFormat1Context) IsLibraryEntryProcedureClauseFormat1Context() {}

func NewLibraryEntryProcedureClauseFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureClauseFormat1Context {
	var p = new(LibraryEntryProcedureClauseFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureClauseFormat1

	return p
}

func (s *LibraryEntryProcedureClauseFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureClauseFormat1Context) ENTRY_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENTRY_PROCEDURE, 0)
}

func (s *LibraryEntryProcedureClauseFormat1Context) ProgramName() IProgramNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgramNameContext)
}

func (s *LibraryEntryProcedureClauseFormat1Context) LibraryEntryProcedureForClause() ILibraryEntryProcedureForClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureForClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureForClauseContext)
}

func (s *LibraryEntryProcedureClauseFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureClauseFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureClauseFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureClauseFormat1(s)
	}
}

func (s *LibraryEntryProcedureClauseFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureClauseFormat1(s)
	}
}

func (s *LibraryEntryProcedureClauseFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryEntryProcedureClauseFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureClauseFormat1() (localctx ILibraryEntryProcedureClauseFormat1Context) {
	localctx = NewLibraryEntryProcedureClauseFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, Cobol85ParserRULE_libraryEntryProcedureClauseFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3133)
		p.Match(Cobol85ParserENTRY_PROCEDURE)
	}
	{
		p.SetState(3134)
		p.ProgramName()
	}
	p.SetState(3136)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(3135)
			p.LibraryEntryProcedureForClause()
		}

	}

	return localctx
}

// ILibraryEntryProcedureClauseFormat2Context is an interface to support dynamic dispatch.
type ILibraryEntryProcedureClauseFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureClauseFormat2Context differentiates from other interfaces.
	IsLibraryEntryProcedureClauseFormat2Context()
}

type LibraryEntryProcedureClauseFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureClauseFormat2Context() *LibraryEntryProcedureClauseFormat2Context {
	var p = new(LibraryEntryProcedureClauseFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureClauseFormat2
	return p
}

func (*LibraryEntryProcedureClauseFormat2Context) IsLibraryEntryProcedureClauseFormat2Context() {}

func NewLibraryEntryProcedureClauseFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureClauseFormat2Context {
	var p = new(LibraryEntryProcedureClauseFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureClauseFormat2

	return p
}

func (s *LibraryEntryProcedureClauseFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureClauseFormat2Context) ENTRY_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENTRY_PROCEDURE, 0)
}

func (s *LibraryEntryProcedureClauseFormat2Context) ProgramName() IProgramNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgramNameContext)
}

func (s *LibraryEntryProcedureClauseFormat2Context) LibraryEntryProcedureForClause() ILibraryEntryProcedureForClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureForClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureForClauseContext)
}

func (s *LibraryEntryProcedureClauseFormat2Context) LibraryEntryProcedureWithClause() ILibraryEntryProcedureWithClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureWithClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureWithClauseContext)
}

func (s *LibraryEntryProcedureClauseFormat2Context) LibraryEntryProcedureUsingClause() ILibraryEntryProcedureUsingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureUsingClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureUsingClauseContext)
}

func (s *LibraryEntryProcedureClauseFormat2Context) LibraryEntryProcedureGivingClause() ILibraryEntryProcedureGivingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureGivingClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureGivingClauseContext)
}

func (s *LibraryEntryProcedureClauseFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureClauseFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureClauseFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureClauseFormat2(s)
	}
}

func (s *LibraryEntryProcedureClauseFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureClauseFormat2(s)
	}
}

func (s *LibraryEntryProcedureClauseFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryEntryProcedureClauseFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureClauseFormat2() (localctx ILibraryEntryProcedureClauseFormat2Context) {
	localctx = NewLibraryEntryProcedureClauseFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, Cobol85ParserRULE_libraryEntryProcedureClauseFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3138)
		p.Match(Cobol85ParserENTRY_PROCEDURE)
	}
	{
		p.SetState(3139)
		p.ProgramName()
	}
	p.SetState(3141)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(3140)
			p.LibraryEntryProcedureForClause()
		}

	}
	p.SetState(3144)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(3143)
			p.LibraryEntryProcedureWithClause()
		}

	}
	p.SetState(3147)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSING {
		{
			p.SetState(3146)
			p.LibraryEntryProcedureUsingClause()
		}

	}
	p.SetState(3150)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGIVING {
		{
			p.SetState(3149)
			p.LibraryEntryProcedureGivingClause()
		}

	}

	return localctx
}

// ILibraryEntryProcedureForClauseContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureForClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureForClauseContext differentiates from other interfaces.
	IsLibraryEntryProcedureForClauseContext()
}

type LibraryEntryProcedureForClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureForClauseContext() *LibraryEntryProcedureForClauseContext {
	var p = new(LibraryEntryProcedureForClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureForClause
	return p
}

func (*LibraryEntryProcedureForClauseContext) IsLibraryEntryProcedureForClauseContext() {}

func NewLibraryEntryProcedureForClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureForClauseContext {
	var p = new(LibraryEntryProcedureForClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureForClause

	return p
}

func (s *LibraryEntryProcedureForClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureForClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *LibraryEntryProcedureForClauseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LibraryEntryProcedureForClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureForClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureForClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureForClause(s)
	}
}

func (s *LibraryEntryProcedureForClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureForClause(s)
	}
}

func (s *LibraryEntryProcedureForClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryEntryProcedureForClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureForClause() (localctx ILibraryEntryProcedureForClauseContext) {
	localctx = NewLibraryEntryProcedureForClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, Cobol85ParserRULE_libraryEntryProcedureForClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3152)
		p.Match(Cobol85ParserFOR)
	}
	{
		p.SetState(3153)
		p.Literal()
	}

	return localctx
}

// ILibraryEntryProcedureGivingClauseContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureGivingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureGivingClauseContext differentiates from other interfaces.
	IsLibraryEntryProcedureGivingClauseContext()
}

type LibraryEntryProcedureGivingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureGivingClauseContext() *LibraryEntryProcedureGivingClauseContext {
	var p = new(LibraryEntryProcedureGivingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureGivingClause
	return p
}

func (*LibraryEntryProcedureGivingClauseContext) IsLibraryEntryProcedureGivingClauseContext() {}

func NewLibraryEntryProcedureGivingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureGivingClauseContext {
	var p = new(LibraryEntryProcedureGivingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureGivingClause

	return p
}

func (s *LibraryEntryProcedureGivingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureGivingClauseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *LibraryEntryProcedureGivingClauseContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LibraryEntryProcedureGivingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureGivingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureGivingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureGivingClause(s)
	}
}

func (s *LibraryEntryProcedureGivingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureGivingClause(s)
	}
}

func (s *LibraryEntryProcedureGivingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryEntryProcedureGivingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureGivingClause() (localctx ILibraryEntryProcedureGivingClauseContext) {
	localctx = NewLibraryEntryProcedureGivingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, Cobol85ParserRULE_libraryEntryProcedureGivingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3155)
		p.Match(Cobol85ParserGIVING)
	}
	{
		p.SetState(3156)
		p.DataName()
	}

	return localctx
}

// ILibraryEntryProcedureUsingClauseContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureUsingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureUsingClauseContext differentiates from other interfaces.
	IsLibraryEntryProcedureUsingClauseContext()
}

type LibraryEntryProcedureUsingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureUsingClauseContext() *LibraryEntryProcedureUsingClauseContext {
	var p = new(LibraryEntryProcedureUsingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureUsingClause
	return p
}

func (*LibraryEntryProcedureUsingClauseContext) IsLibraryEntryProcedureUsingClauseContext() {}

func NewLibraryEntryProcedureUsingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureUsingClauseContext {
	var p = new(LibraryEntryProcedureUsingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureUsingClause

	return p
}

func (s *LibraryEntryProcedureUsingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureUsingClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *LibraryEntryProcedureUsingClauseContext) AllLibraryEntryProcedureUsingName() []ILibraryEntryProcedureUsingNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibraryEntryProcedureUsingNameContext)(nil)).Elem())
	var tst = make([]ILibraryEntryProcedureUsingNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibraryEntryProcedureUsingNameContext)
		}
	}

	return tst
}

func (s *LibraryEntryProcedureUsingClauseContext) LibraryEntryProcedureUsingName(i int) ILibraryEntryProcedureUsingNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureUsingNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureUsingNameContext)
}

func (s *LibraryEntryProcedureUsingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureUsingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureUsingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureUsingClause(s)
	}
}

func (s *LibraryEntryProcedureUsingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureUsingClause(s)
	}
}

func (s *LibraryEntryProcedureUsingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryEntryProcedureUsingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureUsingClause() (localctx ILibraryEntryProcedureUsingClauseContext) {
	localctx = NewLibraryEntryProcedureUsingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, Cobol85ParserRULE_libraryEntryProcedureUsingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3158)
		p.Match(Cobol85ParserUSING)
	}
	p.SetState(3160)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3159)
				p.LibraryEntryProcedureUsingName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3162)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 393, p.GetParserRuleContext())
	}

	return localctx
}

// ILibraryEntryProcedureUsingNameContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureUsingNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureUsingNameContext differentiates from other interfaces.
	IsLibraryEntryProcedureUsingNameContext()
}

type LibraryEntryProcedureUsingNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureUsingNameContext() *LibraryEntryProcedureUsingNameContext {
	var p = new(LibraryEntryProcedureUsingNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureUsingName
	return p
}

func (*LibraryEntryProcedureUsingNameContext) IsLibraryEntryProcedureUsingNameContext() {}

func NewLibraryEntryProcedureUsingNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureUsingNameContext {
	var p = new(LibraryEntryProcedureUsingNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureUsingName

	return p
}

func (s *LibraryEntryProcedureUsingNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureUsingNameContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LibraryEntryProcedureUsingNameContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *LibraryEntryProcedureUsingNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureUsingNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureUsingNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureUsingName(s)
	}
}

func (s *LibraryEntryProcedureUsingNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureUsingName(s)
	}
}

func (s *LibraryEntryProcedureUsingNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryEntryProcedureUsingName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureUsingName() (localctx ILibraryEntryProcedureUsingNameContext) {
	localctx = NewLibraryEntryProcedureUsingNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, Cobol85ParserRULE_libraryEntryProcedureUsingName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3166)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 394, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3164)
			p.DataName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3165)
			p.FileName()
		}

	}

	return localctx
}

// ILibraryEntryProcedureWithClauseContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureWithClauseContext differentiates from other interfaces.
	IsLibraryEntryProcedureWithClauseContext()
}

type LibraryEntryProcedureWithClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureWithClauseContext() *LibraryEntryProcedureWithClauseContext {
	var p = new(LibraryEntryProcedureWithClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureWithClause
	return p
}

func (*LibraryEntryProcedureWithClauseContext) IsLibraryEntryProcedureWithClauseContext() {}

func NewLibraryEntryProcedureWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureWithClauseContext {
	var p = new(LibraryEntryProcedureWithClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureWithClause

	return p
}

func (s *LibraryEntryProcedureWithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureWithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *LibraryEntryProcedureWithClauseContext) AllLibraryEntryProcedureWithName() []ILibraryEntryProcedureWithNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibraryEntryProcedureWithNameContext)(nil)).Elem())
	var tst = make([]ILibraryEntryProcedureWithNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibraryEntryProcedureWithNameContext)
		}
	}

	return tst
}

func (s *LibraryEntryProcedureWithClauseContext) LibraryEntryProcedureWithName(i int) ILibraryEntryProcedureWithNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureWithNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureWithNameContext)
}

func (s *LibraryEntryProcedureWithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureWithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureWithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureWithClause(s)
	}
}

func (s *LibraryEntryProcedureWithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureWithClause(s)
	}
}

func (s *LibraryEntryProcedureWithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryEntryProcedureWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureWithClause() (localctx ILibraryEntryProcedureWithClauseContext) {
	localctx = NewLibraryEntryProcedureWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, Cobol85ParserRULE_libraryEntryProcedureWithClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3168)
		p.Match(Cobol85ParserWITH)
	}
	p.SetState(3170)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3169)
				p.LibraryEntryProcedureWithName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3172)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 395, p.GetParserRuleContext())
	}

	return localctx
}

// ILibraryEntryProcedureWithNameContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureWithNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureWithNameContext differentiates from other interfaces.
	IsLibraryEntryProcedureWithNameContext()
}

type LibraryEntryProcedureWithNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureWithNameContext() *LibraryEntryProcedureWithNameContext {
	var p = new(LibraryEntryProcedureWithNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureWithName
	return p
}

func (*LibraryEntryProcedureWithNameContext) IsLibraryEntryProcedureWithNameContext() {}

func NewLibraryEntryProcedureWithNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureWithNameContext {
	var p = new(LibraryEntryProcedureWithNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureWithName

	return p
}

func (s *LibraryEntryProcedureWithNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureWithNameContext) LocalName() ILocalNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalNameContext)
}

func (s *LibraryEntryProcedureWithNameContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *LibraryEntryProcedureWithNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureWithNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureWithNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureWithName(s)
	}
}

func (s *LibraryEntryProcedureWithNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureWithName(s)
	}
}

func (s *LibraryEntryProcedureWithNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryEntryProcedureWithName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureWithName() (localctx ILibraryEntryProcedureWithNameContext) {
	localctx = NewLibraryEntryProcedureWithNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, Cobol85ParserRULE_libraryEntryProcedureWithName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3176)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 396, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3174)
			p.LocalName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3175)
			p.FileName()
		}

	}

	return localctx
}

// ILibraryIsCommonClauseContext is an interface to support dynamic dispatch.
type ILibraryIsCommonClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryIsCommonClauseContext differentiates from other interfaces.
	IsLibraryIsCommonClauseContext()
}

type LibraryIsCommonClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryIsCommonClauseContext() *LibraryIsCommonClauseContext {
	var p = new(LibraryIsCommonClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryIsCommonClause
	return p
}

func (*LibraryIsCommonClauseContext) IsLibraryIsCommonClauseContext() {}

func NewLibraryIsCommonClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryIsCommonClauseContext {
	var p = new(LibraryIsCommonClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryIsCommonClause

	return p
}

func (s *LibraryIsCommonClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryIsCommonClauseContext) COMMON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMON, 0)
}

func (s *LibraryIsCommonClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryIsCommonClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryIsCommonClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryIsCommonClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryIsCommonClause(s)
	}
}

func (s *LibraryIsCommonClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryIsCommonClause(s)
	}
}

func (s *LibraryIsCommonClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryIsCommonClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryIsCommonClause() (localctx ILibraryIsCommonClauseContext) {
	localctx = NewLibraryIsCommonClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, Cobol85ParserRULE_libraryIsCommonClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3179)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3178)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3181)
		p.Match(Cobol85ParserCOMMON)
	}

	return localctx
}

// ILibraryIsGlobalClauseContext is an interface to support dynamic dispatch.
type ILibraryIsGlobalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryIsGlobalClauseContext differentiates from other interfaces.
	IsLibraryIsGlobalClauseContext()
}

type LibraryIsGlobalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryIsGlobalClauseContext() *LibraryIsGlobalClauseContext {
	var p = new(LibraryIsGlobalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryIsGlobalClause
	return p
}

func (*LibraryIsGlobalClauseContext) IsLibraryIsGlobalClauseContext() {}

func NewLibraryIsGlobalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryIsGlobalClauseContext {
	var p = new(LibraryIsGlobalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryIsGlobalClause

	return p
}

func (s *LibraryIsGlobalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryIsGlobalClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGLOBAL, 0)
}

func (s *LibraryIsGlobalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryIsGlobalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryIsGlobalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryIsGlobalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryIsGlobalClause(s)
	}
}

func (s *LibraryIsGlobalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryIsGlobalClause(s)
	}
}

func (s *LibraryIsGlobalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryIsGlobalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryIsGlobalClause() (localctx ILibraryIsGlobalClauseContext) {
	localctx = NewLibraryIsGlobalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, Cobol85ParserRULE_libraryIsGlobalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3184)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3183)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3186)
		p.Match(Cobol85ParserGLOBAL)
	}

	return localctx
}

// IDataDescriptionEntryContext is an interface to support dynamic dispatch.
type IDataDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescriptionEntryContext differentiates from other interfaces.
	IsDataDescriptionEntryContext()
}

type DataDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescriptionEntryContext() *DataDescriptionEntryContext {
	var p = new(DataDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntry
	return p
}

func (*DataDescriptionEntryContext) IsDataDescriptionEntryContext() {}

func NewDataDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescriptionEntryContext {
	var p = new(DataDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntry

	return p
}

func (s *DataDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescriptionEntryContext) DataDescriptionEntryFormat1() IDataDescriptionEntryFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryFormat1Context)
}

func (s *DataDescriptionEntryContext) DataDescriptionEntryFormat2() IDataDescriptionEntryFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryFormat2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryFormat2Context)
}

func (s *DataDescriptionEntryContext) DataDescriptionEntryFormat3() IDataDescriptionEntryFormat3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryFormat3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryFormat3Context)
}

func (s *DataDescriptionEntryContext) DataDescriptionEntryExecSql() IDataDescriptionEntryExecSqlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryExecSqlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryExecSqlContext)
}

func (s *DataDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescriptionEntry(s)
	}
}

func (s *DataDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescriptionEntry(s)
	}
}

func (s *DataDescriptionEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataDescriptionEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataDescriptionEntry() (localctx IDataDescriptionEntryContext) {
	localctx = NewDataDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, Cobol85ParserRULE_dataDescriptionEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3192)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserINTEGERLITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3188)
			p.DataDescriptionEntryFormat1()
		}

	case Cobol85ParserLEVEL_NUMBER_66:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3189)
			p.DataDescriptionEntryFormat2()
		}

	case Cobol85ParserLEVEL_NUMBER_88:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3190)
			p.DataDescriptionEntryFormat3()
		}

	case Cobol85ParserEXECSQLLINE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3191)
			p.DataDescriptionEntryExecSql()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDataDescriptionEntryFormat1Context is an interface to support dynamic dispatch.
type IDataDescriptionEntryFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescriptionEntryFormat1Context differentiates from other interfaces.
	IsDataDescriptionEntryFormat1Context()
}

type DataDescriptionEntryFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescriptionEntryFormat1Context() *DataDescriptionEntryFormat1Context {
	var p = new(DataDescriptionEntryFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat1
	return p
}

func (*DataDescriptionEntryFormat1Context) IsDataDescriptionEntryFormat1Context() {}

func NewDataDescriptionEntryFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescriptionEntryFormat1Context {
	var p = new(DataDescriptionEntryFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat1

	return p
}

func (s *DataDescriptionEntryFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *DataDescriptionEntryFormat1Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataDescriptionEntryFormat1Context) INTEGERLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGERLITERAL, 0)
}

func (s *DataDescriptionEntryFormat1Context) LEVEL_NUMBER_77() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_77, 0)
}

func (s *DataDescriptionEntryFormat1Context) FILLER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILLER, 0)
}

func (s *DataDescriptionEntryFormat1Context) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataDescriptionEntryFormat1Context) DataRedefinesClause() IDataRedefinesClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataRedefinesClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataRedefinesClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) DataIntegerStringClause() IDataIntegerStringClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataIntegerStringClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataIntegerStringClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) DataExternalClause() IDataExternalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataExternalClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataExternalClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) DataGlobalClause() IDataGlobalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataGlobalClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataGlobalClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) DataTypeDefClause() IDataTypeDefClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeDefClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeDefClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) DataThreadLocalClause() IDataThreadLocalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataThreadLocalClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataThreadLocalClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataPictureClause() []IDataPictureClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataPictureClauseContext)(nil)).Elem())
	var tst = make([]IDataPictureClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataPictureClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataPictureClause(i int) IDataPictureClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataPictureClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataPictureClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataCommonOwnLocalClause() []IDataCommonOwnLocalClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataCommonOwnLocalClauseContext)(nil)).Elem())
	var tst = make([]IDataCommonOwnLocalClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataCommonOwnLocalClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataCommonOwnLocalClause(i int) IDataCommonOwnLocalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataCommonOwnLocalClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataCommonOwnLocalClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataTypeClause() []IDataTypeClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataTypeClauseContext)(nil)).Elem())
	var tst = make([]IDataTypeClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataTypeClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataTypeClause(i int) IDataTypeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataTypeClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataUsingClause() []IDataUsingClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataUsingClauseContext)(nil)).Elem())
	var tst = make([]IDataUsingClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataUsingClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataUsingClause(i int) IDataUsingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataUsingClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataUsingClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataValueClause() []IDataValueClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataValueClauseContext)(nil)).Elem())
	var tst = make([]IDataValueClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataValueClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataValueClause(i int) IDataValueClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataValueClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataValueClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataUsageClause() []IDataUsageClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataUsageClauseContext)(nil)).Elem())
	var tst = make([]IDataUsageClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataUsageClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataUsageClause(i int) IDataUsageClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataUsageClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataUsageClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataReceivedByClause() []IDataReceivedByClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataReceivedByClauseContext)(nil)).Elem())
	var tst = make([]IDataReceivedByClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataReceivedByClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataReceivedByClause(i int) IDataReceivedByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataReceivedByClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataReceivedByClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataOccursClause() []IDataOccursClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataOccursClauseContext)(nil)).Elem())
	var tst = make([]IDataOccursClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataOccursClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataOccursClause(i int) IDataOccursClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataOccursClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataOccursClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataSignClause() []IDataSignClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataSignClauseContext)(nil)).Elem())
	var tst = make([]IDataSignClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataSignClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataSignClause(i int) IDataSignClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataSignClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataSignClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataSynchronizedClause() []IDataSynchronizedClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataSynchronizedClauseContext)(nil)).Elem())
	var tst = make([]IDataSynchronizedClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataSynchronizedClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataSynchronizedClause(i int) IDataSynchronizedClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataSynchronizedClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataSynchronizedClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataJustifiedClause() []IDataJustifiedClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataJustifiedClauseContext)(nil)).Elem())
	var tst = make([]IDataJustifiedClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataJustifiedClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataJustifiedClause(i int) IDataJustifiedClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataJustifiedClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataJustifiedClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataBlankWhenZeroClause() []IDataBlankWhenZeroClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataBlankWhenZeroClauseContext)(nil)).Elem())
	var tst = make([]IDataBlankWhenZeroClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataBlankWhenZeroClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataBlankWhenZeroClause(i int) IDataBlankWhenZeroClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataBlankWhenZeroClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataBlankWhenZeroClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) DataWithLowerBoundsClause() IDataWithLowerBoundsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataWithLowerBoundsClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataWithLowerBoundsClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) DataAlignedClause() IDataAlignedClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataAlignedClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataAlignedClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) DataRecordAreaClause() IDataRecordAreaClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataRecordAreaClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataRecordAreaClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescriptionEntryFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescriptionEntryFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescriptionEntryFormat1(s)
	}
}

func (s *DataDescriptionEntryFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescriptionEntryFormat1(s)
	}
}

func (s *DataDescriptionEntryFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataDescriptionEntryFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataDescriptionEntryFormat1() (localctx IDataDescriptionEntryFormat1Context) {
	localctx = NewDataDescriptionEntryFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, Cobol85ParserRULE_dataDescriptionEntryFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3194)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserLEVEL_NUMBER_77 || _la == Cobol85ParserINTEGERLITERAL) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(3197)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 400, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3195)
			p.Match(Cobol85ParserFILLER)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 400, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(3196)
			p.DataName()
		}

	}
	p.SetState(3200)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserREDEFINES {
		{
			p.SetState(3199)
			p.DataRedefinesClause()
		}

	}
	p.SetState(3203)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 402, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3202)
			p.DataIntegerStringClause()
		}

	}
	p.SetState(3206)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 403, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3205)
			p.DataExternalClause()
		}

	}
	p.SetState(3209)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 404, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3208)
			p.DataGlobalClause()
		}

	}
	p.SetState(3212)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 405, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3211)
			p.DataTypeDefClause()
		}

	}
	p.SetState(3215)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 406, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3214)
			p.DataThreadLocalClause()
		}

	}
	p.SetState(3231)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 408, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3229)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 407, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(3217)
					p.DataPictureClause()
				}

			case 2:
				{
					p.SetState(3218)
					p.DataCommonOwnLocalClause()
				}

			case 3:
				{
					p.SetState(3219)
					p.DataTypeClause()
				}

			case 4:
				{
					p.SetState(3220)
					p.DataUsingClause()
				}

			case 5:
				{
					p.SetState(3221)
					p.DataValueClause()
				}

			case 6:
				{
					p.SetState(3222)
					p.DataUsageClause()
				}

			case 7:
				{
					p.SetState(3223)
					p.DataReceivedByClause()
				}

			case 8:
				{
					p.SetState(3224)
					p.DataOccursClause()
				}

			case 9:
				{
					p.SetState(3225)
					p.DataSignClause()
				}

			case 10:
				{
					p.SetState(3226)
					p.DataSynchronizedClause()
				}

			case 11:
				{
					p.SetState(3227)
					p.DataJustifiedClause()
				}

			case 12:
				{
					p.SetState(3228)
					p.DataBlankWhenZeroClause()
				}

			}

		}
		p.SetState(3233)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 408, p.GetParserRuleContext())
	}
	p.SetState(3235)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLOWER || _la == Cobol85ParserWITH {
		{
			p.SetState(3234)
			p.DataWithLowerBoundsClause()
		}

	}
	p.SetState(3238)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserALIGNED {
		{
			p.SetState(3237)
			p.DataAlignedClause()
		}

	}
	p.SetState(3241)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRECORD {
		{
			p.SetState(3240)
			p.DataRecordAreaClause()
		}

	}
	{
		p.SetState(3243)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IDataDescriptionEntryFormat2Context is an interface to support dynamic dispatch.
type IDataDescriptionEntryFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescriptionEntryFormat2Context differentiates from other interfaces.
	IsDataDescriptionEntryFormat2Context()
}

type DataDescriptionEntryFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescriptionEntryFormat2Context() *DataDescriptionEntryFormat2Context {
	var p = new(DataDescriptionEntryFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat2
	return p
}

func (*DataDescriptionEntryFormat2Context) IsDataDescriptionEntryFormat2Context() {}

func NewDataDescriptionEntryFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescriptionEntryFormat2Context {
	var p = new(DataDescriptionEntryFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat2

	return p
}

func (s *DataDescriptionEntryFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *DataDescriptionEntryFormat2Context) LEVEL_NUMBER_66() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_66, 0)
}

func (s *DataDescriptionEntryFormat2Context) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataDescriptionEntryFormat2Context) DataRenamesClause() IDataRenamesClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataRenamesClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataRenamesClauseContext)
}

func (s *DataDescriptionEntryFormat2Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataDescriptionEntryFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescriptionEntryFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescriptionEntryFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescriptionEntryFormat2(s)
	}
}

func (s *DataDescriptionEntryFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescriptionEntryFormat2(s)
	}
}

func (s *DataDescriptionEntryFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataDescriptionEntryFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataDescriptionEntryFormat2() (localctx IDataDescriptionEntryFormat2Context) {
	localctx = NewDataDescriptionEntryFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, Cobol85ParserRULE_dataDescriptionEntryFormat2)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3245)
		p.Match(Cobol85ParserLEVEL_NUMBER_66)
	}
	{
		p.SetState(3246)
		p.DataName()
	}
	{
		p.SetState(3247)
		p.DataRenamesClause()
	}
	{
		p.SetState(3248)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IDataDescriptionEntryFormat3Context is an interface to support dynamic dispatch.
type IDataDescriptionEntryFormat3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescriptionEntryFormat3Context differentiates from other interfaces.
	IsDataDescriptionEntryFormat3Context()
}

type DataDescriptionEntryFormat3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescriptionEntryFormat3Context() *DataDescriptionEntryFormat3Context {
	var p = new(DataDescriptionEntryFormat3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat3
	return p
}

func (*DataDescriptionEntryFormat3Context) IsDataDescriptionEntryFormat3Context() {}

func NewDataDescriptionEntryFormat3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescriptionEntryFormat3Context {
	var p = new(DataDescriptionEntryFormat3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat3

	return p
}

func (s *DataDescriptionEntryFormat3Context) GetParser() antlr.Parser { return s.parser }

func (s *DataDescriptionEntryFormat3Context) LEVEL_NUMBER_88() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_88, 0)
}

func (s *DataDescriptionEntryFormat3Context) ConditionName() IConditionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionNameContext)
}

func (s *DataDescriptionEntryFormat3Context) DataValueClause() IDataValueClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataValueClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataValueClauseContext)
}

func (s *DataDescriptionEntryFormat3Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataDescriptionEntryFormat3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescriptionEntryFormat3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescriptionEntryFormat3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescriptionEntryFormat3(s)
	}
}

func (s *DataDescriptionEntryFormat3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescriptionEntryFormat3(s)
	}
}

func (s *DataDescriptionEntryFormat3Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataDescriptionEntryFormat3(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataDescriptionEntryFormat3() (localctx IDataDescriptionEntryFormat3Context) {
	localctx = NewDataDescriptionEntryFormat3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, Cobol85ParserRULE_dataDescriptionEntryFormat3)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3250)
		p.Match(Cobol85ParserLEVEL_NUMBER_88)
	}
	{
		p.SetState(3251)
		p.ConditionName()
	}
	{
		p.SetState(3252)
		p.DataValueClause()
	}
	{
		p.SetState(3253)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IDataDescriptionEntryExecSqlContext is an interface to support dynamic dispatch.
type IDataDescriptionEntryExecSqlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescriptionEntryExecSqlContext differentiates from other interfaces.
	IsDataDescriptionEntryExecSqlContext()
}

type DataDescriptionEntryExecSqlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescriptionEntryExecSqlContext() *DataDescriptionEntryExecSqlContext {
	var p = new(DataDescriptionEntryExecSqlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryExecSql
	return p
}

func (*DataDescriptionEntryExecSqlContext) IsDataDescriptionEntryExecSqlContext() {}

func NewDataDescriptionEntryExecSqlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescriptionEntryExecSqlContext {
	var p = new(DataDescriptionEntryExecSqlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryExecSql

	return p
}

func (s *DataDescriptionEntryExecSqlContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescriptionEntryExecSqlContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataDescriptionEntryExecSqlContext) AllEXECSQLLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserEXECSQLLINE)
}

func (s *DataDescriptionEntryExecSqlContext) EXECSQLLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXECSQLLINE, i)
}

func (s *DataDescriptionEntryExecSqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescriptionEntryExecSqlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescriptionEntryExecSqlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescriptionEntryExecSql(s)
	}
}

func (s *DataDescriptionEntryExecSqlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescriptionEntryExecSql(s)
	}
}

func (s *DataDescriptionEntryExecSqlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataDescriptionEntryExecSql(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataDescriptionEntryExecSql() (localctx IDataDescriptionEntryExecSqlContext) {
	localctx = NewDataDescriptionEntryExecSqlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, Cobol85ParserRULE_dataDescriptionEntryExecSql)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3256)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserEXECSQLLINE {
		{
			p.SetState(3255)
			p.Match(Cobol85ParserEXECSQLLINE)
		}

		p.SetState(3258)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3260)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IDataAlignedClauseContext is an interface to support dynamic dispatch.
type IDataAlignedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataAlignedClauseContext differentiates from other interfaces.
	IsDataAlignedClauseContext()
}

type DataAlignedClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataAlignedClauseContext() *DataAlignedClauseContext {
	var p = new(DataAlignedClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataAlignedClause
	return p
}

func (*DataAlignedClauseContext) IsDataAlignedClauseContext() {}

func NewDataAlignedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataAlignedClauseContext {
	var p = new(DataAlignedClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataAlignedClause

	return p
}

func (s *DataAlignedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataAlignedClauseContext) ALIGNED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALIGNED, 0)
}

func (s *DataAlignedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataAlignedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataAlignedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataAlignedClause(s)
	}
}

func (s *DataAlignedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataAlignedClause(s)
	}
}

func (s *DataAlignedClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataAlignedClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataAlignedClause() (localctx IDataAlignedClauseContext) {
	localctx = NewDataAlignedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, Cobol85ParserRULE_dataAlignedClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3262)
		p.Match(Cobol85ParserALIGNED)
	}

	return localctx
}

// IDataBlankWhenZeroClauseContext is an interface to support dynamic dispatch.
type IDataBlankWhenZeroClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataBlankWhenZeroClauseContext differentiates from other interfaces.
	IsDataBlankWhenZeroClauseContext()
}

type DataBlankWhenZeroClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataBlankWhenZeroClauseContext() *DataBlankWhenZeroClauseContext {
	var p = new(DataBlankWhenZeroClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataBlankWhenZeroClause
	return p
}

func (*DataBlankWhenZeroClauseContext) IsDataBlankWhenZeroClauseContext() {}

func NewDataBlankWhenZeroClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataBlankWhenZeroClauseContext {
	var p = new(DataBlankWhenZeroClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataBlankWhenZeroClause

	return p
}

func (s *DataBlankWhenZeroClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataBlankWhenZeroClauseContext) BLANK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLANK, 0)
}

func (s *DataBlankWhenZeroClauseContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *DataBlankWhenZeroClauseContext) ZEROS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZEROS, 0)
}

func (s *DataBlankWhenZeroClauseContext) ZEROES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZEROES, 0)
}

func (s *DataBlankWhenZeroClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *DataBlankWhenZeroClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataBlankWhenZeroClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataBlankWhenZeroClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataBlankWhenZeroClause(s)
	}
}

func (s *DataBlankWhenZeroClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataBlankWhenZeroClause(s)
	}
}

func (s *DataBlankWhenZeroClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataBlankWhenZeroClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataBlankWhenZeroClause() (localctx IDataBlankWhenZeroClauseContext) {
	localctx = NewDataBlankWhenZeroClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, Cobol85ParserRULE_dataBlankWhenZeroClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3264)
		p.Match(Cobol85ParserBLANK)
	}
	p.SetState(3266)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWHEN {
		{
			p.SetState(3265)
			p.Match(Cobol85ParserWHEN)
		}

	}
	p.SetState(3268)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-526)&-(0x1f+1)) == 0 && ((1<<uint((_la-526)))&((1<<(Cobol85ParserZERO-526))|(1<<(Cobol85ParserZEROS-526))|(1<<(Cobol85ParserZEROES-526)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IDataCommonOwnLocalClauseContext is an interface to support dynamic dispatch.
type IDataCommonOwnLocalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataCommonOwnLocalClauseContext differentiates from other interfaces.
	IsDataCommonOwnLocalClauseContext()
}

type DataCommonOwnLocalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataCommonOwnLocalClauseContext() *DataCommonOwnLocalClauseContext {
	var p = new(DataCommonOwnLocalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataCommonOwnLocalClause
	return p
}

func (*DataCommonOwnLocalClauseContext) IsDataCommonOwnLocalClauseContext() {}

func NewDataCommonOwnLocalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataCommonOwnLocalClauseContext {
	var p = new(DataCommonOwnLocalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataCommonOwnLocalClause

	return p
}

func (s *DataCommonOwnLocalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataCommonOwnLocalClauseContext) COMMON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMON, 0)
}

func (s *DataCommonOwnLocalClauseContext) OWN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOWN, 0)
}

func (s *DataCommonOwnLocalClauseContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCAL, 0)
}

func (s *DataCommonOwnLocalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataCommonOwnLocalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataCommonOwnLocalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataCommonOwnLocalClause(s)
	}
}

func (s *DataCommonOwnLocalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataCommonOwnLocalClause(s)
	}
}

func (s *DataCommonOwnLocalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataCommonOwnLocalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataCommonOwnLocalClause() (localctx IDataCommonOwnLocalClauseContext) {
	localctx = NewDataCommonOwnLocalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, Cobol85ParserRULE_dataCommonOwnLocalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3270)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserCOMMON || _la == Cobol85ParserLOCAL || _la == Cobol85ParserOWN) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IDataExternalClauseContext is an interface to support dynamic dispatch.
type IDataExternalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataExternalClauseContext differentiates from other interfaces.
	IsDataExternalClauseContext()
}

type DataExternalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataExternalClauseContext() *DataExternalClauseContext {
	var p = new(DataExternalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataExternalClause
	return p
}

func (*DataExternalClauseContext) IsDataExternalClauseContext() {}

func NewDataExternalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataExternalClauseContext {
	var p = new(DataExternalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataExternalClause

	return p
}

func (s *DataExternalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataExternalClauseContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTERNAL, 0)
}

func (s *DataExternalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataExternalClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *DataExternalClauseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DataExternalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataExternalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataExternalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataExternalClause(s)
	}
}

func (s *DataExternalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataExternalClause(s)
	}
}

func (s *DataExternalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataExternalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataExternalClause() (localctx IDataExternalClauseContext) {
	localctx = NewDataExternalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, Cobol85ParserRULE_dataExternalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3273)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3272)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3275)
		p.Match(Cobol85ParserEXTERNAL)
	}
	p.SetState(3278)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 415, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3276)
			p.Match(Cobol85ParserBY)
		}
		{
			p.SetState(3277)
			p.Literal()
		}

	}

	return localctx
}

// IDataGlobalClauseContext is an interface to support dynamic dispatch.
type IDataGlobalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataGlobalClauseContext differentiates from other interfaces.
	IsDataGlobalClauseContext()
}

type DataGlobalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataGlobalClauseContext() *DataGlobalClauseContext {
	var p = new(DataGlobalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataGlobalClause
	return p
}

func (*DataGlobalClauseContext) IsDataGlobalClauseContext() {}

func NewDataGlobalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataGlobalClauseContext {
	var p = new(DataGlobalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataGlobalClause

	return p
}

func (s *DataGlobalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataGlobalClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGLOBAL, 0)
}

func (s *DataGlobalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataGlobalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataGlobalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataGlobalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataGlobalClause(s)
	}
}

func (s *DataGlobalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataGlobalClause(s)
	}
}

func (s *DataGlobalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataGlobalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataGlobalClause() (localctx IDataGlobalClauseContext) {
	localctx = NewDataGlobalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, Cobol85ParserRULE_dataGlobalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3280)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3283)
		p.Match(Cobol85ParserGLOBAL)
	}

	return localctx
}

// IDataIntegerStringClauseContext is an interface to support dynamic dispatch.
type IDataIntegerStringClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataIntegerStringClauseContext differentiates from other interfaces.
	IsDataIntegerStringClauseContext()
}

type DataIntegerStringClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataIntegerStringClauseContext() *DataIntegerStringClauseContext {
	var p = new(DataIntegerStringClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataIntegerStringClause
	return p
}

func (*DataIntegerStringClauseContext) IsDataIntegerStringClauseContext() {}

func NewDataIntegerStringClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataIntegerStringClauseContext {
	var p = new(DataIntegerStringClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataIntegerStringClause

	return p
}

func (s *DataIntegerStringClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataIntegerStringClauseContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGER, 0)
}

func (s *DataIntegerStringClauseContext) STRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTRING, 0)
}

func (s *DataIntegerStringClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataIntegerStringClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataIntegerStringClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataIntegerStringClause(s)
	}
}

func (s *DataIntegerStringClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataIntegerStringClause(s)
	}
}

func (s *DataIntegerStringClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataIntegerStringClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataIntegerStringClause() (localctx IDataIntegerStringClauseContext) {
	localctx = NewDataIntegerStringClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, Cobol85ParserRULE_dataIntegerStringClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3285)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserINTEGER || _la == Cobol85ParserSTRING) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IDataJustifiedClauseContext is an interface to support dynamic dispatch.
type IDataJustifiedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataJustifiedClauseContext differentiates from other interfaces.
	IsDataJustifiedClauseContext()
}

type DataJustifiedClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataJustifiedClauseContext() *DataJustifiedClauseContext {
	var p = new(DataJustifiedClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataJustifiedClause
	return p
}

func (*DataJustifiedClauseContext) IsDataJustifiedClauseContext() {}

func NewDataJustifiedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataJustifiedClauseContext {
	var p = new(DataJustifiedClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataJustifiedClause

	return p
}

func (s *DataJustifiedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataJustifiedClauseContext) JUSTIFIED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUSTIFIED, 0)
}

func (s *DataJustifiedClauseContext) JUST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUST, 0)
}

func (s *DataJustifiedClauseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRIGHT, 0)
}

func (s *DataJustifiedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataJustifiedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataJustifiedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataJustifiedClause(s)
	}
}

func (s *DataJustifiedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataJustifiedClause(s)
	}
}

func (s *DataJustifiedClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataJustifiedClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataJustifiedClause() (localctx IDataJustifiedClauseContext) {
	localctx = NewDataJustifiedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, Cobol85ParserRULE_dataJustifiedClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3287)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserJUST || _la == Cobol85ParserJUSTIFIED) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(3289)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRIGHT {
		{
			p.SetState(3288)
			p.Match(Cobol85ParserRIGHT)
		}

	}

	return localctx
}

// IDataOccursClauseContext is an interface to support dynamic dispatch.
type IDataOccursClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataOccursClauseContext differentiates from other interfaces.
	IsDataOccursClauseContext()
}

type DataOccursClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataOccursClauseContext() *DataOccursClauseContext {
	var p = new(DataOccursClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataOccursClause
	return p
}

func (*DataOccursClauseContext) IsDataOccursClauseContext() {}

func NewDataOccursClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataOccursClauseContext {
	var p = new(DataOccursClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataOccursClause

	return p
}

func (s *DataOccursClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataOccursClauseContext) OCCURS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOCCURS, 0)
}

func (s *DataOccursClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *DataOccursClauseContext) DataOccursTo() IDataOccursToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataOccursToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataOccursToContext)
}

func (s *DataOccursClauseContext) TIMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMES, 0)
}

func (s *DataOccursClauseContext) DEPENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEPENDING, 0)
}

func (s *DataOccursClauseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *DataOccursClauseContext) AllDataOccursSort() []IDataOccursSortContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataOccursSortContext)(nil)).Elem())
	var tst = make([]IDataOccursSortContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataOccursSortContext)
		}
	}

	return tst
}

func (s *DataOccursClauseContext) DataOccursSort(i int) IDataOccursSortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataOccursSortContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataOccursSortContext)
}

func (s *DataOccursClauseContext) INDEXED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINDEXED, 0)
}

func (s *DataOccursClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *DataOccursClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *DataOccursClauseContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCAL, 0)
}

func (s *DataOccursClauseContext) AllIndexName() []IIndexNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIndexNameContext)(nil)).Elem())
	var tst = make([]IIndexNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIndexNameContext)
		}
	}

	return tst
}

func (s *DataOccursClauseContext) IndexName(i int) IIndexNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *DataOccursClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataOccursClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataOccursClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataOccursClause(s)
	}
}

func (s *DataOccursClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataOccursClause(s)
	}
}

func (s *DataOccursClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataOccursClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataOccursClause() (localctx IDataOccursClauseContext) {
	localctx = NewDataOccursClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, Cobol85ParserRULE_dataOccursClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3291)
		p.Match(Cobol85ParserOCCURS)
	}
	{
		p.SetState(3292)
		p.IntegerLiteral()
	}
	p.SetState(3294)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(3293)
			p.DataOccursTo()
		}

	}
	p.SetState(3297)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTIMES {
		{
			p.SetState(3296)
			p.Match(Cobol85ParserTIMES)
		}

	}
	p.SetState(3304)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDEPENDING {
		{
			p.SetState(3299)
			p.Match(Cobol85ParserDEPENDING)
		}
		p.SetState(3301)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserON {
			{
				p.SetState(3300)
				p.Match(Cobol85ParserON)
			}

		}
		{
			p.SetState(3303)
			p.QualifiedDataName()
		}

	}
	p.SetState(3309)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserASCENDING || _la == Cobol85ParserDESCENDING {
		{
			p.SetState(3306)
			p.DataOccursSort()
		}

		p.SetState(3311)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINDEXED {
		{
			p.SetState(3312)
			p.Match(Cobol85ParserINDEXED)
		}
		p.SetState(3314)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserBY {
			{
				p.SetState(3313)
				p.Match(Cobol85ParserBY)
			}

		}
		p.SetState(3317)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 424, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3316)
				p.Match(Cobol85ParserLOCAL)
			}

		}
		p.SetState(3320)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(3319)
					p.IndexName()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(3322)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 425, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IDataOccursToContext is an interface to support dynamic dispatch.
type IDataOccursToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataOccursToContext differentiates from other interfaces.
	IsDataOccursToContext()
}

type DataOccursToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataOccursToContext() *DataOccursToContext {
	var p = new(DataOccursToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataOccursTo
	return p
}

func (*DataOccursToContext) IsDataOccursToContext() {}

func NewDataOccursToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataOccursToContext {
	var p = new(DataOccursToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataOccursTo

	return p
}

func (s *DataOccursToContext) GetParser() antlr.Parser { return s.parser }

func (s *DataOccursToContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *DataOccursToContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *DataOccursToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataOccursToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataOccursToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataOccursTo(s)
	}
}

func (s *DataOccursToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataOccursTo(s)
	}
}

func (s *DataOccursToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataOccursTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataOccursTo() (localctx IDataOccursToContext) {
	localctx = NewDataOccursToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, Cobol85ParserRULE_dataOccursTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3326)
		p.Match(Cobol85ParserTO)
	}
	{
		p.SetState(3327)
		p.IntegerLiteral()
	}

	return localctx
}

// IDataOccursSortContext is an interface to support dynamic dispatch.
type IDataOccursSortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataOccursSortContext differentiates from other interfaces.
	IsDataOccursSortContext()
}

type DataOccursSortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataOccursSortContext() *DataOccursSortContext {
	var p = new(DataOccursSortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataOccursSort
	return p
}

func (*DataOccursSortContext) IsDataOccursSortContext() {}

func NewDataOccursSortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataOccursSortContext {
	var p = new(DataOccursSortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataOccursSort

	return p
}

func (s *DataOccursSortContext) GetParser() antlr.Parser { return s.parser }

func (s *DataOccursSortContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASCENDING, 0)
}

func (s *DataOccursSortContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESCENDING, 0)
}

func (s *DataOccursSortContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *DataOccursSortContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataOccursSortContext) AllQualifiedDataName() []IQualifiedDataNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem())
	var tst = make([]IQualifiedDataNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedDataNameContext)
		}
	}

	return tst
}

func (s *DataOccursSortContext) QualifiedDataName(i int) IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *DataOccursSortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataOccursSortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataOccursSortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataOccursSort(s)
	}
}

func (s *DataOccursSortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataOccursSort(s)
	}
}

func (s *DataOccursSortContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataOccursSort(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataOccursSort() (localctx IDataOccursSortContext) {
	localctx = NewDataOccursSortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, Cobol85ParserRULE_dataOccursSort)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3329)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserASCENDING || _la == Cobol85ParserDESCENDING) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(3331)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(3330)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(3334)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3333)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(3337)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3336)
				p.QualifiedDataName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3339)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 429, p.GetParserRuleContext())
	}

	return localctx
}

// IDataPictureClauseContext is an interface to support dynamic dispatch.
type IDataPictureClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataPictureClauseContext differentiates from other interfaces.
	IsDataPictureClauseContext()
}

type DataPictureClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataPictureClauseContext() *DataPictureClauseContext {
	var p = new(DataPictureClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataPictureClause
	return p
}

func (*DataPictureClauseContext) IsDataPictureClauseContext() {}

func NewDataPictureClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataPictureClauseContext {
	var p = new(DataPictureClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataPictureClause

	return p
}

func (s *DataPictureClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataPictureClauseContext) PictureString() IPictureStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPictureStringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPictureStringContext)
}

func (s *DataPictureClauseContext) PICTURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPICTURE, 0)
}

func (s *DataPictureClauseContext) PIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPIC, 0)
}

func (s *DataPictureClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataPictureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataPictureClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataPictureClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataPictureClause(s)
	}
}

func (s *DataPictureClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataPictureClause(s)
	}
}

func (s *DataPictureClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataPictureClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataPictureClause() (localctx IDataPictureClauseContext) {
	localctx = NewDataPictureClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, Cobol85ParserRULE_dataPictureClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3341)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserPIC || _la == Cobol85ParserPICTURE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(3343)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3342)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3345)
		p.PictureString()
	}

	return localctx
}

// IPictureStringContext is an interface to support dynamic dispatch.
type IPictureStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPictureStringContext differentiates from other interfaces.
	IsPictureStringContext()
}

type PictureStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPictureStringContext() *PictureStringContext {
	var p = new(PictureStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_pictureString
	return p
}

func (*PictureStringContext) IsPictureStringContext() {}

func NewPictureStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PictureStringContext {
	var p = new(PictureStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_pictureString

	return p
}

func (s *PictureStringContext) GetParser() antlr.Parser { return s.parser }

func (s *PictureStringContext) AllPictureChars() []IPictureCharsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPictureCharsContext)(nil)).Elem())
	var tst = make([]IPictureCharsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPictureCharsContext)
		}
	}

	return tst
}

func (s *PictureStringContext) PictureChars(i int) IPictureCharsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPictureCharsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPictureCharsContext)
}

func (s *PictureStringContext) AllPictureCardinality() []IPictureCardinalityContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPictureCardinalityContext)(nil)).Elem())
	var tst = make([]IPictureCardinalityContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPictureCardinalityContext)
		}
	}

	return tst
}

func (s *PictureStringContext) PictureCardinality(i int) IPictureCardinalityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPictureCardinalityContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPictureCardinalityContext)
}

func (s *PictureStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PictureStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PictureStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPictureString(s)
	}
}

func (s *PictureStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPictureString(s)
	}
}

func (s *PictureStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPictureString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PictureString() (localctx IPictureStringContext) {
	localctx = NewPictureStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, Cobol85ParserRULE_pictureString)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3355)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(3348)
			p.GetErrorHandler().Sync(p)
			_alt = 1
			for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				switch _alt {
				case 1:
					{
						p.SetState(3347)
						p.PictureChars()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

				p.SetState(3350)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 431, p.GetParserRuleContext())
			}
			p.SetState(3353)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 432, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3352)
					p.PictureCardinality()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3357)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 433, p.GetParserRuleContext())
	}

	return localctx
}

// IPictureCharsContext is an interface to support dynamic dispatch.
type IPictureCharsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPictureCharsContext differentiates from other interfaces.
	IsPictureCharsContext()
}

type PictureCharsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPictureCharsContext() *PictureCharsContext {
	var p = new(PictureCharsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_pictureChars
	return p
}

func (*PictureCharsContext) IsPictureCharsContext() {}

func NewPictureCharsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PictureCharsContext {
	var p = new(PictureCharsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_pictureChars

	return p
}

func (s *PictureCharsContext) GetParser() antlr.Parser { return s.parser }

func (s *PictureCharsContext) DOLLARCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOLLARCHAR, 0)
}

func (s *PictureCharsContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIDENTIFIER, 0)
}

func (s *PictureCharsContext) NUMERICLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERICLITERAL, 0)
}

func (s *PictureCharsContext) SLASHCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSLASHCHAR, 0)
}

func (s *PictureCharsContext) COMMACHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMACHAR, 0)
}

func (s *PictureCharsContext) DOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT, 0)
}

func (s *PictureCharsContext) COLONCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLONCHAR, 0)
}

func (s *PictureCharsContext) ASTERISKCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASTERISKCHAR, 0)
}

func (s *PictureCharsContext) DOUBLEASTERISKCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOUBLEASTERISKCHAR, 0)
}

func (s *PictureCharsContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *PictureCharsContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *PictureCharsContext) PLUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUSCHAR, 0)
}

func (s *PictureCharsContext) MINUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMINUSCHAR, 0)
}

func (s *PictureCharsContext) LESSTHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESSTHANCHAR, 0)
}

func (s *PictureCharsContext) MORETHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORETHANCHAR, 0)
}

func (s *PictureCharsContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *PictureCharsContext) PictureCharsKeyword() IPictureCharsKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPictureCharsKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPictureCharsKeywordContext)
}

func (s *PictureCharsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PictureCharsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PictureCharsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPictureChars(s)
	}
}

func (s *PictureCharsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPictureChars(s)
	}
}

func (s *PictureCharsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPictureChars(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PictureChars() (localctx IPictureCharsContext) {
	localctx = NewPictureCharsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, Cobol85ParserRULE_pictureChars)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3376)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserDOLLARCHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3359)
			p.Match(Cobol85ParserDOLLARCHAR)
		}

	case Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3360)
			p.Match(Cobol85ParserIDENTIFIER)
		}

	case Cobol85ParserNUMERICLITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3361)
			p.Match(Cobol85ParserNUMERICLITERAL)
		}

	case Cobol85ParserSLASHCHAR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3362)
			p.Match(Cobol85ParserSLASHCHAR)
		}

	case Cobol85ParserCOMMACHAR:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3363)
			p.Match(Cobol85ParserCOMMACHAR)
		}

	case Cobol85ParserDOT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3364)
			p.Match(Cobol85ParserDOT)
		}

	case Cobol85ParserCOLONCHAR:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3365)
			p.Match(Cobol85ParserCOLONCHAR)
		}

	case Cobol85ParserASTERISKCHAR:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3366)
			p.Match(Cobol85ParserASTERISKCHAR)
		}

	case Cobol85ParserDOUBLEASTERISKCHAR:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3367)
			p.Match(Cobol85ParserDOUBLEASTERISKCHAR)
		}

	case Cobol85ParserLPARENCHAR:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3368)
			p.Match(Cobol85ParserLPARENCHAR)
		}

	case Cobol85ParserRPARENCHAR:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3369)
			p.Match(Cobol85ParserRPARENCHAR)
		}

	case Cobol85ParserPLUSCHAR:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3370)
			p.Match(Cobol85ParserPLUSCHAR)
		}

	case Cobol85ParserMINUSCHAR:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3371)
			p.Match(Cobol85ParserMINUSCHAR)
		}

	case Cobol85ParserLESSTHANCHAR:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3372)
			p.Match(Cobol85ParserLESSTHANCHAR)
		}

	case Cobol85ParserMORETHANCHAR:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3373)
			p.Match(Cobol85ParserMORETHANCHAR)
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3374)
			p.IntegerLiteral()
		}

	case Cobol85ParserSP:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3375)
			p.PictureCharsKeyword()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPictureCharsKeywordContext is an interface to support dynamic dispatch.
type IPictureCharsKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPictureCharsKeywordContext differentiates from other interfaces.
	IsPictureCharsKeywordContext()
}

type PictureCharsKeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPictureCharsKeywordContext() *PictureCharsKeywordContext {
	var p = new(PictureCharsKeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_pictureCharsKeyword
	return p
}

func (*PictureCharsKeywordContext) IsPictureCharsKeywordContext() {}

func NewPictureCharsKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PictureCharsKeywordContext {
	var p = new(PictureCharsKeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_pictureCharsKeyword

	return p
}

func (s *PictureCharsKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *PictureCharsKeywordContext) SP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSP, 0)
}

func (s *PictureCharsKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PictureCharsKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PictureCharsKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPictureCharsKeyword(s)
	}
}

func (s *PictureCharsKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPictureCharsKeyword(s)
	}
}

func (s *PictureCharsKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPictureCharsKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PictureCharsKeyword() (localctx IPictureCharsKeywordContext) {
	localctx = NewPictureCharsKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, Cobol85ParserRULE_pictureCharsKeyword)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3378)
		p.Match(Cobol85ParserSP)
	}

	return localctx
}

// IPictureCardinalityContext is an interface to support dynamic dispatch.
type IPictureCardinalityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPictureCardinalityContext differentiates from other interfaces.
	IsPictureCardinalityContext()
}

type PictureCardinalityContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPictureCardinalityContext() *PictureCardinalityContext {
	var p = new(PictureCardinalityContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_pictureCardinality
	return p
}

func (*PictureCardinalityContext) IsPictureCardinalityContext() {}

func NewPictureCardinalityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PictureCardinalityContext {
	var p = new(PictureCardinalityContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_pictureCardinality

	return p
}

func (s *PictureCardinalityContext) GetParser() antlr.Parser { return s.parser }

func (s *PictureCardinalityContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *PictureCardinalityContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *PictureCardinalityContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *PictureCardinalityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PictureCardinalityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PictureCardinalityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPictureCardinality(s)
	}
}

func (s *PictureCardinalityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPictureCardinality(s)
	}
}

func (s *PictureCardinalityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPictureCardinality(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PictureCardinality() (localctx IPictureCardinalityContext) {
	localctx = NewPictureCardinalityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, Cobol85ParserRULE_pictureCardinality)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3380)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	{
		p.SetState(3381)
		p.IntegerLiteral()
	}
	{
		p.SetState(3382)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// IDataReceivedByClauseContext is an interface to support dynamic dispatch.
type IDataReceivedByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataReceivedByClauseContext differentiates from other interfaces.
	IsDataReceivedByClauseContext()
}

type DataReceivedByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataReceivedByClauseContext() *DataReceivedByClauseContext {
	var p = new(DataReceivedByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataReceivedByClause
	return p
}

func (*DataReceivedByClauseContext) IsDataReceivedByClauseContext() {}

func NewDataReceivedByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataReceivedByClauseContext {
	var p = new(DataReceivedByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataReceivedByClause

	return p
}

func (s *DataReceivedByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataReceivedByClauseContext) CONTENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTENT, 0)
}

func (s *DataReceivedByClauseContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREFERENCE, 0)
}

func (s *DataReceivedByClauseContext) REF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREF, 0)
}

func (s *DataReceivedByClauseContext) RECEIVED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECEIVED, 0)
}

func (s *DataReceivedByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *DataReceivedByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataReceivedByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataReceivedByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataReceivedByClause(s)
	}
}

func (s *DataReceivedByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataReceivedByClause(s)
	}
}

func (s *DataReceivedByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataReceivedByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataReceivedByClause() (localctx IDataReceivedByClauseContext) {
	localctx = NewDataReceivedByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, Cobol85ParserRULE_dataReceivedByClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3385)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRECEIVED {
		{
			p.SetState(3384)
			p.Match(Cobol85ParserRECEIVED)
		}

	}
	p.SetState(3388)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY {
		{
			p.SetState(3387)
			p.Match(Cobol85ParserBY)
		}

	}
	p.SetState(3390)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserCONTENT || _la == Cobol85ParserREF || _la == Cobol85ParserREFERENCE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IDataRecordAreaClauseContext is an interface to support dynamic dispatch.
type IDataRecordAreaClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataRecordAreaClauseContext differentiates from other interfaces.
	IsDataRecordAreaClauseContext()
}

type DataRecordAreaClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataRecordAreaClauseContext() *DataRecordAreaClauseContext {
	var p = new(DataRecordAreaClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataRecordAreaClause
	return p
}

func (*DataRecordAreaClauseContext) IsDataRecordAreaClauseContext() {}

func NewDataRecordAreaClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataRecordAreaClauseContext {
	var p = new(DataRecordAreaClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataRecordAreaClause

	return p
}

func (s *DataRecordAreaClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataRecordAreaClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *DataRecordAreaClauseContext) AREA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAREA, 0)
}

func (s *DataRecordAreaClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataRecordAreaClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataRecordAreaClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataRecordAreaClause(s)
	}
}

func (s *DataRecordAreaClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataRecordAreaClause(s)
	}
}

func (s *DataRecordAreaClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataRecordAreaClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataRecordAreaClause() (localctx IDataRecordAreaClauseContext) {
	localctx = NewDataRecordAreaClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, Cobol85ParserRULE_dataRecordAreaClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3392)
		p.Match(Cobol85ParserRECORD)
	}
	{
		p.SetState(3393)
		p.Match(Cobol85ParserAREA)
	}

	return localctx
}

// IDataRedefinesClauseContext is an interface to support dynamic dispatch.
type IDataRedefinesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataRedefinesClauseContext differentiates from other interfaces.
	IsDataRedefinesClauseContext()
}

type DataRedefinesClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataRedefinesClauseContext() *DataRedefinesClauseContext {
	var p = new(DataRedefinesClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataRedefinesClause
	return p
}

func (*DataRedefinesClauseContext) IsDataRedefinesClauseContext() {}

func NewDataRedefinesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataRedefinesClauseContext {
	var p = new(DataRedefinesClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataRedefinesClause

	return p
}

func (s *DataRedefinesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataRedefinesClauseContext) REDEFINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREDEFINES, 0)
}

func (s *DataRedefinesClauseContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataRedefinesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataRedefinesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataRedefinesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataRedefinesClause(s)
	}
}

func (s *DataRedefinesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataRedefinesClause(s)
	}
}

func (s *DataRedefinesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataRedefinesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataRedefinesClause() (localctx IDataRedefinesClauseContext) {
	localctx = NewDataRedefinesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, Cobol85ParserRULE_dataRedefinesClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3395)
		p.Match(Cobol85ParserREDEFINES)
	}
	{
		p.SetState(3396)
		p.DataName()
	}

	return localctx
}

// IDataRenamesClauseContext is an interface to support dynamic dispatch.
type IDataRenamesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataRenamesClauseContext differentiates from other interfaces.
	IsDataRenamesClauseContext()
}

type DataRenamesClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataRenamesClauseContext() *DataRenamesClauseContext {
	var p = new(DataRenamesClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataRenamesClause
	return p
}

func (*DataRenamesClauseContext) IsDataRenamesClauseContext() {}

func NewDataRenamesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataRenamesClauseContext {
	var p = new(DataRenamesClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataRenamesClause

	return p
}

func (s *DataRenamesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataRenamesClauseContext) RENAMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRENAMES, 0)
}

func (s *DataRenamesClauseContext) AllQualifiedDataName() []IQualifiedDataNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem())
	var tst = make([]IQualifiedDataNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedDataNameContext)
		}
	}

	return tst
}

func (s *DataRenamesClauseContext) QualifiedDataName(i int) IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *DataRenamesClauseContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *DataRenamesClauseContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *DataRenamesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataRenamesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataRenamesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataRenamesClause(s)
	}
}

func (s *DataRenamesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataRenamesClause(s)
	}
}

func (s *DataRenamesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataRenamesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataRenamesClause() (localctx IDataRenamesClauseContext) {
	localctx = NewDataRenamesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, Cobol85ParserRULE_dataRenamesClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3398)
		p.Match(Cobol85ParserRENAMES)
	}
	{
		p.SetState(3399)
		p.QualifiedDataName()
	}
	p.SetState(3402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		p.SetState(3400)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(3401)
			p.QualifiedDataName()
		}

	}

	return localctx
}

// IDataSignClauseContext is an interface to support dynamic dispatch.
type IDataSignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataSignClauseContext differentiates from other interfaces.
	IsDataSignClauseContext()
}

type DataSignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataSignClauseContext() *DataSignClauseContext {
	var p = new(DataSignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataSignClause
	return p
}

func (*DataSignClauseContext) IsDataSignClauseContext() {}

func NewDataSignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataSignClauseContext {
	var p = new(DataSignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataSignClause

	return p
}

func (s *DataSignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataSignClauseContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *DataSignClauseContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRAILING, 0)
}

func (s *DataSignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *DataSignClauseContext) SEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEPARATE, 0)
}

func (s *DataSignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataSignClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *DataSignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataSignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataSignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataSignClause(s)
	}
}

func (s *DataSignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataSignClause(s)
	}
}

func (s *DataSignClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataSignClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataSignClause() (localctx IDataSignClauseContext) {
	localctx = NewDataSignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, Cobol85ParserRULE_dataSignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3408)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIGN {
		{
			p.SetState(3404)
			p.Match(Cobol85ParserSIGN)
		}
		p.SetState(3406)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(3405)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	p.SetState(3410)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(3415)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSEPARATE {
		{
			p.SetState(3411)
			p.Match(Cobol85ParserSEPARATE)
		}
		p.SetState(3413)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserCHARACTER {
			{
				p.SetState(3412)
				p.Match(Cobol85ParserCHARACTER)
			}

		}

	}

	return localctx
}

// IDataSynchronizedClauseContext is an interface to support dynamic dispatch.
type IDataSynchronizedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataSynchronizedClauseContext differentiates from other interfaces.
	IsDataSynchronizedClauseContext()
}

type DataSynchronizedClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataSynchronizedClauseContext() *DataSynchronizedClauseContext {
	var p = new(DataSynchronizedClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataSynchronizedClause
	return p
}

func (*DataSynchronizedClauseContext) IsDataSynchronizedClauseContext() {}

func NewDataSynchronizedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataSynchronizedClauseContext {
	var p = new(DataSynchronizedClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataSynchronizedClause

	return p
}

func (s *DataSynchronizedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataSynchronizedClauseContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYNCHRONIZED, 0)
}

func (s *DataSynchronizedClauseContext) SYNC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYNC, 0)
}

func (s *DataSynchronizedClauseContext) LEFT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEFT, 0)
}

func (s *DataSynchronizedClauseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRIGHT, 0)
}

func (s *DataSynchronizedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataSynchronizedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataSynchronizedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataSynchronizedClause(s)
	}
}

func (s *DataSynchronizedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataSynchronizedClause(s)
	}
}

func (s *DataSynchronizedClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataSynchronizedClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataSynchronizedClause() (localctx IDataSynchronizedClauseContext) {
	localctx = NewDataSynchronizedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, Cobol85ParserRULE_dataSynchronizedClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3417)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserSYNC || _la == Cobol85ParserSYNCHRONIZED) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(3419)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLEFT || _la == Cobol85ParserRIGHT {
		p.SetState(3418)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserLEFT || _la == Cobol85ParserRIGHT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// IDataThreadLocalClauseContext is an interface to support dynamic dispatch.
type IDataThreadLocalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataThreadLocalClauseContext differentiates from other interfaces.
	IsDataThreadLocalClauseContext()
}

type DataThreadLocalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataThreadLocalClauseContext() *DataThreadLocalClauseContext {
	var p = new(DataThreadLocalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataThreadLocalClause
	return p
}

func (*DataThreadLocalClauseContext) IsDataThreadLocalClauseContext() {}

func NewDataThreadLocalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataThreadLocalClauseContext {
	var p = new(DataThreadLocalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataThreadLocalClause

	return p
}

func (s *DataThreadLocalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataThreadLocalClauseContext) THREAD_LOCAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHREAD_LOCAL, 0)
}

func (s *DataThreadLocalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataThreadLocalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataThreadLocalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataThreadLocalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataThreadLocalClause(s)
	}
}

func (s *DataThreadLocalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataThreadLocalClause(s)
	}
}

func (s *DataThreadLocalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataThreadLocalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataThreadLocalClause() (localctx IDataThreadLocalClauseContext) {
	localctx = NewDataThreadLocalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, Cobol85ParserRULE_dataThreadLocalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3422)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3421)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3424)
		p.Match(Cobol85ParserTHREAD_LOCAL)
	}

	return localctx
}

// IDataTypeClauseContext is an interface to support dynamic dispatch.
type IDataTypeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeClauseContext differentiates from other interfaces.
	IsDataTypeClauseContext()
}

type DataTypeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeClauseContext() *DataTypeClauseContext {
	var p = new(DataTypeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataTypeClause
	return p
}

func (*DataTypeClauseContext) IsDataTypeClauseContext() {}

func NewDataTypeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeClauseContext {
	var p = new(DataTypeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataTypeClause

	return p
}

func (s *DataTypeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeClauseContext) TYPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTYPE, 0)
}

func (s *DataTypeClauseContext) SHORT_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHORT_DATE, 0)
}

func (s *DataTypeClauseContext) LONG_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLONG_DATE, 0)
}

func (s *DataTypeClauseContext) NUMERIC_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC_DATE, 0)
}

func (s *DataTypeClauseContext) NUMERIC_TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC_TIME, 0)
}

func (s *DataTypeClauseContext) LONG_TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLONG_TIME, 0)
}

func (s *DataTypeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataTypeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataTypeClause(s)
	}
}

func (s *DataTypeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataTypeClause(s)
	}
}

func (s *DataTypeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataTypeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataTypeClause() (localctx IDataTypeClauseContext) {
	localctx = NewDataTypeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, Cobol85ParserRULE_dataTypeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3426)
		p.Match(Cobol85ParserTYPE)
	}
	p.SetState(3428)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3427)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(3430)
	_la = p.GetTokenStream().LA(1)

	if !((((_la-290)&-(0x1f+1)) == 0 && ((1<<uint((_la-290)))&((1<<(Cobol85ParserLONG_DATE-290))|(1<<(Cobol85ParserLONG_TIME-290))|(1<<(Cobol85ParserNUMERIC_DATE-290)))) != 0) || _la == Cobol85ParserNUMERIC_TIME || _la == Cobol85ParserSHORT_DATE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IDataTypeDefClauseContext is an interface to support dynamic dispatch.
type IDataTypeDefClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeDefClauseContext differentiates from other interfaces.
	IsDataTypeDefClauseContext()
}

type DataTypeDefClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeDefClauseContext() *DataTypeDefClauseContext {
	var p = new(DataTypeDefClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataTypeDefClause
	return p
}

func (*DataTypeDefClauseContext) IsDataTypeDefClauseContext() {}

func NewDataTypeDefClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeDefClauseContext {
	var p = new(DataTypeDefClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataTypeDefClause

	return p
}

func (s *DataTypeDefClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeDefClauseContext) TYPEDEF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTYPEDEF, 0)
}

func (s *DataTypeDefClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataTypeDefClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeDefClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeDefClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataTypeDefClause(s)
	}
}

func (s *DataTypeDefClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataTypeDefClause(s)
	}
}

func (s *DataTypeDefClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataTypeDefClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataTypeDefClause() (localctx IDataTypeDefClauseContext) {
	localctx = NewDataTypeDefClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, Cobol85ParserRULE_dataTypeDefClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3433)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3432)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3435)
		p.Match(Cobol85ParserTYPEDEF)
	}

	return localctx
}

// IDataUsageClauseContext is an interface to support dynamic dispatch.
type IDataUsageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataUsageClauseContext differentiates from other interfaces.
	IsDataUsageClauseContext()
}

type DataUsageClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataUsageClauseContext() *DataUsageClauseContext {
	var p = new(DataUsageClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataUsageClause
	return p
}

func (*DataUsageClauseContext) IsDataUsageClauseContext() {}

func NewDataUsageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataUsageClauseContext {
	var p = new(DataUsageClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataUsageClause

	return p
}

func (s *DataUsageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataUsageClauseContext) BINARY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBINARY, 0)
}

func (s *DataUsageClauseContext) BIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBIT, 0)
}

func (s *DataUsageClauseContext) COMP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP, 0)
}

func (s *DataUsageClauseContext) COMP_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP_1, 0)
}

func (s *DataUsageClauseContext) COMP_2() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP_2, 0)
}

func (s *DataUsageClauseContext) COMP_3() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP_3, 0)
}

func (s *DataUsageClauseContext) COMP_4() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP_4, 0)
}

func (s *DataUsageClauseContext) COMP_5() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP_5, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL_1, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL_2() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL_2, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL_3() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL_3, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL_4() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL_4, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL_5() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL_5, 0)
}

func (s *DataUsageClauseContext) CONTROL_POINT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL_POINT, 0)
}

func (s *DataUsageClauseContext) DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE, 0)
}

func (s *DataUsageClauseContext) DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY, 0)
}

func (s *DataUsageClauseContext) DISPLAY_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY_1, 0)
}

func (s *DataUsageClauseContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOUBLE, 0)
}

func (s *DataUsageClauseContext) EVENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEVENT, 0)
}

func (s *DataUsageClauseContext) FUNCTION_POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFUNCTION_POINTER, 0)
}

func (s *DataUsageClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINDEX, 0)
}

func (s *DataUsageClauseContext) KANJI() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKANJI, 0)
}

func (s *DataUsageClauseContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *DataUsageClauseContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *DataUsageClauseContext) PACKED_DECIMAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPACKED_DECIMAL, 0)
}

func (s *DataUsageClauseContext) POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPOINTER, 0)
}

func (s *DataUsageClauseContext) PROCEDURE_POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE_POINTER, 0)
}

func (s *DataUsageClauseContext) REAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREAL, 0)
}

func (s *DataUsageClauseContext) TASK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTASK, 0)
}

func (s *DataUsageClauseContext) USAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSAGE, 0)
}

func (s *DataUsageClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataUsageClauseContext) TRUNCATED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRUNCATED, 0)
}

func (s *DataUsageClauseContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTENDED, 0)
}

func (s *DataUsageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataUsageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataUsageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataUsageClause(s)
	}
}

func (s *DataUsageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataUsageClause(s)
	}
}

func (s *DataUsageClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataUsageClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataUsageClause() (localctx IDataUsageClauseContext) {
	localctx = NewDataUsageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, Cobol85ParserRULE_dataUsageClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3441)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSAGE {
		{
			p.SetState(3437)
			p.Match(Cobol85ParserUSAGE)
		}
		p.SetState(3439)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(3438)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	p.SetState(3476)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserBINARY:
		{
			p.SetState(3443)
			p.Match(Cobol85ParserBINARY)
		}
		p.SetState(3445)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 448, p.GetParserRuleContext()) == 1 {
			p.SetState(3444)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserEXTENDED || _la == Cobol85ParserTRUNCATED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}

		}

	case Cobol85ParserBIT:
		{
			p.SetState(3447)
			p.Match(Cobol85ParserBIT)
		}

	case Cobol85ParserCOMP:
		{
			p.SetState(3448)
			p.Match(Cobol85ParserCOMP)
		}

	case Cobol85ParserCOMP_1:
		{
			p.SetState(3449)
			p.Match(Cobol85ParserCOMP_1)
		}

	case Cobol85ParserCOMP_2:
		{
			p.SetState(3450)
			p.Match(Cobol85ParserCOMP_2)
		}

	case Cobol85ParserCOMP_3:
		{
			p.SetState(3451)
			p.Match(Cobol85ParserCOMP_3)
		}

	case Cobol85ParserCOMP_4:
		{
			p.SetState(3452)
			p.Match(Cobol85ParserCOMP_4)
		}

	case Cobol85ParserCOMP_5:
		{
			p.SetState(3453)
			p.Match(Cobol85ParserCOMP_5)
		}

	case Cobol85ParserCOMPUTATIONAL:
		{
			p.SetState(3454)
			p.Match(Cobol85ParserCOMPUTATIONAL)
		}

	case Cobol85ParserCOMPUTATIONAL_1:
		{
			p.SetState(3455)
			p.Match(Cobol85ParserCOMPUTATIONAL_1)
		}

	case Cobol85ParserCOMPUTATIONAL_2:
		{
			p.SetState(3456)
			p.Match(Cobol85ParserCOMPUTATIONAL_2)
		}

	case Cobol85ParserCOMPUTATIONAL_3:
		{
			p.SetState(3457)
			p.Match(Cobol85ParserCOMPUTATIONAL_3)
		}

	case Cobol85ParserCOMPUTATIONAL_4:
		{
			p.SetState(3458)
			p.Match(Cobol85ParserCOMPUTATIONAL_4)
		}

	case Cobol85ParserCOMPUTATIONAL_5:
		{
			p.SetState(3459)
			p.Match(Cobol85ParserCOMPUTATIONAL_5)
		}

	case Cobol85ParserCONTROL_POINT:
		{
			p.SetState(3460)
			p.Match(Cobol85ParserCONTROL_POINT)
		}

	case Cobol85ParserDATE:
		{
			p.SetState(3461)
			p.Match(Cobol85ParserDATE)
		}

	case Cobol85ParserDISPLAY:
		{
			p.SetState(3462)
			p.Match(Cobol85ParserDISPLAY)
		}

	case Cobol85ParserDISPLAY_1:
		{
			p.SetState(3463)
			p.Match(Cobol85ParserDISPLAY_1)
		}

	case Cobol85ParserDOUBLE:
		{
			p.SetState(3464)
			p.Match(Cobol85ParserDOUBLE)
		}

	case Cobol85ParserEVENT:
		{
			p.SetState(3465)
			p.Match(Cobol85ParserEVENT)
		}

	case Cobol85ParserFUNCTION_POINTER:
		{
			p.SetState(3466)
			p.Match(Cobol85ParserFUNCTION_POINTER)
		}

	case Cobol85ParserINDEX:
		{
			p.SetState(3467)
			p.Match(Cobol85ParserINDEX)
		}

	case Cobol85ParserKANJI:
		{
			p.SetState(3468)
			p.Match(Cobol85ParserKANJI)
		}

	case Cobol85ParserLOCK:
		{
			p.SetState(3469)
			p.Match(Cobol85ParserLOCK)
		}

	case Cobol85ParserNATIONAL:
		{
			p.SetState(3470)
			p.Match(Cobol85ParserNATIONAL)
		}

	case Cobol85ParserPACKED_DECIMAL:
		{
			p.SetState(3471)
			p.Match(Cobol85ParserPACKED_DECIMAL)
		}

	case Cobol85ParserPOINTER:
		{
			p.SetState(3472)
			p.Match(Cobol85ParserPOINTER)
		}

	case Cobol85ParserPROCEDURE_POINTER:
		{
			p.SetState(3473)
			p.Match(Cobol85ParserPROCEDURE_POINTER)
		}

	case Cobol85ParserREAL:
		{
			p.SetState(3474)
			p.Match(Cobol85ParserREAL)
		}

	case Cobol85ParserTASK:
		{
			p.SetState(3475)
			p.Match(Cobol85ParserTASK)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDataUsingClauseContext is an interface to support dynamic dispatch.
type IDataUsingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataUsingClauseContext differentiates from other interfaces.
	IsDataUsingClauseContext()
}

type DataUsingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataUsingClauseContext() *DataUsingClauseContext {
	var p = new(DataUsingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataUsingClause
	return p
}

func (*DataUsingClauseContext) IsDataUsingClauseContext() {}

func NewDataUsingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataUsingClauseContext {
	var p = new(DataUsingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataUsingClause

	return p
}

func (s *DataUsingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataUsingClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *DataUsingClauseContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLANGUAGE, 0)
}

func (s *DataUsingClauseContext) CONVENTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONVENTION, 0)
}

func (s *DataUsingClauseContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *DataUsingClauseContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataUsingClauseContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *DataUsingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataUsingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataUsingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataUsingClause(s)
	}
}

func (s *DataUsingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataUsingClause(s)
	}
}

func (s *DataUsingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataUsingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataUsingClause() (localctx IDataUsingClauseContext) {
	localctx = NewDataUsingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, Cobol85ParserRULE_dataUsingClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3478)
		p.Match(Cobol85ParserUSING)
	}
	p.SetState(3479)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserCONVENTION || _la == Cobol85ParserLANGUAGE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(3481)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOF {
		{
			p.SetState(3480)
			p.Match(Cobol85ParserOF)
		}

	}
	p.SetState(3485)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 451, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3483)
			p.CobolWord()
		}

	case 2:
		{
			p.SetState(3484)
			p.DataName()
		}

	}

	return localctx
}

// IDataValueClauseContext is an interface to support dynamic dispatch.
type IDataValueClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataValueClauseContext differentiates from other interfaces.
	IsDataValueClauseContext()
}

type DataValueClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataValueClauseContext() *DataValueClauseContext {
	var p = new(DataValueClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataValueClause
	return p
}

func (*DataValueClauseContext) IsDataValueClauseContext() {}

func NewDataValueClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataValueClauseContext {
	var p = new(DataValueClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataValueClause

	return p
}

func (s *DataValueClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataValueClauseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUE, 0)
}

func (s *DataValueClauseContext) VALUES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUES, 0)
}

func (s *DataValueClauseContext) AllDataValueInterval() []IDataValueIntervalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataValueIntervalContext)(nil)).Elem())
	var tst = make([]IDataValueIntervalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataValueIntervalContext)
		}
	}

	return tst
}

func (s *DataValueClauseContext) DataValueInterval(i int) IDataValueIntervalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataValueIntervalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataValueIntervalContext)
}

func (s *DataValueClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataValueClauseContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *DataValueClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataValueClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataValueClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataValueClause(s)
	}
}

func (s *DataValueClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataValueClause(s)
	}
}

func (s *DataValueClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataValueClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataValueClause() (localctx IDataValueClauseContext) {
	localctx = NewDataValueClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, Cobol85ParserRULE_dataValueClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3495)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserVALUE:
		{
			p.SetState(3487)
			p.Match(Cobol85ParserVALUE)
		}
		p.SetState(3489)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(3488)
				p.Match(Cobol85ParserIS)
			}

		}

	case Cobol85ParserVALUES:
		{
			p.SetState(3491)
			p.Match(Cobol85ParserVALUES)
		}
		p.SetState(3493)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserARE {
			{
				p.SetState(3492)
				p.Match(Cobol85ParserARE)
			}

		}

	case Cobol85ParserABORT, Cobol85ParserALL, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFALSE, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserHIGH_VALUE, Cobol85ParserHIGH_VALUES, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserLOW_VALUE, Cobol85ParserLOW_VALUES, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNULL, Cobol85ParserNULLS, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserQUOTE, Cobol85ParserQUOTES, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSPACE, Cobol85ParserSPACES, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUE, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO, Cobol85ParserZERO_FILL, Cobol85ParserZEROS, Cobol85ParserZEROES, Cobol85ParserNONNUMERICLITERAL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserNUMERICLITERAL, Cobol85ParserIDENTIFIER:

	default:
	}
	p.SetState(3498)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3497)
				p.DataValueInterval()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3500)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 455, p.GetParserRuleContext())
	}

	return localctx
}

// IDataValueIntervalContext is an interface to support dynamic dispatch.
type IDataValueIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataValueIntervalContext differentiates from other interfaces.
	IsDataValueIntervalContext()
}

type DataValueIntervalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataValueIntervalContext() *DataValueIntervalContext {
	var p = new(DataValueIntervalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataValueInterval
	return p
}

func (*DataValueIntervalContext) IsDataValueIntervalContext() {}

func NewDataValueIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataValueIntervalContext {
	var p = new(DataValueIntervalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataValueInterval

	return p
}

func (s *DataValueIntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *DataValueIntervalContext) DataValueIntervalFrom() IDataValueIntervalFromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataValueIntervalFromContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataValueIntervalFromContext)
}

func (s *DataValueIntervalContext) DataValueIntervalTo() IDataValueIntervalToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataValueIntervalToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataValueIntervalToContext)
}

func (s *DataValueIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataValueIntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataValueIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataValueInterval(s)
	}
}

func (s *DataValueIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataValueInterval(s)
	}
}

func (s *DataValueIntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataValueInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataValueInterval() (localctx IDataValueIntervalContext) {
	localctx = NewDataValueIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, Cobol85ParserRULE_dataValueInterval)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3502)
		p.DataValueIntervalFrom()
	}
	p.SetState(3504)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(3503)
			p.DataValueIntervalTo()
		}

	}

	return localctx
}

// IDataValueIntervalFromContext is an interface to support dynamic dispatch.
type IDataValueIntervalFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataValueIntervalFromContext differentiates from other interfaces.
	IsDataValueIntervalFromContext()
}

type DataValueIntervalFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataValueIntervalFromContext() *DataValueIntervalFromContext {
	var p = new(DataValueIntervalFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataValueIntervalFrom
	return p
}

func (*DataValueIntervalFromContext) IsDataValueIntervalFromContext() {}

func NewDataValueIntervalFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataValueIntervalFromContext {
	var p = new(DataValueIntervalFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataValueIntervalFrom

	return p
}

func (s *DataValueIntervalFromContext) GetParser() antlr.Parser { return s.parser }

func (s *DataValueIntervalFromContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DataValueIntervalFromContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *DataValueIntervalFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataValueIntervalFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataValueIntervalFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataValueIntervalFrom(s)
	}
}

func (s *DataValueIntervalFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataValueIntervalFrom(s)
	}
}

func (s *DataValueIntervalFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataValueIntervalFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataValueIntervalFrom() (localctx IDataValueIntervalFromContext) {
	localctx = NewDataValueIntervalFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, Cobol85ParserRULE_dataValueIntervalFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3508)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 457, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3506)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3507)
			p.CobolWord()
		}

	}

	return localctx
}

// IDataValueIntervalToContext is an interface to support dynamic dispatch.
type IDataValueIntervalToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataValueIntervalToContext differentiates from other interfaces.
	IsDataValueIntervalToContext()
}

type DataValueIntervalToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataValueIntervalToContext() *DataValueIntervalToContext {
	var p = new(DataValueIntervalToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataValueIntervalTo
	return p
}

func (*DataValueIntervalToContext) IsDataValueIntervalToContext() {}

func NewDataValueIntervalToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataValueIntervalToContext {
	var p = new(DataValueIntervalToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataValueIntervalTo

	return p
}

func (s *DataValueIntervalToContext) GetParser() antlr.Parser { return s.parser }

func (s *DataValueIntervalToContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DataValueIntervalToContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *DataValueIntervalToContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *DataValueIntervalToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataValueIntervalToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataValueIntervalToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataValueIntervalTo(s)
	}
}

func (s *DataValueIntervalToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataValueIntervalTo(s)
	}
}

func (s *DataValueIntervalToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataValueIntervalTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataValueIntervalTo() (localctx IDataValueIntervalToContext) {
	localctx = NewDataValueIntervalToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, Cobol85ParserRULE_dataValueIntervalTo)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3510)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(3511)
		p.Literal()
	}

	return localctx
}

// IDataWithLowerBoundsClauseContext is an interface to support dynamic dispatch.
type IDataWithLowerBoundsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataWithLowerBoundsClauseContext differentiates from other interfaces.
	IsDataWithLowerBoundsClauseContext()
}

type DataWithLowerBoundsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataWithLowerBoundsClauseContext() *DataWithLowerBoundsClauseContext {
	var p = new(DataWithLowerBoundsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataWithLowerBoundsClause
	return p
}

func (*DataWithLowerBoundsClauseContext) IsDataWithLowerBoundsClauseContext() {}

func NewDataWithLowerBoundsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataWithLowerBoundsClauseContext {
	var p = new(DataWithLowerBoundsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataWithLowerBoundsClause

	return p
}

func (s *DataWithLowerBoundsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataWithLowerBoundsClauseContext) LOWER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOWER, 0)
}

func (s *DataWithLowerBoundsClauseContext) BOUNDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBOUNDS, 0)
}

func (s *DataWithLowerBoundsClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *DataWithLowerBoundsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataWithLowerBoundsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataWithLowerBoundsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataWithLowerBoundsClause(s)
	}
}

func (s *DataWithLowerBoundsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataWithLowerBoundsClause(s)
	}
}

func (s *DataWithLowerBoundsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataWithLowerBoundsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataWithLowerBoundsClause() (localctx IDataWithLowerBoundsClauseContext) {
	localctx = NewDataWithLowerBoundsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, Cobol85ParserRULE_dataWithLowerBoundsClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3514)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(3513)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(3516)
		p.Match(Cobol85ParserLOWER)
	}
	{
		p.SetState(3517)
		p.Match(Cobol85ParserBOUNDS)
	}

	return localctx
}

// IProcedureDivisionContext is an interface to support dynamic dispatch.
type IProcedureDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionContext differentiates from other interfaces.
	IsProcedureDivisionContext()
}

type ProcedureDivisionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionContext() *ProcedureDivisionContext {
	var p = new(ProcedureDivisionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivision
	return p
}

func (*ProcedureDivisionContext) IsProcedureDivisionContext() {}

func NewProcedureDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionContext {
	var p = new(ProcedureDivisionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivision

	return p
}

func (s *ProcedureDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE, 0)
}

func (s *ProcedureDivisionContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDIVISION, 0)
}

func (s *ProcedureDivisionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ProcedureDivisionContext) ProcedureDivisionBody() IProcedureDivisionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDivisionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionBodyContext)
}

func (s *ProcedureDivisionContext) ProcedureDivisionUsingClause() IProcedureDivisionUsingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDivisionUsingClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionUsingClauseContext)
}

func (s *ProcedureDivisionContext) ProcedureDivisionGivingClause() IProcedureDivisionGivingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDivisionGivingClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionGivingClauseContext)
}

func (s *ProcedureDivisionContext) ProcedureDeclaratives() IProcedureDeclarativesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDeclarativesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureDeclarativesContext)
}

func (s *ProcedureDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivision(s)
	}
}

func (s *ProcedureDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivision(s)
	}
}

func (s *ProcedureDivisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureDivision(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureDivision() (localctx IProcedureDivisionContext) {
	localctx = NewProcedureDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, Cobol85ParserRULE_procedureDivision)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3519)
		p.Match(Cobol85ParserPROCEDURE)
	}
	{
		p.SetState(3520)
		p.Match(Cobol85ParserDIVISION)
	}
	p.SetState(3522)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSING {
		{
			p.SetState(3521)
			p.ProcedureDivisionUsingClause()
		}

	}
	p.SetState(3525)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGIVING {
		{
			p.SetState(3524)
			p.ProcedureDivisionGivingClause()
		}

	}
	{
		p.SetState(3527)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(3529)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDECLARATIVES {
		{
			p.SetState(3528)
			p.ProcedureDeclaratives()
		}

	}
	{
		p.SetState(3531)
		p.ProcedureDivisionBody()
	}

	return localctx
}

// IProcedureDivisionUsingClauseContext is an interface to support dynamic dispatch.
type IProcedureDivisionUsingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionUsingClauseContext differentiates from other interfaces.
	IsProcedureDivisionUsingClauseContext()
}

type ProcedureDivisionUsingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionUsingClauseContext() *ProcedureDivisionUsingClauseContext {
	var p = new(ProcedureDivisionUsingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionUsingClause
	return p
}

func (*ProcedureDivisionUsingClauseContext) IsProcedureDivisionUsingClauseContext() {}

func NewProcedureDivisionUsingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionUsingClauseContext {
	var p = new(ProcedureDivisionUsingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionUsingClause

	return p
}

func (s *ProcedureDivisionUsingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionUsingClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *ProcedureDivisionUsingClauseContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserSTRING)
}

func (s *ProcedureDivisionUsingClauseContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTRING, i)
}

func (s *ProcedureDivisionUsingClauseContext) AllDataName() []IDataNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataNameContext)(nil)).Elem())
	var tst = make([]IDataNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataNameContext)
		}
	}

	return tst
}

func (s *ProcedureDivisionUsingClauseContext) DataName(i int) IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ProcedureDivisionUsingClauseContext) AllINTEGER() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserINTEGER)
}

func (s *ProcedureDivisionUsingClauseContext) INTEGER(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGER, i)
}

func (s *ProcedureDivisionUsingClauseContext) AllFileName() []IFileNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileNameContext)(nil)).Elem())
	var tst = make([]IFileNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileNameContext)
		}
	}

	return tst
}

func (s *ProcedureDivisionUsingClauseContext) FileName(i int) IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *ProcedureDivisionUsingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionUsingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionUsingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionUsingClause(s)
	}
}

func (s *ProcedureDivisionUsingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionUsingClause(s)
	}
}

func (s *ProcedureDivisionUsingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureDivisionUsingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionUsingClause() (localctx IProcedureDivisionUsingClauseContext) {
	localctx = NewProcedureDivisionUsingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, Cobol85ParserRULE_procedureDivisionUsingClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3533)
		p.Match(Cobol85ParserUSING)
	}
	p.SetState(3540)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434))|(1<<(Cobol85ParserSTRING-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		p.SetState(3540)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 462, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3534)
				p.Match(Cobol85ParserSTRING)
			}
			{
				p.SetState(3535)
				p.DataName()
			}

		case 2:
			{
				p.SetState(3536)
				p.Match(Cobol85ParserINTEGER)
			}
			{
				p.SetState(3537)
				p.DataName()
			}

		case 3:
			{
				p.SetState(3538)
				p.DataName()
			}

		case 4:
			{
				p.SetState(3539)
				p.FileName()
			}

		}

		p.SetState(3542)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProcedureDivisionGivingClauseContext is an interface to support dynamic dispatch.
type IProcedureDivisionGivingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionGivingClauseContext differentiates from other interfaces.
	IsProcedureDivisionGivingClauseContext()
}

type ProcedureDivisionGivingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionGivingClauseContext() *ProcedureDivisionGivingClauseContext {
	var p = new(ProcedureDivisionGivingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionGivingClause
	return p
}

func (*ProcedureDivisionGivingClauseContext) IsProcedureDivisionGivingClauseContext() {}

func NewProcedureDivisionGivingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionGivingClauseContext {
	var p = new(ProcedureDivisionGivingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionGivingClause

	return p
}

func (s *ProcedureDivisionGivingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionGivingClauseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *ProcedureDivisionGivingClauseContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ProcedureDivisionGivingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionGivingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionGivingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionGivingClause(s)
	}
}

func (s *ProcedureDivisionGivingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionGivingClause(s)
	}
}

func (s *ProcedureDivisionGivingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureDivisionGivingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionGivingClause() (localctx IProcedureDivisionGivingClauseContext) {
	localctx = NewProcedureDivisionGivingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, Cobol85ParserRULE_procedureDivisionGivingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3544)
		p.Match(Cobol85ParserGIVING)
	}
	{
		p.SetState(3545)
		p.DataName()
	}

	return localctx
}

// IProcedureDeclarativesContext is an interface to support dynamic dispatch.
type IProcedureDeclarativesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDeclarativesContext differentiates from other interfaces.
	IsProcedureDeclarativesContext()
}

type ProcedureDeclarativesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDeclarativesContext() *ProcedureDeclarativesContext {
	var p = new(ProcedureDeclarativesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDeclaratives
	return p
}

func (*ProcedureDeclarativesContext) IsProcedureDeclarativesContext() {}

func NewProcedureDeclarativesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDeclarativesContext {
	var p = new(ProcedureDeclarativesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDeclaratives

	return p
}

func (s *ProcedureDeclarativesContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDeclarativesContext) AllDECLARATIVES() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDECLARATIVES)
}

func (s *ProcedureDeclarativesContext) DECLARATIVES(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDECLARATIVES, i)
}

func (s *ProcedureDeclarativesContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *ProcedureDeclarativesContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *ProcedureDeclarativesContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *ProcedureDeclarativesContext) AllProcedureDeclarative() []IProcedureDeclarativeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcedureDeclarativeContext)(nil)).Elem())
	var tst = make([]IProcedureDeclarativeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcedureDeclarativeContext)
		}
	}

	return tst
}

func (s *ProcedureDeclarativesContext) ProcedureDeclarative(i int) IProcedureDeclarativeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDeclarativeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcedureDeclarativeContext)
}

func (s *ProcedureDeclarativesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDeclarativesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDeclarativesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDeclaratives(s)
	}
}

func (s *ProcedureDeclarativesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDeclaratives(s)
	}
}

func (s *ProcedureDeclarativesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureDeclaratives(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureDeclaratives() (localctx IProcedureDeclarativesContext) {
	localctx = NewProcedureDeclarativesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, Cobol85ParserRULE_procedureDeclaratives)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3547)
		p.Match(Cobol85ParserDECLARATIVES)
	}
	{
		p.SetState(3548)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(3550)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(3549)
			p.ProcedureDeclarative()
		}

		p.SetState(3552)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3554)
		p.Match(Cobol85ParserEND)
	}
	{
		p.SetState(3555)
		p.Match(Cobol85ParserDECLARATIVES)
	}
	{
		p.SetState(3556)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IProcedureDeclarativeContext is an interface to support dynamic dispatch.
type IProcedureDeclarativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDeclarativeContext differentiates from other interfaces.
	IsProcedureDeclarativeContext()
}

type ProcedureDeclarativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDeclarativeContext() *ProcedureDeclarativeContext {
	var p = new(ProcedureDeclarativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDeclarative
	return p
}

func (*ProcedureDeclarativeContext) IsProcedureDeclarativeContext() {}

func NewProcedureDeclarativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDeclarativeContext {
	var p = new(ProcedureDeclarativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDeclarative

	return p
}

func (s *ProcedureDeclarativeContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDeclarativeContext) ProcedureSectionHeader() IProcedureSectionHeaderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureSectionHeaderContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureSectionHeaderContext)
}

func (s *ProcedureDeclarativeContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *ProcedureDeclarativeContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *ProcedureDeclarativeContext) UseStatement() IUseStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUseStatementContext)
}

func (s *ProcedureDeclarativeContext) Paragraphs() IParagraphsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphsContext)
}

func (s *ProcedureDeclarativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDeclarativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDeclarativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDeclarative(s)
	}
}

func (s *ProcedureDeclarativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDeclarative(s)
	}
}

func (s *ProcedureDeclarativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureDeclarative(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureDeclarative() (localctx IProcedureDeclarativeContext) {
	localctx = NewProcedureDeclarativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, Cobol85ParserRULE_procedureDeclarative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3558)
		p.ProcedureSectionHeader()
	}
	{
		p.SetState(3559)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(3560)
		p.UseStatement()
	}
	{
		p.SetState(3561)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(3562)
		p.Paragraphs()
	}

	return localctx
}

// IProcedureSectionHeaderContext is an interface to support dynamic dispatch.
type IProcedureSectionHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureSectionHeaderContext differentiates from other interfaces.
	IsProcedureSectionHeaderContext()
}

type ProcedureSectionHeaderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureSectionHeaderContext() *ProcedureSectionHeaderContext {
	var p = new(ProcedureSectionHeaderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureSectionHeader
	return p
}

func (*ProcedureSectionHeaderContext) IsProcedureSectionHeaderContext() {}

func NewProcedureSectionHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureSectionHeaderContext {
	var p = new(ProcedureSectionHeaderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureSectionHeader

	return p
}

func (s *ProcedureSectionHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureSectionHeaderContext) SectionName() ISectionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISectionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISectionNameContext)
}

func (s *ProcedureSectionHeaderContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *ProcedureSectionHeaderContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ProcedureSectionHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureSectionHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureSectionHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureSectionHeader(s)
	}
}

func (s *ProcedureSectionHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureSectionHeader(s)
	}
}

func (s *ProcedureSectionHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureSectionHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureSectionHeader() (localctx IProcedureSectionHeaderContext) {
	localctx = NewProcedureSectionHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, Cobol85ParserRULE_procedureSectionHeader)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3564)
		p.SectionName()
	}
	{
		p.SetState(3565)
		p.Match(Cobol85ParserSECTION)
	}
	p.SetState(3567)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556)))) != 0 {
		{
			p.SetState(3566)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IProcedureDivisionBodyContext is an interface to support dynamic dispatch.
type IProcedureDivisionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionBodyContext differentiates from other interfaces.
	IsProcedureDivisionBodyContext()
}

type ProcedureDivisionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionBodyContext() *ProcedureDivisionBodyContext {
	var p = new(ProcedureDivisionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionBody
	return p
}

func (*ProcedureDivisionBodyContext) IsProcedureDivisionBodyContext() {}

func NewProcedureDivisionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionBodyContext {
	var p = new(ProcedureDivisionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionBody

	return p
}

func (s *ProcedureDivisionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionBodyContext) Paragraphs() IParagraphsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphsContext)
}

func (s *ProcedureDivisionBodyContext) AllProcedureSection() []IProcedureSectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcedureSectionContext)(nil)).Elem())
	var tst = make([]IProcedureSectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcedureSectionContext)
		}
	}

	return tst
}

func (s *ProcedureDivisionBodyContext) ProcedureSection(i int) IProcedureSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureSectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcedureSectionContext)
}

func (s *ProcedureDivisionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionBody(s)
	}
}

func (s *ProcedureDivisionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionBody(s)
	}
}

func (s *ProcedureDivisionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureDivisionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionBody() (localctx IProcedureDivisionBodyContext) {
	localctx = NewProcedureDivisionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, Cobol85ParserRULE_procedureDivisionBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3569)
		p.Paragraphs()
	}
	p.SetState(3573)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 466, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3570)
				p.ProcedureSection()
			}

		}
		p.SetState(3575)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 466, p.GetParserRuleContext())
	}

	return localctx
}

// IProcedureSectionContext is an interface to support dynamic dispatch.
type IProcedureSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureSectionContext differentiates from other interfaces.
	IsProcedureSectionContext()
}

type ProcedureSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureSectionContext() *ProcedureSectionContext {
	var p = new(ProcedureSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureSection
	return p
}

func (*ProcedureSectionContext) IsProcedureSectionContext() {}

func NewProcedureSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureSectionContext {
	var p = new(ProcedureSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureSection

	return p
}

func (s *ProcedureSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureSectionContext) ProcedureSectionHeader() IProcedureSectionHeaderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureSectionHeaderContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureSectionHeaderContext)
}

func (s *ProcedureSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ProcedureSectionContext) Paragraphs() IParagraphsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphsContext)
}

func (s *ProcedureSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureSection(s)
	}
}

func (s *ProcedureSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureSection(s)
	}
}

func (s *ProcedureSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureSection() (localctx IProcedureSectionContext) {
	localctx = NewProcedureSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, Cobol85ParserRULE_procedureSection)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3576)
		p.ProcedureSectionHeader()
	}
	{
		p.SetState(3577)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(3578)
		p.Paragraphs()
	}

	return localctx
}

// IParagraphsContext is an interface to support dynamic dispatch.
type IParagraphsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParagraphsContext differentiates from other interfaces.
	IsParagraphsContext()
}

type ParagraphsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraphsContext() *ParagraphsContext {
	var p = new(ParagraphsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_paragraphs
	return p
}

func (*ParagraphsContext) IsParagraphsContext() {}

func NewParagraphsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParagraphsContext {
	var p = new(ParagraphsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_paragraphs

	return p
}

func (s *ParagraphsContext) GetParser() antlr.Parser { return s.parser }

func (s *ParagraphsContext) AllSentence() []ISentenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISentenceContext)(nil)).Elem())
	var tst = make([]ISentenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISentenceContext)
		}
	}

	return tst
}

func (s *ParagraphsContext) Sentence(i int) ISentenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISentenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISentenceContext)
}

func (s *ParagraphsContext) AllParagraph() []IParagraphContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParagraphContext)(nil)).Elem())
	var tst = make([]IParagraphContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParagraphContext)
		}
	}

	return tst
}

func (s *ParagraphsContext) Paragraph(i int) IParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParagraphContext)
}

func (s *ParagraphsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParagraphsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParagraphsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterParagraphs(s)
	}
}

func (s *ParagraphsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitParagraphs(s)
	}
}

func (s *ParagraphsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitParagraphs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Paragraphs() (localctx IParagraphsContext) {
	localctx = NewParagraphsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, Cobol85ParserRULE_paragraphs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3583)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserACCEPT)|(1<<Cobol85ParserADD)|(1<<Cobol85ParserALTER))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(Cobol85ParserCALL-54))|(1<<(Cobol85ParserCANCEL-54))|(1<<(Cobol85ParserCLOSE-54)))) != 0) || _la == Cobol85ParserCOMPUTE || _la == Cobol85ParserCONTINUE || (((_la-134)&-(0x1f+1)) == 0 && ((1<<uint((_la-134)))&((1<<(Cobol85ParserDELETE-134))|(1<<(Cobol85ParserDISABLE-134))|(1<<(Cobol85ParserDISPLAY-134))|(1<<(Cobol85ParserDIVIDE-134))|(1<<(Cobol85ParserENABLE-134)))) != 0) || (((_la-185)&-(0x1f+1)) == 0 && ((1<<uint((_la-185)))&((1<<(Cobol85ParserENTRY-185))|(1<<(Cobol85ParserEVALUATE-185))|(1<<(Cobol85ParserEXHIBIT-185))|(1<<(Cobol85ParserEXIT-185)))) != 0) || (((_la-223)&-(0x1f+1)) == 0 && ((1<<uint((_la-223)))&((1<<(Cobol85ParserGENERATE-223))|(1<<(Cobol85ParserGOBACK-223))|(1<<(Cobol85ParserGO-223))|(1<<(Cobol85ParserIF-223))|(1<<(Cobol85ParserINITIALIZE-223))|(1<<(Cobol85ParserINITIATE-223))|(1<<(Cobol85ParserINSPECT-223)))) != 0) || (((_la-297)&-(0x1f+1)) == 0 && ((1<<uint((_la-297)))&((1<<(Cobol85ParserMERGE-297))|(1<<(Cobol85ParserMOVE-297))|(1<<(Cobol85ParserMULTIPLY-297)))) != 0) || _la == Cobol85ParserOPEN || _la == Cobol85ParserPERFORM || (((_la-370)&-(0x1f+1)) == 0 && ((1<<uint((_la-370)))&((1<<(Cobol85ParserPURGE-370))|(1<<(Cobol85ParserREAD-370))|(1<<(Cobol85ParserRECEIVE-370))|(1<<(Cobol85ParserRELEASE-370)))) != 0) || (((_la-407)&-(0x1f+1)) == 0 && ((1<<uint((_la-407)))&((1<<(Cobol85ParserRETURN-407))|(1<<(Cobol85ParserREWRITE-407))|(1<<(Cobol85ParserSEARCH-407))|(1<<(Cobol85ParserSEND-407))|(1<<(Cobol85ParserSET-407)))) != 0) || (((_la-443)&-(0x1f+1)) == 0 && ((1<<uint((_la-443)))&((1<<(Cobol85ParserSORT-443))|(1<<(Cobol85ParserSTART-443))|(1<<(Cobol85ParserSTOP-443))|(1<<(Cobol85ParserSTRING-443))|(1<<(Cobol85ParserSUBTRACT-443)))) != 0) || _la == Cobol85ParserTERMINATE || _la == Cobol85ParserUNSTRING || _la == Cobol85ParserWRITE || _la == Cobol85ParserDOT_FS || (((_la-563)&-(0x1f+1)) == 0 && ((1<<uint((_la-563)))&((1<<(Cobol85ParserEXECCICSLINE-563))|(1<<(Cobol85ParserEXECSQLIMSLINE-563))|(1<<(Cobol85ParserEXECSQLLINE-563)))) != 0) {
		{
			p.SetState(3580)
			p.Sentence()
		}

		p.SetState(3585)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3589)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 468, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3586)
				p.Paragraph()
			}

		}
		p.SetState(3591)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 468, p.GetParserRuleContext())
	}

	return localctx
}

// IParagraphContext is an interface to support dynamic dispatch.
type IParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParagraphContext differentiates from other interfaces.
	IsParagraphContext()
}

type ParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraphContext() *ParagraphContext {
	var p = new(ParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_paragraph
	return p
}

func (*ParagraphContext) IsParagraphContext() {}

func NewParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParagraphContext {
	var p = new(ParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_paragraph

	return p
}

func (s *ParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *ParagraphContext) ParagraphName() IParagraphNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphNameContext)
}

func (s *ParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ParagraphContext) AlteredGoTo() IAlteredGoToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlteredGoToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlteredGoToContext)
}

func (s *ParagraphContext) AllSentence() []ISentenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISentenceContext)(nil)).Elem())
	var tst = make([]ISentenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISentenceContext)
		}
	}

	return tst
}

func (s *ParagraphContext) Sentence(i int) ISentenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISentenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISentenceContext)
}

func (s *ParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterParagraph(s)
	}
}

func (s *ParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitParagraph(s)
	}
}

func (s *ParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Paragraph() (localctx IParagraphContext) {
	localctx = NewParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, Cobol85ParserRULE_paragraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3592)
		p.ParagraphName()
	}
	{
		p.SetState(3593)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(3601)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 470, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3594)
			p.AlteredGoTo()
		}

	case 2:
		p.SetState(3598)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserACCEPT)|(1<<Cobol85ParserADD)|(1<<Cobol85ParserALTER))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(Cobol85ParserCALL-54))|(1<<(Cobol85ParserCANCEL-54))|(1<<(Cobol85ParserCLOSE-54)))) != 0) || _la == Cobol85ParserCOMPUTE || _la == Cobol85ParserCONTINUE || (((_la-134)&-(0x1f+1)) == 0 && ((1<<uint((_la-134)))&((1<<(Cobol85ParserDELETE-134))|(1<<(Cobol85ParserDISABLE-134))|(1<<(Cobol85ParserDISPLAY-134))|(1<<(Cobol85ParserDIVIDE-134))|(1<<(Cobol85ParserENABLE-134)))) != 0) || (((_la-185)&-(0x1f+1)) == 0 && ((1<<uint((_la-185)))&((1<<(Cobol85ParserENTRY-185))|(1<<(Cobol85ParserEVALUATE-185))|(1<<(Cobol85ParserEXHIBIT-185))|(1<<(Cobol85ParserEXIT-185)))) != 0) || (((_la-223)&-(0x1f+1)) == 0 && ((1<<uint((_la-223)))&((1<<(Cobol85ParserGENERATE-223))|(1<<(Cobol85ParserGOBACK-223))|(1<<(Cobol85ParserGO-223))|(1<<(Cobol85ParserIF-223))|(1<<(Cobol85ParserINITIALIZE-223))|(1<<(Cobol85ParserINITIATE-223))|(1<<(Cobol85ParserINSPECT-223)))) != 0) || (((_la-297)&-(0x1f+1)) == 0 && ((1<<uint((_la-297)))&((1<<(Cobol85ParserMERGE-297))|(1<<(Cobol85ParserMOVE-297))|(1<<(Cobol85ParserMULTIPLY-297)))) != 0) || _la == Cobol85ParserOPEN || _la == Cobol85ParserPERFORM || (((_la-370)&-(0x1f+1)) == 0 && ((1<<uint((_la-370)))&((1<<(Cobol85ParserPURGE-370))|(1<<(Cobol85ParserREAD-370))|(1<<(Cobol85ParserRECEIVE-370))|(1<<(Cobol85ParserRELEASE-370)))) != 0) || (((_la-407)&-(0x1f+1)) == 0 && ((1<<uint((_la-407)))&((1<<(Cobol85ParserRETURN-407))|(1<<(Cobol85ParserREWRITE-407))|(1<<(Cobol85ParserSEARCH-407))|(1<<(Cobol85ParserSEND-407))|(1<<(Cobol85ParserSET-407)))) != 0) || (((_la-443)&-(0x1f+1)) == 0 && ((1<<uint((_la-443)))&((1<<(Cobol85ParserSORT-443))|(1<<(Cobol85ParserSTART-443))|(1<<(Cobol85ParserSTOP-443))|(1<<(Cobol85ParserSTRING-443))|(1<<(Cobol85ParserSUBTRACT-443)))) != 0) || _la == Cobol85ParserTERMINATE || _la == Cobol85ParserUNSTRING || _la == Cobol85ParserWRITE || _la == Cobol85ParserDOT_FS || (((_la-563)&-(0x1f+1)) == 0 && ((1<<uint((_la-563)))&((1<<(Cobol85ParserEXECCICSLINE-563))|(1<<(Cobol85ParserEXECSQLIMSLINE-563))|(1<<(Cobol85ParserEXECSQLLINE-563)))) != 0) {
			{
				p.SetState(3595)
				p.Sentence()
			}

			p.SetState(3600)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// ISentenceContext is an interface to support dynamic dispatch.
type ISentenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSentenceContext differentiates from other interfaces.
	IsSentenceContext()
}

type SentenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySentenceContext() *SentenceContext {
	var p = new(SentenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sentence
	return p
}

func (*SentenceContext) IsSentenceContext() {}

func NewSentenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SentenceContext {
	var p = new(SentenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sentence

	return p
}

func (s *SentenceContext) GetParser() antlr.Parser { return s.parser }

func (s *SentenceContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *SentenceContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *SentenceContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SentenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SentenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SentenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSentence(s)
	}
}

func (s *SentenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSentence(s)
	}
}

func (s *SentenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSentence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Sentence() (localctx ISentenceContext) {
	localctx = NewSentenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, Cobol85ParserRULE_sentence)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3606)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserACCEPT)|(1<<Cobol85ParserADD)|(1<<Cobol85ParserALTER))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(Cobol85ParserCALL-54))|(1<<(Cobol85ParserCANCEL-54))|(1<<(Cobol85ParserCLOSE-54)))) != 0) || _la == Cobol85ParserCOMPUTE || _la == Cobol85ParserCONTINUE || (((_la-134)&-(0x1f+1)) == 0 && ((1<<uint((_la-134)))&((1<<(Cobol85ParserDELETE-134))|(1<<(Cobol85ParserDISABLE-134))|(1<<(Cobol85ParserDISPLAY-134))|(1<<(Cobol85ParserDIVIDE-134))|(1<<(Cobol85ParserENABLE-134)))) != 0) || (((_la-185)&-(0x1f+1)) == 0 && ((1<<uint((_la-185)))&((1<<(Cobol85ParserENTRY-185))|(1<<(Cobol85ParserEVALUATE-185))|(1<<(Cobol85ParserEXHIBIT-185))|(1<<(Cobol85ParserEXIT-185)))) != 0) || (((_la-223)&-(0x1f+1)) == 0 && ((1<<uint((_la-223)))&((1<<(Cobol85ParserGENERATE-223))|(1<<(Cobol85ParserGOBACK-223))|(1<<(Cobol85ParserGO-223))|(1<<(Cobol85ParserIF-223))|(1<<(Cobol85ParserINITIALIZE-223))|(1<<(Cobol85ParserINITIATE-223))|(1<<(Cobol85ParserINSPECT-223)))) != 0) || (((_la-297)&-(0x1f+1)) == 0 && ((1<<uint((_la-297)))&((1<<(Cobol85ParserMERGE-297))|(1<<(Cobol85ParserMOVE-297))|(1<<(Cobol85ParserMULTIPLY-297)))) != 0) || _la == Cobol85ParserOPEN || _la == Cobol85ParserPERFORM || (((_la-370)&-(0x1f+1)) == 0 && ((1<<uint((_la-370)))&((1<<(Cobol85ParserPURGE-370))|(1<<(Cobol85ParserREAD-370))|(1<<(Cobol85ParserRECEIVE-370))|(1<<(Cobol85ParserRELEASE-370)))) != 0) || (((_la-407)&-(0x1f+1)) == 0 && ((1<<uint((_la-407)))&((1<<(Cobol85ParserRETURN-407))|(1<<(Cobol85ParserREWRITE-407))|(1<<(Cobol85ParserSEARCH-407))|(1<<(Cobol85ParserSEND-407))|(1<<(Cobol85ParserSET-407)))) != 0) || (((_la-443)&-(0x1f+1)) == 0 && ((1<<uint((_la-443)))&((1<<(Cobol85ParserSORT-443))|(1<<(Cobol85ParserSTART-443))|(1<<(Cobol85ParserSTOP-443))|(1<<(Cobol85ParserSTRING-443))|(1<<(Cobol85ParserSUBTRACT-443)))) != 0) || _la == Cobol85ParserTERMINATE || _la == Cobol85ParserUNSTRING || _la == Cobol85ParserWRITE || (((_la-563)&-(0x1f+1)) == 0 && ((1<<uint((_la-563)))&((1<<(Cobol85ParserEXECCICSLINE-563))|(1<<(Cobol85ParserEXECSQLIMSLINE-563))|(1<<(Cobol85ParserEXECSQLLINE-563)))) != 0) {
		{
			p.SetState(3603)
			p.Statement()
		}

		p.SetState(3608)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3609)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) AcceptStatement() IAcceptStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcceptStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcceptStatementContext)
}

func (s *StatementContext) AddStatement() IAddStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddStatementContext)
}

func (s *StatementContext) AlterStatement() IAlterStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterStatementContext)
}

func (s *StatementContext) CallStatement() ICallStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallStatementContext)
}

func (s *StatementContext) CancelStatement() ICancelStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICancelStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICancelStatementContext)
}

func (s *StatementContext) CloseStatement() ICloseStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICloseStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICloseStatementContext)
}

func (s *StatementContext) ComputeStatement() IComputeStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputeStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputeStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinueStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) DeleteStatement() IDeleteStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeleteStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *StatementContext) DisableStatement() IDisableStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisableStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisableStatementContext)
}

func (s *StatementContext) DisplayStatement() IDisplayStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisplayStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisplayStatementContext)
}

func (s *StatementContext) DivideStatement() IDivideStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDivideStatementContext)
}

func (s *StatementContext) EnableStatement() IEnableStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnableStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnableStatementContext)
}

func (s *StatementContext) EntryStatement() IEntryStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntryStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntryStatementContext)
}

func (s *StatementContext) EvaluateStatement() IEvaluateStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateStatementContext)
}

func (s *StatementContext) ExhibitStatement() IExhibitStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExhibitStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExhibitStatementContext)
}

func (s *StatementContext) ExecCicsStatement() IExecCicsStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExecCicsStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExecCicsStatementContext)
}

func (s *StatementContext) ExecSqlStatement() IExecSqlStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExecSqlStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExecSqlStatementContext)
}

func (s *StatementContext) ExecSqlImsStatement() IExecSqlImsStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExecSqlImsStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExecSqlImsStatementContext)
}

func (s *StatementContext) ExitStatement() IExitStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExitStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExitStatementContext)
}

func (s *StatementContext) GenerateStatement() IGenerateStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerateStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerateStatementContext)
}

func (s *StatementContext) GobackStatement() IGobackStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGobackStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGobackStatementContext)
}

func (s *StatementContext) GoToStatement() IGoToStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoToStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoToStatementContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) InitializeStatement() IInitializeStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializeStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializeStatementContext)
}

func (s *StatementContext) InitiateStatement() IInitiateStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitiateStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitiateStatementContext)
}

func (s *StatementContext) InspectStatement() IInspectStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInspectStatementContext)
}

func (s *StatementContext) MergeStatement() IMergeStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMergeStatementContext)
}

func (s *StatementContext) MoveStatement() IMoveStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoveStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMoveStatementContext)
}

func (s *StatementContext) MultiplyStatement() IMultiplyStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplyStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiplyStatementContext)
}

func (s *StatementContext) OpenStatement() IOpenStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpenStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOpenStatementContext)
}

func (s *StatementContext) PerformStatement() IPerformStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformStatementContext)
}

func (s *StatementContext) PurgeStatement() IPurgeStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPurgeStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPurgeStatementContext)
}

func (s *StatementContext) ReadStatement() IReadStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadStatementContext)
}

func (s *StatementContext) ReceiveStatement() IReceiveStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiveStatementContext)
}

func (s *StatementContext) ReleaseStatement() IReleaseStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReleaseStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReleaseStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) RewriteStatement() IRewriteStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRewriteStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRewriteStatementContext)
}

func (s *StatementContext) SearchStatement() ISearchStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISearchStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISearchStatementContext)
}

func (s *StatementContext) SendStatement() ISendStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendStatementContext)
}

func (s *StatementContext) SetStatement() ISetStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetStatementContext)
}

func (s *StatementContext) SortStatement() ISortStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortStatementContext)
}

func (s *StatementContext) StartStatement() IStartStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStartStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStartStatementContext)
}

func (s *StatementContext) StopStatement() IStopStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStopStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStopStatementContext)
}

func (s *StatementContext) StringStatement() IStringStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringStatementContext)
}

func (s *StatementContext) SubtractStatement() ISubtractStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtractStatementContext)
}

func (s *StatementContext) TerminateStatement() ITerminateStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminateStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminateStatementContext)
}

func (s *StatementContext) UnstringStatement() IUnstringStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnstringStatementContext)
}

func (s *StatementContext) WriteStatement() IWriteStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWriteStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWriteStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, Cobol85ParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3660)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserACCEPT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3611)
			p.AcceptStatement()
		}

	case Cobol85ParserADD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3612)
			p.AddStatement()
		}

	case Cobol85ParserALTER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3613)
			p.AlterStatement()
		}

	case Cobol85ParserCALL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3614)
			p.CallStatement()
		}

	case Cobol85ParserCANCEL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3615)
			p.CancelStatement()
		}

	case Cobol85ParserCLOSE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3616)
			p.CloseStatement()
		}

	case Cobol85ParserCOMPUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3617)
			p.ComputeStatement()
		}

	case Cobol85ParserCONTINUE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3618)
			p.ContinueStatement()
		}

	case Cobol85ParserDELETE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3619)
			p.DeleteStatement()
		}

	case Cobol85ParserDISABLE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3620)
			p.DisableStatement()
		}

	case Cobol85ParserDISPLAY:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3621)
			p.DisplayStatement()
		}

	case Cobol85ParserDIVIDE:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3622)
			p.DivideStatement()
		}

	case Cobol85ParserENABLE:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3623)
			p.EnableStatement()
		}

	case Cobol85ParserENTRY:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3624)
			p.EntryStatement()
		}

	case Cobol85ParserEVALUATE:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3625)
			p.EvaluateStatement()
		}

	case Cobol85ParserEXHIBIT:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3626)
			p.ExhibitStatement()
		}

	case Cobol85ParserEXECCICSLINE:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3627)
			p.ExecCicsStatement()
		}

	case Cobol85ParserEXECSQLLINE:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(3628)
			p.ExecSqlStatement()
		}

	case Cobol85ParserEXECSQLIMSLINE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(3629)
			p.ExecSqlImsStatement()
		}

	case Cobol85ParserEXIT:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(3630)
			p.ExitStatement()
		}

	case Cobol85ParserGENERATE:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(3631)
			p.GenerateStatement()
		}

	case Cobol85ParserGOBACK:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(3632)
			p.GobackStatement()
		}

	case Cobol85ParserGO:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(3633)
			p.GoToStatement()
		}

	case Cobol85ParserIF:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(3634)
			p.IfStatement()
		}

	case Cobol85ParserINITIALIZE:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(3635)
			p.InitializeStatement()
		}

	case Cobol85ParserINITIATE:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(3636)
			p.InitiateStatement()
		}

	case Cobol85ParserINSPECT:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(3637)
			p.InspectStatement()
		}

	case Cobol85ParserMERGE:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(3638)
			p.MergeStatement()
		}

	case Cobol85ParserMOVE:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(3639)
			p.MoveStatement()
		}

	case Cobol85ParserMULTIPLY:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(3640)
			p.MultiplyStatement()
		}

	case Cobol85ParserOPEN:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(3641)
			p.OpenStatement()
		}

	case Cobol85ParserPERFORM:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(3642)
			p.PerformStatement()
		}

	case Cobol85ParserPURGE:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(3643)
			p.PurgeStatement()
		}

	case Cobol85ParserREAD:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(3644)
			p.ReadStatement()
		}

	case Cobol85ParserRECEIVE:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(3645)
			p.ReceiveStatement()
		}

	case Cobol85ParserRELEASE:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(3646)
			p.ReleaseStatement()
		}

	case Cobol85ParserRETURN:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(3647)
			p.ReturnStatement()
		}

	case Cobol85ParserREWRITE:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(3648)
			p.RewriteStatement()
		}

	case Cobol85ParserSEARCH:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(3649)
			p.SearchStatement()
		}

	case Cobol85ParserSEND:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(3650)
			p.SendStatement()
		}

	case Cobol85ParserSET:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(3651)
			p.SetStatement()
		}

	case Cobol85ParserSORT:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(3652)
			p.SortStatement()
		}

	case Cobol85ParserSTART:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(3653)
			p.StartStatement()
		}

	case Cobol85ParserSTOP:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(3654)
			p.StopStatement()
		}

	case Cobol85ParserSTRING:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(3655)
			p.StringStatement()
		}

	case Cobol85ParserSUBTRACT:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(3656)
			p.SubtractStatement()
		}

	case Cobol85ParserTERMINATE:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(3657)
			p.TerminateStatement()
		}

	case Cobol85ParserUNSTRING:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(3658)
			p.UnstringStatement()
		}

	case Cobol85ParserWRITE:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(3659)
			p.WriteStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcceptStatementContext is an interface to support dynamic dispatch.
type IAcceptStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcceptStatementContext differentiates from other interfaces.
	IsAcceptStatementContext()
}

type AcceptStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptStatementContext() *AcceptStatementContext {
	var p = new(AcceptStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_acceptStatement
	return p
}

func (*AcceptStatementContext) IsAcceptStatementContext() {}

func NewAcceptStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptStatementContext {
	var p = new(AcceptStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_acceptStatement

	return p
}

func (s *AcceptStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptStatementContext) ACCEPT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserACCEPT, 0)
}

func (s *AcceptStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcceptStatementContext) AcceptFromDateStatement() IAcceptFromDateStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcceptFromDateStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcceptFromDateStatementContext)
}

func (s *AcceptStatementContext) AcceptFromEscapeKeyStatement() IAcceptFromEscapeKeyStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcceptFromEscapeKeyStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcceptFromEscapeKeyStatementContext)
}

func (s *AcceptStatementContext) AcceptFromMnemonicStatement() IAcceptFromMnemonicStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcceptFromMnemonicStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcceptFromMnemonicStatementContext)
}

func (s *AcceptStatementContext) AcceptMessageCountStatement() IAcceptMessageCountStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcceptMessageCountStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcceptMessageCountStatementContext)
}

func (s *AcceptStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAcceptStatement(s)
	}
}

func (s *AcceptStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAcceptStatement(s)
	}
}

func (s *AcceptStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAcceptStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AcceptStatement() (localctx IAcceptStatementContext) {
	localctx = NewAcceptStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, Cobol85ParserRULE_acceptStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3662)
		p.Match(Cobol85ParserACCEPT)
	}
	{
		p.SetState(3663)
		p.Identifier()
	}
	p.SetState(3668)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 473, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3664)
			p.AcceptFromDateStatement()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 473, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(3665)
			p.AcceptFromEscapeKeyStatement()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 473, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(3666)
			p.AcceptFromMnemonicStatement()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 473, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(3667)
			p.AcceptMessageCountStatement()
		}

	}

	return localctx
}

// IAcceptFromDateStatementContext is an interface to support dynamic dispatch.
type IAcceptFromDateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcceptFromDateStatementContext differentiates from other interfaces.
	IsAcceptFromDateStatementContext()
}

type AcceptFromDateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptFromDateStatementContext() *AcceptFromDateStatementContext {
	var p = new(AcceptFromDateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_acceptFromDateStatement
	return p
}

func (*AcceptFromDateStatementContext) IsAcceptFromDateStatementContext() {}

func NewAcceptFromDateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptFromDateStatementContext {
	var p = new(AcceptFromDateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_acceptFromDateStatement

	return p
}

func (s *AcceptFromDateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptFromDateStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *AcceptFromDateStatementContext) DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE, 0)
}

func (s *AcceptFromDateStatementContext) DAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDAY, 0)
}

func (s *AcceptFromDateStatementContext) DAY_OF_WEEK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDAY_OF_WEEK, 0)
}

func (s *AcceptFromDateStatementContext) TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIME, 0)
}

func (s *AcceptFromDateStatementContext) TIMER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMER, 0)
}

func (s *AcceptFromDateStatementContext) TODAYS_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTODAYS_DATE, 0)
}

func (s *AcceptFromDateStatementContext) TODAYS_NAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTODAYS_NAME, 0)
}

func (s *AcceptFromDateStatementContext) YEAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYEAR, 0)
}

func (s *AcceptFromDateStatementContext) YYYYMMDD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYYYYMMDD, 0)
}

func (s *AcceptFromDateStatementContext) YYYYDDD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYYYYDDD, 0)
}

func (s *AcceptFromDateStatementContext) MMDDYYYY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMMDDYYYY, 0)
}

func (s *AcceptFromDateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptFromDateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptFromDateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAcceptFromDateStatement(s)
	}
}

func (s *AcceptFromDateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAcceptFromDateStatement(s)
	}
}

func (s *AcceptFromDateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAcceptFromDateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AcceptFromDateStatement() (localctx IAcceptFromDateStatementContext) {
	localctx = NewAcceptFromDateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, Cobol85ParserRULE_acceptFromDateStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3670)
		p.Match(Cobol85ParserFROM)
	}
	p.SetState(3690)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserDATE:
		{
			p.SetState(3671)
			p.Match(Cobol85ParserDATE)
		}
		p.SetState(3673)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserYYYYMMDD {
			{
				p.SetState(3672)
				p.Match(Cobol85ParserYYYYMMDD)
			}

		}

	case Cobol85ParserDAY:
		{
			p.SetState(3675)
			p.Match(Cobol85ParserDAY)
		}
		p.SetState(3677)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserYYYYDDD {
			{
				p.SetState(3676)
				p.Match(Cobol85ParserYYYYDDD)
			}

		}

	case Cobol85ParserDAY_OF_WEEK:
		{
			p.SetState(3679)
			p.Match(Cobol85ParserDAY_OF_WEEK)
		}

	case Cobol85ParserTIME:
		{
			p.SetState(3680)
			p.Match(Cobol85ParserTIME)
		}

	case Cobol85ParserTIMER:
		{
			p.SetState(3681)
			p.Match(Cobol85ParserTIMER)
		}

	case Cobol85ParserTODAYS_DATE:
		{
			p.SetState(3682)
			p.Match(Cobol85ParserTODAYS_DATE)
		}
		p.SetState(3684)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserMMDDYYYY {
			{
				p.SetState(3683)
				p.Match(Cobol85ParserMMDDYYYY)
			}

		}

	case Cobol85ParserTODAYS_NAME:
		{
			p.SetState(3686)
			p.Match(Cobol85ParserTODAYS_NAME)
		}

	case Cobol85ParserYEAR:
		{
			p.SetState(3687)
			p.Match(Cobol85ParserYEAR)
		}

	case Cobol85ParserYYYYMMDD:
		{
			p.SetState(3688)
			p.Match(Cobol85ParserYYYYMMDD)
		}

	case Cobol85ParserYYYYDDD:
		{
			p.SetState(3689)
			p.Match(Cobol85ParserYYYYDDD)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcceptFromMnemonicStatementContext is an interface to support dynamic dispatch.
type IAcceptFromMnemonicStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcceptFromMnemonicStatementContext differentiates from other interfaces.
	IsAcceptFromMnemonicStatementContext()
}

type AcceptFromMnemonicStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptFromMnemonicStatementContext() *AcceptFromMnemonicStatementContext {
	var p = new(AcceptFromMnemonicStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_acceptFromMnemonicStatement
	return p
}

func (*AcceptFromMnemonicStatementContext) IsAcceptFromMnemonicStatementContext() {}

func NewAcceptFromMnemonicStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptFromMnemonicStatementContext {
	var p = new(AcceptFromMnemonicStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_acceptFromMnemonicStatement

	return p
}

func (s *AcceptFromMnemonicStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptFromMnemonicStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *AcceptFromMnemonicStatementContext) MnemonicName() IMnemonicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMnemonicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *AcceptFromMnemonicStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptFromMnemonicStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptFromMnemonicStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAcceptFromMnemonicStatement(s)
	}
}

func (s *AcceptFromMnemonicStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAcceptFromMnemonicStatement(s)
	}
}

func (s *AcceptFromMnemonicStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAcceptFromMnemonicStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AcceptFromMnemonicStatement() (localctx IAcceptFromMnemonicStatementContext) {
	localctx = NewAcceptFromMnemonicStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, Cobol85ParserRULE_acceptFromMnemonicStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3692)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(3693)
		p.MnemonicName()
	}

	return localctx
}

// IAcceptFromEscapeKeyStatementContext is an interface to support dynamic dispatch.
type IAcceptFromEscapeKeyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcceptFromEscapeKeyStatementContext differentiates from other interfaces.
	IsAcceptFromEscapeKeyStatementContext()
}

type AcceptFromEscapeKeyStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptFromEscapeKeyStatementContext() *AcceptFromEscapeKeyStatementContext {
	var p = new(AcceptFromEscapeKeyStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_acceptFromEscapeKeyStatement
	return p
}

func (*AcceptFromEscapeKeyStatementContext) IsAcceptFromEscapeKeyStatementContext() {}

func NewAcceptFromEscapeKeyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptFromEscapeKeyStatementContext {
	var p = new(AcceptFromEscapeKeyStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_acceptFromEscapeKeyStatement

	return p
}

func (s *AcceptFromEscapeKeyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptFromEscapeKeyStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *AcceptFromEscapeKeyStatementContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserESCAPE, 0)
}

func (s *AcceptFromEscapeKeyStatementContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *AcceptFromEscapeKeyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptFromEscapeKeyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptFromEscapeKeyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAcceptFromEscapeKeyStatement(s)
	}
}

func (s *AcceptFromEscapeKeyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAcceptFromEscapeKeyStatement(s)
	}
}

func (s *AcceptFromEscapeKeyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAcceptFromEscapeKeyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AcceptFromEscapeKeyStatement() (localctx IAcceptFromEscapeKeyStatementContext) {
	localctx = NewAcceptFromEscapeKeyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, Cobol85ParserRULE_acceptFromEscapeKeyStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3695)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(3696)
		p.Match(Cobol85ParserESCAPE)
	}
	{
		p.SetState(3697)
		p.Match(Cobol85ParserKEY)
	}

	return localctx
}

// IAcceptMessageCountStatementContext is an interface to support dynamic dispatch.
type IAcceptMessageCountStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcceptMessageCountStatementContext differentiates from other interfaces.
	IsAcceptMessageCountStatementContext()
}

type AcceptMessageCountStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptMessageCountStatementContext() *AcceptMessageCountStatementContext {
	var p = new(AcceptMessageCountStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_acceptMessageCountStatement
	return p
}

func (*AcceptMessageCountStatementContext) IsAcceptMessageCountStatementContext() {}

func NewAcceptMessageCountStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptMessageCountStatementContext {
	var p = new(AcceptMessageCountStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_acceptMessageCountStatement

	return p
}

func (s *AcceptMessageCountStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptMessageCountStatementContext) COUNT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOUNT, 0)
}

func (s *AcceptMessageCountStatementContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMESSAGE, 0)
}

func (s *AcceptMessageCountStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptMessageCountStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptMessageCountStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAcceptMessageCountStatement(s)
	}
}

func (s *AcceptMessageCountStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAcceptMessageCountStatement(s)
	}
}

func (s *AcceptMessageCountStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAcceptMessageCountStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AcceptMessageCountStatement() (localctx IAcceptMessageCountStatementContext) {
	localctx = NewAcceptMessageCountStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, Cobol85ParserRULE_acceptMessageCountStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3700)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMESSAGE {
		{
			p.SetState(3699)
			p.Match(Cobol85ParserMESSAGE)
		}

	}
	{
		p.SetState(3702)
		p.Match(Cobol85ParserCOUNT)
	}

	return localctx
}

// IAddStatementContext is an interface to support dynamic dispatch.
type IAddStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddStatementContext differentiates from other interfaces.
	IsAddStatementContext()
}

type AddStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddStatementContext() *AddStatementContext {
	var p = new(AddStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addStatement
	return p
}

func (*AddStatementContext) IsAddStatementContext() {}

func NewAddStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddStatementContext {
	var p = new(AddStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addStatement

	return p
}

func (s *AddStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADD, 0)
}

func (s *AddStatementContext) AddToStatement() IAddToStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddToStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddToStatementContext)
}

func (s *AddStatementContext) AddToGivingStatement() IAddToGivingStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddToGivingStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddToGivingStatementContext)
}

func (s *AddStatementContext) AddCorrespondingStatement() IAddCorrespondingStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddCorrespondingStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddCorrespondingStatementContext)
}

func (s *AddStatementContext) OnSizeErrorPhrase() IOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnSizeErrorPhraseContext)
}

func (s *AddStatementContext) NotOnSizeErrorPhrase() INotOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnSizeErrorPhraseContext)
}

func (s *AddStatementContext) END_ADD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_ADD, 0)
}

func (s *AddStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddStatement(s)
	}
}

func (s *AddStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddStatement(s)
	}
}

func (s *AddStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAddStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AddStatement() (localctx IAddStatementContext) {
	localctx = NewAddStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, Cobol85ParserRULE_addStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3704)
		p.Match(Cobol85ParserADD)
	}
	p.SetState(3708)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 479, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3705)
			p.AddToStatement()
		}

	case 2:
		{
			p.SetState(3706)
			p.AddToGivingStatement()
		}

	case 3:
		{
			p.SetState(3707)
			p.AddCorrespondingStatement()
		}

	}
	p.SetState(3711)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 480, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3710)
			p.OnSizeErrorPhrase()
		}

	}
	p.SetState(3714)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 481, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3713)
			p.NotOnSizeErrorPhrase()
		}

	}
	p.SetState(3717)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 482, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3716)
			p.Match(Cobol85ParserEND_ADD)
		}

	}

	return localctx
}

// IAddToStatementContext is an interface to support dynamic dispatch.
type IAddToStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddToStatementContext differentiates from other interfaces.
	IsAddToStatementContext()
}

type AddToStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddToStatementContext() *AddToStatementContext {
	var p = new(AddToStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addToStatement
	return p
}

func (*AddToStatementContext) IsAddToStatementContext() {}

func NewAddToStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddToStatementContext {
	var p = new(AddToStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addToStatement

	return p
}

func (s *AddToStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddToStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *AddToStatementContext) AllAddFrom() []IAddFromContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAddFromContext)(nil)).Elem())
	var tst = make([]IAddFromContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAddFromContext)
		}
	}

	return tst
}

func (s *AddToStatementContext) AddFrom(i int) IAddFromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddFromContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAddFromContext)
}

func (s *AddToStatementContext) AllAddTo() []IAddToContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAddToContext)(nil)).Elem())
	var tst = make([]IAddToContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAddToContext)
		}
	}

	return tst
}

func (s *AddToStatementContext) AddTo(i int) IAddToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddToContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAddToContext)
}

func (s *AddToStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddToStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddToStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddToStatement(s)
	}
}

func (s *AddToStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddToStatement(s)
	}
}

func (s *AddToStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAddToStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AddToStatement() (localctx IAddToStatementContext) {
	localctx = NewAddToStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, Cobol85ParserRULE_addToStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3720)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184))|(1<<(Cobol85ParserFALSE-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserHIGH_VALUE-216))|(1<<(Cobol85ParserHIGH_VALUES-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserLOW_VALUE-286))|(1<<(Cobol85ParserLOW_VALUES-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286))|(1<<(Cobol85ParserNULL-286)))) != 0) || (((_la-318)&-(0x1f+1)) == 0 && ((1<<uint((_la-318)))&((1<<(Cobol85ParserNULLS-318))|(1<<(Cobol85ParserNUMERIC_DATE-318))|(1<<(Cobol85ParserNUMERIC_TIME-318))|(1<<(Cobol85ParserODT-318))|(1<<(Cobol85ParserOPTIMIZE-318))|(1<<(Cobol85ParserORDERLY-318))|(1<<(Cobol85ParserOVERLINE-318))|(1<<(Cobol85ParserOWN-318))|(1<<(Cobol85ParserPAGE_COUNTER-318))|(1<<(Cobol85ParserPASSWORD-318)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserQUOTE-357))|(1<<(Cobol85ParserQUOTES-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434))|(1<<(Cobol85ParserSPACE-434))|(1<<(Cobol85ParserSPACES-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUE-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO-502))|(1<<(Cobol85ParserZERO_FILL-502))|(1<<(Cobol85ParserZEROS-502))|(1<<(Cobol85ParserZEROES-502)))) != 0) || (((_la-555)&-(0x1f+1)) == 0 && ((1<<uint((_la-555)))&((1<<(Cobol85ParserNONNUMERICLITERAL-555))|(1<<(Cobol85ParserLEVEL_NUMBER_66-555))|(1<<(Cobol85ParserLEVEL_NUMBER_77-555))|(1<<(Cobol85ParserLEVEL_NUMBER_88-555))|(1<<(Cobol85ParserINTEGERLITERAL-555))|(1<<(Cobol85ParserNUMERICLITERAL-555))|(1<<(Cobol85ParserIDENTIFIER-555)))) != 0) {
		{
			p.SetState(3719)
			p.AddFrom()
		}

		p.SetState(3722)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3724)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(3726)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(3725)
			p.AddTo()
		}

		p.SetState(3728)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAddToGivingStatementContext is an interface to support dynamic dispatch.
type IAddToGivingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddToGivingStatementContext differentiates from other interfaces.
	IsAddToGivingStatementContext()
}

type AddToGivingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddToGivingStatementContext() *AddToGivingStatementContext {
	var p = new(AddToGivingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addToGivingStatement
	return p
}

func (*AddToGivingStatementContext) IsAddToGivingStatementContext() {}

func NewAddToGivingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddToGivingStatementContext {
	var p = new(AddToGivingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addToGivingStatement

	return p
}

func (s *AddToGivingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddToGivingStatementContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *AddToGivingStatementContext) AllAddFrom() []IAddFromContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAddFromContext)(nil)).Elem())
	var tst = make([]IAddFromContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAddFromContext)
		}
	}

	return tst
}

func (s *AddToGivingStatementContext) AddFrom(i int) IAddFromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddFromContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAddFromContext)
}

func (s *AddToGivingStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *AddToGivingStatementContext) AllAddGiving() []IAddGivingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAddGivingContext)(nil)).Elem())
	var tst = make([]IAddGivingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAddGivingContext)
		}
	}

	return tst
}

func (s *AddToGivingStatementContext) AddGiving(i int) IAddGivingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddGivingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAddGivingContext)
}

func (s *AddToGivingStatementContext) AllAddTo() []IAddToContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAddToContext)(nil)).Elem())
	var tst = make([]IAddToContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAddToContext)
		}
	}

	return tst
}

func (s *AddToGivingStatementContext) AddTo(i int) IAddToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddToContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAddToContext)
}

func (s *AddToGivingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddToGivingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddToGivingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddToGivingStatement(s)
	}
}

func (s *AddToGivingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddToGivingStatement(s)
	}
}

func (s *AddToGivingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAddToGivingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AddToGivingStatement() (localctx IAddToGivingStatementContext) {
	localctx = NewAddToGivingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, Cobol85ParserRULE_addToGivingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3731)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184))|(1<<(Cobol85ParserFALSE-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserHIGH_VALUE-216))|(1<<(Cobol85ParserHIGH_VALUES-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserLOW_VALUE-286))|(1<<(Cobol85ParserLOW_VALUES-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286))|(1<<(Cobol85ParserNULL-286)))) != 0) || (((_la-318)&-(0x1f+1)) == 0 && ((1<<uint((_la-318)))&((1<<(Cobol85ParserNULLS-318))|(1<<(Cobol85ParserNUMERIC_DATE-318))|(1<<(Cobol85ParserNUMERIC_TIME-318))|(1<<(Cobol85ParserODT-318))|(1<<(Cobol85ParserOPTIMIZE-318))|(1<<(Cobol85ParserORDERLY-318))|(1<<(Cobol85ParserOVERLINE-318))|(1<<(Cobol85ParserOWN-318))|(1<<(Cobol85ParserPAGE_COUNTER-318))|(1<<(Cobol85ParserPASSWORD-318)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserQUOTE-357))|(1<<(Cobol85ParserQUOTES-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434))|(1<<(Cobol85ParserSPACE-434))|(1<<(Cobol85ParserSPACES-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUE-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO-502))|(1<<(Cobol85ParserZERO_FILL-502))|(1<<(Cobol85ParserZEROS-502))|(1<<(Cobol85ParserZEROES-502)))) != 0) || (((_la-555)&-(0x1f+1)) == 0 && ((1<<uint((_la-555)))&((1<<(Cobol85ParserNONNUMERICLITERAL-555))|(1<<(Cobol85ParserLEVEL_NUMBER_66-555))|(1<<(Cobol85ParserLEVEL_NUMBER_77-555))|(1<<(Cobol85ParserLEVEL_NUMBER_88-555))|(1<<(Cobol85ParserINTEGERLITERAL-555))|(1<<(Cobol85ParserNUMERICLITERAL-555))|(1<<(Cobol85ParserIDENTIFIER-555)))) != 0) {
		{
			p.SetState(3730)
			p.AddFrom()
		}

		p.SetState(3733)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3741)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(3735)
			p.Match(Cobol85ParserTO)
		}
		p.SetState(3737)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
			{
				p.SetState(3736)
				p.AddTo()
			}

			p.SetState(3739)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3743)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(3745)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(3744)
			p.AddGiving()
		}

		p.SetState(3747)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAddCorrespondingStatementContext is an interface to support dynamic dispatch.
type IAddCorrespondingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddCorrespondingStatementContext differentiates from other interfaces.
	IsAddCorrespondingStatementContext()
}

type AddCorrespondingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddCorrespondingStatementContext() *AddCorrespondingStatementContext {
	var p = new(AddCorrespondingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addCorrespondingStatement
	return p
}

func (*AddCorrespondingStatementContext) IsAddCorrespondingStatementContext() {}

func NewAddCorrespondingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddCorrespondingStatementContext {
	var p = new(AddCorrespondingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addCorrespondingStatement

	return p
}

func (s *AddCorrespondingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddCorrespondingStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddCorrespondingStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *AddCorrespondingStatementContext) AddTo() IAddToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddToContext)
}

func (s *AddCorrespondingStatementContext) CORRESPONDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORRESPONDING, 0)
}

func (s *AddCorrespondingStatementContext) CORR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORR, 0)
}

func (s *AddCorrespondingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddCorrespondingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddCorrespondingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddCorrespondingStatement(s)
	}
}

func (s *AddCorrespondingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddCorrespondingStatement(s)
	}
}

func (s *AddCorrespondingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAddCorrespondingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AddCorrespondingStatement() (localctx IAddCorrespondingStatementContext) {
	localctx = NewAddCorrespondingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, Cobol85ParserRULE_addCorrespondingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3749)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserCORR || _la == Cobol85ParserCORRESPONDING) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(3750)
		p.Identifier()
	}
	{
		p.SetState(3751)
		p.Match(Cobol85ParserTO)
	}
	{
		p.SetState(3752)
		p.AddTo()
	}

	return localctx
}

// IAddFromContext is an interface to support dynamic dispatch.
type IAddFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddFromContext differentiates from other interfaces.
	IsAddFromContext()
}

type AddFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddFromContext() *AddFromContext {
	var p = new(AddFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addFrom
	return p
}

func (*AddFromContext) IsAddFromContext() {}

func NewAddFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddFromContext {
	var p = new(AddFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addFrom

	return p
}

func (s *AddFromContext) GetParser() antlr.Parser { return s.parser }

func (s *AddFromContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddFromContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AddFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddFrom(s)
	}
}

func (s *AddFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddFrom(s)
	}
}

func (s *AddFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAddFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AddFrom() (localctx IAddFromContext) {
	localctx = NewAddFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, Cobol85ParserRULE_addFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3756)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 489, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3754)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3755)
			p.Literal()
		}

	}

	return localctx
}

// IAddToContext is an interface to support dynamic dispatch.
type IAddToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddToContext differentiates from other interfaces.
	IsAddToContext()
}

type AddToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddToContext() *AddToContext {
	var p = new(AddToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addTo
	return p
}

func (*AddToContext) IsAddToContext() {}

func NewAddToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddToContext {
	var p = new(AddToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addTo

	return p
}

func (s *AddToContext) GetParser() antlr.Parser { return s.parser }

func (s *AddToContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddToContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *AddToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddTo(s)
	}
}

func (s *AddToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddTo(s)
	}
}

func (s *AddToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAddTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AddTo() (localctx IAddToContext) {
	localctx = NewAddToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, Cobol85ParserRULE_addTo)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3758)
		p.Identifier()
	}
	p.SetState(3760)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(3759)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IAddGivingContext is an interface to support dynamic dispatch.
type IAddGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddGivingContext differentiates from other interfaces.
	IsAddGivingContext()
}

type AddGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddGivingContext() *AddGivingContext {
	var p = new(AddGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addGiving
	return p
}

func (*AddGivingContext) IsAddGivingContext() {}

func NewAddGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddGivingContext {
	var p = new(AddGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addGiving

	return p
}

func (s *AddGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *AddGivingContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddGivingContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *AddGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddGiving(s)
	}
}

func (s *AddGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddGiving(s)
	}
}

func (s *AddGivingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAddGiving(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AddGiving() (localctx IAddGivingContext) {
	localctx = NewAddGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, Cobol85ParserRULE_addGiving)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3762)
		p.Identifier()
	}
	p.SetState(3764)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(3763)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IAlteredGoToContext is an interface to support dynamic dispatch.
type IAlteredGoToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlteredGoToContext differentiates from other interfaces.
	IsAlteredGoToContext()
}

type AlteredGoToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlteredGoToContext() *AlteredGoToContext {
	var p = new(AlteredGoToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alteredGoTo
	return p
}

func (*AlteredGoToContext) IsAlteredGoToContext() {}

func NewAlteredGoToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlteredGoToContext {
	var p = new(AlteredGoToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alteredGoTo

	return p
}

func (s *AlteredGoToContext) GetParser() antlr.Parser { return s.parser }

func (s *AlteredGoToContext) GO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGO, 0)
}

func (s *AlteredGoToContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *AlteredGoToContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *AlteredGoToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlteredGoToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlteredGoToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlteredGoTo(s)
	}
}

func (s *AlteredGoToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlteredGoTo(s)
	}
}

func (s *AlteredGoToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlteredGoTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlteredGoTo() (localctx IAlteredGoToContext) {
	localctx = NewAlteredGoToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, Cobol85ParserRULE_alteredGoTo)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3766)
		p.Match(Cobol85ParserGO)
	}
	p.SetState(3768)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(3767)
			p.Match(Cobol85ParserTO)
		}

	}
	{
		p.SetState(3770)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IAlterStatementContext is an interface to support dynamic dispatch.
type IAlterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterStatementContext differentiates from other interfaces.
	IsAlterStatementContext()
}

type AlterStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementContext() *AlterStatementContext {
	var p = new(AlterStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alterStatement
	return p
}

func (*AlterStatementContext) IsAlterStatementContext() {}

func NewAlterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementContext {
	var p = new(AlterStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alterStatement

	return p
}

func (s *AlterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALTER, 0)
}

func (s *AlterStatementContext) AllAlterProceedTo() []IAlterProceedToContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlterProceedToContext)(nil)).Elem())
	var tst = make([]IAlterProceedToContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlterProceedToContext)
		}
	}

	return tst
}

func (s *AlterStatementContext) AlterProceedTo(i int) IAlterProceedToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterProceedToContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlterProceedToContext)
}

func (s *AlterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlterStatement(s)
	}
}

func (s *AlterStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlterStatement(s)
	}
}

func (s *AlterStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlterStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlterStatement() (localctx IAlterStatementContext) {
	localctx = NewAlterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, Cobol85ParserRULE_alterStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3772)
		p.Match(Cobol85ParserALTER)
	}
	p.SetState(3774)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(3773)
			p.AlterProceedTo()
		}

		p.SetState(3776)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAlterProceedToContext is an interface to support dynamic dispatch.
type IAlterProceedToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterProceedToContext differentiates from other interfaces.
	IsAlterProceedToContext()
}

type AlterProceedToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterProceedToContext() *AlterProceedToContext {
	var p = new(AlterProceedToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alterProceedTo
	return p
}

func (*AlterProceedToContext) IsAlterProceedToContext() {}

func NewAlterProceedToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterProceedToContext {
	var p = new(AlterProceedToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alterProceedTo

	return p
}

func (s *AlterProceedToContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterProceedToContext) AllProcedureName() []IProcedureNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem())
	var tst = make([]IProcedureNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcedureNameContext)
		}
	}

	return tst
}

func (s *AlterProceedToContext) ProcedureName(i int) IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *AlterProceedToContext) AllTO() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserTO)
}

func (s *AlterProceedToContext) TO(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, i)
}

func (s *AlterProceedToContext) PROCEED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEED, 0)
}

func (s *AlterProceedToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterProceedToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterProceedToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlterProceedTo(s)
	}
}

func (s *AlterProceedToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlterProceedTo(s)
	}
}

func (s *AlterProceedToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlterProceedTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlterProceedTo() (localctx IAlterProceedToContext) {
	localctx = NewAlterProceedToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, Cobol85ParserRULE_alterProceedTo)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3778)
		p.ProcedureName()
	}
	{
		p.SetState(3779)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(3782)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPROCEED {
		{
			p.SetState(3780)
			p.Match(Cobol85ParserPROCEED)
		}
		{
			p.SetState(3781)
			p.Match(Cobol85ParserTO)
		}

	}
	{
		p.SetState(3784)
		p.ProcedureName()
	}

	return localctx
}

// ICallStatementContext is an interface to support dynamic dispatch.
type ICallStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallStatementContext differentiates from other interfaces.
	IsCallStatementContext()
}

type CallStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallStatementContext() *CallStatementContext {
	var p = new(CallStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callStatement
	return p
}

func (*CallStatementContext) IsCallStatementContext() {}

func NewCallStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallStatementContext {
	var p = new(CallStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callStatement

	return p
}

func (s *CallStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CallStatementContext) CALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCALL, 0)
}

func (s *CallStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CallStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CallStatementContext) CallUsingPhrase() ICallUsingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallUsingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallUsingPhraseContext)
}

func (s *CallStatementContext) CallGivingPhrase() ICallGivingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallGivingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallGivingPhraseContext)
}

func (s *CallStatementContext) OnOverflowPhrase() IOnOverflowPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnOverflowPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnOverflowPhraseContext)
}

func (s *CallStatementContext) OnExceptionClause() IOnExceptionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnExceptionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnExceptionClauseContext)
}

func (s *CallStatementContext) NotOnExceptionClause() INotOnExceptionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnExceptionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnExceptionClauseContext)
}

func (s *CallStatementContext) END_CALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_CALL, 0)
}

func (s *CallStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallStatement(s)
	}
}

func (s *CallStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallStatement(s)
	}
}

func (s *CallStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallStatement() (localctx ICallStatementContext) {
	localctx = NewCallStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, Cobol85ParserRULE_callStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3786)
		p.Match(Cobol85ParserCALL)
	}
	p.SetState(3789)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 495, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3787)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(3788)
			p.Literal()
		}

	}
	p.SetState(3792)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSING {
		{
			p.SetState(3791)
			p.CallUsingPhrase()
		}

	}
	p.SetState(3795)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGIVING {
		{
			p.SetState(3794)
			p.CallGivingPhrase()
		}

	}
	p.SetState(3798)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 498, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3797)
			p.OnOverflowPhrase()
		}

	}
	p.SetState(3801)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 499, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3800)
			p.OnExceptionClause()
		}

	}
	p.SetState(3804)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 500, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3803)
			p.NotOnExceptionClause()
		}

	}
	p.SetState(3807)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 501, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3806)
			p.Match(Cobol85ParserEND_CALL)
		}

	}

	return localctx
}

// ICallUsingPhraseContext is an interface to support dynamic dispatch.
type ICallUsingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallUsingPhraseContext differentiates from other interfaces.
	IsCallUsingPhraseContext()
}

type CallUsingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallUsingPhraseContext() *CallUsingPhraseContext {
	var p = new(CallUsingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callUsingPhrase
	return p
}

func (*CallUsingPhraseContext) IsCallUsingPhraseContext() {}

func NewCallUsingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallUsingPhraseContext {
	var p = new(CallUsingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callUsingPhrase

	return p
}

func (s *CallUsingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *CallUsingPhraseContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *CallUsingPhraseContext) AllCallUsingParameter() []ICallUsingParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICallUsingParameterContext)(nil)).Elem())
	var tst = make([]ICallUsingParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICallUsingParameterContext)
		}
	}

	return tst
}

func (s *CallUsingPhraseContext) CallUsingParameter(i int) ICallUsingParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallUsingParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICallUsingParameterContext)
}

func (s *CallUsingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallUsingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallUsingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallUsingPhrase(s)
	}
}

func (s *CallUsingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallUsingPhrase(s)
	}
}

func (s *CallUsingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallUsingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallUsingPhrase() (localctx ICallUsingPhraseContext) {
	localctx = NewCallUsingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, Cobol85ParserRULE_callUsingPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3809)
		p.Match(Cobol85ParserUSING)
	}
	p.SetState(3811)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3810)
				p.CallUsingParameter()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3813)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 502, p.GetParserRuleContext())
	}

	return localctx
}

// ICallUsingParameterContext is an interface to support dynamic dispatch.
type ICallUsingParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallUsingParameterContext differentiates from other interfaces.
	IsCallUsingParameterContext()
}

type CallUsingParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallUsingParameterContext() *CallUsingParameterContext {
	var p = new(CallUsingParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callUsingParameter
	return p
}

func (*CallUsingParameterContext) IsCallUsingParameterContext() {}

func NewCallUsingParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallUsingParameterContext {
	var p = new(CallUsingParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callUsingParameter

	return p
}

func (s *CallUsingParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *CallUsingParameterContext) CallByReferencePhrase() ICallByReferencePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallByReferencePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallByReferencePhraseContext)
}

func (s *CallUsingParameterContext) CallByValuePhrase() ICallByValuePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallByValuePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallByValuePhraseContext)
}

func (s *CallUsingParameterContext) CallByContentPhrase() ICallByContentPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallByContentPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallByContentPhraseContext)
}

func (s *CallUsingParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallUsingParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallUsingParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallUsingParameter(s)
	}
}

func (s *CallUsingParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallUsingParameter(s)
	}
}

func (s *CallUsingParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallUsingParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallUsingParameter() (localctx ICallUsingParameterContext) {
	localctx = NewCallUsingParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, Cobol85ParserRULE_callUsingParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3818)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 503, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3815)
			p.CallByReferencePhrase()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3816)
			p.CallByValuePhrase()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3817)
			p.CallByContentPhrase()
		}

	}

	return localctx
}

// ICallByReferencePhraseContext is an interface to support dynamic dispatch.
type ICallByReferencePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByReferencePhraseContext differentiates from other interfaces.
	IsCallByReferencePhraseContext()
}

type CallByReferencePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByReferencePhraseContext() *CallByReferencePhraseContext {
	var p = new(CallByReferencePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByReferencePhrase
	return p
}

func (*CallByReferencePhraseContext) IsCallByReferencePhraseContext() {}

func NewCallByReferencePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByReferencePhraseContext {
	var p = new(CallByReferencePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByReferencePhrase

	return p
}

func (s *CallByReferencePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByReferencePhraseContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREFERENCE, 0)
}

func (s *CallByReferencePhraseContext) AllCallByReference() []ICallByReferenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICallByReferenceContext)(nil)).Elem())
	var tst = make([]ICallByReferenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICallByReferenceContext)
		}
	}

	return tst
}

func (s *CallByReferencePhraseContext) CallByReference(i int) ICallByReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallByReferenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICallByReferenceContext)
}

func (s *CallByReferencePhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *CallByReferencePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByReferencePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByReferencePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByReferencePhrase(s)
	}
}

func (s *CallByReferencePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByReferencePhrase(s)
	}
}

func (s *CallByReferencePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallByReferencePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallByReferencePhrase() (localctx ICallByReferencePhraseContext) {
	localctx = NewCallByReferencePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, Cobol85ParserRULE_callByReferencePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3824)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY || _la == Cobol85ParserREFERENCE {
		p.SetState(3821)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserBY {
			{
				p.SetState(3820)
				p.Match(Cobol85ParserBY)
			}

		}
		{
			p.SetState(3823)
			p.Match(Cobol85ParserREFERENCE)
		}

	}
	p.SetState(3827)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3826)
				p.CallByReference()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3829)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 506, p.GetParserRuleContext())
	}

	return localctx
}

// ICallByReferenceContext is an interface to support dynamic dispatch.
type ICallByReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByReferenceContext differentiates from other interfaces.
	IsCallByReferenceContext()
}

type CallByReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByReferenceContext() *CallByReferenceContext {
	var p = new(CallByReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByReference
	return p
}

func (*CallByReferenceContext) IsCallByReferenceContext() {}

func NewCallByReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByReferenceContext {
	var p = new(CallByReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByReference

	return p
}

func (s *CallByReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByReferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CallByReferenceContext) ADDRESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADDRESS, 0)
}

func (s *CallByReferenceContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *CallByReferenceContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGER, 0)
}

func (s *CallByReferenceContext) STRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTRING, 0)
}

func (s *CallByReferenceContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *CallByReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByReference(s)
	}
}

func (s *CallByReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByReference(s)
	}
}

func (s *CallByReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallByReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallByReference() (localctx ICallByReferenceContext) {
	localctx = NewCallByReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, Cobol85ParserRULE_callByReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3839)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 508, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3835)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 507, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3831)
				p.Match(Cobol85ParserADDRESS)
			}
			{
				p.SetState(3832)
				p.Match(Cobol85ParserOF)
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 507, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3833)
				p.Match(Cobol85ParserINTEGER)
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 507, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(3834)
				p.Match(Cobol85ParserSTRING)
			}

		}
		{
			p.SetState(3837)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3838)
			p.FileName()
		}

	}

	return localctx
}

// ICallByValuePhraseContext is an interface to support dynamic dispatch.
type ICallByValuePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByValuePhraseContext differentiates from other interfaces.
	IsCallByValuePhraseContext()
}

type CallByValuePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByValuePhraseContext() *CallByValuePhraseContext {
	var p = new(CallByValuePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByValuePhrase
	return p
}

func (*CallByValuePhraseContext) IsCallByValuePhraseContext() {}

func NewCallByValuePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByValuePhraseContext {
	var p = new(CallByValuePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByValuePhrase

	return p
}

func (s *CallByValuePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByValuePhraseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUE, 0)
}

func (s *CallByValuePhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *CallByValuePhraseContext) AllCallByValue() []ICallByValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICallByValueContext)(nil)).Elem())
	var tst = make([]ICallByValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICallByValueContext)
		}
	}

	return tst
}

func (s *CallByValuePhraseContext) CallByValue(i int) ICallByValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallByValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICallByValueContext)
}

func (s *CallByValuePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByValuePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByValuePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByValuePhrase(s)
	}
}

func (s *CallByValuePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByValuePhrase(s)
	}
}

func (s *CallByValuePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallByValuePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallByValuePhrase() (localctx ICallByValuePhraseContext) {
	localctx = NewCallByValuePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, Cobol85ParserRULE_callByValuePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3842)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY {
		{
			p.SetState(3841)
			p.Match(Cobol85ParserBY)
		}

	}
	{
		p.SetState(3844)
		p.Match(Cobol85ParserVALUE)
	}
	p.SetState(3846)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3845)
				p.CallByValue()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3848)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 510, p.GetParserRuleContext())
	}

	return localctx
}

// ICallByValueContext is an interface to support dynamic dispatch.
type ICallByValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByValueContext differentiates from other interfaces.
	IsCallByValueContext()
}

type CallByValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByValueContext() *CallByValueContext {
	var p = new(CallByValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByValue
	return p
}

func (*CallByValueContext) IsCallByValueContext() {}

func NewCallByValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByValueContext {
	var p = new(CallByValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByValue

	return p
}

func (s *CallByValueContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByValueContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CallByValueContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CallByValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByValue(s)
	}
}

func (s *CallByValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByValue(s)
	}
}

func (s *CallByValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallByValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallByValue() (localctx ICallByValueContext) {
	localctx = NewCallByValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, Cobol85ParserRULE_callByValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3852)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 511, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3850)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3851)
			p.Literal()
		}

	}

	return localctx
}

// ICallByContentPhraseContext is an interface to support dynamic dispatch.
type ICallByContentPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByContentPhraseContext differentiates from other interfaces.
	IsCallByContentPhraseContext()
}

type CallByContentPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByContentPhraseContext() *CallByContentPhraseContext {
	var p = new(CallByContentPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByContentPhrase
	return p
}

func (*CallByContentPhraseContext) IsCallByContentPhraseContext() {}

func NewCallByContentPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByContentPhraseContext {
	var p = new(CallByContentPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByContentPhrase

	return p
}

func (s *CallByContentPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByContentPhraseContext) CONTENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTENT, 0)
}

func (s *CallByContentPhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *CallByContentPhraseContext) AllCallByContent() []ICallByContentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICallByContentContext)(nil)).Elem())
	var tst = make([]ICallByContentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICallByContentContext)
		}
	}

	return tst
}

func (s *CallByContentPhraseContext) CallByContent(i int) ICallByContentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallByContentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICallByContentContext)
}

func (s *CallByContentPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByContentPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByContentPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByContentPhrase(s)
	}
}

func (s *CallByContentPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByContentPhrase(s)
	}
}

func (s *CallByContentPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallByContentPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallByContentPhrase() (localctx ICallByContentPhraseContext) {
	localctx = NewCallByContentPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, Cobol85ParserRULE_callByContentPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3855)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY {
		{
			p.SetState(3854)
			p.Match(Cobol85ParserBY)
		}

	}
	{
		p.SetState(3857)
		p.Match(Cobol85ParserCONTENT)
	}
	p.SetState(3859)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3858)
				p.CallByContent()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3861)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 513, p.GetParserRuleContext())
	}

	return localctx
}

// ICallByContentContext is an interface to support dynamic dispatch.
type ICallByContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByContentContext differentiates from other interfaces.
	IsCallByContentContext()
}

type CallByContentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByContentContext() *CallByContentContext {
	var p = new(CallByContentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByContent
	return p
}

func (*CallByContentContext) IsCallByContentContext() {}

func NewCallByContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByContentContext {
	var p = new(CallByContentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByContent

	return p
}

func (s *CallByContentContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByContentContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CallByContentContext) ADDRESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADDRESS, 0)
}

func (s *CallByContentContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *CallByContentContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH, 0)
}

func (s *CallByContentContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CallByContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByContent(s)
	}
}

func (s *CallByContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByContent(s)
	}
}

func (s *CallByContentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallByContent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallByContent() (localctx ICallByContentContext) {
	localctx = NewCallByContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, Cobol85ParserRULE_callByContent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3871)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 515, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3867)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 514, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3863)
				p.Match(Cobol85ParserADDRESS)
			}
			{
				p.SetState(3864)
				p.Match(Cobol85ParserOF)
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 514, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3865)
				p.Match(Cobol85ParserLENGTH)
			}
			{
				p.SetState(3866)
				p.Match(Cobol85ParserOF)
			}

		}
		{
			p.SetState(3869)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3870)
			p.Literal()
		}

	}

	return localctx
}

// ICallGivingPhraseContext is an interface to support dynamic dispatch.
type ICallGivingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallGivingPhraseContext differentiates from other interfaces.
	IsCallGivingPhraseContext()
}

type CallGivingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallGivingPhraseContext() *CallGivingPhraseContext {
	var p = new(CallGivingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callGivingPhrase
	return p
}

func (*CallGivingPhraseContext) IsCallGivingPhraseContext() {}

func NewCallGivingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallGivingPhraseContext {
	var p = new(CallGivingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callGivingPhrase

	return p
}

func (s *CallGivingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *CallGivingPhraseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *CallGivingPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CallGivingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallGivingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallGivingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallGivingPhrase(s)
	}
}

func (s *CallGivingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallGivingPhrase(s)
	}
}

func (s *CallGivingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallGivingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallGivingPhrase() (localctx ICallGivingPhraseContext) {
	localctx = NewCallGivingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, Cobol85ParserRULE_callGivingPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3873)
		p.Match(Cobol85ParserGIVING)
	}
	{
		p.SetState(3874)
		p.Identifier()
	}

	return localctx
}

// ICancelStatementContext is an interface to support dynamic dispatch.
type ICancelStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCancelStatementContext differentiates from other interfaces.
	IsCancelStatementContext()
}

type CancelStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelStatementContext() *CancelStatementContext {
	var p = new(CancelStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cancelStatement
	return p
}

func (*CancelStatementContext) IsCancelStatementContext() {}

func NewCancelStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelStatementContext {
	var p = new(CancelStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cancelStatement

	return p
}

func (s *CancelStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCANCEL, 0)
}

func (s *CancelStatementContext) AllCancelCall() []ICancelCallContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICancelCallContext)(nil)).Elem())
	var tst = make([]ICancelCallContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICancelCallContext)
		}
	}

	return tst
}

func (s *CancelStatementContext) CancelCall(i int) ICancelCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICancelCallContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICancelCallContext)
}

func (s *CancelStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCancelStatement(s)
	}
}

func (s *CancelStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCancelStatement(s)
	}
}

func (s *CancelStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCancelStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CancelStatement() (localctx ICancelStatementContext) {
	localctx = NewCancelStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, Cobol85ParserRULE_cancelStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3876)
		p.Match(Cobol85ParserCANCEL)
	}
	p.SetState(3878)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184))|(1<<(Cobol85ParserFALSE-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserHIGH_VALUE-216))|(1<<(Cobol85ParserHIGH_VALUES-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserLOW_VALUE-286))|(1<<(Cobol85ParserLOW_VALUES-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286))|(1<<(Cobol85ParserNULL-286)))) != 0) || (((_la-318)&-(0x1f+1)) == 0 && ((1<<uint((_la-318)))&((1<<(Cobol85ParserNULLS-318))|(1<<(Cobol85ParserNUMERIC_DATE-318))|(1<<(Cobol85ParserNUMERIC_TIME-318))|(1<<(Cobol85ParserODT-318))|(1<<(Cobol85ParserOPTIMIZE-318))|(1<<(Cobol85ParserORDERLY-318))|(1<<(Cobol85ParserOVERLINE-318))|(1<<(Cobol85ParserOWN-318))|(1<<(Cobol85ParserPAGE_COUNTER-318))|(1<<(Cobol85ParserPASSWORD-318)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserQUOTE-357))|(1<<(Cobol85ParserQUOTES-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434))|(1<<(Cobol85ParserSPACE-434))|(1<<(Cobol85ParserSPACES-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUE-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO-502))|(1<<(Cobol85ParserZERO_FILL-502))|(1<<(Cobol85ParserZEROS-502))|(1<<(Cobol85ParserZEROES-502)))) != 0) || (((_la-555)&-(0x1f+1)) == 0 && ((1<<uint((_la-555)))&((1<<(Cobol85ParserNONNUMERICLITERAL-555))|(1<<(Cobol85ParserLEVEL_NUMBER_66-555))|(1<<(Cobol85ParserLEVEL_NUMBER_77-555))|(1<<(Cobol85ParserLEVEL_NUMBER_88-555))|(1<<(Cobol85ParserINTEGERLITERAL-555))|(1<<(Cobol85ParserNUMERICLITERAL-555))|(1<<(Cobol85ParserIDENTIFIER-555)))) != 0) {
		{
			p.SetState(3877)
			p.CancelCall()
		}

		p.SetState(3880)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICancelCallContext is an interface to support dynamic dispatch.
type ICancelCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCancelCallContext differentiates from other interfaces.
	IsCancelCallContext()
}

type CancelCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelCallContext() *CancelCallContext {
	var p = new(CancelCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cancelCall
	return p
}

func (*CancelCallContext) IsCancelCallContext() {}

func NewCancelCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelCallContext {
	var p = new(CancelCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cancelCall

	return p
}

func (s *CancelCallContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelCallContext) LibraryName() ILibraryNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryNameContext)
}

func (s *CancelCallContext) BYTITLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBYTITLE, 0)
}

func (s *CancelCallContext) BYFUNCTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBYFUNCTION, 0)
}

func (s *CancelCallContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelCallContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CancelCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCancelCall(s)
	}
}

func (s *CancelCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCancelCall(s)
	}
}

func (s *CancelCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCancelCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CancelCall() (localctx ICancelCallContext) {
	localctx = NewCancelCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, Cobol85ParserRULE_cancelCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3887)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 517, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3882)
			p.LibraryName()
		}
		p.SetState(3883)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserBYFUNCTION || _la == Cobol85ParserBYTITLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3885)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3886)
			p.Literal()
		}

	}

	return localctx
}

// ICloseStatementContext is an interface to support dynamic dispatch.
type ICloseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCloseStatementContext differentiates from other interfaces.
	IsCloseStatementContext()
}

type CloseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCloseStatementContext() *CloseStatementContext {
	var p = new(CloseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closeStatement
	return p
}

func (*CloseStatementContext) IsCloseStatementContext() {}

func NewCloseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CloseStatementContext {
	var p = new(CloseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closeStatement

	return p
}

func (s *CloseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CloseStatementContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCLOSE, 0)
}

func (s *CloseStatementContext) AllCloseFile() []ICloseFileContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICloseFileContext)(nil)).Elem())
	var tst = make([]ICloseFileContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICloseFileContext)
		}
	}

	return tst
}

func (s *CloseStatementContext) CloseFile(i int) ICloseFileContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICloseFileContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICloseFileContext)
}

func (s *CloseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CloseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCloseStatement(s)
	}
}

func (s *CloseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCloseStatement(s)
	}
}

func (s *CloseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCloseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CloseStatement() (localctx ICloseStatementContext) {
	localctx = NewCloseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, Cobol85ParserRULE_closeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3889)
		p.Match(Cobol85ParserCLOSE)
	}
	p.SetState(3891)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(3890)
			p.CloseFile()
		}

		p.SetState(3893)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICloseFileContext is an interface to support dynamic dispatch.
type ICloseFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCloseFileContext differentiates from other interfaces.
	IsCloseFileContext()
}

type CloseFileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCloseFileContext() *CloseFileContext {
	var p = new(CloseFileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closeFile
	return p
}

func (*CloseFileContext) IsCloseFileContext() {}

func NewCloseFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CloseFileContext {
	var p = new(CloseFileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closeFile

	return p
}

func (s *CloseFileContext) GetParser() antlr.Parser { return s.parser }

func (s *CloseFileContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *CloseFileContext) CloseReelUnitStatement() ICloseReelUnitStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICloseReelUnitStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICloseReelUnitStatementContext)
}

func (s *CloseFileContext) CloseRelativeStatement() ICloseRelativeStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICloseRelativeStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICloseRelativeStatementContext)
}

func (s *CloseFileContext) ClosePortFileIOStatement() IClosePortFileIOStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClosePortFileIOStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClosePortFileIOStatementContext)
}

func (s *CloseFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseFileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CloseFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCloseFile(s)
	}
}

func (s *CloseFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCloseFile(s)
	}
}

func (s *CloseFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCloseFile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CloseFile() (localctx ICloseFileContext) {
	localctx = NewCloseFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, Cobol85ParserRULE_closeFile)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3895)
		p.FileName()
	}
	p.SetState(3899)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 519, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3896)
			p.CloseReelUnitStatement()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 519, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(3897)
			p.CloseRelativeStatement()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 519, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(3898)
			p.ClosePortFileIOStatement()
		}

	}

	return localctx
}

// ICloseReelUnitStatementContext is an interface to support dynamic dispatch.
type ICloseReelUnitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCloseReelUnitStatementContext differentiates from other interfaces.
	IsCloseReelUnitStatementContext()
}

type CloseReelUnitStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCloseReelUnitStatementContext() *CloseReelUnitStatementContext {
	var p = new(CloseReelUnitStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closeReelUnitStatement
	return p
}

func (*CloseReelUnitStatementContext) IsCloseReelUnitStatementContext() {}

func NewCloseReelUnitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CloseReelUnitStatementContext {
	var p = new(CloseReelUnitStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closeReelUnitStatement

	return p
}

func (s *CloseReelUnitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CloseReelUnitStatementContext) REEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREEL, 0)
}

func (s *CloseReelUnitStatementContext) UNIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNIT, 0)
}

func (s *CloseReelUnitStatementContext) REMOVAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOVAL, 0)
}

func (s *CloseReelUnitStatementContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *CloseReelUnitStatementContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *CloseReelUnitStatementContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *CloseReelUnitStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CloseReelUnitStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *CloseReelUnitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseReelUnitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CloseReelUnitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCloseReelUnitStatement(s)
	}
}

func (s *CloseReelUnitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCloseReelUnitStatement(s)
	}
}

func (s *CloseReelUnitStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCloseReelUnitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CloseReelUnitStatement() (localctx ICloseReelUnitStatementContext) {
	localctx = NewCloseReelUnitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, Cobol85ParserRULE_closeReelUnitStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3901)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserREEL || _la == Cobol85ParserUNIT) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(3906)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR || _la == Cobol85ParserREMOVAL {
		p.SetState(3903)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFOR {
			{
				p.SetState(3902)
				p.Match(Cobol85ParserFOR)
			}

		}
		{
			p.SetState(3905)
			p.Match(Cobol85ParserREMOVAL)
		}

	}
	p.SetState(3916)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 524, p.GetParserRuleContext()) == 1 {
		p.SetState(3909)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(3908)
				p.Match(Cobol85ParserWITH)
			}

		}
		p.SetState(3914)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserNO:
			{
				p.SetState(3911)
				p.Match(Cobol85ParserNO)
			}
			{
				p.SetState(3912)
				p.Match(Cobol85ParserREWIND)
			}

		case Cobol85ParserLOCK:
			{
				p.SetState(3913)
				p.Match(Cobol85ParserLOCK)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// ICloseRelativeStatementContext is an interface to support dynamic dispatch.
type ICloseRelativeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCloseRelativeStatementContext differentiates from other interfaces.
	IsCloseRelativeStatementContext()
}

type CloseRelativeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCloseRelativeStatementContext() *CloseRelativeStatementContext {
	var p = new(CloseRelativeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closeRelativeStatement
	return p
}

func (*CloseRelativeStatementContext) IsCloseRelativeStatementContext() {}

func NewCloseRelativeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CloseRelativeStatementContext {
	var p = new(CloseRelativeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closeRelativeStatement

	return p
}

func (s *CloseRelativeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CloseRelativeStatementContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *CloseRelativeStatementContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *CloseRelativeStatementContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *CloseRelativeStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *CloseRelativeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseRelativeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CloseRelativeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCloseRelativeStatement(s)
	}
}

func (s *CloseRelativeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCloseRelativeStatement(s)
	}
}

func (s *CloseRelativeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCloseRelativeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CloseRelativeStatement() (localctx ICloseRelativeStatementContext) {
	localctx = NewCloseRelativeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, Cobol85ParserRULE_closeRelativeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3919)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(3918)
			p.Match(Cobol85ParserWITH)
		}

	}
	p.SetState(3924)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNO:
		{
			p.SetState(3921)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(3922)
			p.Match(Cobol85ParserREWIND)
		}

	case Cobol85ParserLOCK:
		{
			p.SetState(3923)
			p.Match(Cobol85ParserLOCK)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClosePortFileIOStatementContext is an interface to support dynamic dispatch.
type IClosePortFileIOStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosePortFileIOStatementContext differentiates from other interfaces.
	IsClosePortFileIOStatementContext()
}

type ClosePortFileIOStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosePortFileIOStatementContext() *ClosePortFileIOStatementContext {
	var p = new(ClosePortFileIOStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOStatement
	return p
}

func (*ClosePortFileIOStatementContext) IsClosePortFileIOStatementContext() {}

func NewClosePortFileIOStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosePortFileIOStatementContext {
	var p = new(ClosePortFileIOStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOStatement

	return p
}

func (s *ClosePortFileIOStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosePortFileIOStatementContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *ClosePortFileIOStatementContext) WAIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWAIT, 0)
}

func (s *ClosePortFileIOStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *ClosePortFileIOStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *ClosePortFileIOStatementContext) AllClosePortFileIOUsing() []IClosePortFileIOUsingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClosePortFileIOUsingContext)(nil)).Elem())
	var tst = make([]IClosePortFileIOUsingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClosePortFileIOUsingContext)
		}
	}

	return tst
}

func (s *ClosePortFileIOStatementContext) ClosePortFileIOUsing(i int) IClosePortFileIOUsingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClosePortFileIOUsingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClosePortFileIOUsingContext)
}

func (s *ClosePortFileIOStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosePortFileIOStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosePortFileIOStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClosePortFileIOStatement(s)
	}
}

func (s *ClosePortFileIOStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClosePortFileIOStatement(s)
	}
}

func (s *ClosePortFileIOStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClosePortFileIOStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClosePortFileIOStatement() (localctx IClosePortFileIOStatementContext) {
	localctx = NewClosePortFileIOStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, Cobol85ParserRULE_closePortFileIOStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3933)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 528, p.GetParserRuleContext()) {
	case 1:
		p.SetState(3927)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(3926)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(3929)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(3930)
			p.Match(Cobol85ParserWAIT)
		}

	case 2:
		{
			p.SetState(3931)
			p.Match(Cobol85ParserWITH)
		}
		{
			p.SetState(3932)
			p.Match(Cobol85ParserWAIT)
		}

	}
	p.SetState(3941)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSING {
		{
			p.SetState(3935)
			p.Match(Cobol85ParserUSING)
		}
		p.SetState(3937)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(3936)
					p.ClosePortFileIOUsing()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(3939)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 529, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IClosePortFileIOUsingContext is an interface to support dynamic dispatch.
type IClosePortFileIOUsingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosePortFileIOUsingContext differentiates from other interfaces.
	IsClosePortFileIOUsingContext()
}

type ClosePortFileIOUsingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosePortFileIOUsingContext() *ClosePortFileIOUsingContext {
	var p = new(ClosePortFileIOUsingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsing
	return p
}

func (*ClosePortFileIOUsingContext) IsClosePortFileIOUsingContext() {}

func NewClosePortFileIOUsingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosePortFileIOUsingContext {
	var p = new(ClosePortFileIOUsingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsing

	return p
}

func (s *ClosePortFileIOUsingContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosePortFileIOUsingContext) ClosePortFileIOUsingCloseDisposition() IClosePortFileIOUsingCloseDispositionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClosePortFileIOUsingCloseDispositionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClosePortFileIOUsingCloseDispositionContext)
}

func (s *ClosePortFileIOUsingContext) ClosePortFileIOUsingAssociatedData() IClosePortFileIOUsingAssociatedDataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClosePortFileIOUsingAssociatedDataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClosePortFileIOUsingAssociatedDataContext)
}

func (s *ClosePortFileIOUsingContext) ClosePortFileIOUsingAssociatedDataLength() IClosePortFileIOUsingAssociatedDataLengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClosePortFileIOUsingAssociatedDataLengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClosePortFileIOUsingAssociatedDataLengthContext)
}

func (s *ClosePortFileIOUsingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosePortFileIOUsingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosePortFileIOUsingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClosePortFileIOUsing(s)
	}
}

func (s *ClosePortFileIOUsingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClosePortFileIOUsing(s)
	}
}

func (s *ClosePortFileIOUsingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClosePortFileIOUsing(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClosePortFileIOUsing() (localctx IClosePortFileIOUsingContext) {
	localctx = NewClosePortFileIOUsingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, Cobol85ParserRULE_closePortFileIOUsing)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3946)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserCLOSE_DISPOSITION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3943)
			p.ClosePortFileIOUsingCloseDisposition()
		}

	case Cobol85ParserASSOCIATED_DATA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3944)
			p.ClosePortFileIOUsingAssociatedData()
		}

	case Cobol85ParserASSOCIATED_DATA_LENGTH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3945)
			p.ClosePortFileIOUsingAssociatedDataLength()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClosePortFileIOUsingCloseDispositionContext is an interface to support dynamic dispatch.
type IClosePortFileIOUsingCloseDispositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosePortFileIOUsingCloseDispositionContext differentiates from other interfaces.
	IsClosePortFileIOUsingCloseDispositionContext()
}

type ClosePortFileIOUsingCloseDispositionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosePortFileIOUsingCloseDispositionContext() *ClosePortFileIOUsingCloseDispositionContext {
	var p = new(ClosePortFileIOUsingCloseDispositionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingCloseDisposition
	return p
}

func (*ClosePortFileIOUsingCloseDispositionContext) IsClosePortFileIOUsingCloseDispositionContext() {}

func NewClosePortFileIOUsingCloseDispositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosePortFileIOUsingCloseDispositionContext {
	var p = new(ClosePortFileIOUsingCloseDispositionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingCloseDisposition

	return p
}

func (s *ClosePortFileIOUsingCloseDispositionContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosePortFileIOUsingCloseDispositionContext) CLOSE_DISPOSITION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCLOSE_DISPOSITION, 0)
}

func (s *ClosePortFileIOUsingCloseDispositionContext) ABORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserABORT, 0)
}

func (s *ClosePortFileIOUsingCloseDispositionContext) ORDERLY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserORDERLY, 0)
}

func (s *ClosePortFileIOUsingCloseDispositionContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *ClosePortFileIOUsingCloseDispositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosePortFileIOUsingCloseDispositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosePortFileIOUsingCloseDispositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClosePortFileIOUsingCloseDisposition(s)
	}
}

func (s *ClosePortFileIOUsingCloseDispositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClosePortFileIOUsingCloseDisposition(s)
	}
}

func (s *ClosePortFileIOUsingCloseDispositionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClosePortFileIOUsingCloseDisposition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClosePortFileIOUsingCloseDisposition() (localctx IClosePortFileIOUsingCloseDispositionContext) {
	localctx = NewClosePortFileIOUsingCloseDispositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, Cobol85ParserRULE_closePortFileIOUsingCloseDisposition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3948)
		p.Match(Cobol85ParserCLOSE_DISPOSITION)
	}
	p.SetState(3950)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOF {
		{
			p.SetState(3949)
			p.Match(Cobol85ParserOF)
		}

	}
	p.SetState(3952)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserABORT || _la == Cobol85ParserORDERLY) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IClosePortFileIOUsingAssociatedDataContext is an interface to support dynamic dispatch.
type IClosePortFileIOUsingAssociatedDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosePortFileIOUsingAssociatedDataContext differentiates from other interfaces.
	IsClosePortFileIOUsingAssociatedDataContext()
}

type ClosePortFileIOUsingAssociatedDataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosePortFileIOUsingAssociatedDataContext() *ClosePortFileIOUsingAssociatedDataContext {
	var p = new(ClosePortFileIOUsingAssociatedDataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingAssociatedData
	return p
}

func (*ClosePortFileIOUsingAssociatedDataContext) IsClosePortFileIOUsingAssociatedDataContext() {}

func NewClosePortFileIOUsingAssociatedDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosePortFileIOUsingAssociatedDataContext {
	var p = new(ClosePortFileIOUsingAssociatedDataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingAssociatedData

	return p
}

func (s *ClosePortFileIOUsingAssociatedDataContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosePortFileIOUsingAssociatedDataContext) ASSOCIATED_DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASSOCIATED_DATA, 0)
}

func (s *ClosePortFileIOUsingAssociatedDataContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClosePortFileIOUsingAssociatedDataContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ClosePortFileIOUsingAssociatedDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosePortFileIOUsingAssociatedDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosePortFileIOUsingAssociatedDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClosePortFileIOUsingAssociatedData(s)
	}
}

func (s *ClosePortFileIOUsingAssociatedDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClosePortFileIOUsingAssociatedData(s)
	}
}

func (s *ClosePortFileIOUsingAssociatedDataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClosePortFileIOUsingAssociatedData(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClosePortFileIOUsingAssociatedData() (localctx IClosePortFileIOUsingAssociatedDataContext) {
	localctx = NewClosePortFileIOUsingAssociatedDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, Cobol85ParserRULE_closePortFileIOUsingAssociatedData)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3954)
		p.Match(Cobol85ParserASSOCIATED_DATA)
	}
	p.SetState(3957)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 533, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3955)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(3956)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IClosePortFileIOUsingAssociatedDataLengthContext is an interface to support dynamic dispatch.
type IClosePortFileIOUsingAssociatedDataLengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosePortFileIOUsingAssociatedDataLengthContext differentiates from other interfaces.
	IsClosePortFileIOUsingAssociatedDataLengthContext()
}

type ClosePortFileIOUsingAssociatedDataLengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosePortFileIOUsingAssociatedDataLengthContext() *ClosePortFileIOUsingAssociatedDataLengthContext {
	var p = new(ClosePortFileIOUsingAssociatedDataLengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingAssociatedDataLength
	return p
}

func (*ClosePortFileIOUsingAssociatedDataLengthContext) IsClosePortFileIOUsingAssociatedDataLengthContext() {
}

func NewClosePortFileIOUsingAssociatedDataLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosePortFileIOUsingAssociatedDataLengthContext {
	var p = new(ClosePortFileIOUsingAssociatedDataLengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingAssociatedDataLength

	return p
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) ASSOCIATED_DATA_LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASSOCIATED_DATA_LENGTH, 0)
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClosePortFileIOUsingAssociatedDataLength(s)
	}
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClosePortFileIOUsingAssociatedDataLength(s)
	}
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClosePortFileIOUsingAssociatedDataLength(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClosePortFileIOUsingAssociatedDataLength() (localctx IClosePortFileIOUsingAssociatedDataLengthContext) {
	localctx = NewClosePortFileIOUsingAssociatedDataLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, Cobol85ParserRULE_closePortFileIOUsingAssociatedDataLength)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3959)
		p.Match(Cobol85ParserASSOCIATED_DATA_LENGTH)
	}
	p.SetState(3961)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOF {
		{
			p.SetState(3960)
			p.Match(Cobol85ParserOF)
		}

	}
	p.SetState(3965)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 535, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3963)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(3964)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IComputeStatementContext is an interface to support dynamic dispatch.
type IComputeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComputeStatementContext differentiates from other interfaces.
	IsComputeStatementContext()
}

type ComputeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComputeStatementContext() *ComputeStatementContext {
	var p = new(ComputeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_computeStatement
	return p
}

func (*ComputeStatementContext) IsComputeStatementContext() {}

func NewComputeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComputeStatementContext {
	var p = new(ComputeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_computeStatement

	return p
}

func (s *ComputeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ComputeStatementContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTE, 0)
}

func (s *ComputeStatementContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *ComputeStatementContext) EQUALCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUALCHAR, 0)
}

func (s *ComputeStatementContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUAL, 0)
}

func (s *ComputeStatementContext) AllComputeStore() []IComputeStoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComputeStoreContext)(nil)).Elem())
	var tst = make([]IComputeStoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComputeStoreContext)
		}
	}

	return tst
}

func (s *ComputeStatementContext) ComputeStore(i int) IComputeStoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputeStoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComputeStoreContext)
}

func (s *ComputeStatementContext) OnSizeErrorPhrase() IOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnSizeErrorPhraseContext)
}

func (s *ComputeStatementContext) NotOnSizeErrorPhrase() INotOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnSizeErrorPhraseContext)
}

func (s *ComputeStatementContext) END_COMPUTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_COMPUTE, 0)
}

func (s *ComputeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComputeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterComputeStatement(s)
	}
}

func (s *ComputeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitComputeStatement(s)
	}
}

func (s *ComputeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitComputeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ComputeStatement() (localctx IComputeStatementContext) {
	localctx = NewComputeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, Cobol85ParserRULE_computeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3967)
		p.Match(Cobol85ParserCOMPUTE)
	}
	p.SetState(3969)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(3968)
			p.ComputeStore()
		}

		p.SetState(3971)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3973)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserEQUAL || _la == Cobol85ParserEQUALCHAR) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(3974)
		p.ArithmeticExpression()
	}
	p.SetState(3976)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 537, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3975)
			p.OnSizeErrorPhrase()
		}

	}
	p.SetState(3979)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 538, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3978)
			p.NotOnSizeErrorPhrase()
		}

	}
	p.SetState(3982)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 539, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3981)
			p.Match(Cobol85ParserEND_COMPUTE)
		}

	}

	return localctx
}

// IComputeStoreContext is an interface to support dynamic dispatch.
type IComputeStoreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComputeStoreContext differentiates from other interfaces.
	IsComputeStoreContext()
}

type ComputeStoreContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComputeStoreContext() *ComputeStoreContext {
	var p = new(ComputeStoreContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_computeStore
	return p
}

func (*ComputeStoreContext) IsComputeStoreContext() {}

func NewComputeStoreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComputeStoreContext {
	var p = new(ComputeStoreContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_computeStore

	return p
}

func (s *ComputeStoreContext) GetParser() antlr.Parser { return s.parser }

func (s *ComputeStoreContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ComputeStoreContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *ComputeStoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputeStoreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComputeStoreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterComputeStore(s)
	}
}

func (s *ComputeStoreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitComputeStore(s)
	}
}

func (s *ComputeStoreContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitComputeStore(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ComputeStore() (localctx IComputeStoreContext) {
	localctx = NewComputeStoreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, Cobol85ParserRULE_computeStore)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3984)
		p.Identifier()
	}
	p.SetState(3986)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(3985)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTINUE, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (s *ContinueStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitContinueStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, Cobol85ParserRULE_continueStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3988)
		p.Match(Cobol85ParserCONTINUE)
	}

	return localctx
}

// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_deleteStatement
	return p
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDELETE, 0)
}

func (s *DeleteStatementContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *DeleteStatementContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *DeleteStatementContext) InvalidKeyPhrase() IInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvalidKeyPhraseContext)
}

func (s *DeleteStatementContext) NotInvalidKeyPhrase() INotInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotInvalidKeyPhraseContext)
}

func (s *DeleteStatementContext) END_DELETE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_DELETE, 0)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DeleteStatement() (localctx IDeleteStatementContext) {
	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, Cobol85ParserRULE_deleteStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3990)
		p.Match(Cobol85ParserDELETE)
	}
	{
		p.SetState(3991)
		p.FileName()
	}
	p.SetState(3993)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRECORD {
		{
			p.SetState(3992)
			p.Match(Cobol85ParserRECORD)
		}

	}
	p.SetState(3996)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 542, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3995)
			p.InvalidKeyPhrase()
		}

	}
	p.SetState(3999)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 543, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3998)
			p.NotInvalidKeyPhrase()
		}

	}
	p.SetState(4002)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 544, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4001)
			p.Match(Cobol85ParserEND_DELETE)
		}

	}

	return localctx
}

// IDisableStatementContext is an interface to support dynamic dispatch.
type IDisableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisableStatementContext differentiates from other interfaces.
	IsDisableStatementContext()
}

type DisableStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisableStatementContext() *DisableStatementContext {
	var p = new(DisableStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_disableStatement
	return p
}

func (*DisableStatementContext) IsDisableStatementContext() {}

func NewDisableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisableStatementContext {
	var p = new(DisableStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_disableStatement

	return p
}

func (s *DisableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DisableStatementContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISABLE, 0)
}

func (s *DisableStatementContext) CdName() ICdNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICdNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *DisableStatementContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *DisableStatementContext) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *DisableStatementContext) I_O() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O, 0)
}

func (s *DisableStatementContext) TERMINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTERMINAL, 0)
}

func (s *DisableStatementContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *DisableStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DisableStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DisableStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *DisableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisableStatement(s)
	}
}

func (s *DisableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisableStatement(s)
	}
}

func (s *DisableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDisableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DisableStatement() (localctx IDisableStatementContext) {
	localctx = NewDisableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, Cobol85ParserRULE_disableStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4004)
		p.Match(Cobol85ParserDISABLE)
	}
	p.SetState(4012)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserINPUT:
		{
			p.SetState(4005)
			p.Match(Cobol85ParserINPUT)
		}
		p.SetState(4007)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTERMINAL {
			{
				p.SetState(4006)
				p.Match(Cobol85ParserTERMINAL)
			}

		}

	case Cobol85ParserI_O:
		{
			p.SetState(4009)
			p.Match(Cobol85ParserI_O)
		}
		{
			p.SetState(4010)
			p.Match(Cobol85ParserTERMINAL)
		}

	case Cobol85ParserOUTPUT:
		{
			p.SetState(4011)
			p.Match(Cobol85ParserOUTPUT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(4014)
		p.CdName()
	}
	p.SetState(4016)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4015)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(4018)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(4021)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 548, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4019)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4020)
			p.Literal()
		}

	}

	return localctx
}

// IDisplayStatementContext is an interface to support dynamic dispatch.
type IDisplayStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplayStatementContext differentiates from other interfaces.
	IsDisplayStatementContext()
}

type DisplayStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayStatementContext() *DisplayStatementContext {
	var p = new(DisplayStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_displayStatement
	return p
}

func (*DisplayStatementContext) IsDisplayStatementContext() {}

func NewDisplayStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayStatementContext {
	var p = new(DisplayStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_displayStatement

	return p
}

func (s *DisplayStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayStatementContext) DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY, 0)
}

func (s *DisplayStatementContext) AllDisplayOperand() []IDisplayOperandContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDisplayOperandContext)(nil)).Elem())
	var tst = make([]IDisplayOperandContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDisplayOperandContext)
		}
	}

	return tst
}

func (s *DisplayStatementContext) DisplayOperand(i int) IDisplayOperandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisplayOperandContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDisplayOperandContext)
}

func (s *DisplayStatementContext) DisplayAt() IDisplayAtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisplayAtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisplayAtContext)
}

func (s *DisplayStatementContext) DisplayUpon() IDisplayUponContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisplayUponContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisplayUponContext)
}

func (s *DisplayStatementContext) DisplayWith() IDisplayWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisplayWithContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisplayWithContext)
}

func (s *DisplayStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisplayStatement(s)
	}
}

func (s *DisplayStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisplayStatement(s)
	}
}

func (s *DisplayStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDisplayStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DisplayStatement() (localctx IDisplayStatementContext) {
	localctx = NewDisplayStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, Cobol85ParserRULE_displayStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4023)
		p.Match(Cobol85ParserDISPLAY)
	}
	p.SetState(4025)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184))|(1<<(Cobol85ParserFALSE-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserHIGH_VALUE-216))|(1<<(Cobol85ParserHIGH_VALUES-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserLOW_VALUE-286))|(1<<(Cobol85ParserLOW_VALUES-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286))|(1<<(Cobol85ParserNULL-286)))) != 0) || (((_la-318)&-(0x1f+1)) == 0 && ((1<<uint((_la-318)))&((1<<(Cobol85ParserNULLS-318))|(1<<(Cobol85ParserNUMERIC_DATE-318))|(1<<(Cobol85ParserNUMERIC_TIME-318))|(1<<(Cobol85ParserODT-318))|(1<<(Cobol85ParserOPTIMIZE-318))|(1<<(Cobol85ParserORDERLY-318))|(1<<(Cobol85ParserOVERLINE-318))|(1<<(Cobol85ParserOWN-318))|(1<<(Cobol85ParserPAGE_COUNTER-318))|(1<<(Cobol85ParserPASSWORD-318)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserQUOTE-357))|(1<<(Cobol85ParserQUOTES-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434))|(1<<(Cobol85ParserSPACE-434))|(1<<(Cobol85ParserSPACES-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUE-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO-502))|(1<<(Cobol85ParserZERO_FILL-502))|(1<<(Cobol85ParserZEROS-502))|(1<<(Cobol85ParserZEROES-502)))) != 0) || (((_la-555)&-(0x1f+1)) == 0 && ((1<<uint((_la-555)))&((1<<(Cobol85ParserNONNUMERICLITERAL-555))|(1<<(Cobol85ParserLEVEL_NUMBER_66-555))|(1<<(Cobol85ParserLEVEL_NUMBER_77-555))|(1<<(Cobol85ParserLEVEL_NUMBER_88-555))|(1<<(Cobol85ParserINTEGERLITERAL-555))|(1<<(Cobol85ParserNUMERICLITERAL-555))|(1<<(Cobol85ParserIDENTIFIER-555)))) != 0) {
		{
			p.SetState(4024)
			p.DisplayOperand()
		}

		p.SetState(4027)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4030)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 550, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4029)
			p.DisplayAt()
		}

	}
	p.SetState(4033)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUPON {
		{
			p.SetState(4032)
			p.DisplayUpon()
		}

	}
	p.SetState(4036)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 552, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4035)
			p.DisplayWith()
		}

	}

	return localctx
}

// IDisplayOperandContext is an interface to support dynamic dispatch.
type IDisplayOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplayOperandContext differentiates from other interfaces.
	IsDisplayOperandContext()
}

type DisplayOperandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayOperandContext() *DisplayOperandContext {
	var p = new(DisplayOperandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_displayOperand
	return p
}

func (*DisplayOperandContext) IsDisplayOperandContext() {}

func NewDisplayOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayOperandContext {
	var p = new(DisplayOperandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_displayOperand

	return p
}

func (s *DisplayOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayOperandContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DisplayOperandContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DisplayOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisplayOperand(s)
	}
}

func (s *DisplayOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisplayOperand(s)
	}
}

func (s *DisplayOperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDisplayOperand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DisplayOperand() (localctx IDisplayOperandContext) {
	localctx = NewDisplayOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, Cobol85ParserRULE_displayOperand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4040)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 553, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4038)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4039)
			p.Literal()
		}

	}

	return localctx
}

// IDisplayAtContext is an interface to support dynamic dispatch.
type IDisplayAtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplayAtContext differentiates from other interfaces.
	IsDisplayAtContext()
}

type DisplayAtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayAtContext() *DisplayAtContext {
	var p = new(DisplayAtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_displayAt
	return p
}

func (*DisplayAtContext) IsDisplayAtContext() {}

func NewDisplayAtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayAtContext {
	var p = new(DisplayAtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_displayAt

	return p
}

func (s *DisplayAtContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayAtContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *DisplayAtContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DisplayAtContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DisplayAtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayAtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayAtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisplayAt(s)
	}
}

func (s *DisplayAtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisplayAt(s)
	}
}

func (s *DisplayAtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDisplayAt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DisplayAt() (localctx IDisplayAtContext) {
	localctx = NewDisplayAtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, Cobol85ParserRULE_displayAt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4042)
		p.Match(Cobol85ParserAT)
	}
	p.SetState(4045)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 554, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4043)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4044)
			p.Literal()
		}

	}

	return localctx
}

// IDisplayUponContext is an interface to support dynamic dispatch.
type IDisplayUponContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplayUponContext differentiates from other interfaces.
	IsDisplayUponContext()
}

type DisplayUponContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayUponContext() *DisplayUponContext {
	var p = new(DisplayUponContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_displayUpon
	return p
}

func (*DisplayUponContext) IsDisplayUponContext() {}

func NewDisplayUponContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayUponContext {
	var p = new(DisplayUponContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_displayUpon

	return p
}

func (s *DisplayUponContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayUponContext) UPON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUPON, 0)
}

func (s *DisplayUponContext) MnemonicName() IMnemonicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMnemonicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *DisplayUponContext) EnvironmentName() IEnvironmentNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnvironmentNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnvironmentNameContext)
}

func (s *DisplayUponContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayUponContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayUponContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisplayUpon(s)
	}
}

func (s *DisplayUponContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisplayUpon(s)
	}
}

func (s *DisplayUponContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDisplayUpon(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DisplayUpon() (localctx IDisplayUponContext) {
	localctx = NewDisplayUponContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, Cobol85ParserRULE_displayUpon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4047)
		p.Match(Cobol85ParserUPON)
	}
	p.SetState(4050)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 555, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4048)
			p.MnemonicName()
		}

	case 2:
		{
			p.SetState(4049)
			p.EnvironmentName()
		}

	}

	return localctx
}

// IDisplayWithContext is an interface to support dynamic dispatch.
type IDisplayWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplayWithContext differentiates from other interfaces.
	IsDisplayWithContext()
}

type DisplayWithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayWithContext() *DisplayWithContext {
	var p = new(DisplayWithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_displayWith
	return p
}

func (*DisplayWithContext) IsDisplayWithContext() {}

func NewDisplayWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayWithContext {
	var p = new(DisplayWithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_displayWith

	return p
}

func (s *DisplayWithContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayWithContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *DisplayWithContext) ADVANCING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADVANCING, 0)
}

func (s *DisplayWithContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *DisplayWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisplayWith(s)
	}
}

func (s *DisplayWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisplayWith(s)
	}
}

func (s *DisplayWithContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDisplayWith(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DisplayWith() (localctx IDisplayWithContext) {
	localctx = NewDisplayWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, Cobol85ParserRULE_displayWith)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4053)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4052)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(4055)
		p.Match(Cobol85ParserNO)
	}
	{
		p.SetState(4056)
		p.Match(Cobol85ParserADVANCING)
	}

	return localctx
}

// IDivideStatementContext is an interface to support dynamic dispatch.
type IDivideStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideStatementContext differentiates from other interfaces.
	IsDivideStatementContext()
}

type DivideStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideStatementContext() *DivideStatementContext {
	var p = new(DivideStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideStatement
	return p
}

func (*DivideStatementContext) IsDivideStatementContext() {}

func NewDivideStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideStatementContext {
	var p = new(DivideStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideStatement

	return p
}

func (s *DivideStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideStatementContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDIVIDE, 0)
}

func (s *DivideStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DivideStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DivideStatementContext) DivideIntoStatement() IDivideIntoStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideIntoStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDivideIntoStatementContext)
}

func (s *DivideStatementContext) DivideIntoGivingStatement() IDivideIntoGivingStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideIntoGivingStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDivideIntoGivingStatementContext)
}

func (s *DivideStatementContext) DivideByGivingStatement() IDivideByGivingStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideByGivingStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDivideByGivingStatementContext)
}

func (s *DivideStatementContext) DivideRemainder() IDivideRemainderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideRemainderContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDivideRemainderContext)
}

func (s *DivideStatementContext) OnSizeErrorPhrase() IOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnSizeErrorPhraseContext)
}

func (s *DivideStatementContext) NotOnSizeErrorPhrase() INotOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnSizeErrorPhraseContext)
}

func (s *DivideStatementContext) END_DIVIDE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_DIVIDE, 0)
}

func (s *DivideStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideStatement(s)
	}
}

func (s *DivideStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideStatement(s)
	}
}

func (s *DivideStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDivideStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DivideStatement() (localctx IDivideStatementContext) {
	localctx = NewDivideStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, Cobol85ParserRULE_divideStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4058)
		p.Match(Cobol85ParserDIVIDE)
	}
	p.SetState(4061)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 557, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4059)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4060)
			p.Literal()
		}

	}
	p.SetState(4066)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 558, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4063)
			p.DivideIntoStatement()
		}

	case 2:
		{
			p.SetState(4064)
			p.DivideIntoGivingStatement()
		}

	case 3:
		{
			p.SetState(4065)
			p.DivideByGivingStatement()
		}

	}
	p.SetState(4069)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserREMAINDER {
		{
			p.SetState(4068)
			p.DivideRemainder()
		}

	}
	p.SetState(4072)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 560, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4071)
			p.OnSizeErrorPhrase()
		}

	}
	p.SetState(4075)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 561, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4074)
			p.NotOnSizeErrorPhrase()
		}

	}
	p.SetState(4078)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 562, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4077)
			p.Match(Cobol85ParserEND_DIVIDE)
		}

	}

	return localctx
}

// IDivideIntoStatementContext is an interface to support dynamic dispatch.
type IDivideIntoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideIntoStatementContext differentiates from other interfaces.
	IsDivideIntoStatementContext()
}

type DivideIntoStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideIntoStatementContext() *DivideIntoStatementContext {
	var p = new(DivideIntoStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideIntoStatement
	return p
}

func (*DivideIntoStatementContext) IsDivideIntoStatementContext() {}

func NewDivideIntoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideIntoStatementContext {
	var p = new(DivideIntoStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideIntoStatement

	return p
}

func (s *DivideIntoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideIntoStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *DivideIntoStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DivideIntoStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DivideIntoStatementContext) DivideGivingPhrase() IDivideGivingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideGivingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDivideGivingPhraseContext)
}

func (s *DivideIntoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideIntoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideIntoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideIntoStatement(s)
	}
}

func (s *DivideIntoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideIntoStatement(s)
	}
}

func (s *DivideIntoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDivideIntoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DivideIntoStatement() (localctx IDivideIntoStatementContext) {
	localctx = NewDivideIntoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, Cobol85ParserRULE_divideIntoStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4080)
		p.Match(Cobol85ParserINTO)
	}
	p.SetState(4083)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 563, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4081)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4082)
			p.Literal()
		}

	}
	p.SetState(4086)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGIVING {
		{
			p.SetState(4085)
			p.DivideGivingPhrase()
		}

	}

	return localctx
}

// IDivideIntoGivingStatementContext is an interface to support dynamic dispatch.
type IDivideIntoGivingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideIntoGivingStatementContext differentiates from other interfaces.
	IsDivideIntoGivingStatementContext()
}

type DivideIntoGivingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideIntoGivingStatementContext() *DivideIntoGivingStatementContext {
	var p = new(DivideIntoGivingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideIntoGivingStatement
	return p
}

func (*DivideIntoGivingStatementContext) IsDivideIntoGivingStatementContext() {}

func NewDivideIntoGivingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideIntoGivingStatementContext {
	var p = new(DivideIntoGivingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideIntoGivingStatement

	return p
}

func (s *DivideIntoGivingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideIntoGivingStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *DivideIntoGivingStatementContext) AllDivideGiving() []IDivideGivingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDivideGivingContext)(nil)).Elem())
	var tst = make([]IDivideGivingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDivideGivingContext)
		}
	}

	return tst
}

func (s *DivideIntoGivingStatementContext) DivideGiving(i int) IDivideGivingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideGivingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDivideGivingContext)
}

func (s *DivideIntoGivingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideIntoGivingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideIntoGivingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideIntoGivingStatement(s)
	}
}

func (s *DivideIntoGivingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideIntoGivingStatement(s)
	}
}

func (s *DivideIntoGivingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDivideIntoGivingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DivideIntoGivingStatement() (localctx IDivideIntoGivingStatementContext) {
	localctx = NewDivideIntoGivingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, Cobol85ParserRULE_divideIntoGivingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4088)
		p.Match(Cobol85ParserINTO)
	}
	p.SetState(4090)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(4089)
			p.DivideGiving()
		}

		p.SetState(4092)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDivideByGivingStatementContext is an interface to support dynamic dispatch.
type IDivideByGivingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideByGivingStatementContext differentiates from other interfaces.
	IsDivideByGivingStatementContext()
}

type DivideByGivingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideByGivingStatementContext() *DivideByGivingStatementContext {
	var p = new(DivideByGivingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideByGivingStatement
	return p
}

func (*DivideByGivingStatementContext) IsDivideByGivingStatementContext() {}

func NewDivideByGivingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideByGivingStatementContext {
	var p = new(DivideByGivingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideByGivingStatement

	return p
}

func (s *DivideByGivingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideByGivingStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *DivideByGivingStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DivideByGivingStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DivideByGivingStatementContext) DivideGivingPhrase() IDivideGivingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideGivingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDivideGivingPhraseContext)
}

func (s *DivideByGivingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideByGivingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideByGivingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideByGivingStatement(s)
	}
}

func (s *DivideByGivingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideByGivingStatement(s)
	}
}

func (s *DivideByGivingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDivideByGivingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DivideByGivingStatement() (localctx IDivideByGivingStatementContext) {
	localctx = NewDivideByGivingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, Cobol85ParserRULE_divideByGivingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4094)
		p.Match(Cobol85ParserBY)
	}
	p.SetState(4097)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 566, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4095)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4096)
			p.Literal()
		}

	}
	p.SetState(4100)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGIVING {
		{
			p.SetState(4099)
			p.DivideGivingPhrase()
		}

	}

	return localctx
}

// IDivideGivingPhraseContext is an interface to support dynamic dispatch.
type IDivideGivingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideGivingPhraseContext differentiates from other interfaces.
	IsDivideGivingPhraseContext()
}

type DivideGivingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideGivingPhraseContext() *DivideGivingPhraseContext {
	var p = new(DivideGivingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideGivingPhrase
	return p
}

func (*DivideGivingPhraseContext) IsDivideGivingPhraseContext() {}

func NewDivideGivingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideGivingPhraseContext {
	var p = new(DivideGivingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideGivingPhrase

	return p
}

func (s *DivideGivingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideGivingPhraseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *DivideGivingPhraseContext) AllDivideGiving() []IDivideGivingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDivideGivingContext)(nil)).Elem())
	var tst = make([]IDivideGivingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDivideGivingContext)
		}
	}

	return tst
}

func (s *DivideGivingPhraseContext) DivideGiving(i int) IDivideGivingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideGivingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDivideGivingContext)
}

func (s *DivideGivingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideGivingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideGivingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideGivingPhrase(s)
	}
}

func (s *DivideGivingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideGivingPhrase(s)
	}
}

func (s *DivideGivingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDivideGivingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DivideGivingPhrase() (localctx IDivideGivingPhraseContext) {
	localctx = NewDivideGivingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, Cobol85ParserRULE_divideGivingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4102)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(4104)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(4103)
			p.DivideGiving()
		}

		p.SetState(4106)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDivideGivingContext is an interface to support dynamic dispatch.
type IDivideGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideGivingContext differentiates from other interfaces.
	IsDivideGivingContext()
}

type DivideGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideGivingContext() *DivideGivingContext {
	var p = new(DivideGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideGiving
	return p
}

func (*DivideGivingContext) IsDivideGivingContext() {}

func NewDivideGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideGivingContext {
	var p = new(DivideGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideGiving

	return p
}

func (s *DivideGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideGivingContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DivideGivingContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *DivideGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideGiving(s)
	}
}

func (s *DivideGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideGiving(s)
	}
}

func (s *DivideGivingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDivideGiving(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DivideGiving() (localctx IDivideGivingContext) {
	localctx = NewDivideGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, Cobol85ParserRULE_divideGiving)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4108)
		p.Identifier()
	}
	p.SetState(4110)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(4109)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IDivideRemainderContext is an interface to support dynamic dispatch.
type IDivideRemainderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideRemainderContext differentiates from other interfaces.
	IsDivideRemainderContext()
}

type DivideRemainderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideRemainderContext() *DivideRemainderContext {
	var p = new(DivideRemainderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideRemainder
	return p
}

func (*DivideRemainderContext) IsDivideRemainderContext() {}

func NewDivideRemainderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideRemainderContext {
	var p = new(DivideRemainderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideRemainder

	return p
}

func (s *DivideRemainderContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideRemainderContext) REMAINDER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMAINDER, 0)
}

func (s *DivideRemainderContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DivideRemainderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideRemainderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideRemainderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideRemainder(s)
	}
}

func (s *DivideRemainderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideRemainder(s)
	}
}

func (s *DivideRemainderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDivideRemainder(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DivideRemainder() (localctx IDivideRemainderContext) {
	localctx = NewDivideRemainderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, Cobol85ParserRULE_divideRemainder)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4112)
		p.Match(Cobol85ParserREMAINDER)
	}
	{
		p.SetState(4113)
		p.Identifier()
	}

	return localctx
}

// IEnableStatementContext is an interface to support dynamic dispatch.
type IEnableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnableStatementContext differentiates from other interfaces.
	IsEnableStatementContext()
}

type EnableStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnableStatementContext() *EnableStatementContext {
	var p = new(EnableStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_enableStatement
	return p
}

func (*EnableStatementContext) IsEnableStatementContext() {}

func NewEnableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnableStatementContext {
	var p = new(EnableStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_enableStatement

	return p
}

func (s *EnableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EnableStatementContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENABLE, 0)
}

func (s *EnableStatementContext) CdName() ICdNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICdNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *EnableStatementContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *EnableStatementContext) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *EnableStatementContext) I_O() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O, 0)
}

func (s *EnableStatementContext) TERMINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTERMINAL, 0)
}

func (s *EnableStatementContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *EnableStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *EnableStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnableStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *EnableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnableStatement(s)
	}
}

func (s *EnableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnableStatement(s)
	}
}

func (s *EnableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEnableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EnableStatement() (localctx IEnableStatementContext) {
	localctx = NewEnableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, Cobol85ParserRULE_enableStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4115)
		p.Match(Cobol85ParserENABLE)
	}
	p.SetState(4123)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserINPUT:
		{
			p.SetState(4116)
			p.Match(Cobol85ParserINPUT)
		}
		p.SetState(4118)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTERMINAL {
			{
				p.SetState(4117)
				p.Match(Cobol85ParserTERMINAL)
			}

		}

	case Cobol85ParserI_O:
		{
			p.SetState(4120)
			p.Match(Cobol85ParserI_O)
		}
		{
			p.SetState(4121)
			p.Match(Cobol85ParserTERMINAL)
		}

	case Cobol85ParserOUTPUT:
		{
			p.SetState(4122)
			p.Match(Cobol85ParserOUTPUT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(4125)
		p.CdName()
	}
	p.SetState(4127)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4126)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(4129)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(4132)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 573, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4130)
			p.Literal()
		}

	case 2:
		{
			p.SetState(4131)
			p.Identifier()
		}

	}

	return localctx
}

// IEntryStatementContext is an interface to support dynamic dispatch.
type IEntryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntryStatementContext differentiates from other interfaces.
	IsEntryStatementContext()
}

type EntryStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntryStatementContext() *EntryStatementContext {
	var p = new(EntryStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_entryStatement
	return p
}

func (*EntryStatementContext) IsEntryStatementContext() {}

func NewEntryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EntryStatementContext {
	var p = new(EntryStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_entryStatement

	return p
}

func (s *EntryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EntryStatementContext) ENTRY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENTRY, 0)
}

func (s *EntryStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *EntryStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *EntryStatementContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *EntryStatementContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EntryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EntryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EntryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEntryStatement(s)
	}
}

func (s *EntryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEntryStatement(s)
	}
}

func (s *EntryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEntryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EntryStatement() (localctx IEntryStatementContext) {
	localctx = NewEntryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, Cobol85ParserRULE_entryStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4134)
		p.Match(Cobol85ParserENTRY)
	}
	{
		p.SetState(4135)
		p.Literal()
	}
	p.SetState(4142)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSING {
		{
			p.SetState(4136)
			p.Match(Cobol85ParserUSING)
		}
		p.SetState(4138)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
			{
				p.SetState(4137)
				p.Identifier()
			}

			p.SetState(4140)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IEvaluateStatementContext is an interface to support dynamic dispatch.
type IEvaluateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateStatementContext differentiates from other interfaces.
	IsEvaluateStatementContext()
}

type EvaluateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateStatementContext() *EvaluateStatementContext {
	var p = new(EvaluateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateStatement
	return p
}

func (*EvaluateStatementContext) IsEvaluateStatementContext() {}

func NewEvaluateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateStatementContext {
	var p = new(EvaluateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateStatement

	return p
}

func (s *EvaluateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateStatementContext) EVALUATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEVALUATE, 0)
}

func (s *EvaluateStatementContext) EvaluateSelect() IEvaluateSelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateSelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateSelectContext)
}

func (s *EvaluateStatementContext) AllEvaluateAlsoSelect() []IEvaluateAlsoSelectContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEvaluateAlsoSelectContext)(nil)).Elem())
	var tst = make([]IEvaluateAlsoSelectContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEvaluateAlsoSelectContext)
		}
	}

	return tst
}

func (s *EvaluateStatementContext) EvaluateAlsoSelect(i int) IEvaluateAlsoSelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateAlsoSelectContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEvaluateAlsoSelectContext)
}

func (s *EvaluateStatementContext) AllEvaluateWhenPhrase() []IEvaluateWhenPhraseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEvaluateWhenPhraseContext)(nil)).Elem())
	var tst = make([]IEvaluateWhenPhraseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEvaluateWhenPhraseContext)
		}
	}

	return tst
}

func (s *EvaluateStatementContext) EvaluateWhenPhrase(i int) IEvaluateWhenPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateWhenPhraseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEvaluateWhenPhraseContext)
}

func (s *EvaluateStatementContext) EvaluateWhenOther() IEvaluateWhenOtherContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateWhenOtherContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateWhenOtherContext)
}

func (s *EvaluateStatementContext) END_EVALUATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_EVALUATE, 0)
}

func (s *EvaluateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateStatement(s)
	}
}

func (s *EvaluateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateStatement(s)
	}
}

func (s *EvaluateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateStatement() (localctx IEvaluateStatementContext) {
	localctx = NewEvaluateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, Cobol85ParserRULE_evaluateStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4144)
		p.Match(Cobol85ParserEVALUATE)
	}
	{
		p.SetState(4145)
		p.EvaluateSelect()
	}
	p.SetState(4149)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserALSO {
		{
			p.SetState(4146)
			p.EvaluateAlsoSelect()
		}

		p.SetState(4151)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4153)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4152)
				p.EvaluateWhenPhrase()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4155)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 577, p.GetParserRuleContext())
	}
	p.SetState(4158)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 578, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4157)
			p.EvaluateWhenOther()
		}

	}
	p.SetState(4161)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 579, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4160)
			p.Match(Cobol85ParserEND_EVALUATE)
		}

	}

	return localctx
}

// IEvaluateSelectContext is an interface to support dynamic dispatch.
type IEvaluateSelectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateSelectContext differentiates from other interfaces.
	IsEvaluateSelectContext()
}

type EvaluateSelectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateSelectContext() *EvaluateSelectContext {
	var p = new(EvaluateSelectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateSelect
	return p
}

func (*EvaluateSelectContext) IsEvaluateSelectContext() {}

func NewEvaluateSelectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateSelectContext {
	var p = new(EvaluateSelectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateSelect

	return p
}

func (s *EvaluateSelectContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateSelectContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EvaluateSelectContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *EvaluateSelectContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *EvaluateSelectContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *EvaluateSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateSelectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateSelect(s)
	}
}

func (s *EvaluateSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateSelect(s)
	}
}

func (s *EvaluateSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateSelect() (localctx IEvaluateSelectContext) {
	localctx = NewEvaluateSelectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, Cobol85ParserRULE_evaluateSelect)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4167)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 580, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4163)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4164)
			p.Literal()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4165)
			p.ArithmeticExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4166)
			p.Condition()
		}

	}

	return localctx
}

// IEvaluateAlsoSelectContext is an interface to support dynamic dispatch.
type IEvaluateAlsoSelectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateAlsoSelectContext differentiates from other interfaces.
	IsEvaluateAlsoSelectContext()
}

type EvaluateAlsoSelectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateAlsoSelectContext() *EvaluateAlsoSelectContext {
	var p = new(EvaluateAlsoSelectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateAlsoSelect
	return p
}

func (*EvaluateAlsoSelectContext) IsEvaluateAlsoSelectContext() {}

func NewEvaluateAlsoSelectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateAlsoSelectContext {
	var p = new(EvaluateAlsoSelectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateAlsoSelect

	return p
}

func (s *EvaluateAlsoSelectContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateAlsoSelectContext) ALSO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALSO, 0)
}

func (s *EvaluateAlsoSelectContext) EvaluateSelect() IEvaluateSelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateSelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateSelectContext)
}

func (s *EvaluateAlsoSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateAlsoSelectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateAlsoSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateAlsoSelect(s)
	}
}

func (s *EvaluateAlsoSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateAlsoSelect(s)
	}
}

func (s *EvaluateAlsoSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateAlsoSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateAlsoSelect() (localctx IEvaluateAlsoSelectContext) {
	localctx = NewEvaluateAlsoSelectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, Cobol85ParserRULE_evaluateAlsoSelect)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4169)
		p.Match(Cobol85ParserALSO)
	}
	{
		p.SetState(4170)
		p.EvaluateSelect()
	}

	return localctx
}

// IEvaluateWhenPhraseContext is an interface to support dynamic dispatch.
type IEvaluateWhenPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateWhenPhraseContext differentiates from other interfaces.
	IsEvaluateWhenPhraseContext()
}

type EvaluateWhenPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateWhenPhraseContext() *EvaluateWhenPhraseContext {
	var p = new(EvaluateWhenPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateWhenPhrase
	return p
}

func (*EvaluateWhenPhraseContext) IsEvaluateWhenPhraseContext() {}

func NewEvaluateWhenPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateWhenPhraseContext {
	var p = new(EvaluateWhenPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateWhenPhrase

	return p
}

func (s *EvaluateWhenPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateWhenPhraseContext) AllEvaluateWhen() []IEvaluateWhenContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEvaluateWhenContext)(nil)).Elem())
	var tst = make([]IEvaluateWhenContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEvaluateWhenContext)
		}
	}

	return tst
}

func (s *EvaluateWhenPhraseContext) EvaluateWhen(i int) IEvaluateWhenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateWhenContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEvaluateWhenContext)
}

func (s *EvaluateWhenPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *EvaluateWhenPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *EvaluateWhenPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateWhenPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateWhenPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateWhenPhrase(s)
	}
}

func (s *EvaluateWhenPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateWhenPhrase(s)
	}
}

func (s *EvaluateWhenPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateWhenPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateWhenPhrase() (localctx IEvaluateWhenPhraseContext) {
	localctx = NewEvaluateWhenPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, Cobol85ParserRULE_evaluateWhenPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4173)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4172)
				p.EvaluateWhen()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4175)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 581, p.GetParserRuleContext())
	}
	p.SetState(4180)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 582, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4177)
				p.Statement()
			}

		}
		p.SetState(4182)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 582, p.GetParserRuleContext())
	}

	return localctx
}

// IEvaluateWhenContext is an interface to support dynamic dispatch.
type IEvaluateWhenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateWhenContext differentiates from other interfaces.
	IsEvaluateWhenContext()
}

type EvaluateWhenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateWhenContext() *EvaluateWhenContext {
	var p = new(EvaluateWhenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateWhen
	return p
}

func (*EvaluateWhenContext) IsEvaluateWhenContext() {}

func NewEvaluateWhenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateWhenContext {
	var p = new(EvaluateWhenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateWhen

	return p
}

func (s *EvaluateWhenContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateWhenContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *EvaluateWhenContext) EvaluateCondition() IEvaluateConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateConditionContext)
}

func (s *EvaluateWhenContext) AllEvaluateAlsoCondition() []IEvaluateAlsoConditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEvaluateAlsoConditionContext)(nil)).Elem())
	var tst = make([]IEvaluateAlsoConditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEvaluateAlsoConditionContext)
		}
	}

	return tst
}

func (s *EvaluateWhenContext) EvaluateAlsoCondition(i int) IEvaluateAlsoConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateAlsoConditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEvaluateAlsoConditionContext)
}

func (s *EvaluateWhenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateWhenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateWhenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateWhen(s)
	}
}

func (s *EvaluateWhenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateWhen(s)
	}
}

func (s *EvaluateWhenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateWhen(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateWhen() (localctx IEvaluateWhenContext) {
	localctx = NewEvaluateWhenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, Cobol85ParserRULE_evaluateWhen)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4183)
		p.Match(Cobol85ParserWHEN)
	}
	{
		p.SetState(4184)
		p.EvaluateCondition()
	}
	p.SetState(4188)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserALSO {
		{
			p.SetState(4185)
			p.EvaluateAlsoCondition()
		}

		p.SetState(4190)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEvaluateConditionContext is an interface to support dynamic dispatch.
type IEvaluateConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateConditionContext differentiates from other interfaces.
	IsEvaluateConditionContext()
}

type EvaluateConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateConditionContext() *EvaluateConditionContext {
	var p = new(EvaluateConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateCondition
	return p
}

func (*EvaluateConditionContext) IsEvaluateConditionContext() {}

func NewEvaluateConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateConditionContext {
	var p = new(EvaluateConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateCondition

	return p
}

func (s *EvaluateConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateConditionContext) ANY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserANY, 0)
}

func (s *EvaluateConditionContext) EvaluateValue() IEvaluateValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateValueContext)
}

func (s *EvaluateConditionContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *EvaluateConditionContext) EvaluateThrough() IEvaluateThroughContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateThroughContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateThroughContext)
}

func (s *EvaluateConditionContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *EvaluateConditionContext) BooleanLiteral() IBooleanLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *EvaluateConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateCondition(s)
	}
}

func (s *EvaluateConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateCondition(s)
	}
}

func (s *EvaluateConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateCondition() (localctx IEvaluateConditionContext) {
	localctx = NewEvaluateConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, Cobol85ParserRULE_evaluateCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4201)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 586, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4191)
			p.Match(Cobol85ParserANY)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4193)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserNOT {
			{
				p.SetState(4192)
				p.Match(Cobol85ParserNOT)
			}

		}
		{
			p.SetState(4195)
			p.EvaluateValue()
		}
		p.SetState(4197)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
			{
				p.SetState(4196)
				p.EvaluateThrough()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4199)
			p.Condition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4200)
			p.BooleanLiteral()
		}

	}

	return localctx
}

// IEvaluateThroughContext is an interface to support dynamic dispatch.
type IEvaluateThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateThroughContext differentiates from other interfaces.
	IsEvaluateThroughContext()
}

type EvaluateThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateThroughContext() *EvaluateThroughContext {
	var p = new(EvaluateThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateThrough
	return p
}

func (*EvaluateThroughContext) IsEvaluateThroughContext() {}

func NewEvaluateThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateThroughContext {
	var p = new(EvaluateThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateThrough

	return p
}

func (s *EvaluateThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateThroughContext) EvaluateValue() IEvaluateValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateValueContext)
}

func (s *EvaluateThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *EvaluateThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *EvaluateThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateThrough(s)
	}
}

func (s *EvaluateThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateThrough(s)
	}
}

func (s *EvaluateThroughContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateThrough(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateThrough() (localctx IEvaluateThroughContext) {
	localctx = NewEvaluateThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, Cobol85ParserRULE_evaluateThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4203)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(4204)
		p.EvaluateValue()
	}

	return localctx
}

// IEvaluateAlsoConditionContext is an interface to support dynamic dispatch.
type IEvaluateAlsoConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateAlsoConditionContext differentiates from other interfaces.
	IsEvaluateAlsoConditionContext()
}

type EvaluateAlsoConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateAlsoConditionContext() *EvaluateAlsoConditionContext {
	var p = new(EvaluateAlsoConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateAlsoCondition
	return p
}

func (*EvaluateAlsoConditionContext) IsEvaluateAlsoConditionContext() {}

func NewEvaluateAlsoConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateAlsoConditionContext {
	var p = new(EvaluateAlsoConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateAlsoCondition

	return p
}

func (s *EvaluateAlsoConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateAlsoConditionContext) ALSO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALSO, 0)
}

func (s *EvaluateAlsoConditionContext) EvaluateCondition() IEvaluateConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateConditionContext)
}

func (s *EvaluateAlsoConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateAlsoConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateAlsoConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateAlsoCondition(s)
	}
}

func (s *EvaluateAlsoConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateAlsoCondition(s)
	}
}

func (s *EvaluateAlsoConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateAlsoCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateAlsoCondition() (localctx IEvaluateAlsoConditionContext) {
	localctx = NewEvaluateAlsoConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, Cobol85ParserRULE_evaluateAlsoCondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4206)
		p.Match(Cobol85ParserALSO)
	}
	{
		p.SetState(4207)
		p.EvaluateCondition()
	}

	return localctx
}

// IEvaluateWhenOtherContext is an interface to support dynamic dispatch.
type IEvaluateWhenOtherContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateWhenOtherContext differentiates from other interfaces.
	IsEvaluateWhenOtherContext()
}

type EvaluateWhenOtherContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateWhenOtherContext() *EvaluateWhenOtherContext {
	var p = new(EvaluateWhenOtherContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateWhenOther
	return p
}

func (*EvaluateWhenOtherContext) IsEvaluateWhenOtherContext() {}

func NewEvaluateWhenOtherContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateWhenOtherContext {
	var p = new(EvaluateWhenOtherContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateWhenOther

	return p
}

func (s *EvaluateWhenOtherContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateWhenOtherContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *EvaluateWhenOtherContext) OTHER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOTHER, 0)
}

func (s *EvaluateWhenOtherContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *EvaluateWhenOtherContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *EvaluateWhenOtherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateWhenOtherContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateWhenOtherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateWhenOther(s)
	}
}

func (s *EvaluateWhenOtherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateWhenOther(s)
	}
}

func (s *EvaluateWhenOtherContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateWhenOther(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateWhenOther() (localctx IEvaluateWhenOtherContext) {
	localctx = NewEvaluateWhenOtherContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, Cobol85ParserRULE_evaluateWhenOther)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4209)
		p.Match(Cobol85ParserWHEN)
	}
	{
		p.SetState(4210)
		p.Match(Cobol85ParserOTHER)
	}
	p.SetState(4214)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 587, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4211)
				p.Statement()
			}

		}
		p.SetState(4216)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 587, p.GetParserRuleContext())
	}

	return localctx
}

// IEvaluateValueContext is an interface to support dynamic dispatch.
type IEvaluateValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateValueContext differentiates from other interfaces.
	IsEvaluateValueContext()
}

type EvaluateValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateValueContext() *EvaluateValueContext {
	var p = new(EvaluateValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateValue
	return p
}

func (*EvaluateValueContext) IsEvaluateValueContext() {}

func NewEvaluateValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateValueContext {
	var p = new(EvaluateValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateValue

	return p
}

func (s *EvaluateValueContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateValueContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EvaluateValueContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *EvaluateValueContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *EvaluateValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateValue(s)
	}
}

func (s *EvaluateValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateValue(s)
	}
}

func (s *EvaluateValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateValue() (localctx IEvaluateValueContext) {
	localctx = NewEvaluateValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, Cobol85ParserRULE_evaluateValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4220)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 588, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4217)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4218)
			p.Literal()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4219)
			p.ArithmeticExpression()
		}

	}

	return localctx
}

// IExecCicsStatementContext is an interface to support dynamic dispatch.
type IExecCicsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExecCicsStatementContext differentiates from other interfaces.
	IsExecCicsStatementContext()
}

type ExecCicsStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecCicsStatementContext() *ExecCicsStatementContext {
	var p = new(ExecCicsStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_execCicsStatement
	return p
}

func (*ExecCicsStatementContext) IsExecCicsStatementContext() {}

func NewExecCicsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecCicsStatementContext {
	var p = new(ExecCicsStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_execCicsStatement

	return p
}

func (s *ExecCicsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecCicsStatementContext) AllEXECCICSLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserEXECCICSLINE)
}

func (s *ExecCicsStatementContext) EXECCICSLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXECCICSLINE, i)
}

func (s *ExecCicsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecCicsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecCicsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExecCicsStatement(s)
	}
}

func (s *ExecCicsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExecCicsStatement(s)
	}
}

func (s *ExecCicsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitExecCicsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ExecCicsStatement() (localctx IExecCicsStatementContext) {
	localctx = NewExecCicsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, Cobol85ParserRULE_execCicsStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4223)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4222)
				p.Match(Cobol85ParserEXECCICSLINE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4225)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 589, p.GetParserRuleContext())
	}

	return localctx
}

// IExecSqlStatementContext is an interface to support dynamic dispatch.
type IExecSqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExecSqlStatementContext differentiates from other interfaces.
	IsExecSqlStatementContext()
}

type ExecSqlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecSqlStatementContext() *ExecSqlStatementContext {
	var p = new(ExecSqlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_execSqlStatement
	return p
}

func (*ExecSqlStatementContext) IsExecSqlStatementContext() {}

func NewExecSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecSqlStatementContext {
	var p = new(ExecSqlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_execSqlStatement

	return p
}

func (s *ExecSqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecSqlStatementContext) AllEXECSQLLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserEXECSQLLINE)
}

func (s *ExecSqlStatementContext) EXECSQLLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXECSQLLINE, i)
}

func (s *ExecSqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecSqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecSqlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExecSqlStatement(s)
	}
}

func (s *ExecSqlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExecSqlStatement(s)
	}
}

func (s *ExecSqlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitExecSqlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ExecSqlStatement() (localctx IExecSqlStatementContext) {
	localctx = NewExecSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, Cobol85ParserRULE_execSqlStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4228)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4227)
				p.Match(Cobol85ParserEXECSQLLINE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4230)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 590, p.GetParserRuleContext())
	}

	return localctx
}

// IExecSqlImsStatementContext is an interface to support dynamic dispatch.
type IExecSqlImsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExecSqlImsStatementContext differentiates from other interfaces.
	IsExecSqlImsStatementContext()
}

type ExecSqlImsStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecSqlImsStatementContext() *ExecSqlImsStatementContext {
	var p = new(ExecSqlImsStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_execSqlImsStatement
	return p
}

func (*ExecSqlImsStatementContext) IsExecSqlImsStatementContext() {}

func NewExecSqlImsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecSqlImsStatementContext {
	var p = new(ExecSqlImsStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_execSqlImsStatement

	return p
}

func (s *ExecSqlImsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecSqlImsStatementContext) AllEXECSQLIMSLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserEXECSQLIMSLINE)
}

func (s *ExecSqlImsStatementContext) EXECSQLIMSLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXECSQLIMSLINE, i)
}

func (s *ExecSqlImsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecSqlImsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecSqlImsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExecSqlImsStatement(s)
	}
}

func (s *ExecSqlImsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExecSqlImsStatement(s)
	}
}

func (s *ExecSqlImsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitExecSqlImsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ExecSqlImsStatement() (localctx IExecSqlImsStatementContext) {
	localctx = NewExecSqlImsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, Cobol85ParserRULE_execSqlImsStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4233)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4232)
				p.Match(Cobol85ParserEXECSQLIMSLINE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4235)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 591, p.GetParserRuleContext())
	}

	return localctx
}

// IExhibitStatementContext is an interface to support dynamic dispatch.
type IExhibitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExhibitStatementContext differentiates from other interfaces.
	IsExhibitStatementContext()
}

type ExhibitStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExhibitStatementContext() *ExhibitStatementContext {
	var p = new(ExhibitStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_exhibitStatement
	return p
}

func (*ExhibitStatementContext) IsExhibitStatementContext() {}

func NewExhibitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExhibitStatementContext {
	var p = new(ExhibitStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_exhibitStatement

	return p
}

func (s *ExhibitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExhibitStatementContext) EXHIBIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXHIBIT, 0)
}

func (s *ExhibitStatementContext) NAMED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNAMED, 0)
}

func (s *ExhibitStatementContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHANGED, 0)
}

func (s *ExhibitStatementContext) AllExhibitOperand() []IExhibitOperandContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExhibitOperandContext)(nil)).Elem())
	var tst = make([]IExhibitOperandContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExhibitOperandContext)
		}
	}

	return tst
}

func (s *ExhibitStatementContext) ExhibitOperand(i int) IExhibitOperandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExhibitOperandContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExhibitOperandContext)
}

func (s *ExhibitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExhibitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExhibitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExhibitStatement(s)
	}
}

func (s *ExhibitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExhibitStatement(s)
	}
}

func (s *ExhibitStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitExhibitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ExhibitStatement() (localctx IExhibitStatementContext) {
	localctx = NewExhibitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, Cobol85ParserRULE_exhibitStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4237)
		p.Match(Cobol85ParserEXHIBIT)
	}
	p.SetState(4239)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 592, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4238)
			p.Match(Cobol85ParserNAMED)
		}

	}
	p.SetState(4242)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 593, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4241)
			p.Match(Cobol85ParserCHANGED)
		}

	}
	p.SetState(4245)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184))|(1<<(Cobol85ParserFALSE-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserHIGH_VALUE-216))|(1<<(Cobol85ParserHIGH_VALUES-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserLOW_VALUE-286))|(1<<(Cobol85ParserLOW_VALUES-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286))|(1<<(Cobol85ParserNULL-286)))) != 0) || (((_la-318)&-(0x1f+1)) == 0 && ((1<<uint((_la-318)))&((1<<(Cobol85ParserNULLS-318))|(1<<(Cobol85ParserNUMERIC_DATE-318))|(1<<(Cobol85ParserNUMERIC_TIME-318))|(1<<(Cobol85ParserODT-318))|(1<<(Cobol85ParserOPTIMIZE-318))|(1<<(Cobol85ParserORDERLY-318))|(1<<(Cobol85ParserOVERLINE-318))|(1<<(Cobol85ParserOWN-318))|(1<<(Cobol85ParserPAGE_COUNTER-318))|(1<<(Cobol85ParserPASSWORD-318)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserQUOTE-357))|(1<<(Cobol85ParserQUOTES-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434))|(1<<(Cobol85ParserSPACE-434))|(1<<(Cobol85ParserSPACES-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUE-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO-502))|(1<<(Cobol85ParserZERO_FILL-502))|(1<<(Cobol85ParserZEROS-502))|(1<<(Cobol85ParserZEROES-502)))) != 0) || (((_la-555)&-(0x1f+1)) == 0 && ((1<<uint((_la-555)))&((1<<(Cobol85ParserNONNUMERICLITERAL-555))|(1<<(Cobol85ParserLEVEL_NUMBER_66-555))|(1<<(Cobol85ParserLEVEL_NUMBER_77-555))|(1<<(Cobol85ParserLEVEL_NUMBER_88-555))|(1<<(Cobol85ParserINTEGERLITERAL-555))|(1<<(Cobol85ParserNUMERICLITERAL-555))|(1<<(Cobol85ParserIDENTIFIER-555)))) != 0) {
		{
			p.SetState(4244)
			p.ExhibitOperand()
		}

		p.SetState(4247)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExhibitOperandContext is an interface to support dynamic dispatch.
type IExhibitOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExhibitOperandContext differentiates from other interfaces.
	IsExhibitOperandContext()
}

type ExhibitOperandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExhibitOperandContext() *ExhibitOperandContext {
	var p = new(ExhibitOperandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_exhibitOperand
	return p
}

func (*ExhibitOperandContext) IsExhibitOperandContext() {}

func NewExhibitOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExhibitOperandContext {
	var p = new(ExhibitOperandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_exhibitOperand

	return p
}

func (s *ExhibitOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *ExhibitOperandContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExhibitOperandContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ExhibitOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExhibitOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExhibitOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExhibitOperand(s)
	}
}

func (s *ExhibitOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExhibitOperand(s)
	}
}

func (s *ExhibitOperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitExhibitOperand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ExhibitOperand() (localctx IExhibitOperandContext) {
	localctx = NewExhibitOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, Cobol85ParserRULE_exhibitOperand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4251)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 595, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4249)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4250)
			p.Literal()
		}

	}

	return localctx
}

// IExitStatementContext is an interface to support dynamic dispatch.
type IExitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExitStatementContext differentiates from other interfaces.
	IsExitStatementContext()
}

type ExitStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExitStatementContext() *ExitStatementContext {
	var p = new(ExitStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_exitStatement
	return p
}

func (*ExitStatementContext) IsExitStatementContext() {}

func NewExitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExitStatementContext {
	var p = new(ExitStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_exitStatement

	return p
}

func (s *ExitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExitStatementContext) EXIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXIT, 0)
}

func (s *ExitStatementContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM, 0)
}

func (s *ExitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExitStatement(s)
	}
}

func (s *ExitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExitStatement(s)
	}
}

func (s *ExitStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitExitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ExitStatement() (localctx IExitStatementContext) {
	localctx = NewExitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, Cobol85ParserRULE_exitStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4253)
		p.Match(Cobol85ParserEXIT)
	}
	p.SetState(4255)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPROGRAM {
		{
			p.SetState(4254)
			p.Match(Cobol85ParserPROGRAM)
		}

	}

	return localctx
}

// IGenerateStatementContext is an interface to support dynamic dispatch.
type IGenerateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerateStatementContext differentiates from other interfaces.
	IsGenerateStatementContext()
}

type GenerateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerateStatementContext() *GenerateStatementContext {
	var p = new(GenerateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_generateStatement
	return p
}

func (*GenerateStatementContext) IsGenerateStatementContext() {}

func NewGenerateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenerateStatementContext {
	var p = new(GenerateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_generateStatement

	return p
}

func (s *GenerateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GenerateStatementContext) GENERATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGENERATE, 0)
}

func (s *GenerateStatementContext) ReportName() IReportNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportNameContext)
}

func (s *GenerateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenerateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenerateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGenerateStatement(s)
	}
}

func (s *GenerateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGenerateStatement(s)
	}
}

func (s *GenerateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitGenerateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) GenerateStatement() (localctx IGenerateStatementContext) {
	localctx = NewGenerateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, Cobol85ParserRULE_generateStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4257)
		p.Match(Cobol85ParserGENERATE)
	}
	{
		p.SetState(4258)
		p.ReportName()
	}

	return localctx
}

// IGobackStatementContext is an interface to support dynamic dispatch.
type IGobackStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGobackStatementContext differentiates from other interfaces.
	IsGobackStatementContext()
}

type GobackStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGobackStatementContext() *GobackStatementContext {
	var p = new(GobackStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_gobackStatement
	return p
}

func (*GobackStatementContext) IsGobackStatementContext() {}

func NewGobackStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GobackStatementContext {
	var p = new(GobackStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_gobackStatement

	return p
}

func (s *GobackStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GobackStatementContext) GOBACK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGOBACK, 0)
}

func (s *GobackStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GobackStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GobackStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGobackStatement(s)
	}
}

func (s *GobackStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGobackStatement(s)
	}
}

func (s *GobackStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitGobackStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) GobackStatement() (localctx IGobackStatementContext) {
	localctx = NewGobackStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, Cobol85ParserRULE_gobackStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4260)
		p.Match(Cobol85ParserGOBACK)
	}

	return localctx
}

// IGoToStatementContext is an interface to support dynamic dispatch.
type IGoToStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoToStatementContext differentiates from other interfaces.
	IsGoToStatementContext()
}

type GoToStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoToStatementContext() *GoToStatementContext {
	var p = new(GoToStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_goToStatement
	return p
}

func (*GoToStatementContext) IsGoToStatementContext() {}

func NewGoToStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GoToStatementContext {
	var p = new(GoToStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_goToStatement

	return p
}

func (s *GoToStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GoToStatementContext) GO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGO, 0)
}

func (s *GoToStatementContext) GoToStatementSimple() IGoToStatementSimpleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoToStatementSimpleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoToStatementSimpleContext)
}

func (s *GoToStatementContext) GoToDependingOnStatement() IGoToDependingOnStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoToDependingOnStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoToDependingOnStatementContext)
}

func (s *GoToStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *GoToStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoToStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GoToStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGoToStatement(s)
	}
}

func (s *GoToStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGoToStatement(s)
	}
}

func (s *GoToStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitGoToStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) GoToStatement() (localctx IGoToStatementContext) {
	localctx = NewGoToStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, Cobol85ParserRULE_goToStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4262)
		p.Match(Cobol85ParserGO)
	}
	p.SetState(4264)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(4263)
			p.Match(Cobol85ParserTO)
		}

	}
	p.SetState(4268)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 598, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4266)
			p.GoToStatementSimple()
		}

	case 2:
		{
			p.SetState(4267)
			p.GoToDependingOnStatement()
		}

	}

	return localctx
}

// IGoToStatementSimpleContext is an interface to support dynamic dispatch.
type IGoToStatementSimpleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoToStatementSimpleContext differentiates from other interfaces.
	IsGoToStatementSimpleContext()
}

type GoToStatementSimpleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoToStatementSimpleContext() *GoToStatementSimpleContext {
	var p = new(GoToStatementSimpleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_goToStatementSimple
	return p
}

func (*GoToStatementSimpleContext) IsGoToStatementSimpleContext() {}

func NewGoToStatementSimpleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GoToStatementSimpleContext {
	var p = new(GoToStatementSimpleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_goToStatementSimple

	return p
}

func (s *GoToStatementSimpleContext) GetParser() antlr.Parser { return s.parser }

func (s *GoToStatementSimpleContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *GoToStatementSimpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoToStatementSimpleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GoToStatementSimpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGoToStatementSimple(s)
	}
}

func (s *GoToStatementSimpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGoToStatementSimple(s)
	}
}

func (s *GoToStatementSimpleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitGoToStatementSimple(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) GoToStatementSimple() (localctx IGoToStatementSimpleContext) {
	localctx = NewGoToStatementSimpleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, Cobol85ParserRULE_goToStatementSimple)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4270)
		p.ProcedureName()
	}

	return localctx
}

// IGoToDependingOnStatementContext is an interface to support dynamic dispatch.
type IGoToDependingOnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoToDependingOnStatementContext differentiates from other interfaces.
	IsGoToDependingOnStatementContext()
}

type GoToDependingOnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoToDependingOnStatementContext() *GoToDependingOnStatementContext {
	var p = new(GoToDependingOnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_goToDependingOnStatement
	return p
}

func (*GoToDependingOnStatementContext) IsGoToDependingOnStatementContext() {}

func NewGoToDependingOnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GoToDependingOnStatementContext {
	var p = new(GoToDependingOnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_goToDependingOnStatement

	return p
}

func (s *GoToDependingOnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GoToDependingOnStatementContext) MORE_LABELS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORE_LABELS, 0)
}

func (s *GoToDependingOnStatementContext) AllProcedureName() []IProcedureNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem())
	var tst = make([]IProcedureNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcedureNameContext)
		}
	}

	return tst
}

func (s *GoToDependingOnStatementContext) ProcedureName(i int) IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *GoToDependingOnStatementContext) DEPENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEPENDING, 0)
}

func (s *GoToDependingOnStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GoToDependingOnStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *GoToDependingOnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoToDependingOnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GoToDependingOnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGoToDependingOnStatement(s)
	}
}

func (s *GoToDependingOnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGoToDependingOnStatement(s)
	}
}

func (s *GoToDependingOnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitGoToDependingOnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) GoToDependingOnStatement() (localctx IGoToDependingOnStatementContext) {
	localctx = NewGoToDependingOnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, Cobol85ParserRULE_goToDependingOnStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4285)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserMORE_LABELS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4272)
			p.Match(Cobol85ParserMORE_LABELS)
		}

	case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4274)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
			{
				p.SetState(4273)
				p.ProcedureName()
			}

			p.SetState(4276)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(4283)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserDEPENDING {
			{
				p.SetState(4278)
				p.Match(Cobol85ParserDEPENDING)
			}
			p.SetState(4280)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserON {
				{
					p.SetState(4279)
					p.Match(Cobol85ParserON)
				}

			}
			{
				p.SetState(4282)
				p.Identifier()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_ifStatement
	return p
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIF, 0)
}

func (s *IfStatementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *IfStatementContext) IfThen() IIfThenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfThenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfThenContext)
}

func (s *IfStatementContext) IfElse() IIfElseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfElseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfElseContext)
}

func (s *IfStatementContext) END_IF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_IF, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, Cobol85ParserRULE_ifStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4287)
		p.Match(Cobol85ParserIF)
	}
	{
		p.SetState(4288)
		p.Condition()
	}
	{
		p.SetState(4289)
		p.IfThen()
	}
	p.SetState(4291)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 603, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4290)
			p.IfElse()
		}

	}
	p.SetState(4294)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 604, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4293)
			p.Match(Cobol85ParserEND_IF)
		}

	}

	return localctx
}

// IIfThenContext is an interface to support dynamic dispatch.
type IIfThenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfThenContext differentiates from other interfaces.
	IsIfThenContext()
}

type IfThenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfThenContext() *IfThenContext {
	var p = new(IfThenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_ifThen
	return p
}

func (*IfThenContext) IsIfThenContext() {}

func NewIfThenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfThenContext {
	var p = new(IfThenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_ifThen

	return p
}

func (s *IfThenContext) GetParser() antlr.Parser { return s.parser }

func (s *IfThenContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *IfThenContext) SENTENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSENTENCE, 0)
}

func (s *IfThenContext) THEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHEN, 0)
}

func (s *IfThenContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *IfThenContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfThenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfThenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfThenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIfThen(s)
	}
}

func (s *IfThenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIfThen(s)
	}
}

func (s *IfThenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIfThen(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IfThen() (localctx IIfThenContext) {
	localctx = NewIfThenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, Cobol85ParserRULE_ifThen)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4297)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHEN {
		{
			p.SetState(4296)
			p.Match(Cobol85ParserTHEN)
		}

	}
	p.SetState(4307)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNEXT:
		{
			p.SetState(4299)
			p.Match(Cobol85ParserNEXT)
		}
		{
			p.SetState(4300)
			p.Match(Cobol85ParserSENTENCE)
		}

	case Cobol85ParserACCEPT, Cobol85ParserADD, Cobol85ParserALTER, Cobol85ParserAT, Cobol85ParserCALL, Cobol85ParserCANCEL, Cobol85ParserCLOSE, Cobol85ParserCOMPUTE, Cobol85ParserCONTINUE, Cobol85ParserDELETE, Cobol85ParserDISABLE, Cobol85ParserDISPLAY, Cobol85ParserDIVIDE, Cobol85ParserELSE, Cobol85ParserENABLE, Cobol85ParserEND, Cobol85ParserEND_ADD, Cobol85ParserEND_CALL, Cobol85ParserEND_COMPUTE, Cobol85ParserEND_DELETE, Cobol85ParserEND_DIVIDE, Cobol85ParserEND_EVALUATE, Cobol85ParserEND_IF, Cobol85ParserEND_MULTIPLY, Cobol85ParserEND_PERFORM, Cobol85ParserEND_READ, Cobol85ParserEND_RECEIVE, Cobol85ParserEND_RETURN, Cobol85ParserEND_REWRITE, Cobol85ParserEND_SEARCH, Cobol85ParserEND_START, Cobol85ParserEND_STRING, Cobol85ParserEND_SUBTRACT, Cobol85ParserEND_UNSTRING, Cobol85ParserEND_WRITE, Cobol85ParserENTRY, Cobol85ParserEVALUATE, Cobol85ParserEXCEPTION, Cobol85ParserEXHIBIT, Cobol85ParserEXIT, Cobol85ParserGENERATE, Cobol85ParserGOBACK, Cobol85ParserGO, Cobol85ParserIF, Cobol85ParserINITIALIZE, Cobol85ParserINITIATE, Cobol85ParserINSPECT, Cobol85ParserINVALID, Cobol85ParserMERGE, Cobol85ParserMOVE, Cobol85ParserMULTIPLY, Cobol85ParserNOT, Cobol85ParserON, Cobol85ParserOPEN, Cobol85ParserPERFORM, Cobol85ParserPURGE, Cobol85ParserREAD, Cobol85ParserRECEIVE, Cobol85ParserRELEASE, Cobol85ParserRETURN, Cobol85ParserREWRITE, Cobol85ParserSEARCH, Cobol85ParserSEND, Cobol85ParserSET, Cobol85ParserSORT, Cobol85ParserSTART, Cobol85ParserSTOP, Cobol85ParserSTRING, Cobol85ParserSUBTRACT, Cobol85ParserTERMINATE, Cobol85ParserUNSTRING, Cobol85ParserWHEN, Cobol85ParserWITH, Cobol85ParserWRITE, Cobol85ParserDOT_FS, Cobol85ParserEXECCICSLINE, Cobol85ParserEXECSQLIMSLINE, Cobol85ParserEXECSQLLINE:
		p.SetState(4304)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 606, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4301)
					p.Statement()
				}

			}
			p.SetState(4306)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 606, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIfElseContext is an interface to support dynamic dispatch.
type IIfElseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfElseContext differentiates from other interfaces.
	IsIfElseContext()
}

type IfElseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfElseContext() *IfElseContext {
	var p = new(IfElseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_ifElse
	return p
}

func (*IfElseContext) IsIfElseContext() {}

func NewIfElseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfElseContext {
	var p = new(IfElseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_ifElse

	return p
}

func (s *IfElseContext) GetParser() antlr.Parser { return s.parser }

func (s *IfElseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserELSE, 0)
}

func (s *IfElseContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *IfElseContext) SENTENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSENTENCE, 0)
}

func (s *IfElseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *IfElseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfElseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfElseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfElseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIfElse(s)
	}
}

func (s *IfElseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIfElse(s)
	}
}

func (s *IfElseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIfElse(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IfElse() (localctx IIfElseContext) {
	localctx = NewIfElseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, Cobol85ParserRULE_ifElse)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4309)
		p.Match(Cobol85ParserELSE)
	}
	p.SetState(4318)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNEXT:
		{
			p.SetState(4310)
			p.Match(Cobol85ParserNEXT)
		}
		{
			p.SetState(4311)
			p.Match(Cobol85ParserSENTENCE)
		}

	case Cobol85ParserACCEPT, Cobol85ParserADD, Cobol85ParserALTER, Cobol85ParserAT, Cobol85ParserCALL, Cobol85ParserCANCEL, Cobol85ParserCLOSE, Cobol85ParserCOMPUTE, Cobol85ParserCONTINUE, Cobol85ParserDELETE, Cobol85ParserDISABLE, Cobol85ParserDISPLAY, Cobol85ParserDIVIDE, Cobol85ParserELSE, Cobol85ParserENABLE, Cobol85ParserEND, Cobol85ParserEND_ADD, Cobol85ParserEND_CALL, Cobol85ParserEND_COMPUTE, Cobol85ParserEND_DELETE, Cobol85ParserEND_DIVIDE, Cobol85ParserEND_EVALUATE, Cobol85ParserEND_IF, Cobol85ParserEND_MULTIPLY, Cobol85ParserEND_PERFORM, Cobol85ParserEND_READ, Cobol85ParserEND_RECEIVE, Cobol85ParserEND_RETURN, Cobol85ParserEND_REWRITE, Cobol85ParserEND_SEARCH, Cobol85ParserEND_START, Cobol85ParserEND_STRING, Cobol85ParserEND_SUBTRACT, Cobol85ParserEND_UNSTRING, Cobol85ParserEND_WRITE, Cobol85ParserENTRY, Cobol85ParserEVALUATE, Cobol85ParserEXCEPTION, Cobol85ParserEXHIBIT, Cobol85ParserEXIT, Cobol85ParserGENERATE, Cobol85ParserGOBACK, Cobol85ParserGO, Cobol85ParserIF, Cobol85ParserINITIALIZE, Cobol85ParserINITIATE, Cobol85ParserINSPECT, Cobol85ParserINVALID, Cobol85ParserMERGE, Cobol85ParserMOVE, Cobol85ParserMULTIPLY, Cobol85ParserNOT, Cobol85ParserON, Cobol85ParserOPEN, Cobol85ParserPERFORM, Cobol85ParserPURGE, Cobol85ParserREAD, Cobol85ParserRECEIVE, Cobol85ParserRELEASE, Cobol85ParserRETURN, Cobol85ParserREWRITE, Cobol85ParserSEARCH, Cobol85ParserSEND, Cobol85ParserSET, Cobol85ParserSORT, Cobol85ParserSTART, Cobol85ParserSTOP, Cobol85ParserSTRING, Cobol85ParserSUBTRACT, Cobol85ParserTERMINATE, Cobol85ParserUNSTRING, Cobol85ParserWHEN, Cobol85ParserWITH, Cobol85ParserWRITE, Cobol85ParserDOT_FS, Cobol85ParserEXECCICSLINE, Cobol85ParserEXECSQLIMSLINE, Cobol85ParserEXECSQLLINE:
		p.SetState(4315)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 608, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4312)
					p.Statement()
				}

			}
			p.SetState(4317)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 608, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInitializeStatementContext is an interface to support dynamic dispatch.
type IInitializeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializeStatementContext differentiates from other interfaces.
	IsInitializeStatementContext()
}

type InitializeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializeStatementContext() *InitializeStatementContext {
	var p = new(InitializeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_initializeStatement
	return p
}

func (*InitializeStatementContext) IsInitializeStatementContext() {}

func NewInitializeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializeStatementContext {
	var p = new(InitializeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_initializeStatement

	return p
}

func (s *InitializeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializeStatementContext) INITIALIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIALIZE, 0)
}

func (s *InitializeStatementContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *InitializeStatementContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InitializeStatementContext) InitializeReplacingPhrase() IInitializeReplacingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializeReplacingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializeReplacingPhraseContext)
}

func (s *InitializeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInitializeStatement(s)
	}
}

func (s *InitializeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInitializeStatement(s)
	}
}

func (s *InitializeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInitializeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InitializeStatement() (localctx IInitializeStatementContext) {
	localctx = NewInitializeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, Cobol85ParserRULE_initializeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4320)
		p.Match(Cobol85ParserINITIALIZE)
	}
	p.SetState(4322)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(4321)
			p.Identifier()
		}

		p.SetState(4324)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4327)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserREPLACING {
		{
			p.SetState(4326)
			p.InitializeReplacingPhrase()
		}

	}

	return localctx
}

// IInitializeReplacingPhraseContext is an interface to support dynamic dispatch.
type IInitializeReplacingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializeReplacingPhraseContext differentiates from other interfaces.
	IsInitializeReplacingPhraseContext()
}

type InitializeReplacingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializeReplacingPhraseContext() *InitializeReplacingPhraseContext {
	var p = new(InitializeReplacingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_initializeReplacingPhrase
	return p
}

func (*InitializeReplacingPhraseContext) IsInitializeReplacingPhraseContext() {}

func NewInitializeReplacingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializeReplacingPhraseContext {
	var p = new(InitializeReplacingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_initializeReplacingPhrase

	return p
}

func (s *InitializeReplacingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializeReplacingPhraseContext) REPLACING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPLACING, 0)
}

func (s *InitializeReplacingPhraseContext) AllInitializeReplacingBy() []IInitializeReplacingByContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInitializeReplacingByContext)(nil)).Elem())
	var tst = make([]IInitializeReplacingByContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInitializeReplacingByContext)
		}
	}

	return tst
}

func (s *InitializeReplacingPhraseContext) InitializeReplacingBy(i int) IInitializeReplacingByContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializeReplacingByContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInitializeReplacingByContext)
}

func (s *InitializeReplacingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializeReplacingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializeReplacingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInitializeReplacingPhrase(s)
	}
}

func (s *InitializeReplacingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInitializeReplacingPhrase(s)
	}
}

func (s *InitializeReplacingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInitializeReplacingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InitializeReplacingPhrase() (localctx IInitializeReplacingPhraseContext) {
	localctx = NewInitializeReplacingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, Cobol85ParserRULE_initializeReplacingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4329)
		p.Match(Cobol85ParserREPLACING)
	}
	p.SetState(4331)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserALPHABETIC)|(1<<Cobol85ParserALPHANUMERIC)|(1<<Cobol85ParserALPHANUMERIC_EDITED))) != 0) || _la == Cobol85ParserDBCS || _la == Cobol85ParserEGCS || (((_la-307)&-(0x1f+1)) == 0 && ((1<<uint((_la-307)))&((1<<(Cobol85ParserNATIONAL-307))|(1<<(Cobol85ParserNUMERIC-307))|(1<<(Cobol85ParserNUMERIC_EDITED-307)))) != 0) {
		{
			p.SetState(4330)
			p.InitializeReplacingBy()
		}

		p.SetState(4333)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInitializeReplacingByContext is an interface to support dynamic dispatch.
type IInitializeReplacingByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializeReplacingByContext differentiates from other interfaces.
	IsInitializeReplacingByContext()
}

type InitializeReplacingByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializeReplacingByContext() *InitializeReplacingByContext {
	var p = new(InitializeReplacingByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_initializeReplacingBy
	return p
}

func (*InitializeReplacingByContext) IsInitializeReplacingByContext() {}

func NewInitializeReplacingByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializeReplacingByContext {
	var p = new(InitializeReplacingByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_initializeReplacingBy

	return p
}

func (s *InitializeReplacingByContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializeReplacingByContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *InitializeReplacingByContext) ALPHABETIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABETIC, 0)
}

func (s *InitializeReplacingByContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *InitializeReplacingByContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *InitializeReplacingByContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC, 0)
}

func (s *InitializeReplacingByContext) ALPHANUMERIC_EDITED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC_EDITED, 0)
}

func (s *InitializeReplacingByContext) NUMERIC_EDITED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC_EDITED, 0)
}

func (s *InitializeReplacingByContext) DBCS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDBCS, 0)
}

func (s *InitializeReplacingByContext) EGCS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEGCS, 0)
}

func (s *InitializeReplacingByContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InitializeReplacingByContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InitializeReplacingByContext) DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA, 0)
}

func (s *InitializeReplacingByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializeReplacingByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializeReplacingByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInitializeReplacingBy(s)
	}
}

func (s *InitializeReplacingByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInitializeReplacingBy(s)
	}
}

func (s *InitializeReplacingByContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInitializeReplacingBy(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InitializeReplacingBy() (localctx IInitializeReplacingByContext) {
	localctx = NewInitializeReplacingByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, Cobol85ParserRULE_initializeReplacingBy)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4335)
	_la = p.GetTokenStream().LA(1)

	if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserALPHABETIC)|(1<<Cobol85ParserALPHANUMERIC)|(1<<Cobol85ParserALPHANUMERIC_EDITED))) != 0) || _la == Cobol85ParserDBCS || _la == Cobol85ParserEGCS || (((_la-307)&-(0x1f+1)) == 0 && ((1<<uint((_la-307)))&((1<<(Cobol85ParserNATIONAL-307))|(1<<(Cobol85ParserNUMERIC-307))|(1<<(Cobol85ParserNUMERIC_EDITED-307)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(4337)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDATA {
		{
			p.SetState(4336)
			p.Match(Cobol85ParserDATA)
		}

	}
	{
		p.SetState(4339)
		p.Match(Cobol85ParserBY)
	}
	p.SetState(4342)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 614, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4340)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4341)
			p.Literal()
		}

	}

	return localctx
}

// IInitiateStatementContext is an interface to support dynamic dispatch.
type IInitiateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitiateStatementContext differentiates from other interfaces.
	IsInitiateStatementContext()
}

type InitiateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitiateStatementContext() *InitiateStatementContext {
	var p = new(InitiateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_initiateStatement
	return p
}

func (*InitiateStatementContext) IsInitiateStatementContext() {}

func NewInitiateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitiateStatementContext {
	var p = new(InitiateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_initiateStatement

	return p
}

func (s *InitiateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InitiateStatementContext) INITIATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIATE, 0)
}

func (s *InitiateStatementContext) AllReportName() []IReportNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportNameContext)(nil)).Elem())
	var tst = make([]IReportNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportNameContext)
		}
	}

	return tst
}

func (s *InitiateStatementContext) ReportName(i int) IReportNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportNameContext)
}

func (s *InitiateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitiateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitiateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInitiateStatement(s)
	}
}

func (s *InitiateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInitiateStatement(s)
	}
}

func (s *InitiateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInitiateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InitiateStatement() (localctx IInitiateStatementContext) {
	localctx = NewInitiateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, Cobol85ParserRULE_initiateStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4344)
		p.Match(Cobol85ParserINITIATE)
	}
	p.SetState(4346)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(4345)
			p.ReportName()
		}

		p.SetState(4348)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectStatementContext is an interface to support dynamic dispatch.
type IInspectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectStatementContext differentiates from other interfaces.
	IsInspectStatementContext()
}

type InspectStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectStatementContext() *InspectStatementContext {
	var p = new(InspectStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectStatement
	return p
}

func (*InspectStatementContext) IsInspectStatementContext() {}

func NewInspectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectStatementContext {
	var p = new(InspectStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectStatement

	return p
}

func (s *InspectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectStatementContext) INSPECT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINSPECT, 0)
}

func (s *InspectStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectStatementContext) InspectTallyingPhrase() IInspectTallyingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectTallyingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInspectTallyingPhraseContext)
}

func (s *InspectStatementContext) InspectReplacingPhrase() IInspectReplacingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectReplacingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInspectReplacingPhraseContext)
}

func (s *InspectStatementContext) InspectTallyingReplacingPhrase() IInspectTallyingReplacingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectTallyingReplacingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInspectTallyingReplacingPhraseContext)
}

func (s *InspectStatementContext) InspectConvertingPhrase() IInspectConvertingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectConvertingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInspectConvertingPhraseContext)
}

func (s *InspectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectStatement(s)
	}
}

func (s *InspectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectStatement(s)
	}
}

func (s *InspectStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectStatement() (localctx IInspectStatementContext) {
	localctx = NewInspectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, Cobol85ParserRULE_inspectStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4350)
		p.Match(Cobol85ParserINSPECT)
	}
	{
		p.SetState(4351)
		p.Identifier()
	}
	p.SetState(4356)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 616, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4352)
			p.InspectTallyingPhrase()
		}

	case 2:
		{
			p.SetState(4353)
			p.InspectReplacingPhrase()
		}

	case 3:
		{
			p.SetState(4354)
			p.InspectTallyingReplacingPhrase()
		}

	case 4:
		{
			p.SetState(4355)
			p.InspectConvertingPhrase()
		}

	}

	return localctx
}

// IInspectTallyingPhraseContext is an interface to support dynamic dispatch.
type IInspectTallyingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectTallyingPhraseContext differentiates from other interfaces.
	IsInspectTallyingPhraseContext()
}

type InspectTallyingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectTallyingPhraseContext() *InspectTallyingPhraseContext {
	var p = new(InspectTallyingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectTallyingPhrase
	return p
}

func (*InspectTallyingPhraseContext) IsInspectTallyingPhraseContext() {}

func NewInspectTallyingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectTallyingPhraseContext {
	var p = new(InspectTallyingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectTallyingPhrase

	return p
}

func (s *InspectTallyingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectTallyingPhraseContext) TALLYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTALLYING, 0)
}

func (s *InspectTallyingPhraseContext) AllInspectFor() []IInspectForContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectForContext)(nil)).Elem())
	var tst = make([]IInspectForContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectForContext)
		}
	}

	return tst
}

func (s *InspectTallyingPhraseContext) InspectFor(i int) IInspectForContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectForContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectForContext)
}

func (s *InspectTallyingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectTallyingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectTallyingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectTallyingPhrase(s)
	}
}

func (s *InspectTallyingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectTallyingPhrase(s)
	}
}

func (s *InspectTallyingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectTallyingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectTallyingPhrase() (localctx IInspectTallyingPhraseContext) {
	localctx = NewInspectTallyingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, Cobol85ParserRULE_inspectTallyingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4358)
		p.Match(Cobol85ParserTALLYING)
	}
	p.SetState(4360)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(4359)
			p.InspectFor()
		}

		p.SetState(4362)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectReplacingPhraseContext is an interface to support dynamic dispatch.
type IInspectReplacingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectReplacingPhraseContext differentiates from other interfaces.
	IsInspectReplacingPhraseContext()
}

type InspectReplacingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectReplacingPhraseContext() *InspectReplacingPhraseContext {
	var p = new(InspectReplacingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingPhrase
	return p
}

func (*InspectReplacingPhraseContext) IsInspectReplacingPhraseContext() {}

func NewInspectReplacingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectReplacingPhraseContext {
	var p = new(InspectReplacingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingPhrase

	return p
}

func (s *InspectReplacingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectReplacingPhraseContext) REPLACING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPLACING, 0)
}

func (s *InspectReplacingPhraseContext) AllInspectReplacingCharacters() []IInspectReplacingCharactersContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectReplacingCharactersContext)(nil)).Elem())
	var tst = make([]IInspectReplacingCharactersContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectReplacingCharactersContext)
		}
	}

	return tst
}

func (s *InspectReplacingPhraseContext) InspectReplacingCharacters(i int) IInspectReplacingCharactersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectReplacingCharactersContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectReplacingCharactersContext)
}

func (s *InspectReplacingPhraseContext) AllInspectReplacingAllLeadings() []IInspectReplacingAllLeadingsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectReplacingAllLeadingsContext)(nil)).Elem())
	var tst = make([]IInspectReplacingAllLeadingsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectReplacingAllLeadingsContext)
		}
	}

	return tst
}

func (s *InspectReplacingPhraseContext) InspectReplacingAllLeadings(i int) IInspectReplacingAllLeadingsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectReplacingAllLeadingsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectReplacingAllLeadingsContext)
}

func (s *InspectReplacingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectReplacingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectReplacingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectReplacingPhrase(s)
	}
}

func (s *InspectReplacingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectReplacingPhrase(s)
	}
}

func (s *InspectReplacingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectReplacingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectReplacingPhrase() (localctx IInspectReplacingPhraseContext) {
	localctx = NewInspectReplacingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, Cobol85ParserRULE_inspectReplacingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4364)
		p.Match(Cobol85ParserREPLACING)
	}
	p.SetState(4367)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserALL || _la == Cobol85ParserCHARACTERS || _la == Cobol85ParserFIRST || _la == Cobol85ParserLEADING {
		p.SetState(4367)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserCHARACTERS:
			{
				p.SetState(4365)
				p.InspectReplacingCharacters()
			}

		case Cobol85ParserALL, Cobol85ParserFIRST, Cobol85ParserLEADING:
			{
				p.SetState(4366)
				p.InspectReplacingAllLeadings()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4369)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectTallyingReplacingPhraseContext is an interface to support dynamic dispatch.
type IInspectTallyingReplacingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectTallyingReplacingPhraseContext differentiates from other interfaces.
	IsInspectTallyingReplacingPhraseContext()
}

type InspectTallyingReplacingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectTallyingReplacingPhraseContext() *InspectTallyingReplacingPhraseContext {
	var p = new(InspectTallyingReplacingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectTallyingReplacingPhrase
	return p
}

func (*InspectTallyingReplacingPhraseContext) IsInspectTallyingReplacingPhraseContext() {}

func NewInspectTallyingReplacingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectTallyingReplacingPhraseContext {
	var p = new(InspectTallyingReplacingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectTallyingReplacingPhrase

	return p
}

func (s *InspectTallyingReplacingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectTallyingReplacingPhraseContext) TALLYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTALLYING, 0)
}

func (s *InspectTallyingReplacingPhraseContext) AllInspectFor() []IInspectForContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectForContext)(nil)).Elem())
	var tst = make([]IInspectForContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectForContext)
		}
	}

	return tst
}

func (s *InspectTallyingReplacingPhraseContext) InspectFor(i int) IInspectForContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectForContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectForContext)
}

func (s *InspectTallyingReplacingPhraseContext) AllInspectReplacingPhrase() []IInspectReplacingPhraseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectReplacingPhraseContext)(nil)).Elem())
	var tst = make([]IInspectReplacingPhraseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectReplacingPhraseContext)
		}
	}

	return tst
}

func (s *InspectTallyingReplacingPhraseContext) InspectReplacingPhrase(i int) IInspectReplacingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectReplacingPhraseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectReplacingPhraseContext)
}

func (s *InspectTallyingReplacingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectTallyingReplacingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectTallyingReplacingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectTallyingReplacingPhrase(s)
	}
}

func (s *InspectTallyingReplacingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectTallyingReplacingPhrase(s)
	}
}

func (s *InspectTallyingReplacingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectTallyingReplacingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectTallyingReplacingPhrase() (localctx IInspectTallyingReplacingPhraseContext) {
	localctx = NewInspectTallyingReplacingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, Cobol85ParserRULE_inspectTallyingReplacingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4371)
		p.Match(Cobol85ParserTALLYING)
	}
	p.SetState(4373)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(4372)
			p.InspectFor()
		}

		p.SetState(4375)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4378)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserREPLACING {
		{
			p.SetState(4377)
			p.InspectReplacingPhrase()
		}

		p.SetState(4380)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectConvertingPhraseContext is an interface to support dynamic dispatch.
type IInspectConvertingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectConvertingPhraseContext differentiates from other interfaces.
	IsInspectConvertingPhraseContext()
}

type InspectConvertingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectConvertingPhraseContext() *InspectConvertingPhraseContext {
	var p = new(InspectConvertingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectConvertingPhrase
	return p
}

func (*InspectConvertingPhraseContext) IsInspectConvertingPhraseContext() {}

func NewInspectConvertingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectConvertingPhraseContext {
	var p = new(InspectConvertingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectConvertingPhrase

	return p
}

func (s *InspectConvertingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectConvertingPhraseContext) CONVERTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONVERTING, 0)
}

func (s *InspectConvertingPhraseContext) InspectTo() IInspectToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInspectToContext)
}

func (s *InspectConvertingPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectConvertingPhraseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectConvertingPhraseContext) AllInspectBeforeAfter() []IInspectBeforeAfterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem())
	var tst = make([]IInspectBeforeAfterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectBeforeAfterContext)
		}
	}

	return tst
}

func (s *InspectConvertingPhraseContext) InspectBeforeAfter(i int) IInspectBeforeAfterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectBeforeAfterContext)
}

func (s *InspectConvertingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectConvertingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectConvertingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectConvertingPhrase(s)
	}
}

func (s *InspectConvertingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectConvertingPhrase(s)
	}
}

func (s *InspectConvertingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectConvertingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectConvertingPhrase() (localctx IInspectConvertingPhraseContext) {
	localctx = NewInspectConvertingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, Cobol85ParserRULE_inspectConvertingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4382)
		p.Match(Cobol85ParserCONVERTING)
	}
	p.SetState(4385)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 622, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4383)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4384)
			p.Literal()
		}

	}
	{
		p.SetState(4387)
		p.InspectTo()
	}
	p.SetState(4391)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(4388)
			p.InspectBeforeAfter()
		}

		p.SetState(4393)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectForContext is an interface to support dynamic dispatch.
type IInspectForContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectForContext differentiates from other interfaces.
	IsInspectForContext()
}

type InspectForContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectForContext() *InspectForContext {
	var p = new(InspectForContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectFor
	return p
}

func (*InspectForContext) IsInspectForContext() {}

func NewInspectForContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectForContext {
	var p = new(InspectForContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectFor

	return p
}

func (s *InspectForContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectForContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectForContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *InspectForContext) AllInspectCharacters() []IInspectCharactersContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectCharactersContext)(nil)).Elem())
	var tst = make([]IInspectCharactersContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectCharactersContext)
		}
	}

	return tst
}

func (s *InspectForContext) InspectCharacters(i int) IInspectCharactersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectCharactersContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectCharactersContext)
}

func (s *InspectForContext) AllInspectAllLeadings() []IInspectAllLeadingsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectAllLeadingsContext)(nil)).Elem())
	var tst = make([]IInspectAllLeadingsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectAllLeadingsContext)
		}
	}

	return tst
}

func (s *InspectForContext) InspectAllLeadings(i int) IInspectAllLeadingsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectAllLeadingsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectAllLeadingsContext)
}

func (s *InspectForContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectForContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectForContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectFor(s)
	}
}

func (s *InspectForContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectFor(s)
	}
}

func (s *InspectForContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectFor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectFor() (localctx IInspectForContext) {
	localctx = NewInspectForContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, Cobol85ParserRULE_inspectFor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4394)
		p.Identifier()
	}
	{
		p.SetState(4395)
		p.Match(Cobol85ParserFOR)
	}
	p.SetState(4398)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserALL || _la == Cobol85ParserCHARACTERS || _la == Cobol85ParserLEADING {
		p.SetState(4398)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserCHARACTERS:
			{
				p.SetState(4396)
				p.InspectCharacters()
			}

		case Cobol85ParserALL, Cobol85ParserLEADING:
			{
				p.SetState(4397)
				p.InspectAllLeadings()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4400)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectCharactersContext is an interface to support dynamic dispatch.
type IInspectCharactersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectCharactersContext differentiates from other interfaces.
	IsInspectCharactersContext()
}

type InspectCharactersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectCharactersContext() *InspectCharactersContext {
	var p = new(InspectCharactersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectCharacters
	return p
}

func (*InspectCharactersContext) IsInspectCharactersContext() {}

func NewInspectCharactersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectCharactersContext {
	var p = new(InspectCharactersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectCharacters

	return p
}

func (s *InspectCharactersContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectCharactersContext) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *InspectCharactersContext) AllInspectBeforeAfter() []IInspectBeforeAfterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem())
	var tst = make([]IInspectBeforeAfterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectBeforeAfterContext)
		}
	}

	return tst
}

func (s *InspectCharactersContext) InspectBeforeAfter(i int) IInspectBeforeAfterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectBeforeAfterContext)
}

func (s *InspectCharactersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectCharactersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectCharactersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectCharacters(s)
	}
}

func (s *InspectCharactersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectCharacters(s)
	}
}

func (s *InspectCharactersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectCharacters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectCharacters() (localctx IInspectCharactersContext) {
	localctx = NewInspectCharactersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, Cobol85ParserRULE_inspectCharacters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4402)
		p.Match(Cobol85ParserCHARACTERS)
	}
	p.SetState(4406)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(4403)
			p.InspectBeforeAfter()
		}

		p.SetState(4408)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectReplacingCharactersContext is an interface to support dynamic dispatch.
type IInspectReplacingCharactersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectReplacingCharactersContext differentiates from other interfaces.
	IsInspectReplacingCharactersContext()
}

type InspectReplacingCharactersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectReplacingCharactersContext() *InspectReplacingCharactersContext {
	var p = new(InspectReplacingCharactersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingCharacters
	return p
}

func (*InspectReplacingCharactersContext) IsInspectReplacingCharactersContext() {}

func NewInspectReplacingCharactersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectReplacingCharactersContext {
	var p = new(InspectReplacingCharactersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingCharacters

	return p
}

func (s *InspectReplacingCharactersContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectReplacingCharactersContext) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *InspectReplacingCharactersContext) InspectBy() IInspectByContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectByContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInspectByContext)
}

func (s *InspectReplacingCharactersContext) AllInspectBeforeAfter() []IInspectBeforeAfterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem())
	var tst = make([]IInspectBeforeAfterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectBeforeAfterContext)
		}
	}

	return tst
}

func (s *InspectReplacingCharactersContext) InspectBeforeAfter(i int) IInspectBeforeAfterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectBeforeAfterContext)
}

func (s *InspectReplacingCharactersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectReplacingCharactersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectReplacingCharactersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectReplacingCharacters(s)
	}
}

func (s *InspectReplacingCharactersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectReplacingCharacters(s)
	}
}

func (s *InspectReplacingCharactersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectReplacingCharacters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectReplacingCharacters() (localctx IInspectReplacingCharactersContext) {
	localctx = NewInspectReplacingCharactersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, Cobol85ParserRULE_inspectReplacingCharacters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4409)
		p.Match(Cobol85ParserCHARACTERS)
	}
	{
		p.SetState(4410)
		p.InspectBy()
	}
	p.SetState(4414)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(4411)
			p.InspectBeforeAfter()
		}

		p.SetState(4416)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectAllLeadingsContext is an interface to support dynamic dispatch.
type IInspectAllLeadingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectAllLeadingsContext differentiates from other interfaces.
	IsInspectAllLeadingsContext()
}

type InspectAllLeadingsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectAllLeadingsContext() *InspectAllLeadingsContext {
	var p = new(InspectAllLeadingsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectAllLeadings
	return p
}

func (*InspectAllLeadingsContext) IsInspectAllLeadingsContext() {}

func NewInspectAllLeadingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectAllLeadingsContext {
	var p = new(InspectAllLeadingsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectAllLeadings

	return p
}

func (s *InspectAllLeadingsContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectAllLeadingsContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *InspectAllLeadingsContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *InspectAllLeadingsContext) AllInspectAllLeading() []IInspectAllLeadingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectAllLeadingContext)(nil)).Elem())
	var tst = make([]IInspectAllLeadingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectAllLeadingContext)
		}
	}

	return tst
}

func (s *InspectAllLeadingsContext) InspectAllLeading(i int) IInspectAllLeadingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectAllLeadingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectAllLeadingContext)
}

func (s *InspectAllLeadingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectAllLeadingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectAllLeadingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectAllLeadings(s)
	}
}

func (s *InspectAllLeadingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectAllLeadings(s)
	}
}

func (s *InspectAllLeadingsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectAllLeadings(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectAllLeadings() (localctx IInspectAllLeadingsContext) {
	localctx = NewInspectAllLeadingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, Cobol85ParserRULE_inspectAllLeadings)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4417)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserALL || _la == Cobol85ParserLEADING) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(4419)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4418)
				p.InspectAllLeading()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4421)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 628, p.GetParserRuleContext())
	}

	return localctx
}

// IInspectReplacingAllLeadingsContext is an interface to support dynamic dispatch.
type IInspectReplacingAllLeadingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectReplacingAllLeadingsContext differentiates from other interfaces.
	IsInspectReplacingAllLeadingsContext()
}

type InspectReplacingAllLeadingsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectReplacingAllLeadingsContext() *InspectReplacingAllLeadingsContext {
	var p = new(InspectReplacingAllLeadingsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingAllLeadings
	return p
}

func (*InspectReplacingAllLeadingsContext) IsInspectReplacingAllLeadingsContext() {}

func NewInspectReplacingAllLeadingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectReplacingAllLeadingsContext {
	var p = new(InspectReplacingAllLeadingsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingAllLeadings

	return p
}

func (s *InspectReplacingAllLeadingsContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectReplacingAllLeadingsContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *InspectReplacingAllLeadingsContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *InspectReplacingAllLeadingsContext) FIRST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFIRST, 0)
}

func (s *InspectReplacingAllLeadingsContext) AllInspectReplacingAllLeading() []IInspectReplacingAllLeadingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectReplacingAllLeadingContext)(nil)).Elem())
	var tst = make([]IInspectReplacingAllLeadingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectReplacingAllLeadingContext)
		}
	}

	return tst
}

func (s *InspectReplacingAllLeadingsContext) InspectReplacingAllLeading(i int) IInspectReplacingAllLeadingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectReplacingAllLeadingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectReplacingAllLeadingContext)
}

func (s *InspectReplacingAllLeadingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectReplacingAllLeadingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectReplacingAllLeadingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectReplacingAllLeadings(s)
	}
}

func (s *InspectReplacingAllLeadingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectReplacingAllLeadings(s)
	}
}

func (s *InspectReplacingAllLeadingsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectReplacingAllLeadings(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectReplacingAllLeadings() (localctx IInspectReplacingAllLeadingsContext) {
	localctx = NewInspectReplacingAllLeadingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, Cobol85ParserRULE_inspectReplacingAllLeadings)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4423)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserALL || _la == Cobol85ParserFIRST || _la == Cobol85ParserLEADING) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(4425)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4424)
				p.InspectReplacingAllLeading()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4427)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 629, p.GetParserRuleContext())
	}

	return localctx
}

// IInspectAllLeadingContext is an interface to support dynamic dispatch.
type IInspectAllLeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectAllLeadingContext differentiates from other interfaces.
	IsInspectAllLeadingContext()
}

type InspectAllLeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectAllLeadingContext() *InspectAllLeadingContext {
	var p = new(InspectAllLeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectAllLeading
	return p
}

func (*InspectAllLeadingContext) IsInspectAllLeadingContext() {}

func NewInspectAllLeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectAllLeadingContext {
	var p = new(InspectAllLeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectAllLeading

	return p
}

func (s *InspectAllLeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectAllLeadingContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectAllLeadingContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectAllLeadingContext) AllInspectBeforeAfter() []IInspectBeforeAfterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem())
	var tst = make([]IInspectBeforeAfterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectBeforeAfterContext)
		}
	}

	return tst
}

func (s *InspectAllLeadingContext) InspectBeforeAfter(i int) IInspectBeforeAfterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectBeforeAfterContext)
}

func (s *InspectAllLeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectAllLeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectAllLeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectAllLeading(s)
	}
}

func (s *InspectAllLeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectAllLeading(s)
	}
}

func (s *InspectAllLeadingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectAllLeading(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectAllLeading() (localctx IInspectAllLeadingContext) {
	localctx = NewInspectAllLeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, Cobol85ParserRULE_inspectAllLeading)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4431)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 630, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4429)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4430)
			p.Literal()
		}

	}
	p.SetState(4436)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(4433)
			p.InspectBeforeAfter()
		}

		p.SetState(4438)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectReplacingAllLeadingContext is an interface to support dynamic dispatch.
type IInspectReplacingAllLeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectReplacingAllLeadingContext differentiates from other interfaces.
	IsInspectReplacingAllLeadingContext()
}

type InspectReplacingAllLeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectReplacingAllLeadingContext() *InspectReplacingAllLeadingContext {
	var p = new(InspectReplacingAllLeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingAllLeading
	return p
}

func (*InspectReplacingAllLeadingContext) IsInspectReplacingAllLeadingContext() {}

func NewInspectReplacingAllLeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectReplacingAllLeadingContext {
	var p = new(InspectReplacingAllLeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingAllLeading

	return p
}

func (s *InspectReplacingAllLeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectReplacingAllLeadingContext) InspectBy() IInspectByContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectByContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInspectByContext)
}

func (s *InspectReplacingAllLeadingContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectReplacingAllLeadingContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectReplacingAllLeadingContext) AllInspectBeforeAfter() []IInspectBeforeAfterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem())
	var tst = make([]IInspectBeforeAfterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectBeforeAfterContext)
		}
	}

	return tst
}

func (s *InspectReplacingAllLeadingContext) InspectBeforeAfter(i int) IInspectBeforeAfterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectBeforeAfterContext)
}

func (s *InspectReplacingAllLeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectReplacingAllLeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectReplacingAllLeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectReplacingAllLeading(s)
	}
}

func (s *InspectReplacingAllLeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectReplacingAllLeading(s)
	}
}

func (s *InspectReplacingAllLeadingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectReplacingAllLeading(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectReplacingAllLeading() (localctx IInspectReplacingAllLeadingContext) {
	localctx = NewInspectReplacingAllLeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, Cobol85ParserRULE_inspectReplacingAllLeading)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4441)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 632, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4439)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4440)
			p.Literal()
		}

	}
	{
		p.SetState(4443)
		p.InspectBy()
	}
	p.SetState(4447)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(4444)
			p.InspectBeforeAfter()
		}

		p.SetState(4449)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectByContext is an interface to support dynamic dispatch.
type IInspectByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectByContext differentiates from other interfaces.
	IsInspectByContext()
}

type InspectByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectByContext() *InspectByContext {
	var p = new(InspectByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectBy
	return p
}

func (*InspectByContext) IsInspectByContext() {}

func NewInspectByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectByContext {
	var p = new(InspectByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectBy

	return p
}

func (s *InspectByContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectByContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *InspectByContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectByContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectBy(s)
	}
}

func (s *InspectByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectBy(s)
	}
}

func (s *InspectByContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectBy(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectBy() (localctx IInspectByContext) {
	localctx = NewInspectByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, Cobol85ParserRULE_inspectBy)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4450)
		p.Match(Cobol85ParserBY)
	}
	p.SetState(4453)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 634, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4451)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4452)
			p.Literal()
		}

	}

	return localctx
}

// IInspectToContext is an interface to support dynamic dispatch.
type IInspectToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectToContext differentiates from other interfaces.
	IsInspectToContext()
}

type InspectToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectToContext() *InspectToContext {
	var p = new(InspectToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectTo
	return p
}

func (*InspectToContext) IsInspectToContext() {}

func NewInspectToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectToContext {
	var p = new(InspectToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectTo

	return p
}

func (s *InspectToContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectToContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *InspectToContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectToContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectTo(s)
	}
}

func (s *InspectToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectTo(s)
	}
}

func (s *InspectToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectTo() (localctx IInspectToContext) {
	localctx = NewInspectToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, Cobol85ParserRULE_inspectTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4455)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(4458)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 635, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4456)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4457)
			p.Literal()
		}

	}

	return localctx
}

// IInspectBeforeAfterContext is an interface to support dynamic dispatch.
type IInspectBeforeAfterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectBeforeAfterContext differentiates from other interfaces.
	IsInspectBeforeAfterContext()
}

type InspectBeforeAfterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectBeforeAfterContext() *InspectBeforeAfterContext {
	var p = new(InspectBeforeAfterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectBeforeAfter
	return p
}

func (*InspectBeforeAfterContext) IsInspectBeforeAfterContext() {}

func NewInspectBeforeAfterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectBeforeAfterContext {
	var p = new(InspectBeforeAfterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectBeforeAfter

	return p
}

func (s *InspectBeforeAfterContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectBeforeAfterContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEFORE, 0)
}

func (s *InspectBeforeAfterContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *InspectBeforeAfterContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectBeforeAfterContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectBeforeAfterContext) INITIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIAL, 0)
}

func (s *InspectBeforeAfterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectBeforeAfterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectBeforeAfterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectBeforeAfter(s)
	}
}

func (s *InspectBeforeAfterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectBeforeAfter(s)
	}
}

func (s *InspectBeforeAfterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectBeforeAfter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectBeforeAfter() (localctx IInspectBeforeAfterContext) {
	localctx = NewInspectBeforeAfterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, Cobol85ParserRULE_inspectBeforeAfter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4460)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(4462)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINITIAL {
		{
			p.SetState(4461)
			p.Match(Cobol85ParserINITIAL)
		}

	}
	p.SetState(4466)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 637, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4464)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4465)
			p.Literal()
		}

	}

	return localctx
}

// IMergeStatementContext is an interface to support dynamic dispatch.
type IMergeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeStatementContext differentiates from other interfaces.
	IsMergeStatementContext()
}

type MergeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeStatementContext() *MergeStatementContext {
	var p = new(MergeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeStatement
	return p
}

func (*MergeStatementContext) IsMergeStatementContext() {}

func NewMergeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeStatementContext {
	var p = new(MergeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeStatement

	return p
}

func (s *MergeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeStatementContext) MERGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMERGE, 0)
}

func (s *MergeStatementContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *MergeStatementContext) AllMergeOnKeyClause() []IMergeOnKeyClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMergeOnKeyClauseContext)(nil)).Elem())
	var tst = make([]IMergeOnKeyClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMergeOnKeyClauseContext)
		}
	}

	return tst
}

func (s *MergeStatementContext) MergeOnKeyClause(i int) IMergeOnKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeOnKeyClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMergeOnKeyClauseContext)
}

func (s *MergeStatementContext) MergeCollatingSequencePhrase() IMergeCollatingSequencePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeCollatingSequencePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMergeCollatingSequencePhraseContext)
}

func (s *MergeStatementContext) AllMergeUsing() []IMergeUsingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMergeUsingContext)(nil)).Elem())
	var tst = make([]IMergeUsingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMergeUsingContext)
		}
	}

	return tst
}

func (s *MergeStatementContext) MergeUsing(i int) IMergeUsingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeUsingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMergeUsingContext)
}

func (s *MergeStatementContext) MergeOutputProcedurePhrase() IMergeOutputProcedurePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeOutputProcedurePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMergeOutputProcedurePhraseContext)
}

func (s *MergeStatementContext) AllMergeGivingPhrase() []IMergeGivingPhraseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMergeGivingPhraseContext)(nil)).Elem())
	var tst = make([]IMergeGivingPhraseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMergeGivingPhraseContext)
		}
	}

	return tst
}

func (s *MergeStatementContext) MergeGivingPhrase(i int) IMergeGivingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeGivingPhraseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMergeGivingPhraseContext)
}

func (s *MergeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeStatement(s)
	}
}

func (s *MergeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeStatement(s)
	}
}

func (s *MergeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeStatement() (localctx IMergeStatementContext) {
	localctx = NewMergeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, Cobol85ParserRULE_mergeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4468)
		p.Match(Cobol85ParserMERGE)
	}
	{
		p.SetState(4469)
		p.FileName()
	}
	p.SetState(4471)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4470)
				p.MergeOnKeyClause()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4473)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 638, p.GetParserRuleContext())
	}
	p.SetState(4476)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOLLATING || _la == Cobol85ParserSEQUENCE {
		{
			p.SetState(4475)
			p.MergeCollatingSequencePhrase()
		}

	}
	p.SetState(4481)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserUSING {
		{
			p.SetState(4478)
			p.MergeUsing()
		}

		p.SetState(4483)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4485)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOUTPUT {
		{
			p.SetState(4484)
			p.MergeOutputProcedurePhrase()
		}

	}
	p.SetState(4490)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserGIVING {
		{
			p.SetState(4487)
			p.MergeGivingPhrase()
		}

		p.SetState(4492)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMergeOnKeyClauseContext is an interface to support dynamic dispatch.
type IMergeOnKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeOnKeyClauseContext differentiates from other interfaces.
	IsMergeOnKeyClauseContext()
}

type MergeOnKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeOnKeyClauseContext() *MergeOnKeyClauseContext {
	var p = new(MergeOnKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeOnKeyClause
	return p
}

func (*MergeOnKeyClauseContext) IsMergeOnKeyClauseContext() {}

func NewMergeOnKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeOnKeyClauseContext {
	var p = new(MergeOnKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeOnKeyClause

	return p
}

func (s *MergeOnKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeOnKeyClauseContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASCENDING, 0)
}

func (s *MergeOnKeyClauseContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESCENDING, 0)
}

func (s *MergeOnKeyClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *MergeOnKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *MergeOnKeyClauseContext) AllQualifiedDataName() []IQualifiedDataNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem())
	var tst = make([]IQualifiedDataNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedDataNameContext)
		}
	}

	return tst
}

func (s *MergeOnKeyClauseContext) QualifiedDataName(i int) IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *MergeOnKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeOnKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeOnKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeOnKeyClause(s)
	}
}

func (s *MergeOnKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeOnKeyClause(s)
	}
}

func (s *MergeOnKeyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeOnKeyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeOnKeyClause() (localctx IMergeOnKeyClauseContext) {
	localctx = NewMergeOnKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, Cobol85ParserRULE_mergeOnKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4494)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(4493)
			p.Match(Cobol85ParserON)
		}

	}
	p.SetState(4496)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserASCENDING || _la == Cobol85ParserDESCENDING) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(4498)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(4497)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(4501)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(4500)
			p.QualifiedDataName()
		}

		p.SetState(4503)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMergeCollatingSequencePhraseContext is an interface to support dynamic dispatch.
type IMergeCollatingSequencePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeCollatingSequencePhraseContext differentiates from other interfaces.
	IsMergeCollatingSequencePhraseContext()
}

type MergeCollatingSequencePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeCollatingSequencePhraseContext() *MergeCollatingSequencePhraseContext {
	var p = new(MergeCollatingSequencePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingSequencePhrase
	return p
}

func (*MergeCollatingSequencePhraseContext) IsMergeCollatingSequencePhraseContext() {}

func NewMergeCollatingSequencePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeCollatingSequencePhraseContext {
	var p = new(MergeCollatingSequencePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingSequencePhrase

	return p
}

func (s *MergeCollatingSequencePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeCollatingSequencePhraseContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEQUENCE, 0)
}

func (s *MergeCollatingSequencePhraseContext) COLLATING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLLATING, 0)
}

func (s *MergeCollatingSequencePhraseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MergeCollatingSequencePhraseContext) AllAlphabetName() []IAlphabetNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem())
	var tst = make([]IAlphabetNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlphabetNameContext)
		}
	}

	return tst
}

func (s *MergeCollatingSequencePhraseContext) AlphabetName(i int) IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *MergeCollatingSequencePhraseContext) MergeCollatingAlphanumeric() IMergeCollatingAlphanumericContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeCollatingAlphanumericContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMergeCollatingAlphanumericContext)
}

func (s *MergeCollatingSequencePhraseContext) MergeCollatingNational() IMergeCollatingNationalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeCollatingNationalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMergeCollatingNationalContext)
}

func (s *MergeCollatingSequencePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeCollatingSequencePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeCollatingSequencePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeCollatingSequencePhrase(s)
	}
}

func (s *MergeCollatingSequencePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeCollatingSequencePhrase(s)
	}
}

func (s *MergeCollatingSequencePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeCollatingSequencePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeCollatingSequencePhrase() (localctx IMergeCollatingSequencePhraseContext) {
	localctx = NewMergeCollatingSequencePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, Cobol85ParserRULE_mergeCollatingSequencePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4506)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOLLATING {
		{
			p.SetState(4505)
			p.Match(Cobol85ParserCOLLATING)
		}

	}
	{
		p.SetState(4508)
		p.Match(Cobol85ParserSEQUENCE)
	}
	p.SetState(4510)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(4509)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(4513)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4512)
				p.AlphabetName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4515)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 648, p.GetParserRuleContext())
	}
	p.SetState(4518)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 649, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4517)
			p.MergeCollatingAlphanumeric()
		}

	}
	p.SetState(4521)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR || _la == Cobol85ParserNATIONAL {
		{
			p.SetState(4520)
			p.MergeCollatingNational()
		}

	}

	return localctx
}

// IMergeCollatingAlphanumericContext is an interface to support dynamic dispatch.
type IMergeCollatingAlphanumericContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeCollatingAlphanumericContext differentiates from other interfaces.
	IsMergeCollatingAlphanumericContext()
}

type MergeCollatingAlphanumericContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeCollatingAlphanumericContext() *MergeCollatingAlphanumericContext {
	var p = new(MergeCollatingAlphanumericContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingAlphanumeric
	return p
}

func (*MergeCollatingAlphanumericContext) IsMergeCollatingAlphanumericContext() {}

func NewMergeCollatingAlphanumericContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeCollatingAlphanumericContext {
	var p = new(MergeCollatingAlphanumericContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingAlphanumeric

	return p
}

func (s *MergeCollatingAlphanumericContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeCollatingAlphanumericContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *MergeCollatingAlphanumericContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MergeCollatingAlphanumericContext) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *MergeCollatingAlphanumericContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *MergeCollatingAlphanumericContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeCollatingAlphanumericContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeCollatingAlphanumericContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeCollatingAlphanumeric(s)
	}
}

func (s *MergeCollatingAlphanumericContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeCollatingAlphanumeric(s)
	}
}

func (s *MergeCollatingAlphanumericContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeCollatingAlphanumeric(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeCollatingAlphanumeric() (localctx IMergeCollatingAlphanumericContext) {
	localctx = NewMergeCollatingAlphanumericContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, Cobol85ParserRULE_mergeCollatingAlphanumeric)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4524)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(4523)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(4526)
		p.Match(Cobol85ParserALPHANUMERIC)
	}
	{
		p.SetState(4527)
		p.Match(Cobol85ParserIS)
	}
	{
		p.SetState(4528)
		p.AlphabetName()
	}

	return localctx
}

// IMergeCollatingNationalContext is an interface to support dynamic dispatch.
type IMergeCollatingNationalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeCollatingNationalContext differentiates from other interfaces.
	IsMergeCollatingNationalContext()
}

type MergeCollatingNationalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeCollatingNationalContext() *MergeCollatingNationalContext {
	var p = new(MergeCollatingNationalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingNational
	return p
}

func (*MergeCollatingNationalContext) IsMergeCollatingNationalContext() {}

func NewMergeCollatingNationalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeCollatingNationalContext {
	var p = new(MergeCollatingNationalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingNational

	return p
}

func (s *MergeCollatingNationalContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeCollatingNationalContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *MergeCollatingNationalContext) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *MergeCollatingNationalContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *MergeCollatingNationalContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MergeCollatingNationalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeCollatingNationalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeCollatingNationalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeCollatingNational(s)
	}
}

func (s *MergeCollatingNationalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeCollatingNational(s)
	}
}

func (s *MergeCollatingNationalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeCollatingNational(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeCollatingNational() (localctx IMergeCollatingNationalContext) {
	localctx = NewMergeCollatingNationalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, Cobol85ParserRULE_mergeCollatingNational)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4531)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(4530)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(4533)
		p.Match(Cobol85ParserNATIONAL)
	}
	p.SetState(4535)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(4534)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(4537)
		p.AlphabetName()
	}

	return localctx
}

// IMergeUsingContext is an interface to support dynamic dispatch.
type IMergeUsingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeUsingContext differentiates from other interfaces.
	IsMergeUsingContext()
}

type MergeUsingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeUsingContext() *MergeUsingContext {
	var p = new(MergeUsingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeUsing
	return p
}

func (*MergeUsingContext) IsMergeUsingContext() {}

func NewMergeUsingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeUsingContext {
	var p = new(MergeUsingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeUsing

	return p
}

func (s *MergeUsingContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeUsingContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *MergeUsingContext) AllFileName() []IFileNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileNameContext)(nil)).Elem())
	var tst = make([]IFileNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileNameContext)
		}
	}

	return tst
}

func (s *MergeUsingContext) FileName(i int) IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *MergeUsingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeUsingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeUsingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeUsing(s)
	}
}

func (s *MergeUsingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeUsing(s)
	}
}

func (s *MergeUsingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeUsing(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeUsing() (localctx IMergeUsingContext) {
	localctx = NewMergeUsingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, Cobol85ParserRULE_mergeUsing)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4539)
		p.Match(Cobol85ParserUSING)
	}
	p.SetState(4541)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4540)
			p.FileName()
		}

		p.SetState(4543)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMergeOutputProcedurePhraseContext is an interface to support dynamic dispatch.
type IMergeOutputProcedurePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeOutputProcedurePhraseContext differentiates from other interfaces.
	IsMergeOutputProcedurePhraseContext()
}

type MergeOutputProcedurePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeOutputProcedurePhraseContext() *MergeOutputProcedurePhraseContext {
	var p = new(MergeOutputProcedurePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeOutputProcedurePhrase
	return p
}

func (*MergeOutputProcedurePhraseContext) IsMergeOutputProcedurePhraseContext() {}

func NewMergeOutputProcedurePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeOutputProcedurePhraseContext {
	var p = new(MergeOutputProcedurePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeOutputProcedurePhrase

	return p
}

func (s *MergeOutputProcedurePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeOutputProcedurePhraseContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *MergeOutputProcedurePhraseContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE, 0)
}

func (s *MergeOutputProcedurePhraseContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *MergeOutputProcedurePhraseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MergeOutputProcedurePhraseContext) MergeOutputThrough() IMergeOutputThroughContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeOutputThroughContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMergeOutputThroughContext)
}

func (s *MergeOutputProcedurePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeOutputProcedurePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeOutputProcedurePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeOutputProcedurePhrase(s)
	}
}

func (s *MergeOutputProcedurePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeOutputProcedurePhrase(s)
	}
}

func (s *MergeOutputProcedurePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeOutputProcedurePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeOutputProcedurePhrase() (localctx IMergeOutputProcedurePhraseContext) {
	localctx = NewMergeOutputProcedurePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, Cobol85ParserRULE_mergeOutputProcedurePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4545)
		p.Match(Cobol85ParserOUTPUT)
	}
	{
		p.SetState(4546)
		p.Match(Cobol85ParserPROCEDURE)
	}
	p.SetState(4548)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(4547)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(4550)
		p.ProcedureName()
	}
	p.SetState(4552)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(4551)
			p.MergeOutputThrough()
		}

	}

	return localctx
}

// IMergeOutputThroughContext is an interface to support dynamic dispatch.
type IMergeOutputThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeOutputThroughContext differentiates from other interfaces.
	IsMergeOutputThroughContext()
}

type MergeOutputThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeOutputThroughContext() *MergeOutputThroughContext {
	var p = new(MergeOutputThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeOutputThrough
	return p
}

func (*MergeOutputThroughContext) IsMergeOutputThroughContext() {}

func NewMergeOutputThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeOutputThroughContext {
	var p = new(MergeOutputThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeOutputThrough

	return p
}

func (s *MergeOutputThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeOutputThroughContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *MergeOutputThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *MergeOutputThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *MergeOutputThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeOutputThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeOutputThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeOutputThrough(s)
	}
}

func (s *MergeOutputThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeOutputThrough(s)
	}
}

func (s *MergeOutputThroughContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeOutputThrough(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeOutputThrough() (localctx IMergeOutputThroughContext) {
	localctx = NewMergeOutputThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, Cobol85ParserRULE_mergeOutputThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4554)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(4555)
		p.ProcedureName()
	}

	return localctx
}

// IMergeGivingPhraseContext is an interface to support dynamic dispatch.
type IMergeGivingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeGivingPhraseContext differentiates from other interfaces.
	IsMergeGivingPhraseContext()
}

type MergeGivingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeGivingPhraseContext() *MergeGivingPhraseContext {
	var p = new(MergeGivingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeGivingPhrase
	return p
}

func (*MergeGivingPhraseContext) IsMergeGivingPhraseContext() {}

func NewMergeGivingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeGivingPhraseContext {
	var p = new(MergeGivingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeGivingPhrase

	return p
}

func (s *MergeGivingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeGivingPhraseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *MergeGivingPhraseContext) AllMergeGiving() []IMergeGivingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMergeGivingContext)(nil)).Elem())
	var tst = make([]IMergeGivingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMergeGivingContext)
		}
	}

	return tst
}

func (s *MergeGivingPhraseContext) MergeGiving(i int) IMergeGivingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeGivingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMergeGivingContext)
}

func (s *MergeGivingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeGivingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeGivingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeGivingPhrase(s)
	}
}

func (s *MergeGivingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeGivingPhrase(s)
	}
}

func (s *MergeGivingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeGivingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeGivingPhrase() (localctx IMergeGivingPhraseContext) {
	localctx = NewMergeGivingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, Cobol85ParserRULE_mergeGivingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4557)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(4559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4558)
			p.MergeGiving()
		}

		p.SetState(4561)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMergeGivingContext is an interface to support dynamic dispatch.
type IMergeGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeGivingContext differentiates from other interfaces.
	IsMergeGivingContext()
}

type MergeGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeGivingContext() *MergeGivingContext {
	var p = new(MergeGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeGiving
	return p
}

func (*MergeGivingContext) IsMergeGivingContext() {}

func NewMergeGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeGivingContext {
	var p = new(MergeGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeGiving

	return p
}

func (s *MergeGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeGivingContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *MergeGivingContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *MergeGivingContext) SAVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSAVE, 0)
}

func (s *MergeGivingContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *MergeGivingContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *MergeGivingContext) CRUNCH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCRUNCH, 0)
}

func (s *MergeGivingContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRELEASE, 0)
}

func (s *MergeGivingContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *MergeGivingContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOVE, 0)
}

func (s *MergeGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeGiving(s)
	}
}

func (s *MergeGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeGiving(s)
	}
}

func (s *MergeGivingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeGiving(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeGiving() (localctx IMergeGivingContext) {
	localctx = NewMergeGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, Cobol85ParserRULE_mergeGiving)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4563)
		p.FileName()
	}
	p.SetState(4573)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 658, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4564)
			p.Match(Cobol85ParserLOCK)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 658, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(4565)
			p.Match(Cobol85ParserSAVE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 658, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(4566)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(4567)
			p.Match(Cobol85ParserREWIND)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 658, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(4568)
			p.Match(Cobol85ParserCRUNCH)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 658, p.GetParserRuleContext()) == 5 {
		{
			p.SetState(4569)
			p.Match(Cobol85ParserRELEASE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 658, p.GetParserRuleContext()) == 6 {
		{
			p.SetState(4570)
			p.Match(Cobol85ParserWITH)
		}
		{
			p.SetState(4571)
			p.Match(Cobol85ParserREMOVE)
		}
		{
			p.SetState(4572)
			p.Match(Cobol85ParserCRUNCH)
		}

	}

	return localctx
}

// IMoveStatementContext is an interface to support dynamic dispatch.
type IMoveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMoveStatementContext differentiates from other interfaces.
	IsMoveStatementContext()
}

type MoveStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMoveStatementContext() *MoveStatementContext {
	var p = new(MoveStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_moveStatement
	return p
}

func (*MoveStatementContext) IsMoveStatementContext() {}

func NewMoveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MoveStatementContext {
	var p = new(MoveStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_moveStatement

	return p
}

func (s *MoveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MoveStatementContext) MOVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMOVE, 0)
}

func (s *MoveStatementContext) MoveToStatement() IMoveToStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoveToStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMoveToStatementContext)
}

func (s *MoveStatementContext) MoveCorrespondingToStatement() IMoveCorrespondingToStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoveCorrespondingToStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMoveCorrespondingToStatementContext)
}

func (s *MoveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MoveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MoveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMoveStatement(s)
	}
}

func (s *MoveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMoveStatement(s)
	}
}

func (s *MoveStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMoveStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MoveStatement() (localctx IMoveStatementContext) {
	localctx = NewMoveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, Cobol85ParserRULE_moveStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4575)
		p.Match(Cobol85ParserMOVE)
	}
	p.SetState(4578)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserADDRESS, Cobol85ParserALL, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDATE, Cobol85ParserDAY, Cobol85ParserDAY_OF_WEEK, Cobol85ParserDEBUG_CONTENTS, Cobol85ParserDEBUG_ITEM, Cobol85ParserDEBUG_LINE, Cobol85ParserDEBUG_NAME, Cobol85ParserDEBUG_SUB_1, Cobol85ParserDEBUG_SUB_2, Cobol85ParserDEBUG_SUB_3, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFALSE, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTION, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserHIGH_VALUE, Cobol85ParserHIGH_VALUES, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLINAGE_COUNTER, Cobol85ParserLINE_COUNTER, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserLOW_VALUE, Cobol85ParserLOW_VALUES, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNULL, Cobol85ParserNULLS, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPAGE_COUNTER, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserQUOTE, Cobol85ParserQUOTES, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserRETURN_CODE, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHIFT_IN, Cobol85ParserSHIFT_OUT, Cobol85ParserSHORT_DATE, Cobol85ParserSORT_CONTROL, Cobol85ParserSORT_CORE_SIZE, Cobol85ParserSORT_FILE_SIZE, Cobol85ParserSORT_MESSAGE, Cobol85ParserSORT_MODE_SIZE, Cobol85ParserSORT_RETURN, Cobol85ParserSP, Cobol85ParserSPACE, Cobol85ParserSPACES, Cobol85ParserSYMBOL, Cobol85ParserTALLY, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIME, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUE, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserWHEN_COMPILED, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO, Cobol85ParserZERO_FILL, Cobol85ParserZEROS, Cobol85ParserZEROES, Cobol85ParserNONNUMERICLITERAL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserNUMERICLITERAL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(4576)
			p.MoveToStatement()
		}

	case Cobol85ParserCORR, Cobol85ParserCORRESPONDING:
		{
			p.SetState(4577)
			p.MoveCorrespondingToStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMoveToStatementContext is an interface to support dynamic dispatch.
type IMoveToStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMoveToStatementContext differentiates from other interfaces.
	IsMoveToStatementContext()
}

type MoveToStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMoveToStatementContext() *MoveToStatementContext {
	var p = new(MoveToStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_moveToStatement
	return p
}

func (*MoveToStatementContext) IsMoveToStatementContext() {}

func NewMoveToStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MoveToStatementContext {
	var p = new(MoveToStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_moveToStatement

	return p
}

func (s *MoveToStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MoveToStatementContext) MoveToSendingArea() IMoveToSendingAreaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoveToSendingAreaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMoveToSendingAreaContext)
}

func (s *MoveToStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *MoveToStatementContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *MoveToStatementContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MoveToStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MoveToStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MoveToStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMoveToStatement(s)
	}
}

func (s *MoveToStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMoveToStatement(s)
	}
}

func (s *MoveToStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMoveToStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MoveToStatement() (localctx IMoveToStatementContext) {
	localctx = NewMoveToStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, Cobol85ParserRULE_moveToStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4580)
		p.MoveToSendingArea()
	}
	{
		p.SetState(4581)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(4583)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(4582)
			p.Identifier()
		}

		p.SetState(4585)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMoveToSendingAreaContext is an interface to support dynamic dispatch.
type IMoveToSendingAreaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMoveToSendingAreaContext differentiates from other interfaces.
	IsMoveToSendingAreaContext()
}

type MoveToSendingAreaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMoveToSendingAreaContext() *MoveToSendingAreaContext {
	var p = new(MoveToSendingAreaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_moveToSendingArea
	return p
}

func (*MoveToSendingAreaContext) IsMoveToSendingAreaContext() {}

func NewMoveToSendingAreaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MoveToSendingAreaContext {
	var p = new(MoveToSendingAreaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_moveToSendingArea

	return p
}

func (s *MoveToSendingAreaContext) GetParser() antlr.Parser { return s.parser }

func (s *MoveToSendingAreaContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MoveToSendingAreaContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *MoveToSendingAreaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MoveToSendingAreaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MoveToSendingAreaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMoveToSendingArea(s)
	}
}

func (s *MoveToSendingAreaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMoveToSendingArea(s)
	}
}

func (s *MoveToSendingAreaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMoveToSendingArea(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MoveToSendingArea() (localctx IMoveToSendingAreaContext) {
	localctx = NewMoveToSendingAreaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 756, Cobol85ParserRULE_moveToSendingArea)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4589)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 661, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4587)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4588)
			p.Literal()
		}

	}

	return localctx
}

// IMoveCorrespondingToStatementContext is an interface to support dynamic dispatch.
type IMoveCorrespondingToStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMoveCorrespondingToStatementContext differentiates from other interfaces.
	IsMoveCorrespondingToStatementContext()
}

type MoveCorrespondingToStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMoveCorrespondingToStatementContext() *MoveCorrespondingToStatementContext {
	var p = new(MoveCorrespondingToStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_moveCorrespondingToStatement
	return p
}

func (*MoveCorrespondingToStatementContext) IsMoveCorrespondingToStatementContext() {}

func NewMoveCorrespondingToStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MoveCorrespondingToStatementContext {
	var p = new(MoveCorrespondingToStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_moveCorrespondingToStatement

	return p
}

func (s *MoveCorrespondingToStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MoveCorrespondingToStatementContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *MoveCorrespondingToStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *MoveCorrespondingToStatementContext) CORRESPONDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORRESPONDING, 0)
}

func (s *MoveCorrespondingToStatementContext) CORR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORR, 0)
}

func (s *MoveCorrespondingToStatementContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *MoveCorrespondingToStatementContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MoveCorrespondingToStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MoveCorrespondingToStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MoveCorrespondingToStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMoveCorrespondingToStatement(s)
	}
}

func (s *MoveCorrespondingToStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMoveCorrespondingToStatement(s)
	}
}

func (s *MoveCorrespondingToStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMoveCorrespondingToStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MoveCorrespondingToStatement() (localctx IMoveCorrespondingToStatementContext) {
	localctx = NewMoveCorrespondingToStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, Cobol85ParserRULE_moveCorrespondingToStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4591)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserCORR || _la == Cobol85ParserCORRESPONDING) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(4592)
		p.QualifiedDataName()
	}
	{
		p.SetState(4593)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(4595)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(4594)
			p.Identifier()
		}

		p.SetState(4597)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMultiplyStatementContext is an interface to support dynamic dispatch.
type IMultiplyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyStatementContext differentiates from other interfaces.
	IsMultiplyStatementContext()
}

type MultiplyStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyStatementContext() *MultiplyStatementContext {
	var p = new(MultiplyStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyStatement
	return p
}

func (*MultiplyStatementContext) IsMultiplyStatementContext() {}

func NewMultiplyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyStatementContext {
	var p = new(MultiplyStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyStatement

	return p
}

func (s *MultiplyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyStatementContext) MULTIPLY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMULTIPLY, 0)
}

func (s *MultiplyStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *MultiplyStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MultiplyStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *MultiplyStatementContext) MultiplyRegular() IMultiplyRegularContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplyRegularContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiplyRegularContext)
}

func (s *MultiplyStatementContext) MultiplyGiving() IMultiplyGivingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplyGivingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiplyGivingContext)
}

func (s *MultiplyStatementContext) OnSizeErrorPhrase() IOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnSizeErrorPhraseContext)
}

func (s *MultiplyStatementContext) NotOnSizeErrorPhrase() INotOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnSizeErrorPhraseContext)
}

func (s *MultiplyStatementContext) END_MULTIPLY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_MULTIPLY, 0)
}

func (s *MultiplyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyStatement(s)
	}
}

func (s *MultiplyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyStatement(s)
	}
}

func (s *MultiplyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultiplyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultiplyStatement() (localctx IMultiplyStatementContext) {
	localctx = NewMultiplyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, Cobol85ParserRULE_multiplyStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4599)
		p.Match(Cobol85ParserMULTIPLY)
	}
	p.SetState(4602)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 663, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4600)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4601)
			p.Literal()
		}

	}
	{
		p.SetState(4604)
		p.Match(Cobol85ParserBY)
	}
	p.SetState(4607)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 664, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4605)
			p.MultiplyRegular()
		}

	case 2:
		{
			p.SetState(4606)
			p.MultiplyGiving()
		}

	}
	p.SetState(4610)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 665, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4609)
			p.OnSizeErrorPhrase()
		}

	}
	p.SetState(4613)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 666, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4612)
			p.NotOnSizeErrorPhrase()
		}

	}
	p.SetState(4616)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 667, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4615)
			p.Match(Cobol85ParserEND_MULTIPLY)
		}

	}

	return localctx
}

// IMultiplyRegularContext is an interface to support dynamic dispatch.
type IMultiplyRegularContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyRegularContext differentiates from other interfaces.
	IsMultiplyRegularContext()
}

type MultiplyRegularContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyRegularContext() *MultiplyRegularContext {
	var p = new(MultiplyRegularContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyRegular
	return p
}

func (*MultiplyRegularContext) IsMultiplyRegularContext() {}

func NewMultiplyRegularContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyRegularContext {
	var p = new(MultiplyRegularContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyRegular

	return p
}

func (s *MultiplyRegularContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyRegularContext) AllMultiplyRegularOperand() []IMultiplyRegularOperandContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplyRegularOperandContext)(nil)).Elem())
	var tst = make([]IMultiplyRegularOperandContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplyRegularOperandContext)
		}
	}

	return tst
}

func (s *MultiplyRegularContext) MultiplyRegularOperand(i int) IMultiplyRegularOperandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplyRegularOperandContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplyRegularOperandContext)
}

func (s *MultiplyRegularContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyRegularContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyRegularContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyRegular(s)
	}
}

func (s *MultiplyRegularContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyRegular(s)
	}
}

func (s *MultiplyRegularContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultiplyRegular(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultiplyRegular() (localctx IMultiplyRegularContext) {
	localctx = NewMultiplyRegularContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 762, Cobol85ParserRULE_multiplyRegular)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4619)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(4618)
			p.MultiplyRegularOperand()
		}

		p.SetState(4621)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMultiplyRegularOperandContext is an interface to support dynamic dispatch.
type IMultiplyRegularOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyRegularOperandContext differentiates from other interfaces.
	IsMultiplyRegularOperandContext()
}

type MultiplyRegularOperandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyRegularOperandContext() *MultiplyRegularOperandContext {
	var p = new(MultiplyRegularOperandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyRegularOperand
	return p
}

func (*MultiplyRegularOperandContext) IsMultiplyRegularOperandContext() {}

func NewMultiplyRegularOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyRegularOperandContext {
	var p = new(MultiplyRegularOperandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyRegularOperand

	return p
}

func (s *MultiplyRegularOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyRegularOperandContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MultiplyRegularOperandContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *MultiplyRegularOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyRegularOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyRegularOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyRegularOperand(s)
	}
}

func (s *MultiplyRegularOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyRegularOperand(s)
	}
}

func (s *MultiplyRegularOperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultiplyRegularOperand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultiplyRegularOperand() (localctx IMultiplyRegularOperandContext) {
	localctx = NewMultiplyRegularOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 764, Cobol85ParserRULE_multiplyRegularOperand)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4623)
		p.Identifier()
	}
	p.SetState(4625)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(4624)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IMultiplyGivingContext is an interface to support dynamic dispatch.
type IMultiplyGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyGivingContext differentiates from other interfaces.
	IsMultiplyGivingContext()
}

type MultiplyGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyGivingContext() *MultiplyGivingContext {
	var p = new(MultiplyGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyGiving
	return p
}

func (*MultiplyGivingContext) IsMultiplyGivingContext() {}

func NewMultiplyGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyGivingContext {
	var p = new(MultiplyGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyGiving

	return p
}

func (s *MultiplyGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyGivingContext) MultiplyGivingOperand() IMultiplyGivingOperandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplyGivingOperandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiplyGivingOperandContext)
}

func (s *MultiplyGivingContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *MultiplyGivingContext) AllMultiplyGivingResult() []IMultiplyGivingResultContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplyGivingResultContext)(nil)).Elem())
	var tst = make([]IMultiplyGivingResultContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplyGivingResultContext)
		}
	}

	return tst
}

func (s *MultiplyGivingContext) MultiplyGivingResult(i int) IMultiplyGivingResultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplyGivingResultContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplyGivingResultContext)
}

func (s *MultiplyGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyGiving(s)
	}
}

func (s *MultiplyGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyGiving(s)
	}
}

func (s *MultiplyGivingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultiplyGiving(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultiplyGiving() (localctx IMultiplyGivingContext) {
	localctx = NewMultiplyGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, Cobol85ParserRULE_multiplyGiving)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4627)
		p.MultiplyGivingOperand()
	}
	{
		p.SetState(4628)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(4630)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(4629)
			p.MultiplyGivingResult()
		}

		p.SetState(4632)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMultiplyGivingOperandContext is an interface to support dynamic dispatch.
type IMultiplyGivingOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyGivingOperandContext differentiates from other interfaces.
	IsMultiplyGivingOperandContext()
}

type MultiplyGivingOperandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyGivingOperandContext() *MultiplyGivingOperandContext {
	var p = new(MultiplyGivingOperandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyGivingOperand
	return p
}

func (*MultiplyGivingOperandContext) IsMultiplyGivingOperandContext() {}

func NewMultiplyGivingOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyGivingOperandContext {
	var p = new(MultiplyGivingOperandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyGivingOperand

	return p
}

func (s *MultiplyGivingOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyGivingOperandContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MultiplyGivingOperandContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *MultiplyGivingOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyGivingOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyGivingOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyGivingOperand(s)
	}
}

func (s *MultiplyGivingOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyGivingOperand(s)
	}
}

func (s *MultiplyGivingOperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultiplyGivingOperand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultiplyGivingOperand() (localctx IMultiplyGivingOperandContext) {
	localctx = NewMultiplyGivingOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, Cobol85ParserRULE_multiplyGivingOperand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4636)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 671, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4634)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4635)
			p.Literal()
		}

	}

	return localctx
}

// IMultiplyGivingResultContext is an interface to support dynamic dispatch.
type IMultiplyGivingResultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyGivingResultContext differentiates from other interfaces.
	IsMultiplyGivingResultContext()
}

type MultiplyGivingResultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyGivingResultContext() *MultiplyGivingResultContext {
	var p = new(MultiplyGivingResultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyGivingResult
	return p
}

func (*MultiplyGivingResultContext) IsMultiplyGivingResultContext() {}

func NewMultiplyGivingResultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyGivingResultContext {
	var p = new(MultiplyGivingResultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyGivingResult

	return p
}

func (s *MultiplyGivingResultContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyGivingResultContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MultiplyGivingResultContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *MultiplyGivingResultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyGivingResultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyGivingResultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyGivingResult(s)
	}
}

func (s *MultiplyGivingResultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyGivingResult(s)
	}
}

func (s *MultiplyGivingResultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultiplyGivingResult(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultiplyGivingResult() (localctx IMultiplyGivingResultContext) {
	localctx = NewMultiplyGivingResultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 770, Cobol85ParserRULE_multiplyGivingResult)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4638)
		p.Identifier()
	}
	p.SetState(4640)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(4639)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IOpenStatementContext is an interface to support dynamic dispatch.
type IOpenStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenStatementContext differentiates from other interfaces.
	IsOpenStatementContext()
}

type OpenStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenStatementContext() *OpenStatementContext {
	var p = new(OpenStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openStatement
	return p
}

func (*OpenStatementContext) IsOpenStatementContext() {}

func NewOpenStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenStatementContext {
	var p = new(OpenStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openStatement

	return p
}

func (s *OpenStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenStatementContext) OPEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOPEN, 0)
}

func (s *OpenStatementContext) AllOpenInputStatement() []IOpenInputStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOpenInputStatementContext)(nil)).Elem())
	var tst = make([]IOpenInputStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOpenInputStatementContext)
		}
	}

	return tst
}

func (s *OpenStatementContext) OpenInputStatement(i int) IOpenInputStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpenInputStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOpenInputStatementContext)
}

func (s *OpenStatementContext) AllOpenOutputStatement() []IOpenOutputStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOpenOutputStatementContext)(nil)).Elem())
	var tst = make([]IOpenOutputStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOpenOutputStatementContext)
		}
	}

	return tst
}

func (s *OpenStatementContext) OpenOutputStatement(i int) IOpenOutputStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpenOutputStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOpenOutputStatementContext)
}

func (s *OpenStatementContext) AllOpenIOStatement() []IOpenIOStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOpenIOStatementContext)(nil)).Elem())
	var tst = make([]IOpenIOStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOpenIOStatementContext)
		}
	}

	return tst
}

func (s *OpenStatementContext) OpenIOStatement(i int) IOpenIOStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpenIOStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOpenIOStatementContext)
}

func (s *OpenStatementContext) AllOpenExtendStatement() []IOpenExtendStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOpenExtendStatementContext)(nil)).Elem())
	var tst = make([]IOpenExtendStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOpenExtendStatementContext)
		}
	}

	return tst
}

func (s *OpenStatementContext) OpenExtendStatement(i int) IOpenExtendStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpenExtendStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOpenExtendStatementContext)
}

func (s *OpenStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenStatement(s)
	}
}

func (s *OpenStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenStatement(s)
	}
}

func (s *OpenStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOpenStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OpenStatement() (localctx IOpenStatementContext) {
	localctx = NewOpenStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 772, Cobol85ParserRULE_openStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4642)
		p.Match(Cobol85ParserOPEN)
	}
	p.SetState(4647)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserEXTEND || _la == Cobol85ParserI_O || _la == Cobol85ParserINPUT || _la == Cobol85ParserOUTPUT {
		p.SetState(4647)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserINPUT:
			{
				p.SetState(4643)
				p.OpenInputStatement()
			}

		case Cobol85ParserOUTPUT:
			{
				p.SetState(4644)
				p.OpenOutputStatement()
			}

		case Cobol85ParserI_O:
			{
				p.SetState(4645)
				p.OpenIOStatement()
			}

		case Cobol85ParserEXTEND:
			{
				p.SetState(4646)
				p.OpenExtendStatement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4649)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOpenInputStatementContext is an interface to support dynamic dispatch.
type IOpenInputStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenInputStatementContext differentiates from other interfaces.
	IsOpenInputStatementContext()
}

type OpenInputStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenInputStatementContext() *OpenInputStatementContext {
	var p = new(OpenInputStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openInputStatement
	return p
}

func (*OpenInputStatementContext) IsOpenInputStatementContext() {}

func NewOpenInputStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenInputStatementContext {
	var p = new(OpenInputStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openInputStatement

	return p
}

func (s *OpenInputStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenInputStatementContext) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *OpenInputStatementContext) AllOpenInput() []IOpenInputContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOpenInputContext)(nil)).Elem())
	var tst = make([]IOpenInputContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOpenInputContext)
		}
	}

	return tst
}

func (s *OpenInputStatementContext) OpenInput(i int) IOpenInputContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpenInputContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOpenInputContext)
}

func (s *OpenInputStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenInputStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenInputStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenInputStatement(s)
	}
}

func (s *OpenInputStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenInputStatement(s)
	}
}

func (s *OpenInputStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOpenInputStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OpenInputStatement() (localctx IOpenInputStatementContext) {
	localctx = NewOpenInputStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 774, Cobol85ParserRULE_openInputStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4651)
		p.Match(Cobol85ParserINPUT)
	}
	p.SetState(4653)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4652)
			p.OpenInput()
		}

		p.SetState(4655)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOpenInputContext is an interface to support dynamic dispatch.
type IOpenInputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenInputContext differentiates from other interfaces.
	IsOpenInputContext()
}

type OpenInputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenInputContext() *OpenInputContext {
	var p = new(OpenInputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openInput
	return p
}

func (*OpenInputContext) IsOpenInputContext() {}

func NewOpenInputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenInputContext {
	var p = new(OpenInputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openInput

	return p
}

func (s *OpenInputContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenInputContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *OpenInputContext) REVERSED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREVERSED, 0)
}

func (s *OpenInputContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *OpenInputContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *OpenInputContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *OpenInputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenInputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenInputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenInput(s)
	}
}

func (s *OpenInputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenInput(s)
	}
}

func (s *OpenInputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOpenInput(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OpenInput() (localctx IOpenInputContext) {
	localctx = NewOpenInputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 776, Cobol85ParserRULE_openInput)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4657)
		p.FileName()
	}
	p.SetState(4664)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 677, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4658)
			p.Match(Cobol85ParserREVERSED)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 677, p.GetParserRuleContext()) == 2 {
		p.SetState(4660)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(4659)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(4662)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(4663)
			p.Match(Cobol85ParserREWIND)
		}

	}

	return localctx
}

// IOpenOutputStatementContext is an interface to support dynamic dispatch.
type IOpenOutputStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenOutputStatementContext differentiates from other interfaces.
	IsOpenOutputStatementContext()
}

type OpenOutputStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenOutputStatementContext() *OpenOutputStatementContext {
	var p = new(OpenOutputStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openOutputStatement
	return p
}

func (*OpenOutputStatementContext) IsOpenOutputStatementContext() {}

func NewOpenOutputStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenOutputStatementContext {
	var p = new(OpenOutputStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openOutputStatement

	return p
}

func (s *OpenOutputStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenOutputStatementContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *OpenOutputStatementContext) AllOpenOutput() []IOpenOutputContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOpenOutputContext)(nil)).Elem())
	var tst = make([]IOpenOutputContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOpenOutputContext)
		}
	}

	return tst
}

func (s *OpenOutputStatementContext) OpenOutput(i int) IOpenOutputContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpenOutputContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOpenOutputContext)
}

func (s *OpenOutputStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenOutputStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenOutputStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenOutputStatement(s)
	}
}

func (s *OpenOutputStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenOutputStatement(s)
	}
}

func (s *OpenOutputStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOpenOutputStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OpenOutputStatement() (localctx IOpenOutputStatementContext) {
	localctx = NewOpenOutputStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 778, Cobol85ParserRULE_openOutputStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4666)
		p.Match(Cobol85ParserOUTPUT)
	}
	p.SetState(4668)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4667)
			p.OpenOutput()
		}

		p.SetState(4670)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOpenOutputContext is an interface to support dynamic dispatch.
type IOpenOutputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenOutputContext differentiates from other interfaces.
	IsOpenOutputContext()
}

type OpenOutputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenOutputContext() *OpenOutputContext {
	var p = new(OpenOutputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openOutput
	return p
}

func (*OpenOutputContext) IsOpenOutputContext() {}

func NewOpenOutputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenOutputContext {
	var p = new(OpenOutputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openOutput

	return p
}

func (s *OpenOutputContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenOutputContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *OpenOutputContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *OpenOutputContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *OpenOutputContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *OpenOutputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenOutputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenOutputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenOutput(s)
	}
}

func (s *OpenOutputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenOutput(s)
	}
}

func (s *OpenOutputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOpenOutput(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OpenOutput() (localctx IOpenOutputContext) {
	localctx = NewOpenOutputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 780, Cobol85ParserRULE_openOutput)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4672)
		p.FileName()
	}
	p.SetState(4678)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 680, p.GetParserRuleContext()) == 1 {
		p.SetState(4674)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(4673)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(4676)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(4677)
			p.Match(Cobol85ParserREWIND)
		}

	}

	return localctx
}

// IOpenIOStatementContext is an interface to support dynamic dispatch.
type IOpenIOStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenIOStatementContext differentiates from other interfaces.
	IsOpenIOStatementContext()
}

type OpenIOStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenIOStatementContext() *OpenIOStatementContext {
	var p = new(OpenIOStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openIOStatement
	return p
}

func (*OpenIOStatementContext) IsOpenIOStatementContext() {}

func NewOpenIOStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenIOStatementContext {
	var p = new(OpenIOStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openIOStatement

	return p
}

func (s *OpenIOStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenIOStatementContext) I_O() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O, 0)
}

func (s *OpenIOStatementContext) AllFileName() []IFileNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileNameContext)(nil)).Elem())
	var tst = make([]IFileNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileNameContext)
		}
	}

	return tst
}

func (s *OpenIOStatementContext) FileName(i int) IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *OpenIOStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenIOStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenIOStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenIOStatement(s)
	}
}

func (s *OpenIOStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenIOStatement(s)
	}
}

func (s *OpenIOStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOpenIOStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OpenIOStatement() (localctx IOpenIOStatementContext) {
	localctx = NewOpenIOStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 782, Cobol85ParserRULE_openIOStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4680)
		p.Match(Cobol85ParserI_O)
	}
	p.SetState(4682)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4681)
			p.FileName()
		}

		p.SetState(4684)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOpenExtendStatementContext is an interface to support dynamic dispatch.
type IOpenExtendStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenExtendStatementContext differentiates from other interfaces.
	IsOpenExtendStatementContext()
}

type OpenExtendStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenExtendStatementContext() *OpenExtendStatementContext {
	var p = new(OpenExtendStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openExtendStatement
	return p
}

func (*OpenExtendStatementContext) IsOpenExtendStatementContext() {}

func NewOpenExtendStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenExtendStatementContext {
	var p = new(OpenExtendStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openExtendStatement

	return p
}

func (s *OpenExtendStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenExtendStatementContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTEND, 0)
}

func (s *OpenExtendStatementContext) AllFileName() []IFileNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileNameContext)(nil)).Elem())
	var tst = make([]IFileNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileNameContext)
		}
	}

	return tst
}

func (s *OpenExtendStatementContext) FileName(i int) IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *OpenExtendStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenExtendStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenExtendStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenExtendStatement(s)
	}
}

func (s *OpenExtendStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenExtendStatement(s)
	}
}

func (s *OpenExtendStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOpenExtendStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OpenExtendStatement() (localctx IOpenExtendStatementContext) {
	localctx = NewOpenExtendStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 784, Cobol85ParserRULE_openExtendStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4686)
		p.Match(Cobol85ParserEXTEND)
	}
	p.SetState(4688)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4687)
			p.FileName()
		}

		p.SetState(4690)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPerformStatementContext is an interface to support dynamic dispatch.
type IPerformStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformStatementContext differentiates from other interfaces.
	IsPerformStatementContext()
}

type PerformStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformStatementContext() *PerformStatementContext {
	var p = new(PerformStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performStatement
	return p
}

func (*PerformStatementContext) IsPerformStatementContext() {}

func NewPerformStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformStatementContext {
	var p = new(PerformStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performStatement

	return p
}

func (s *PerformStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformStatementContext) PERFORM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPERFORM, 0)
}

func (s *PerformStatementContext) PerformInlineStatement() IPerformInlineStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformInlineStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformInlineStatementContext)
}

func (s *PerformStatementContext) PerformProcedureStatement() IPerformProcedureStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformProcedureStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformProcedureStatementContext)
}

func (s *PerformStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformStatement(s)
	}
}

func (s *PerformStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformStatement(s)
	}
}

func (s *PerformStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformStatement() (localctx IPerformStatementContext) {
	localctx = NewPerformStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 786, Cobol85ParserRULE_performStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4692)
		p.Match(Cobol85ParserPERFORM)
	}
	p.SetState(4695)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 683, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4693)
			p.PerformInlineStatement()
		}

	case 2:
		{
			p.SetState(4694)
			p.PerformProcedureStatement()
		}

	}

	return localctx
}

// IPerformInlineStatementContext is an interface to support dynamic dispatch.
type IPerformInlineStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformInlineStatementContext differentiates from other interfaces.
	IsPerformInlineStatementContext()
}

type PerformInlineStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformInlineStatementContext() *PerformInlineStatementContext {
	var p = new(PerformInlineStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performInlineStatement
	return p
}

func (*PerformInlineStatementContext) IsPerformInlineStatementContext() {}

func NewPerformInlineStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformInlineStatementContext {
	var p = new(PerformInlineStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performInlineStatement

	return p
}

func (s *PerformInlineStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformInlineStatementContext) END_PERFORM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_PERFORM, 0)
}

func (s *PerformInlineStatementContext) PerformType() IPerformTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformTypeContext)
}

func (s *PerformInlineStatementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *PerformInlineStatementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *PerformInlineStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformInlineStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformInlineStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformInlineStatement(s)
	}
}

func (s *PerformInlineStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformInlineStatement(s)
	}
}

func (s *PerformInlineStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformInlineStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformInlineStatement() (localctx IPerformInlineStatementContext) {
	localctx = NewPerformInlineStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 788, Cobol85ParserRULE_performInlineStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4698)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTEST-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserUNTIL-502))|(1<<(Cobol85ParserVARYING-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserWITH-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(4697)
			p.PerformType()
		}

	}
	p.SetState(4701)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserACCEPT)|(1<<Cobol85ParserADD)|(1<<Cobol85ParserALTER))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(Cobol85ParserCALL-54))|(1<<(Cobol85ParserCANCEL-54))|(1<<(Cobol85ParserCLOSE-54)))) != 0) || _la == Cobol85ParserCOMPUTE || _la == Cobol85ParserCONTINUE || (((_la-134)&-(0x1f+1)) == 0 && ((1<<uint((_la-134)))&((1<<(Cobol85ParserDELETE-134))|(1<<(Cobol85ParserDISABLE-134))|(1<<(Cobol85ParserDISPLAY-134))|(1<<(Cobol85ParserDIVIDE-134))|(1<<(Cobol85ParserENABLE-134)))) != 0) || (((_la-185)&-(0x1f+1)) == 0 && ((1<<uint((_la-185)))&((1<<(Cobol85ParserENTRY-185))|(1<<(Cobol85ParserEVALUATE-185))|(1<<(Cobol85ParserEXHIBIT-185))|(1<<(Cobol85ParserEXIT-185)))) != 0) || (((_la-223)&-(0x1f+1)) == 0 && ((1<<uint((_la-223)))&((1<<(Cobol85ParserGENERATE-223))|(1<<(Cobol85ParserGOBACK-223))|(1<<(Cobol85ParserGO-223))|(1<<(Cobol85ParserIF-223))|(1<<(Cobol85ParserINITIALIZE-223))|(1<<(Cobol85ParserINITIATE-223))|(1<<(Cobol85ParserINSPECT-223)))) != 0) || (((_la-297)&-(0x1f+1)) == 0 && ((1<<uint((_la-297)))&((1<<(Cobol85ParserMERGE-297))|(1<<(Cobol85ParserMOVE-297))|(1<<(Cobol85ParserMULTIPLY-297)))) != 0) || _la == Cobol85ParserOPEN || _la == Cobol85ParserPERFORM || (((_la-370)&-(0x1f+1)) == 0 && ((1<<uint((_la-370)))&((1<<(Cobol85ParserPURGE-370))|(1<<(Cobol85ParserREAD-370))|(1<<(Cobol85ParserRECEIVE-370))|(1<<(Cobol85ParserRELEASE-370)))) != 0) || (((_la-407)&-(0x1f+1)) == 0 && ((1<<uint((_la-407)))&((1<<(Cobol85ParserRETURN-407))|(1<<(Cobol85ParserREWRITE-407))|(1<<(Cobol85ParserSEARCH-407))|(1<<(Cobol85ParserSEND-407))|(1<<(Cobol85ParserSET-407)))) != 0) || (((_la-443)&-(0x1f+1)) == 0 && ((1<<uint((_la-443)))&((1<<(Cobol85ParserSORT-443))|(1<<(Cobol85ParserSTART-443))|(1<<(Cobol85ParserSTOP-443))|(1<<(Cobol85ParserSTRING-443))|(1<<(Cobol85ParserSUBTRACT-443)))) != 0) || _la == Cobol85ParserTERMINATE || _la == Cobol85ParserUNSTRING || _la == Cobol85ParserWRITE || (((_la-563)&-(0x1f+1)) == 0 && ((1<<uint((_la-563)))&((1<<(Cobol85ParserEXECCICSLINE-563))|(1<<(Cobol85ParserEXECSQLIMSLINE-563))|(1<<(Cobol85ParserEXECSQLLINE-563)))) != 0) {
		{
			p.SetState(4700)
			p.Statement()
		}

		p.SetState(4703)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4705)
		p.Match(Cobol85ParserEND_PERFORM)
	}

	return localctx
}

// IPerformProcedureStatementContext is an interface to support dynamic dispatch.
type IPerformProcedureStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformProcedureStatementContext differentiates from other interfaces.
	IsPerformProcedureStatementContext()
}

type PerformProcedureStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformProcedureStatementContext() *PerformProcedureStatementContext {
	var p = new(PerformProcedureStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performProcedureStatement
	return p
}

func (*PerformProcedureStatementContext) IsPerformProcedureStatementContext() {}

func NewPerformProcedureStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformProcedureStatementContext {
	var p = new(PerformProcedureStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performProcedureStatement

	return p
}

func (s *PerformProcedureStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformProcedureStatementContext) AllProcedureName() []IProcedureNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem())
	var tst = make([]IProcedureNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcedureNameContext)
		}
	}

	return tst
}

func (s *PerformProcedureStatementContext) ProcedureName(i int) IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *PerformProcedureStatementContext) PerformType() IPerformTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformTypeContext)
}

func (s *PerformProcedureStatementContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *PerformProcedureStatementContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *PerformProcedureStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformProcedureStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformProcedureStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformProcedureStatement(s)
	}
}

func (s *PerformProcedureStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformProcedureStatement(s)
	}
}

func (s *PerformProcedureStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformProcedureStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformProcedureStatement() (localctx IPerformProcedureStatementContext) {
	localctx = NewPerformProcedureStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 790, Cobol85ParserRULE_performProcedureStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4707)
		p.ProcedureName()
	}
	p.SetState(4710)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		p.SetState(4708)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(4709)
			p.ProcedureName()
		}

	}
	p.SetState(4713)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 687, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4712)
			p.PerformType()
		}

	}

	return localctx
}

// IPerformTypeContext is an interface to support dynamic dispatch.
type IPerformTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformTypeContext differentiates from other interfaces.
	IsPerformTypeContext()
}

type PerformTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformTypeContext() *PerformTypeContext {
	var p = new(PerformTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performType
	return p
}

func (*PerformTypeContext) IsPerformTypeContext() {}

func NewPerformTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformTypeContext {
	var p = new(PerformTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performType

	return p
}

func (s *PerformTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformTypeContext) PerformTimes() IPerformTimesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformTimesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformTimesContext)
}

func (s *PerformTypeContext) PerformUntil() IPerformUntilContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformUntilContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformUntilContext)
}

func (s *PerformTypeContext) PerformVarying() IPerformVaryingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformVaryingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformVaryingContext)
}

func (s *PerformTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformType(s)
	}
}

func (s *PerformTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformType(s)
	}
}

func (s *PerformTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformType() (localctx IPerformTypeContext) {
	localctx = NewPerformTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 792, Cobol85ParserRULE_performType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4718)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 688, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4715)
			p.PerformTimes()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4716)
			p.PerformUntil()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4717)
			p.PerformVarying()
		}

	}

	return localctx
}

// IPerformTimesContext is an interface to support dynamic dispatch.
type IPerformTimesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformTimesContext differentiates from other interfaces.
	IsPerformTimesContext()
}

type PerformTimesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformTimesContext() *PerformTimesContext {
	var p = new(PerformTimesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performTimes
	return p
}

func (*PerformTimesContext) IsPerformTimesContext() {}

func NewPerformTimesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformTimesContext {
	var p = new(PerformTimesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performTimes

	return p
}

func (s *PerformTimesContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformTimesContext) TIMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMES, 0)
}

func (s *PerformTimesContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PerformTimesContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *PerformTimesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformTimesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformTimesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformTimes(s)
	}
}

func (s *PerformTimesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformTimes(s)
	}
}

func (s *PerformTimesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformTimes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformTimes() (localctx IPerformTimesContext) {
	localctx = NewPerformTimesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 794, Cobol85ParserRULE_performTimes)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4722)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 689, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4720)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4721)
			p.IntegerLiteral()
		}

	}
	{
		p.SetState(4724)
		p.Match(Cobol85ParserTIMES)
	}

	return localctx
}

// IPerformUntilContext is an interface to support dynamic dispatch.
type IPerformUntilContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformUntilContext differentiates from other interfaces.
	IsPerformUntilContext()
}

type PerformUntilContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformUntilContext() *PerformUntilContext {
	var p = new(PerformUntilContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performUntil
	return p
}

func (*PerformUntilContext) IsPerformUntilContext() {}

func NewPerformUntilContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformUntilContext {
	var p = new(PerformUntilContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performUntil

	return p
}

func (s *PerformUntilContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformUntilContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNTIL, 0)
}

func (s *PerformUntilContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *PerformUntilContext) PerformTestClause() IPerformTestClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformTestClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformTestClauseContext)
}

func (s *PerformUntilContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformUntilContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformUntilContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformUntil(s)
	}
}

func (s *PerformUntilContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformUntil(s)
	}
}

func (s *PerformUntilContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformUntil(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformUntil() (localctx IPerformUntilContext) {
	localctx = NewPerformUntilContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 796, Cobol85ParserRULE_performUntil)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4727)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTEST || _la == Cobol85ParserWITH {
		{
			p.SetState(4726)
			p.PerformTestClause()
		}

	}
	{
		p.SetState(4729)
		p.Match(Cobol85ParserUNTIL)
	}
	{
		p.SetState(4730)
		p.Condition()
	}

	return localctx
}

// IPerformVaryingContext is an interface to support dynamic dispatch.
type IPerformVaryingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformVaryingContext differentiates from other interfaces.
	IsPerformVaryingContext()
}

type PerformVaryingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformVaryingContext() *PerformVaryingContext {
	var p = new(PerformVaryingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performVarying
	return p
}

func (*PerformVaryingContext) IsPerformVaryingContext() {}

func NewPerformVaryingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformVaryingContext {
	var p = new(PerformVaryingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performVarying

	return p
}

func (s *PerformVaryingContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformVaryingContext) PerformTestClause() IPerformTestClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformTestClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformTestClauseContext)
}

func (s *PerformVaryingContext) PerformVaryingClause() IPerformVaryingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformVaryingClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformVaryingClauseContext)
}

func (s *PerformVaryingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformVaryingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformVaryingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformVarying(s)
	}
}

func (s *PerformVaryingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformVarying(s)
	}
}

func (s *PerformVaryingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformVarying(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformVarying() (localctx IPerformVaryingContext) {
	localctx = NewPerformVaryingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 798, Cobol85ParserRULE_performVarying)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4739)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserTEST, Cobol85ParserWITH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4732)
			p.PerformTestClause()
		}
		{
			p.SetState(4733)
			p.PerformVaryingClause()
		}

	case Cobol85ParserVARYING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4735)
			p.PerformVaryingClause()
		}
		p.SetState(4737)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 691, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4736)
				p.PerformTestClause()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPerformVaryingClauseContext is an interface to support dynamic dispatch.
type IPerformVaryingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformVaryingClauseContext differentiates from other interfaces.
	IsPerformVaryingClauseContext()
}

type PerformVaryingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformVaryingClauseContext() *PerformVaryingClauseContext {
	var p = new(PerformVaryingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performVaryingClause
	return p
}

func (*PerformVaryingClauseContext) IsPerformVaryingClauseContext() {}

func NewPerformVaryingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformVaryingClauseContext {
	var p = new(PerformVaryingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performVaryingClause

	return p
}

func (s *PerformVaryingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformVaryingClauseContext) VARYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVARYING, 0)
}

func (s *PerformVaryingClauseContext) PerformVaryingPhrase() IPerformVaryingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformVaryingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformVaryingPhraseContext)
}

func (s *PerformVaryingClauseContext) AllPerformAfter() []IPerformAfterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPerformAfterContext)(nil)).Elem())
	var tst = make([]IPerformAfterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPerformAfterContext)
		}
	}

	return tst
}

func (s *PerformVaryingClauseContext) PerformAfter(i int) IPerformAfterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformAfterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPerformAfterContext)
}

func (s *PerformVaryingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformVaryingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformVaryingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformVaryingClause(s)
	}
}

func (s *PerformVaryingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformVaryingClause(s)
	}
}

func (s *PerformVaryingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformVaryingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformVaryingClause() (localctx IPerformVaryingClauseContext) {
	localctx = NewPerformVaryingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 800, Cobol85ParserRULE_performVaryingClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4741)
		p.Match(Cobol85ParserVARYING)
	}
	{
		p.SetState(4742)
		p.PerformVaryingPhrase()
	}
	p.SetState(4746)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER {
		{
			p.SetState(4743)
			p.PerformAfter()
		}

		p.SetState(4748)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPerformVaryingPhraseContext is an interface to support dynamic dispatch.
type IPerformVaryingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformVaryingPhraseContext differentiates from other interfaces.
	IsPerformVaryingPhraseContext()
}

type PerformVaryingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformVaryingPhraseContext() *PerformVaryingPhraseContext {
	var p = new(PerformVaryingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performVaryingPhrase
	return p
}

func (*PerformVaryingPhraseContext) IsPerformVaryingPhraseContext() {}

func NewPerformVaryingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformVaryingPhraseContext {
	var p = new(PerformVaryingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performVaryingPhrase

	return p
}

func (s *PerformVaryingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformVaryingPhraseContext) PerformFrom() IPerformFromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformFromContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformFromContext)
}

func (s *PerformVaryingPhraseContext) PerformBy() IPerformByContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformByContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformByContext)
}

func (s *PerformVaryingPhraseContext) PerformUntil() IPerformUntilContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformUntilContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformUntilContext)
}

func (s *PerformVaryingPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PerformVaryingPhraseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PerformVaryingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformVaryingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformVaryingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformVaryingPhrase(s)
	}
}

func (s *PerformVaryingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformVaryingPhrase(s)
	}
}

func (s *PerformVaryingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformVaryingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformVaryingPhrase() (localctx IPerformVaryingPhraseContext) {
	localctx = NewPerformVaryingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 802, Cobol85ParserRULE_performVaryingPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4751)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 694, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4749)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4750)
			p.Literal()
		}

	}
	{
		p.SetState(4753)
		p.PerformFrom()
	}
	{
		p.SetState(4754)
		p.PerformBy()
	}
	{
		p.SetState(4755)
		p.PerformUntil()
	}

	return localctx
}

// IPerformAfterContext is an interface to support dynamic dispatch.
type IPerformAfterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformAfterContext differentiates from other interfaces.
	IsPerformAfterContext()
}

type PerformAfterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformAfterContext() *PerformAfterContext {
	var p = new(PerformAfterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performAfter
	return p
}

func (*PerformAfterContext) IsPerformAfterContext() {}

func NewPerformAfterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformAfterContext {
	var p = new(PerformAfterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performAfter

	return p
}

func (s *PerformAfterContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformAfterContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *PerformAfterContext) PerformVaryingPhrase() IPerformVaryingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformVaryingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformVaryingPhraseContext)
}

func (s *PerformAfterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformAfterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformAfterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformAfter(s)
	}
}

func (s *PerformAfterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformAfter(s)
	}
}

func (s *PerformAfterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformAfter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformAfter() (localctx IPerformAfterContext) {
	localctx = NewPerformAfterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 804, Cobol85ParserRULE_performAfter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4757)
		p.Match(Cobol85ParserAFTER)
	}
	{
		p.SetState(4758)
		p.PerformVaryingPhrase()
	}

	return localctx
}

// IPerformFromContext is an interface to support dynamic dispatch.
type IPerformFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformFromContext differentiates from other interfaces.
	IsPerformFromContext()
}

type PerformFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformFromContext() *PerformFromContext {
	var p = new(PerformFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performFrom
	return p
}

func (*PerformFromContext) IsPerformFromContext() {}

func NewPerformFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformFromContext {
	var p = new(PerformFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performFrom

	return p
}

func (s *PerformFromContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformFromContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *PerformFromContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PerformFromContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PerformFromContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *PerformFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformFrom(s)
	}
}

func (s *PerformFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformFrom(s)
	}
}

func (s *PerformFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformFrom() (localctx IPerformFromContext) {
	localctx = NewPerformFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 806, Cobol85ParserRULE_performFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4760)
		p.Match(Cobol85ParserFROM)
	}
	p.SetState(4764)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 695, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4761)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4762)
			p.Literal()
		}

	case 3:
		{
			p.SetState(4763)
			p.ArithmeticExpression()
		}

	}

	return localctx
}

// IPerformByContext is an interface to support dynamic dispatch.
type IPerformByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformByContext differentiates from other interfaces.
	IsPerformByContext()
}

type PerformByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformByContext() *PerformByContext {
	var p = new(PerformByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performBy
	return p
}

func (*PerformByContext) IsPerformByContext() {}

func NewPerformByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformByContext {
	var p = new(PerformByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performBy

	return p
}

func (s *PerformByContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformByContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *PerformByContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PerformByContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PerformByContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *PerformByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformBy(s)
	}
}

func (s *PerformByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformBy(s)
	}
}

func (s *PerformByContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformBy(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformBy() (localctx IPerformByContext) {
	localctx = NewPerformByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 808, Cobol85ParserRULE_performBy)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4766)
		p.Match(Cobol85ParserBY)
	}
	p.SetState(4770)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 696, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4767)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4768)
			p.Literal()
		}

	case 3:
		{
			p.SetState(4769)
			p.ArithmeticExpression()
		}

	}

	return localctx
}

// IPerformTestClauseContext is an interface to support dynamic dispatch.
type IPerformTestClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformTestClauseContext differentiates from other interfaces.
	IsPerformTestClauseContext()
}

type PerformTestClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformTestClauseContext() *PerformTestClauseContext {
	var p = new(PerformTestClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performTestClause
	return p
}

func (*PerformTestClauseContext) IsPerformTestClauseContext() {}

func NewPerformTestClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformTestClauseContext {
	var p = new(PerformTestClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performTestClause

	return p
}

func (s *PerformTestClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformTestClauseContext) TEST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTEST, 0)
}

func (s *PerformTestClauseContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEFORE, 0)
}

func (s *PerformTestClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *PerformTestClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *PerformTestClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformTestClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformTestClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformTestClause(s)
	}
}

func (s *PerformTestClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformTestClause(s)
	}
}

func (s *PerformTestClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformTestClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformTestClause() (localctx IPerformTestClauseContext) {
	localctx = NewPerformTestClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 810, Cobol85ParserRULE_performTestClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4773)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4772)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(4775)
		p.Match(Cobol85ParserTEST)
	}
	p.SetState(4776)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IPurgeStatementContext is an interface to support dynamic dispatch.
type IPurgeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPurgeStatementContext differentiates from other interfaces.
	IsPurgeStatementContext()
}

type PurgeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPurgeStatementContext() *PurgeStatementContext {
	var p = new(PurgeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_purgeStatement
	return p
}

func (*PurgeStatementContext) IsPurgeStatementContext() {}

func NewPurgeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PurgeStatementContext {
	var p = new(PurgeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_purgeStatement

	return p
}

func (s *PurgeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PurgeStatementContext) PURGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPURGE, 0)
}

func (s *PurgeStatementContext) AllCdName() []ICdNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICdNameContext)(nil)).Elem())
	var tst = make([]ICdNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICdNameContext)
		}
	}

	return tst
}

func (s *PurgeStatementContext) CdName(i int) ICdNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICdNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *PurgeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PurgeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PurgeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPurgeStatement(s)
	}
}

func (s *PurgeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPurgeStatement(s)
	}
}

func (s *PurgeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPurgeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PurgeStatement() (localctx IPurgeStatementContext) {
	localctx = NewPurgeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 812, Cobol85ParserRULE_purgeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4778)
		p.Match(Cobol85ParserPURGE)
	}
	p.SetState(4780)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4779)
			p.CdName()
		}

		p.SetState(4782)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IReadStatementContext is an interface to support dynamic dispatch.
type IReadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadStatementContext differentiates from other interfaces.
	IsReadStatementContext()
}

type ReadStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadStatementContext() *ReadStatementContext {
	var p = new(ReadStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_readStatement
	return p
}

func (*ReadStatementContext) IsReadStatementContext() {}

func NewReadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadStatementContext {
	var p = new(ReadStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_readStatement

	return p
}

func (s *ReadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadStatementContext) READ() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREAD, 0)
}

func (s *ReadStatementContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *ReadStatementContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *ReadStatementContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *ReadStatementContext) ReadInto() IReadIntoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadIntoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadIntoContext)
}

func (s *ReadStatementContext) ReadWith() IReadWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadWithContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadWithContext)
}

func (s *ReadStatementContext) ReadKey() IReadKeyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadKeyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadKeyContext)
}

func (s *ReadStatementContext) InvalidKeyPhrase() IInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvalidKeyPhraseContext)
}

func (s *ReadStatementContext) NotInvalidKeyPhrase() INotInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotInvalidKeyPhraseContext)
}

func (s *ReadStatementContext) AtEndPhrase() IAtEndPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtEndPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtEndPhraseContext)
}

func (s *ReadStatementContext) NotAtEndPhrase() INotAtEndPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotAtEndPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotAtEndPhraseContext)
}

func (s *ReadStatementContext) END_READ() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_READ, 0)
}

func (s *ReadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReadStatement(s)
	}
}

func (s *ReadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReadStatement(s)
	}
}

func (s *ReadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReadStatement() (localctx IReadStatementContext) {
	localctx = NewReadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 814, Cobol85ParserRULE_readStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4784)
		p.Match(Cobol85ParserREAD)
	}
	{
		p.SetState(4785)
		p.FileName()
	}
	p.SetState(4787)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNEXT {
		{
			p.SetState(4786)
			p.Match(Cobol85ParserNEXT)
		}

	}
	p.SetState(4790)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRECORD {
		{
			p.SetState(4789)
			p.Match(Cobol85ParserRECORD)
		}

	}
	p.SetState(4793)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINTO {
		{
			p.SetState(4792)
			p.ReadInto()
		}

	}
	p.SetState(4796)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 702, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4795)
			p.ReadWith()
		}

	}
	p.SetState(4799)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(4798)
			p.ReadKey()
		}

	}
	p.SetState(4802)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 704, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4801)
			p.InvalidKeyPhrase()
		}

	}
	p.SetState(4805)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 705, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4804)
			p.NotInvalidKeyPhrase()
		}

	}
	p.SetState(4808)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 706, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4807)
			p.AtEndPhrase()
		}

	}
	p.SetState(4811)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 707, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4810)
			p.NotAtEndPhrase()
		}

	}
	p.SetState(4814)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 708, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4813)
			p.Match(Cobol85ParserEND_READ)
		}

	}

	return localctx
}

// IReadIntoContext is an interface to support dynamic dispatch.
type IReadIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadIntoContext differentiates from other interfaces.
	IsReadIntoContext()
}

type ReadIntoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadIntoContext() *ReadIntoContext {
	var p = new(ReadIntoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_readInto
	return p
}

func (*ReadIntoContext) IsReadIntoContext() {}

func NewReadIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadIntoContext {
	var p = new(ReadIntoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_readInto

	return p
}

func (s *ReadIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadIntoContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *ReadIntoContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReadIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReadInto(s)
	}
}

func (s *ReadIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReadInto(s)
	}
}

func (s *ReadIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReadInto(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReadInto() (localctx IReadIntoContext) {
	localctx = NewReadIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 816, Cobol85ParserRULE_readInto)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4816)
		p.Match(Cobol85ParserINTO)
	}
	{
		p.SetState(4817)
		p.Identifier()
	}

	return localctx
}

// IReadWithContext is an interface to support dynamic dispatch.
type IReadWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadWithContext differentiates from other interfaces.
	IsReadWithContext()
}

type ReadWithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadWithContext() *ReadWithContext {
	var p = new(ReadWithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_readWith
	return p
}

func (*ReadWithContext) IsReadWithContext() {}

func NewReadWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadWithContext {
	var p = new(ReadWithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_readWith

	return p
}

func (s *ReadWithContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadWithContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *ReadWithContext) WAIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWAIT, 0)
}

func (s *ReadWithContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *ReadWithContext) KEPT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEPT, 0)
}

func (s *ReadWithContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *ReadWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReadWith(s)
	}
}

func (s *ReadWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReadWith(s)
	}
}

func (s *ReadWithContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReadWith(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReadWith() (localctx IReadWithContext) {
	localctx = NewReadWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 818, Cobol85ParserRULE_readWith)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4820)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4819)
			p.Match(Cobol85ParserWITH)
		}

	}
	p.SetState(4825)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserKEPT, Cobol85ParserNO:
		p.SetState(4822)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserKEPT || _la == Cobol85ParserNO) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(4823)
			p.Match(Cobol85ParserLOCK)
		}

	case Cobol85ParserWAIT:
		{
			p.SetState(4824)
			p.Match(Cobol85ParserWAIT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReadKeyContext is an interface to support dynamic dispatch.
type IReadKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadKeyContext differentiates from other interfaces.
	IsReadKeyContext()
}

type ReadKeyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadKeyContext() *ReadKeyContext {
	var p = new(ReadKeyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_readKey
	return p
}

func (*ReadKeyContext) IsReadKeyContext() {}

func NewReadKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadKeyContext {
	var p = new(ReadKeyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_readKey

	return p
}

func (s *ReadKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *ReadKeyContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ReadKeyContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReadKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReadKey(s)
	}
}

func (s *ReadKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReadKey(s)
	}
}

func (s *ReadKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReadKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReadKey() (localctx IReadKeyContext) {
	localctx = NewReadKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 820, Cobol85ParserRULE_readKey)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4827)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(4829)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(4828)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(4831)
		p.QualifiedDataName()
	}

	return localctx
}

// IReceiveStatementContext is an interface to support dynamic dispatch.
type IReceiveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveStatementContext differentiates from other interfaces.
	IsReceiveStatementContext()
}

type ReceiveStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveStatementContext() *ReceiveStatementContext {
	var p = new(ReceiveStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveStatement
	return p
}

func (*ReceiveStatementContext) IsReceiveStatementContext() {}

func NewReceiveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveStatementContext {
	var p = new(ReceiveStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveStatement

	return p
}

func (s *ReceiveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveStatementContext) RECEIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECEIVE, 0)
}

func (s *ReceiveStatementContext) ReceiveFromStatement() IReceiveFromStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveFromStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiveFromStatementContext)
}

func (s *ReceiveStatementContext) ReceiveIntoStatement() IReceiveIntoStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveIntoStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiveIntoStatementContext)
}

func (s *ReceiveStatementContext) OnExceptionClause() IOnExceptionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnExceptionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnExceptionClauseContext)
}

func (s *ReceiveStatementContext) NotOnExceptionClause() INotOnExceptionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnExceptionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnExceptionClauseContext)
}

func (s *ReceiveStatementContext) END_RECEIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_RECEIVE, 0)
}

func (s *ReceiveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveStatement(s)
	}
}

func (s *ReceiveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveStatement(s)
	}
}

func (s *ReceiveStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveStatement() (localctx IReceiveStatementContext) {
	localctx = NewReceiveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 822, Cobol85ParserRULE_receiveStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4833)
		p.Match(Cobol85ParserRECEIVE)
	}
	p.SetState(4836)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 712, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4834)
			p.ReceiveFromStatement()
		}

	case 2:
		{
			p.SetState(4835)
			p.ReceiveIntoStatement()
		}

	}
	p.SetState(4839)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 713, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4838)
			p.OnExceptionClause()
		}

	}
	p.SetState(4842)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 714, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4841)
			p.NotOnExceptionClause()
		}

	}
	p.SetState(4845)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 715, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4844)
			p.Match(Cobol85ParserEND_RECEIVE)
		}

	}

	return localctx
}

// IReceiveFromStatementContext is an interface to support dynamic dispatch.
type IReceiveFromStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveFromStatementContext differentiates from other interfaces.
	IsReceiveFromStatementContext()
}

type ReceiveFromStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveFromStatementContext() *ReceiveFromStatementContext {
	var p = new(ReceiveFromStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveFromStatement
	return p
}

func (*ReceiveFromStatementContext) IsReceiveFromStatementContext() {}

func NewReceiveFromStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveFromStatementContext {
	var p = new(ReceiveFromStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveFromStatement

	return p
}

func (s *ReceiveFromStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveFromStatementContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReceiveFromStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *ReceiveFromStatementContext) ReceiveFrom() IReceiveFromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveFromContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiveFromContext)
}

func (s *ReceiveFromStatementContext) AllReceiveBefore() []IReceiveBeforeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReceiveBeforeContext)(nil)).Elem())
	var tst = make([]IReceiveBeforeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReceiveBeforeContext)
		}
	}

	return tst
}

func (s *ReceiveFromStatementContext) ReceiveBefore(i int) IReceiveBeforeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveBeforeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReceiveBeforeContext)
}

func (s *ReceiveFromStatementContext) AllReceiveWith() []IReceiveWithContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReceiveWithContext)(nil)).Elem())
	var tst = make([]IReceiveWithContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReceiveWithContext)
		}
	}

	return tst
}

func (s *ReceiveFromStatementContext) ReceiveWith(i int) IReceiveWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveWithContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReceiveWithContext)
}

func (s *ReceiveFromStatementContext) AllReceiveThread() []IReceiveThreadContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReceiveThreadContext)(nil)).Elem())
	var tst = make([]IReceiveThreadContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReceiveThreadContext)
		}
	}

	return tst
}

func (s *ReceiveFromStatementContext) ReceiveThread(i int) IReceiveThreadContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveThreadContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReceiveThreadContext)
}

func (s *ReceiveFromStatementContext) AllReceiveSize() []IReceiveSizeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReceiveSizeContext)(nil)).Elem())
	var tst = make([]IReceiveSizeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReceiveSizeContext)
		}
	}

	return tst
}

func (s *ReceiveFromStatementContext) ReceiveSize(i int) IReceiveSizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveSizeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReceiveSizeContext)
}

func (s *ReceiveFromStatementContext) AllReceiveStatus() []IReceiveStatusContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReceiveStatusContext)(nil)).Elem())
	var tst = make([]IReceiveStatusContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReceiveStatusContext)
		}
	}

	return tst
}

func (s *ReceiveFromStatementContext) ReceiveStatus(i int) IReceiveStatusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveStatusContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReceiveStatusContext)
}

func (s *ReceiveFromStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveFromStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveFromStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveFromStatement(s)
	}
}

func (s *ReceiveFromStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveFromStatement(s)
	}
}

func (s *ReceiveFromStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveFromStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveFromStatement() (localctx IReceiveFromStatementContext) {
	localctx = NewReceiveFromStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 824, Cobol85ParserRULE_receiveFromStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4847)
		p.DataName()
	}
	{
		p.SetState(4848)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(4849)
		p.ReceiveFrom()
	}
	p.SetState(4857)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 717, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(4855)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Cobol85ParserBEFORE:
				{
					p.SetState(4850)
					p.ReceiveBefore()
				}

			case Cobol85ParserNO, Cobol85ParserWITH:
				{
					p.SetState(4851)
					p.ReceiveWith()
				}

			case Cobol85ParserTHREAD:
				{
					p.SetState(4852)
					p.ReceiveThread()
				}

			case Cobol85ParserSIZE:
				{
					p.SetState(4853)
					p.ReceiveSize()
				}

			case Cobol85ParserSTATUS:
				{
					p.SetState(4854)
					p.ReceiveStatus()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(4859)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 717, p.GetParserRuleContext())
	}

	return localctx
}

// IReceiveFromContext is an interface to support dynamic dispatch.
type IReceiveFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveFromContext differentiates from other interfaces.
	IsReceiveFromContext()
}

type ReceiveFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveFromContext() *ReceiveFromContext {
	var p = new(ReceiveFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveFrom
	return p
}

func (*ReceiveFromContext) IsReceiveFromContext() {}

func NewReceiveFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveFromContext {
	var p = new(ReceiveFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveFrom

	return p
}

func (s *ReceiveFromContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveFromContext) THREAD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHREAD, 0)
}

func (s *ReceiveFromContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReceiveFromContext) LAST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLAST, 0)
}

func (s *ReceiveFromContext) ANY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserANY, 0)
}

func (s *ReceiveFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveFrom(s)
	}
}

func (s *ReceiveFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveFrom(s)
	}
}

func (s *ReceiveFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveFrom() (localctx IReceiveFromContext) {
	localctx = NewReceiveFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 826, Cobol85ParserRULE_receiveFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4866)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserTHREAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4860)
			p.Match(Cobol85ParserTHREAD)
		}
		{
			p.SetState(4861)
			p.DataName()
		}

	case Cobol85ParserLAST:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4862)
			p.Match(Cobol85ParserLAST)
		}
		{
			p.SetState(4863)
			p.Match(Cobol85ParserTHREAD)
		}

	case Cobol85ParserANY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4864)
			p.Match(Cobol85ParserANY)
		}
		{
			p.SetState(4865)
			p.Match(Cobol85ParserTHREAD)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReceiveIntoStatementContext is an interface to support dynamic dispatch.
type IReceiveIntoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveIntoStatementContext differentiates from other interfaces.
	IsReceiveIntoStatementContext()
}

type ReceiveIntoStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveIntoStatementContext() *ReceiveIntoStatementContext {
	var p = new(ReceiveIntoStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveIntoStatement
	return p
}

func (*ReceiveIntoStatementContext) IsReceiveIntoStatementContext() {}

func NewReceiveIntoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveIntoStatementContext {
	var p = new(ReceiveIntoStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveIntoStatement

	return p
}

func (s *ReceiveIntoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveIntoStatementContext) CdName() ICdNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICdNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *ReceiveIntoStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReceiveIntoStatementContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMESSAGE, 0)
}

func (s *ReceiveIntoStatementContext) SEGMENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEGMENT, 0)
}

func (s *ReceiveIntoStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *ReceiveIntoStatementContext) ReceiveNoData() IReceiveNoDataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveNoDataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiveNoDataContext)
}

func (s *ReceiveIntoStatementContext) ReceiveWithData() IReceiveWithDataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveWithDataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiveWithDataContext)
}

func (s *ReceiveIntoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveIntoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveIntoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveIntoStatement(s)
	}
}

func (s *ReceiveIntoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveIntoStatement(s)
	}
}

func (s *ReceiveIntoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveIntoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveIntoStatement() (localctx IReceiveIntoStatementContext) {
	localctx = NewReceiveIntoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 828, Cobol85ParserRULE_receiveIntoStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4868)
		p.CdName()
	}
	p.SetState(4869)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserMESSAGE || _la == Cobol85ParserSEGMENT) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(4871)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINTO {
		{
			p.SetState(4870)
			p.Match(Cobol85ParserINTO)
		}

	}
	{
		p.SetState(4873)
		p.Identifier()
	}
	p.SetState(4875)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNO {
		{
			p.SetState(4874)
			p.ReceiveNoData()
		}

	}
	p.SetState(4878)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 721, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4877)
			p.ReceiveWithData()
		}

	}

	return localctx
}

// IReceiveNoDataContext is an interface to support dynamic dispatch.
type IReceiveNoDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveNoDataContext differentiates from other interfaces.
	IsReceiveNoDataContext()
}

type ReceiveNoDataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveNoDataContext() *ReceiveNoDataContext {
	var p = new(ReceiveNoDataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveNoData
	return p
}

func (*ReceiveNoDataContext) IsReceiveNoDataContext() {}

func NewReceiveNoDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveNoDataContext {
	var p = new(ReceiveNoDataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveNoData

	return p
}

func (s *ReceiveNoDataContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveNoDataContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *ReceiveNoDataContext) DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA, 0)
}

func (s *ReceiveNoDataContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *ReceiveNoDataContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ReceiveNoDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveNoDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveNoDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveNoData(s)
	}
}

func (s *ReceiveNoDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveNoData(s)
	}
}

func (s *ReceiveNoDataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveNoData(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveNoData() (localctx IReceiveNoDataContext) {
	localctx = NewReceiveNoDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 830, Cobol85ParserRULE_receiveNoData)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4880)
		p.Match(Cobol85ParserNO)
	}
	{
		p.SetState(4881)
		p.Match(Cobol85ParserDATA)
	}
	p.SetState(4885)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 722, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4882)
				p.Statement()
			}

		}
		p.SetState(4887)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 722, p.GetParserRuleContext())
	}

	return localctx
}

// IReceiveWithDataContext is an interface to support dynamic dispatch.
type IReceiveWithDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveWithDataContext differentiates from other interfaces.
	IsReceiveWithDataContext()
}

type ReceiveWithDataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveWithDataContext() *ReceiveWithDataContext {
	var p = new(ReceiveWithDataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveWithData
	return p
}

func (*ReceiveWithDataContext) IsReceiveWithDataContext() {}

func NewReceiveWithDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveWithDataContext {
	var p = new(ReceiveWithDataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveWithData

	return p
}

func (s *ReceiveWithDataContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveWithDataContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *ReceiveWithDataContext) DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA, 0)
}

func (s *ReceiveWithDataContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *ReceiveWithDataContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ReceiveWithDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveWithDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveWithDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveWithData(s)
	}
}

func (s *ReceiveWithDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveWithData(s)
	}
}

func (s *ReceiveWithDataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveWithData(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveWithData() (localctx IReceiveWithDataContext) {
	localctx = NewReceiveWithDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 832, Cobol85ParserRULE_receiveWithData)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4888)
		p.Match(Cobol85ParserWITH)
	}
	{
		p.SetState(4889)
		p.Match(Cobol85ParserDATA)
	}
	p.SetState(4893)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 723, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4890)
				p.Statement()
			}

		}
		p.SetState(4895)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 723, p.GetParserRuleContext())
	}

	return localctx
}

// IReceiveBeforeContext is an interface to support dynamic dispatch.
type IReceiveBeforeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveBeforeContext differentiates from other interfaces.
	IsReceiveBeforeContext()
}

type ReceiveBeforeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveBeforeContext() *ReceiveBeforeContext {
	var p = new(ReceiveBeforeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveBefore
	return p
}

func (*ReceiveBeforeContext) IsReceiveBeforeContext() {}

func NewReceiveBeforeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveBeforeContext {
	var p = new(ReceiveBeforeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveBefore

	return p
}

func (s *ReceiveBeforeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveBeforeContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEFORE, 0)
}

func (s *ReceiveBeforeContext) NumericLiteral() INumericLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *ReceiveBeforeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReceiveBeforeContext) TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIME, 0)
}

func (s *ReceiveBeforeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveBeforeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveBeforeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveBefore(s)
	}
}

func (s *ReceiveBeforeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveBefore(s)
	}
}

func (s *ReceiveBeforeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveBefore(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveBefore() (localctx IReceiveBeforeContext) {
	localctx = NewReceiveBeforeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 834, Cobol85ParserRULE_receiveBefore)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4896)
		p.Match(Cobol85ParserBEFORE)
	}
	p.SetState(4898)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 724, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4897)
			p.Match(Cobol85ParserTIME)
		}

	}
	p.SetState(4902)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 725, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4900)
			p.NumericLiteral()
		}

	case 2:
		{
			p.SetState(4901)
			p.Identifier()
		}

	}

	return localctx
}

// IReceiveWithContext is an interface to support dynamic dispatch.
type IReceiveWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveWithContext differentiates from other interfaces.
	IsReceiveWithContext()
}

type ReceiveWithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveWithContext() *ReceiveWithContext {
	var p = new(ReceiveWithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveWith
	return p
}

func (*ReceiveWithContext) IsReceiveWithContext() {}

func NewReceiveWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveWithContext {
	var p = new(ReceiveWithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveWith

	return p
}

func (s *ReceiveWithContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveWithContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *ReceiveWithContext) WAIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWAIT, 0)
}

func (s *ReceiveWithContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *ReceiveWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveWith(s)
	}
}

func (s *ReceiveWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveWith(s)
	}
}

func (s *ReceiveWithContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveWith(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveWith() (localctx IReceiveWithContext) {
	localctx = NewReceiveWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 836, Cobol85ParserRULE_receiveWith)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4905)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4904)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(4907)
		p.Match(Cobol85ParserNO)
	}
	{
		p.SetState(4908)
		p.Match(Cobol85ParserWAIT)
	}

	return localctx
}

// IReceiveThreadContext is an interface to support dynamic dispatch.
type IReceiveThreadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveThreadContext differentiates from other interfaces.
	IsReceiveThreadContext()
}

type ReceiveThreadContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveThreadContext() *ReceiveThreadContext {
	var p = new(ReceiveThreadContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveThread
	return p
}

func (*ReceiveThreadContext) IsReceiveThreadContext() {}

func NewReceiveThreadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveThreadContext {
	var p = new(ReceiveThreadContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveThread

	return p
}

func (s *ReceiveThreadContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveThreadContext) THREAD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHREAD, 0)
}

func (s *ReceiveThreadContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReceiveThreadContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *ReceiveThreadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveThreadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveThreadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveThread(s)
	}
}

func (s *ReceiveThreadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveThread(s)
	}
}

func (s *ReceiveThreadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveThread(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveThread() (localctx IReceiveThreadContext) {
	localctx = NewReceiveThreadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 838, Cobol85ParserRULE_receiveThread)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4910)
		p.Match(Cobol85ParserTHREAD)
	}
	p.SetState(4912)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(4911)
			p.Match(Cobol85ParserIN)
		}

	}
	{
		p.SetState(4914)
		p.DataName()
	}

	return localctx
}

// IReceiveSizeContext is an interface to support dynamic dispatch.
type IReceiveSizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveSizeContext differentiates from other interfaces.
	IsReceiveSizeContext()
}

type ReceiveSizeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveSizeContext() *ReceiveSizeContext {
	var p = new(ReceiveSizeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveSize
	return p
}

func (*ReceiveSizeContext) IsReceiveSizeContext() {}

func NewReceiveSizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveSizeContext {
	var p = new(ReceiveSizeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveSize

	return p
}

func (s *ReceiveSizeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveSizeContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *ReceiveSizeContext) NumericLiteral() INumericLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *ReceiveSizeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReceiveSizeContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *ReceiveSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveSizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveSize(s)
	}
}

func (s *ReceiveSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveSize(s)
	}
}

func (s *ReceiveSizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveSize(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveSize() (localctx IReceiveSizeContext) {
	localctx = NewReceiveSizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 840, Cobol85ParserRULE_receiveSize)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4916)
		p.Match(Cobol85ParserSIZE)
	}
	p.SetState(4918)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(4917)
			p.Match(Cobol85ParserIN)
		}

	}
	p.SetState(4922)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 729, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4920)
			p.NumericLiteral()
		}

	case 2:
		{
			p.SetState(4921)
			p.Identifier()
		}

	}

	return localctx
}

// IReceiveStatusContext is an interface to support dynamic dispatch.
type IReceiveStatusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveStatusContext differentiates from other interfaces.
	IsReceiveStatusContext()
}

type ReceiveStatusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveStatusContext() *ReceiveStatusContext {
	var p = new(ReceiveStatusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveStatus
	return p
}

func (*ReceiveStatusContext) IsReceiveStatusContext() {}

func NewReceiveStatusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveStatusContext {
	var p = new(ReceiveStatusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveStatus

	return p
}

func (s *ReceiveStatusContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTATUS, 0)
}

func (s *ReceiveStatusContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReceiveStatusContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *ReceiveStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveStatusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveStatus(s)
	}
}

func (s *ReceiveStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveStatus(s)
	}
}

func (s *ReceiveStatusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveStatus(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveStatus() (localctx IReceiveStatusContext) {
	localctx = NewReceiveStatusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 842, Cobol85ParserRULE_receiveStatus)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4924)
		p.Match(Cobol85ParserSTATUS)
	}
	p.SetState(4926)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(4925)
			p.Match(Cobol85ParserIN)
		}

	}

	{
		p.SetState(4928)
		p.Identifier()
	}

	return localctx
}

// IReleaseStatementContext is an interface to support dynamic dispatch.
type IReleaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReleaseStatementContext differentiates from other interfaces.
	IsReleaseStatementContext()
}

type ReleaseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReleaseStatementContext() *ReleaseStatementContext {
	var p = new(ReleaseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_releaseStatement
	return p
}

func (*ReleaseStatementContext) IsReleaseStatementContext() {}

func NewReleaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReleaseStatementContext {
	var p = new(ReleaseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_releaseStatement

	return p
}

func (s *ReleaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReleaseStatementContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRELEASE, 0)
}

func (s *ReleaseStatementContext) RecordName() IRecordNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordNameContext)
}

func (s *ReleaseStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *ReleaseStatementContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ReleaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReleaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReleaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReleaseStatement(s)
	}
}

func (s *ReleaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReleaseStatement(s)
	}
}

func (s *ReleaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReleaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReleaseStatement() (localctx IReleaseStatementContext) {
	localctx = NewReleaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 844, Cobol85ParserRULE_releaseStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4930)
		p.Match(Cobol85ParserRELEASE)
	}
	{
		p.SetState(4931)
		p.RecordName()
	}
	p.SetState(4934)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFROM {
		{
			p.SetState(4932)
			p.Match(Cobol85ParserFROM)
		}
		{
			p.SetState(4933)
			p.QualifiedDataName()
		}

	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRETURN, 0)
}

func (s *ReturnStatementContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *ReturnStatementContext) AtEndPhrase() IAtEndPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtEndPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtEndPhraseContext)
}

func (s *ReturnStatementContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *ReturnStatementContext) ReturnInto() IReturnIntoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnIntoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnIntoContext)
}

func (s *ReturnStatementContext) NotAtEndPhrase() INotAtEndPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotAtEndPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotAtEndPhraseContext)
}

func (s *ReturnStatementContext) END_RETURN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_RETURN, 0)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 846, Cobol85ParserRULE_returnStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4936)
		p.Match(Cobol85ParserRETURN)
	}
	{
		p.SetState(4937)
		p.FileName()
	}
	p.SetState(4939)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRECORD {
		{
			p.SetState(4938)
			p.Match(Cobol85ParserRECORD)
		}

	}
	p.SetState(4942)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINTO {
		{
			p.SetState(4941)
			p.ReturnInto()
		}

	}
	{
		p.SetState(4944)
		p.AtEndPhrase()
	}
	p.SetState(4946)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 734, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4945)
			p.NotAtEndPhrase()
		}

	}
	p.SetState(4949)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 735, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4948)
			p.Match(Cobol85ParserEND_RETURN)
		}

	}

	return localctx
}

// IReturnIntoContext is an interface to support dynamic dispatch.
type IReturnIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnIntoContext differentiates from other interfaces.
	IsReturnIntoContext()
}

type ReturnIntoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnIntoContext() *ReturnIntoContext {
	var p = new(ReturnIntoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_returnInto
	return p
}

func (*ReturnIntoContext) IsReturnIntoContext() {}

func NewReturnIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnIntoContext {
	var p = new(ReturnIntoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_returnInto

	return p
}

func (s *ReturnIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnIntoContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *ReturnIntoContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ReturnIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReturnInto(s)
	}
}

func (s *ReturnIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReturnInto(s)
	}
}

func (s *ReturnIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReturnInto(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReturnInto() (localctx IReturnIntoContext) {
	localctx = NewReturnIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 848, Cobol85ParserRULE_returnInto)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4951)
		p.Match(Cobol85ParserINTO)
	}
	{
		p.SetState(4952)
		p.QualifiedDataName()
	}

	return localctx
}

// IRewriteStatementContext is an interface to support dynamic dispatch.
type IRewriteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRewriteStatementContext differentiates from other interfaces.
	IsRewriteStatementContext()
}

type RewriteStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRewriteStatementContext() *RewriteStatementContext {
	var p = new(RewriteStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rewriteStatement
	return p
}

func (*RewriteStatementContext) IsRewriteStatementContext() {}

func NewRewriteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RewriteStatementContext {
	var p = new(RewriteStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rewriteStatement

	return p
}

func (s *RewriteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RewriteStatementContext) REWRITE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWRITE, 0)
}

func (s *RewriteStatementContext) RecordName() IRecordNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordNameContext)
}

func (s *RewriteStatementContext) RewriteFrom() IRewriteFromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRewriteFromContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRewriteFromContext)
}

func (s *RewriteStatementContext) InvalidKeyPhrase() IInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvalidKeyPhraseContext)
}

func (s *RewriteStatementContext) NotInvalidKeyPhrase() INotInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotInvalidKeyPhraseContext)
}

func (s *RewriteStatementContext) END_REWRITE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_REWRITE, 0)
}

func (s *RewriteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RewriteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RewriteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRewriteStatement(s)
	}
}

func (s *RewriteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRewriteStatement(s)
	}
}

func (s *RewriteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRewriteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RewriteStatement() (localctx IRewriteStatementContext) {
	localctx = NewRewriteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 850, Cobol85ParserRULE_rewriteStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4954)
		p.Match(Cobol85ParserREWRITE)
	}
	{
		p.SetState(4955)
		p.RecordName()
	}
	p.SetState(4957)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFROM {
		{
			p.SetState(4956)
			p.RewriteFrom()
		}

	}
	p.SetState(4960)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 737, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4959)
			p.InvalidKeyPhrase()
		}

	}
	p.SetState(4963)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 738, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4962)
			p.NotInvalidKeyPhrase()
		}

	}
	p.SetState(4966)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 739, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4965)
			p.Match(Cobol85ParserEND_REWRITE)
		}

	}

	return localctx
}

// IRewriteFromContext is an interface to support dynamic dispatch.
type IRewriteFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRewriteFromContext differentiates from other interfaces.
	IsRewriteFromContext()
}

type RewriteFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRewriteFromContext() *RewriteFromContext {
	var p = new(RewriteFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rewriteFrom
	return p
}

func (*RewriteFromContext) IsRewriteFromContext() {}

func NewRewriteFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RewriteFromContext {
	var p = new(RewriteFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rewriteFrom

	return p
}

func (s *RewriteFromContext) GetParser() antlr.Parser { return s.parser }

func (s *RewriteFromContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *RewriteFromContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RewriteFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RewriteFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RewriteFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRewriteFrom(s)
	}
}

func (s *RewriteFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRewriteFrom(s)
	}
}

func (s *RewriteFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRewriteFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RewriteFrom() (localctx IRewriteFromContext) {
	localctx = NewRewriteFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 852, Cobol85ParserRULE_rewriteFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4968)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(4969)
		p.Identifier()
	}

	return localctx
}

// ISearchStatementContext is an interface to support dynamic dispatch.
type ISearchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSearchStatementContext differentiates from other interfaces.
	IsSearchStatementContext()
}

type SearchStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchStatementContext() *SearchStatementContext {
	var p = new(SearchStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_searchStatement
	return p
}

func (*SearchStatementContext) IsSearchStatementContext() {}

func NewSearchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchStatementContext {
	var p = new(SearchStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_searchStatement

	return p
}

func (s *SearchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchStatementContext) SEARCH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEARCH, 0)
}

func (s *SearchStatementContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *SearchStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *SearchStatementContext) SearchVarying() ISearchVaryingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISearchVaryingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISearchVaryingContext)
}

func (s *SearchStatementContext) AtEndPhrase() IAtEndPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtEndPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtEndPhraseContext)
}

func (s *SearchStatementContext) AllSearchWhen() []ISearchWhenContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISearchWhenContext)(nil)).Elem())
	var tst = make([]ISearchWhenContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISearchWhenContext)
		}
	}

	return tst
}

func (s *SearchStatementContext) SearchWhen(i int) ISearchWhenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISearchWhenContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISearchWhenContext)
}

func (s *SearchStatementContext) END_SEARCH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_SEARCH, 0)
}

func (s *SearchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSearchStatement(s)
	}
}

func (s *SearchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSearchStatement(s)
	}
}

func (s *SearchStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSearchStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SearchStatement() (localctx ISearchStatementContext) {
	localctx = NewSearchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 854, Cobol85ParserRULE_searchStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4971)
		p.Match(Cobol85ParserSEARCH)
	}
	p.SetState(4973)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserALL {
		{
			p.SetState(4972)
			p.Match(Cobol85ParserALL)
		}

	}
	{
		p.SetState(4975)
		p.QualifiedDataName()
	}
	p.SetState(4977)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserVARYING {
		{
			p.SetState(4976)
			p.SearchVarying()
		}

	}
	p.SetState(4980)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT || _la == Cobol85ParserEND {
		{
			p.SetState(4979)
			p.AtEndPhrase()
		}

	}
	p.SetState(4983)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4982)
				p.SearchWhen()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4985)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 743, p.GetParserRuleContext())
	}
	p.SetState(4988)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 744, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4987)
			p.Match(Cobol85ParserEND_SEARCH)
		}

	}

	return localctx
}

// ISearchVaryingContext is an interface to support dynamic dispatch.
type ISearchVaryingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSearchVaryingContext differentiates from other interfaces.
	IsSearchVaryingContext()
}

type SearchVaryingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchVaryingContext() *SearchVaryingContext {
	var p = new(SearchVaryingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_searchVarying
	return p
}

func (*SearchVaryingContext) IsSearchVaryingContext() {}

func NewSearchVaryingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchVaryingContext {
	var p = new(SearchVaryingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_searchVarying

	return p
}

func (s *SearchVaryingContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchVaryingContext) VARYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVARYING, 0)
}

func (s *SearchVaryingContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *SearchVaryingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchVaryingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchVaryingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSearchVarying(s)
	}
}

func (s *SearchVaryingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSearchVarying(s)
	}
}

func (s *SearchVaryingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSearchVarying(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SearchVarying() (localctx ISearchVaryingContext) {
	localctx = NewSearchVaryingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 856, Cobol85ParserRULE_searchVarying)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4990)
		p.Match(Cobol85ParserVARYING)
	}
	{
		p.SetState(4991)
		p.QualifiedDataName()
	}

	return localctx
}

// ISearchWhenContext is an interface to support dynamic dispatch.
type ISearchWhenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSearchWhenContext differentiates from other interfaces.
	IsSearchWhenContext()
}

type SearchWhenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchWhenContext() *SearchWhenContext {
	var p = new(SearchWhenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_searchWhen
	return p
}

func (*SearchWhenContext) IsSearchWhenContext() {}

func NewSearchWhenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchWhenContext {
	var p = new(SearchWhenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_searchWhen

	return p
}

func (s *SearchWhenContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchWhenContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *SearchWhenContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *SearchWhenContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *SearchWhenContext) SENTENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSENTENCE, 0)
}

func (s *SearchWhenContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *SearchWhenContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SearchWhenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchWhenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchWhenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSearchWhen(s)
	}
}

func (s *SearchWhenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSearchWhen(s)
	}
}

func (s *SearchWhenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSearchWhen(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SearchWhen() (localctx ISearchWhenContext) {
	localctx = NewSearchWhenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 858, Cobol85ParserRULE_searchWhen)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4993)
		p.Match(Cobol85ParserWHEN)
	}
	{
		p.SetState(4994)
		p.Condition()
	}
	p.SetState(5003)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNEXT:
		{
			p.SetState(4995)
			p.Match(Cobol85ParserNEXT)
		}
		{
			p.SetState(4996)
			p.Match(Cobol85ParserSENTENCE)
		}

	case Cobol85ParserACCEPT, Cobol85ParserADD, Cobol85ParserALTER, Cobol85ParserAT, Cobol85ParserCALL, Cobol85ParserCANCEL, Cobol85ParserCLOSE, Cobol85ParserCOMPUTE, Cobol85ParserCONTINUE, Cobol85ParserDELETE, Cobol85ParserDISABLE, Cobol85ParserDISPLAY, Cobol85ParserDIVIDE, Cobol85ParserELSE, Cobol85ParserENABLE, Cobol85ParserEND, Cobol85ParserEND_ADD, Cobol85ParserEND_CALL, Cobol85ParserEND_COMPUTE, Cobol85ParserEND_DELETE, Cobol85ParserEND_DIVIDE, Cobol85ParserEND_EVALUATE, Cobol85ParserEND_IF, Cobol85ParserEND_MULTIPLY, Cobol85ParserEND_PERFORM, Cobol85ParserEND_READ, Cobol85ParserEND_RECEIVE, Cobol85ParserEND_RETURN, Cobol85ParserEND_REWRITE, Cobol85ParserEND_SEARCH, Cobol85ParserEND_START, Cobol85ParserEND_STRING, Cobol85ParserEND_SUBTRACT, Cobol85ParserEND_UNSTRING, Cobol85ParserEND_WRITE, Cobol85ParserENTRY, Cobol85ParserEVALUATE, Cobol85ParserEXCEPTION, Cobol85ParserEXHIBIT, Cobol85ParserEXIT, Cobol85ParserGENERATE, Cobol85ParserGOBACK, Cobol85ParserGO, Cobol85ParserIF, Cobol85ParserINITIALIZE, Cobol85ParserINITIATE, Cobol85ParserINSPECT, Cobol85ParserINVALID, Cobol85ParserMERGE, Cobol85ParserMOVE, Cobol85ParserMULTIPLY, Cobol85ParserNOT, Cobol85ParserON, Cobol85ParserOPEN, Cobol85ParserPERFORM, Cobol85ParserPURGE, Cobol85ParserREAD, Cobol85ParserRECEIVE, Cobol85ParserRELEASE, Cobol85ParserRETURN, Cobol85ParserREWRITE, Cobol85ParserSEARCH, Cobol85ParserSEND, Cobol85ParserSET, Cobol85ParserSORT, Cobol85ParserSTART, Cobol85ParserSTOP, Cobol85ParserSTRING, Cobol85ParserSUBTRACT, Cobol85ParserTERMINATE, Cobol85ParserUNSTRING, Cobol85ParserWHEN, Cobol85ParserWITH, Cobol85ParserWRITE, Cobol85ParserDOT_FS, Cobol85ParserEXECCICSLINE, Cobol85ParserEXECSQLIMSLINE, Cobol85ParserEXECSQLLINE:
		p.SetState(5000)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 745, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4997)
					p.Statement()
				}

			}
			p.SetState(5002)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 745, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISendStatementContext is an interface to support dynamic dispatch.
type ISendStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendStatementContext differentiates from other interfaces.
	IsSendStatementContext()
}

type SendStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendStatementContext() *SendStatementContext {
	var p = new(SendStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendStatement
	return p
}

func (*SendStatementContext) IsSendStatementContext() {}

func NewSendStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendStatementContext {
	var p = new(SendStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendStatement

	return p
}

func (s *SendStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SendStatementContext) SEND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEND, 0)
}

func (s *SendStatementContext) SendStatementSync() ISendStatementSyncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendStatementSyncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendStatementSyncContext)
}

func (s *SendStatementContext) SendStatementAsync() ISendStatementAsyncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendStatementAsyncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendStatementAsyncContext)
}

func (s *SendStatementContext) OnExceptionClause() IOnExceptionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnExceptionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnExceptionClauseContext)
}

func (s *SendStatementContext) NotOnExceptionClause() INotOnExceptionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnExceptionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnExceptionClauseContext)
}

func (s *SendStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendStatement(s)
	}
}

func (s *SendStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendStatement(s)
	}
}

func (s *SendStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendStatement() (localctx ISendStatementContext) {
	localctx = NewSendStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 860, Cobol85ParserRULE_sendStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5005)
		p.Match(Cobol85ParserSEND)
	}
	p.SetState(5008)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserADDRESS, Cobol85ParserALL, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDATE, Cobol85ParserDAY, Cobol85ParserDAY_OF_WEEK, Cobol85ParserDEBUG_CONTENTS, Cobol85ParserDEBUG_ITEM, Cobol85ParserDEBUG_LINE, Cobol85ParserDEBUG_NAME, Cobol85ParserDEBUG_SUB_1, Cobol85ParserDEBUG_SUB_2, Cobol85ParserDEBUG_SUB_3, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFALSE, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTION, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserHIGH_VALUE, Cobol85ParserHIGH_VALUES, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLINAGE_COUNTER, Cobol85ParserLINE_COUNTER, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserLOW_VALUE, Cobol85ParserLOW_VALUES, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNULL, Cobol85ParserNULLS, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPAGE_COUNTER, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserQUOTE, Cobol85ParserQUOTES, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserRETURN_CODE, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHIFT_IN, Cobol85ParserSHIFT_OUT, Cobol85ParserSHORT_DATE, Cobol85ParserSORT_CONTROL, Cobol85ParserSORT_CORE_SIZE, Cobol85ParserSORT_FILE_SIZE, Cobol85ParserSORT_MESSAGE, Cobol85ParserSORT_MODE_SIZE, Cobol85ParserSORT_RETURN, Cobol85ParserSP, Cobol85ParserSPACE, Cobol85ParserSPACES, Cobol85ParserSYMBOL, Cobol85ParserTALLY, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIME, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUE, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserWHEN_COMPILED, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO, Cobol85ParserZERO_FILL, Cobol85ParserZEROS, Cobol85ParserZEROES, Cobol85ParserNONNUMERICLITERAL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserNUMERICLITERAL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(5006)
			p.SendStatementSync()
		}

	case Cobol85ParserTO:
		{
			p.SetState(5007)
			p.SendStatementAsync()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(5011)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 748, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5010)
			p.OnExceptionClause()
		}

	}
	p.SetState(5014)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 749, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5013)
			p.NotOnExceptionClause()
		}

	}

	return localctx
}

// ISendStatementSyncContext is an interface to support dynamic dispatch.
type ISendStatementSyncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendStatementSyncContext differentiates from other interfaces.
	IsSendStatementSyncContext()
}

type SendStatementSyncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendStatementSyncContext() *SendStatementSyncContext {
	var p = new(SendStatementSyncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendStatementSync
	return p
}

func (*SendStatementSyncContext) IsSendStatementSyncContext() {}

func NewSendStatementSyncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendStatementSyncContext {
	var p = new(SendStatementSyncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendStatementSync

	return p
}

func (s *SendStatementSyncContext) GetParser() antlr.Parser { return s.parser }

func (s *SendStatementSyncContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SendStatementSyncContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SendStatementSyncContext) SendFromPhrase() ISendFromPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendFromPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendFromPhraseContext)
}

func (s *SendStatementSyncContext) SendWithPhrase() ISendWithPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendWithPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendWithPhraseContext)
}

func (s *SendStatementSyncContext) SendReplacingPhrase() ISendReplacingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendReplacingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendReplacingPhraseContext)
}

func (s *SendStatementSyncContext) SendAdvancingPhrase() ISendAdvancingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendAdvancingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendAdvancingPhraseContext)
}

func (s *SendStatementSyncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendStatementSyncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendStatementSyncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendStatementSync(s)
	}
}

func (s *SendStatementSyncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendStatementSync(s)
	}
}

func (s *SendStatementSyncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendStatementSync(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendStatementSync() (localctx ISendStatementSyncContext) {
	localctx = NewSendStatementSyncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 862, Cobol85ParserRULE_sendStatementSync)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5018)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 750, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5016)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5017)
			p.Literal()
		}

	}
	p.SetState(5021)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFROM {
		{
			p.SetState(5020)
			p.SendFromPhrase()
		}

	}
	p.SetState(5024)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 752, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5023)
			p.SendWithPhrase()
		}

	}
	p.SetState(5027)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserREPLACING {
		{
			p.SetState(5026)
			p.SendReplacingPhrase()
		}

	}
	p.SetState(5030)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(5029)
			p.SendAdvancingPhrase()
		}

	}

	return localctx
}

// ISendStatementAsyncContext is an interface to support dynamic dispatch.
type ISendStatementAsyncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendStatementAsyncContext differentiates from other interfaces.
	IsSendStatementAsyncContext()
}

type SendStatementAsyncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendStatementAsyncContext() *SendStatementAsyncContext {
	var p = new(SendStatementAsyncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendStatementAsync
	return p
}

func (*SendStatementAsyncContext) IsSendStatementAsyncContext() {}

func NewSendStatementAsyncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendStatementAsyncContext {
	var p = new(SendStatementAsyncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendStatementAsync

	return p
}

func (s *SendStatementAsyncContext) GetParser() antlr.Parser { return s.parser }

func (s *SendStatementAsyncContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *SendStatementAsyncContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SendStatementAsyncContext) TOP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTOP, 0)
}

func (s *SendStatementAsyncContext) BOTTOM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBOTTOM, 0)
}

func (s *SendStatementAsyncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendStatementAsyncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendStatementAsyncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendStatementAsync(s)
	}
}

func (s *SendStatementAsyncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendStatementAsync(s)
	}
}

func (s *SendStatementAsyncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendStatementAsync(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendStatementAsync() (localctx ISendStatementAsyncContext) {
	localctx = NewSendStatementAsyncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 864, Cobol85ParserRULE_sendStatementAsync)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5032)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(5033)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserBOTTOM || _la == Cobol85ParserTOP) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(5034)
		p.Identifier()
	}

	return localctx
}

// ISendFromPhraseContext is an interface to support dynamic dispatch.
type ISendFromPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendFromPhraseContext differentiates from other interfaces.
	IsSendFromPhraseContext()
}

type SendFromPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendFromPhraseContext() *SendFromPhraseContext {
	var p = new(SendFromPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendFromPhrase
	return p
}

func (*SendFromPhraseContext) IsSendFromPhraseContext() {}

func NewSendFromPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendFromPhraseContext {
	var p = new(SendFromPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendFromPhrase

	return p
}

func (s *SendFromPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SendFromPhraseContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *SendFromPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SendFromPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendFromPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendFromPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendFromPhrase(s)
	}
}

func (s *SendFromPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendFromPhrase(s)
	}
}

func (s *SendFromPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendFromPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendFromPhrase() (localctx ISendFromPhraseContext) {
	localctx = NewSendFromPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 866, Cobol85ParserRULE_sendFromPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5036)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(5037)
		p.Identifier()
	}

	return localctx
}

// ISendWithPhraseContext is an interface to support dynamic dispatch.
type ISendWithPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendWithPhraseContext differentiates from other interfaces.
	IsSendWithPhraseContext()
}

type SendWithPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendWithPhraseContext() *SendWithPhraseContext {
	var p = new(SendWithPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendWithPhrase
	return p
}

func (*SendWithPhraseContext) IsSendWithPhraseContext() {}

func NewSendWithPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendWithPhraseContext {
	var p = new(SendWithPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendWithPhrase

	return p
}

func (s *SendWithPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SendWithPhraseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *SendWithPhraseContext) EGI() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEGI, 0)
}

func (s *SendWithPhraseContext) EMI() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEMI, 0)
}

func (s *SendWithPhraseContext) ESI() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserESI, 0)
}

func (s *SendWithPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SendWithPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendWithPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendWithPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendWithPhrase(s)
	}
}

func (s *SendWithPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendWithPhrase(s)
	}
}

func (s *SendWithPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendWithPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendWithPhrase() (localctx ISendWithPhraseContext) {
	localctx = NewSendWithPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 868, Cobol85ParserRULE_sendWithPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5039)
		p.Match(Cobol85ParserWITH)
	}
	p.SetState(5044)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserEGI:
		{
			p.SetState(5040)
			p.Match(Cobol85ParserEGI)
		}

	case Cobol85ParserEMI:
		{
			p.SetState(5041)
			p.Match(Cobol85ParserEMI)
		}

	case Cobol85ParserESI:
		{
			p.SetState(5042)
			p.Match(Cobol85ParserESI)
		}

	case Cobol85ParserABORT, Cobol85ParserADDRESS, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDATE, Cobol85ParserDAY, Cobol85ParserDAY_OF_WEEK, Cobol85ParserDEBUG_CONTENTS, Cobol85ParserDEBUG_ITEM, Cobol85ParserDEBUG_LINE, Cobol85ParserDEBUG_NAME, Cobol85ParserDEBUG_SUB_1, Cobol85ParserDEBUG_SUB_2, Cobol85ParserDEBUG_SUB_3, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTION, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLINAGE_COUNTER, Cobol85ParserLINE_COUNTER, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPAGE_COUNTER, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserRETURN_CODE, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHIFT_IN, Cobol85ParserSHIFT_OUT, Cobol85ParserSHORT_DATE, Cobol85ParserSORT_CONTROL, Cobol85ParserSORT_CORE_SIZE, Cobol85ParserSORT_FILE_SIZE, Cobol85ParserSORT_MESSAGE, Cobol85ParserSORT_MODE_SIZE, Cobol85ParserSORT_RETURN, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTALLY, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIME, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserWHEN_COMPILED, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(5043)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISendReplacingPhraseContext is an interface to support dynamic dispatch.
type ISendReplacingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendReplacingPhraseContext differentiates from other interfaces.
	IsSendReplacingPhraseContext()
}

type SendReplacingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendReplacingPhraseContext() *SendReplacingPhraseContext {
	var p = new(SendReplacingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendReplacingPhrase
	return p
}

func (*SendReplacingPhraseContext) IsSendReplacingPhraseContext() {}

func NewSendReplacingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendReplacingPhraseContext {
	var p = new(SendReplacingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendReplacingPhrase

	return p
}

func (s *SendReplacingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SendReplacingPhraseContext) REPLACING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPLACING, 0)
}

func (s *SendReplacingPhraseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *SendReplacingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendReplacingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendReplacingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendReplacingPhrase(s)
	}
}

func (s *SendReplacingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendReplacingPhrase(s)
	}
}

func (s *SendReplacingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendReplacingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendReplacingPhrase() (localctx ISendReplacingPhraseContext) {
	localctx = NewSendReplacingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 870, Cobol85ParserRULE_sendReplacingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5046)
		p.Match(Cobol85ParserREPLACING)
	}
	p.SetState(5048)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINE {
		{
			p.SetState(5047)
			p.Match(Cobol85ParserLINE)
		}

	}

	return localctx
}

// ISendAdvancingPhraseContext is an interface to support dynamic dispatch.
type ISendAdvancingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendAdvancingPhraseContext differentiates from other interfaces.
	IsSendAdvancingPhraseContext()
}

type SendAdvancingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendAdvancingPhraseContext() *SendAdvancingPhraseContext {
	var p = new(SendAdvancingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingPhrase
	return p
}

func (*SendAdvancingPhraseContext) IsSendAdvancingPhraseContext() {}

func NewSendAdvancingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendAdvancingPhraseContext {
	var p = new(SendAdvancingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingPhrase

	return p
}

func (s *SendAdvancingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SendAdvancingPhraseContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEFORE, 0)
}

func (s *SendAdvancingPhraseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *SendAdvancingPhraseContext) SendAdvancingPage() ISendAdvancingPageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendAdvancingPageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendAdvancingPageContext)
}

func (s *SendAdvancingPhraseContext) SendAdvancingLines() ISendAdvancingLinesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendAdvancingLinesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendAdvancingLinesContext)
}

func (s *SendAdvancingPhraseContext) SendAdvancingMnemonic() ISendAdvancingMnemonicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendAdvancingMnemonicContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendAdvancingMnemonicContext)
}

func (s *SendAdvancingPhraseContext) ADVANCING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADVANCING, 0)
}

func (s *SendAdvancingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendAdvancingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendAdvancingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendAdvancingPhrase(s)
	}
}

func (s *SendAdvancingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendAdvancingPhrase(s)
	}
}

func (s *SendAdvancingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendAdvancingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendAdvancingPhrase() (localctx ISendAdvancingPhraseContext) {
	localctx = NewSendAdvancingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 872, Cobol85ParserRULE_sendAdvancingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5050)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(5052)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserADVANCING {
		{
			p.SetState(5051)
			p.Match(Cobol85ParserADVANCING)
		}

	}
	p.SetState(5057)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 758, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5054)
			p.SendAdvancingPage()
		}

	case 2:
		{
			p.SetState(5055)
			p.SendAdvancingLines()
		}

	case 3:
		{
			p.SetState(5056)
			p.SendAdvancingMnemonic()
		}

	}

	return localctx
}

// ISendAdvancingPageContext is an interface to support dynamic dispatch.
type ISendAdvancingPageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendAdvancingPageContext differentiates from other interfaces.
	IsSendAdvancingPageContext()
}

type SendAdvancingPageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendAdvancingPageContext() *SendAdvancingPageContext {
	var p = new(SendAdvancingPageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingPage
	return p
}

func (*SendAdvancingPageContext) IsSendAdvancingPageContext() {}

func NewSendAdvancingPageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendAdvancingPageContext {
	var p = new(SendAdvancingPageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingPage

	return p
}

func (s *SendAdvancingPageContext) GetParser() antlr.Parser { return s.parser }

func (s *SendAdvancingPageContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *SendAdvancingPageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendAdvancingPageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendAdvancingPageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendAdvancingPage(s)
	}
}

func (s *SendAdvancingPageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendAdvancingPage(s)
	}
}

func (s *SendAdvancingPageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendAdvancingPage(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendAdvancingPage() (localctx ISendAdvancingPageContext) {
	localctx = NewSendAdvancingPageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 874, Cobol85ParserRULE_sendAdvancingPage)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5059)
		p.Match(Cobol85ParserPAGE)
	}

	return localctx
}

// ISendAdvancingLinesContext is an interface to support dynamic dispatch.
type ISendAdvancingLinesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendAdvancingLinesContext differentiates from other interfaces.
	IsSendAdvancingLinesContext()
}

type SendAdvancingLinesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendAdvancingLinesContext() *SendAdvancingLinesContext {
	var p = new(SendAdvancingLinesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingLines
	return p
}

func (*SendAdvancingLinesContext) IsSendAdvancingLinesContext() {}

func NewSendAdvancingLinesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendAdvancingLinesContext {
	var p = new(SendAdvancingLinesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingLines

	return p
}

func (s *SendAdvancingLinesContext) GetParser() antlr.Parser { return s.parser }

func (s *SendAdvancingLinesContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SendAdvancingLinesContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SendAdvancingLinesContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *SendAdvancingLinesContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *SendAdvancingLinesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendAdvancingLinesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendAdvancingLinesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendAdvancingLines(s)
	}
}

func (s *SendAdvancingLinesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendAdvancingLines(s)
	}
}

func (s *SendAdvancingLinesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendAdvancingLines(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendAdvancingLines() (localctx ISendAdvancingLinesContext) {
	localctx = NewSendAdvancingLinesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 876, Cobol85ParserRULE_sendAdvancingLines)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5063)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 759, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5061)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5062)
			p.Literal()
		}

	}
	p.SetState(5066)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINE || _la == Cobol85ParserLINES {
		p.SetState(5065)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserLINE || _la == Cobol85ParserLINES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// ISendAdvancingMnemonicContext is an interface to support dynamic dispatch.
type ISendAdvancingMnemonicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendAdvancingMnemonicContext differentiates from other interfaces.
	IsSendAdvancingMnemonicContext()
}

type SendAdvancingMnemonicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendAdvancingMnemonicContext() *SendAdvancingMnemonicContext {
	var p = new(SendAdvancingMnemonicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingMnemonic
	return p
}

func (*SendAdvancingMnemonicContext) IsSendAdvancingMnemonicContext() {}

func NewSendAdvancingMnemonicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendAdvancingMnemonicContext {
	var p = new(SendAdvancingMnemonicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingMnemonic

	return p
}

func (s *SendAdvancingMnemonicContext) GetParser() antlr.Parser { return s.parser }

func (s *SendAdvancingMnemonicContext) MnemonicName() IMnemonicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMnemonicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *SendAdvancingMnemonicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendAdvancingMnemonicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendAdvancingMnemonicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendAdvancingMnemonic(s)
	}
}

func (s *SendAdvancingMnemonicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendAdvancingMnemonic(s)
	}
}

func (s *SendAdvancingMnemonicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendAdvancingMnemonic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendAdvancingMnemonic() (localctx ISendAdvancingMnemonicContext) {
	localctx = NewSendAdvancingMnemonicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 878, Cobol85ParserRULE_sendAdvancingMnemonic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5068)
		p.MnemonicName()
	}

	return localctx
}

// ISetStatementContext is an interface to support dynamic dispatch.
type ISetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetStatementContext differentiates from other interfaces.
	IsSetStatementContext()
}

type SetStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementContext() *SetStatementContext {
	var p = new(SetStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setStatement
	return p
}

func (*SetStatementContext) IsSetStatementContext() {}

func NewSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementContext {
	var p = new(SetStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setStatement

	return p
}

func (s *SetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSET, 0)
}

func (s *SetStatementContext) SetUpDownByStatement() ISetUpDownByStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetUpDownByStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetUpDownByStatementContext)
}

func (s *SetStatementContext) AllSetToStatement() []ISetToStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISetToStatementContext)(nil)).Elem())
	var tst = make([]ISetToStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISetToStatementContext)
		}
	}

	return tst
}

func (s *SetStatementContext) SetToStatement(i int) ISetToStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetToStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISetToStatementContext)
}

func (s *SetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetStatement(s)
	}
}

func (s *SetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetStatement(s)
	}
}

func (s *SetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SetStatement() (localctx ISetStatementContext) {
	localctx = NewSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 880, Cobol85ParserRULE_setStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5070)
		p.Match(Cobol85ParserSET)
	}
	p.SetState(5077)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 762, p.GetParserRuleContext()) {
	case 1:
		p.SetState(5072)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
			{
				p.SetState(5071)
				p.SetToStatement()
			}

			p.SetState(5074)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(5076)
			p.SetUpDownByStatement()
		}

	}

	return localctx
}

// ISetToStatementContext is an interface to support dynamic dispatch.
type ISetToStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetToStatementContext differentiates from other interfaces.
	IsSetToStatementContext()
}

type SetToStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetToStatementContext() *SetToStatementContext {
	var p = new(SetToStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setToStatement
	return p
}

func (*SetToStatementContext) IsSetToStatementContext() {}

func NewSetToStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetToStatementContext {
	var p = new(SetToStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setToStatement

	return p
}

func (s *SetToStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetToStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *SetToStatementContext) AllSetTo() []ISetToContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISetToContext)(nil)).Elem())
	var tst = make([]ISetToContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISetToContext)
		}
	}

	return tst
}

func (s *SetToStatementContext) SetTo(i int) ISetToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetToContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISetToContext)
}

func (s *SetToStatementContext) AllSetToValue() []ISetToValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISetToValueContext)(nil)).Elem())
	var tst = make([]ISetToValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISetToValueContext)
		}
	}

	return tst
}

func (s *SetToStatementContext) SetToValue(i int) ISetToValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetToValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISetToValueContext)
}

func (s *SetToStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetToStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetToStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetToStatement(s)
	}
}

func (s *SetToStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetToStatement(s)
	}
}

func (s *SetToStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSetToStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SetToStatement() (localctx ISetToStatementContext) {
	localctx = NewSetToStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 882, Cobol85ParserRULE_setToStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5080)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(5079)
			p.SetTo()
		}

		p.SetState(5082)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5084)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(5086)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(5085)
				p.SetToValue()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(5088)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 764, p.GetParserRuleContext())
	}

	return localctx
}

// ISetUpDownByStatementContext is an interface to support dynamic dispatch.
type ISetUpDownByStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetUpDownByStatementContext differentiates from other interfaces.
	IsSetUpDownByStatementContext()
}

type SetUpDownByStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetUpDownByStatementContext() *SetUpDownByStatementContext {
	var p = new(SetUpDownByStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setUpDownByStatement
	return p
}

func (*SetUpDownByStatementContext) IsSetUpDownByStatementContext() {}

func NewSetUpDownByStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetUpDownByStatementContext {
	var p = new(SetUpDownByStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setUpDownByStatement

	return p
}

func (s *SetUpDownByStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetUpDownByStatementContext) SetByValue() ISetByValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetByValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetByValueContext)
}

func (s *SetUpDownByStatementContext) UP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUP, 0)
}

func (s *SetUpDownByStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *SetUpDownByStatementContext) DOWN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOWN, 0)
}

func (s *SetUpDownByStatementContext) AllSetTo() []ISetToContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISetToContext)(nil)).Elem())
	var tst = make([]ISetToContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISetToContext)
		}
	}

	return tst
}

func (s *SetUpDownByStatementContext) SetTo(i int) ISetToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetToContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISetToContext)
}

func (s *SetUpDownByStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUpDownByStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetUpDownByStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetUpDownByStatement(s)
	}
}

func (s *SetUpDownByStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetUpDownByStatement(s)
	}
}

func (s *SetUpDownByStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSetUpDownByStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SetUpDownByStatement() (localctx ISetUpDownByStatementContext) {
	localctx = NewSetUpDownByStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 884, Cobol85ParserRULE_setUpDownByStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5091)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(5090)
			p.SetTo()
		}

		p.SetState(5093)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5099)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserUP:
		{
			p.SetState(5095)
			p.Match(Cobol85ParserUP)
		}
		{
			p.SetState(5096)
			p.Match(Cobol85ParserBY)
		}

	case Cobol85ParserDOWN:
		{
			p.SetState(5097)
			p.Match(Cobol85ParserDOWN)
		}
		{
			p.SetState(5098)
			p.Match(Cobol85ParserBY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(5101)
		p.SetByValue()
	}

	return localctx
}

// ISetToContext is an interface to support dynamic dispatch.
type ISetToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetToContext differentiates from other interfaces.
	IsSetToContext()
}

type SetToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetToContext() *SetToContext {
	var p = new(SetToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setTo
	return p
}

func (*SetToContext) IsSetToContext() {}

func NewSetToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetToContext {
	var p = new(SetToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setTo

	return p
}

func (s *SetToContext) GetParser() antlr.Parser { return s.parser }

func (s *SetToContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetTo(s)
	}
}

func (s *SetToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetTo(s)
	}
}

func (s *SetToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSetTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SetTo() (localctx ISetToContext) {
	localctx = NewSetToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 886, Cobol85ParserRULE_setTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5103)
		p.Identifier()
	}

	return localctx
}

// ISetToValueContext is an interface to support dynamic dispatch.
type ISetToValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetToValueContext differentiates from other interfaces.
	IsSetToValueContext()
}

type SetToValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetToValueContext() *SetToValueContext {
	var p = new(SetToValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setToValue
	return p
}

func (*SetToValueContext) IsSetToValueContext() {}

func NewSetToValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetToValueContext {
	var p = new(SetToValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setToValue

	return p
}

func (s *SetToValueContext) GetParser() antlr.Parser { return s.parser }

func (s *SetToValueContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *SetToValueContext) OFF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOFF, 0)
}

func (s *SetToValueContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetToValueContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SetToValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetToValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetToValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetToValue(s)
	}
}

func (s *SetToValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetToValue(s)
	}
}

func (s *SetToValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSetToValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SetToValue() (localctx ISetToValueContext) {
	localctx = NewSetToValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 888, Cobol85ParserRULE_setToValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5109)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 767, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5105)
			p.Match(Cobol85ParserON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5106)
			p.Match(Cobol85ParserOFF)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5107)
			p.Identifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5108)
			p.Literal()
		}

	}

	return localctx
}

// ISetByValueContext is an interface to support dynamic dispatch.
type ISetByValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetByValueContext differentiates from other interfaces.
	IsSetByValueContext()
}

type SetByValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetByValueContext() *SetByValueContext {
	var p = new(SetByValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setByValue
	return p
}

func (*SetByValueContext) IsSetByValueContext() {}

func NewSetByValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetByValueContext {
	var p = new(SetByValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setByValue

	return p
}

func (s *SetByValueContext) GetParser() antlr.Parser { return s.parser }

func (s *SetByValueContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetByValueContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SetByValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetByValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetByValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetByValue(s)
	}
}

func (s *SetByValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetByValue(s)
	}
}

func (s *SetByValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSetByValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SetByValue() (localctx ISetByValueContext) {
	localctx = NewSetByValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 890, Cobol85ParserRULE_setByValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5113)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 768, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5111)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5112)
			p.Literal()
		}

	}

	return localctx
}

// ISortStatementContext is an interface to support dynamic dispatch.
type ISortStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortStatementContext differentiates from other interfaces.
	IsSortStatementContext()
}

type SortStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortStatementContext() *SortStatementContext {
	var p = new(SortStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortStatement
	return p
}

func (*SortStatementContext) IsSortStatementContext() {}

func NewSortStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortStatementContext {
	var p = new(SortStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortStatement

	return p
}

func (s *SortStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SortStatementContext) SORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT, 0)
}

func (s *SortStatementContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *SortStatementContext) AllSortOnKeyClause() []ISortOnKeyClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortOnKeyClauseContext)(nil)).Elem())
	var tst = make([]ISortOnKeyClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortOnKeyClauseContext)
		}
	}

	return tst
}

func (s *SortStatementContext) SortOnKeyClause(i int) ISortOnKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortOnKeyClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortOnKeyClauseContext)
}

func (s *SortStatementContext) SortDuplicatesPhrase() ISortDuplicatesPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortDuplicatesPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortDuplicatesPhraseContext)
}

func (s *SortStatementContext) SortCollatingSequencePhrase() ISortCollatingSequencePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortCollatingSequencePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortCollatingSequencePhraseContext)
}

func (s *SortStatementContext) SortInputProcedurePhrase() ISortInputProcedurePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortInputProcedurePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortInputProcedurePhraseContext)
}

func (s *SortStatementContext) AllSortUsing() []ISortUsingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortUsingContext)(nil)).Elem())
	var tst = make([]ISortUsingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortUsingContext)
		}
	}

	return tst
}

func (s *SortStatementContext) SortUsing(i int) ISortUsingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortUsingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortUsingContext)
}

func (s *SortStatementContext) SortOutputProcedurePhrase() ISortOutputProcedurePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortOutputProcedurePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortOutputProcedurePhraseContext)
}

func (s *SortStatementContext) AllSortGivingPhrase() []ISortGivingPhraseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortGivingPhraseContext)(nil)).Elem())
	var tst = make([]ISortGivingPhraseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortGivingPhraseContext)
		}
	}

	return tst
}

func (s *SortStatementContext) SortGivingPhrase(i int) ISortGivingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortGivingPhraseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortGivingPhraseContext)
}

func (s *SortStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortStatement(s)
	}
}

func (s *SortStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortStatement(s)
	}
}

func (s *SortStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortStatement() (localctx ISortStatementContext) {
	localctx = NewSortStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 892, Cobol85ParserRULE_sortStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5115)
		p.Match(Cobol85ParserSORT)
	}
	{
		p.SetState(5116)
		p.FileName()
	}
	p.SetState(5118)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(5117)
				p.SortOnKeyClause()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(5120)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 769, p.GetParserRuleContext())
	}
	p.SetState(5123)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 770, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5122)
			p.SortDuplicatesPhrase()
		}

	}
	p.SetState(5126)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOLLATING || _la == Cobol85ParserSEQUENCE {
		{
			p.SetState(5125)
			p.SortCollatingSequencePhrase()
		}

	}
	p.SetState(5129)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINPUT {
		{
			p.SetState(5128)
			p.SortInputProcedurePhrase()
		}

	}
	p.SetState(5134)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserUSING {
		{
			p.SetState(5131)
			p.SortUsing()
		}

		p.SetState(5136)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5138)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOUTPUT {
		{
			p.SetState(5137)
			p.SortOutputProcedurePhrase()
		}

	}
	p.SetState(5143)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserGIVING {
		{
			p.SetState(5140)
			p.SortGivingPhrase()
		}

		p.SetState(5145)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISortOnKeyClauseContext is an interface to support dynamic dispatch.
type ISortOnKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortOnKeyClauseContext differentiates from other interfaces.
	IsSortOnKeyClauseContext()
}

type SortOnKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortOnKeyClauseContext() *SortOnKeyClauseContext {
	var p = new(SortOnKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortOnKeyClause
	return p
}

func (*SortOnKeyClauseContext) IsSortOnKeyClauseContext() {}

func NewSortOnKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortOnKeyClauseContext {
	var p = new(SortOnKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortOnKeyClause

	return p
}

func (s *SortOnKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortOnKeyClauseContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASCENDING, 0)
}

func (s *SortOnKeyClauseContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESCENDING, 0)
}

func (s *SortOnKeyClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *SortOnKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *SortOnKeyClauseContext) AllQualifiedDataName() []IQualifiedDataNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem())
	var tst = make([]IQualifiedDataNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedDataNameContext)
		}
	}

	return tst
}

func (s *SortOnKeyClauseContext) QualifiedDataName(i int) IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *SortOnKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortOnKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortOnKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortOnKeyClause(s)
	}
}

func (s *SortOnKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortOnKeyClause(s)
	}
}

func (s *SortOnKeyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortOnKeyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortOnKeyClause() (localctx ISortOnKeyClauseContext) {
	localctx = NewSortOnKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 894, Cobol85ParserRULE_sortOnKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5147)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5146)
			p.Match(Cobol85ParserON)
		}

	}
	p.SetState(5149)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserASCENDING || _la == Cobol85ParserDESCENDING) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(5151)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(5150)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(5154)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(5153)
			p.QualifiedDataName()
		}

		p.SetState(5156)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISortDuplicatesPhraseContext is an interface to support dynamic dispatch.
type ISortDuplicatesPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortDuplicatesPhraseContext differentiates from other interfaces.
	IsSortDuplicatesPhraseContext()
}

type SortDuplicatesPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortDuplicatesPhraseContext() *SortDuplicatesPhraseContext {
	var p = new(SortDuplicatesPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortDuplicatesPhrase
	return p
}

func (*SortDuplicatesPhraseContext) IsSortDuplicatesPhraseContext() {}

func NewSortDuplicatesPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortDuplicatesPhraseContext {
	var p = new(SortDuplicatesPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortDuplicatesPhrase

	return p
}

func (s *SortDuplicatesPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortDuplicatesPhraseContext) DUPLICATES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDUPLICATES, 0)
}

func (s *SortDuplicatesPhraseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *SortDuplicatesPhraseContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *SortDuplicatesPhraseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserORDER, 0)
}

func (s *SortDuplicatesPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortDuplicatesPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortDuplicatesPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortDuplicatesPhrase(s)
	}
}

func (s *SortDuplicatesPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortDuplicatesPhrase(s)
	}
}

func (s *SortDuplicatesPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortDuplicatesPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortDuplicatesPhrase() (localctx ISortDuplicatesPhraseContext) {
	localctx = NewSortDuplicatesPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 896, Cobol85ParserRULE_sortDuplicatesPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5159)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(5158)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(5161)
		p.Match(Cobol85ParserDUPLICATES)
	}
	p.SetState(5163)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(5162)
			p.Match(Cobol85ParserIN)
		}

	}
	p.SetState(5166)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserORDER {
		{
			p.SetState(5165)
			p.Match(Cobol85ParserORDER)
		}

	}

	return localctx
}

// ISortCollatingSequencePhraseContext is an interface to support dynamic dispatch.
type ISortCollatingSequencePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortCollatingSequencePhraseContext differentiates from other interfaces.
	IsSortCollatingSequencePhraseContext()
}

type SortCollatingSequencePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortCollatingSequencePhraseContext() *SortCollatingSequencePhraseContext {
	var p = new(SortCollatingSequencePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortCollatingSequencePhrase
	return p
}

func (*SortCollatingSequencePhraseContext) IsSortCollatingSequencePhraseContext() {}

func NewSortCollatingSequencePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortCollatingSequencePhraseContext {
	var p = new(SortCollatingSequencePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortCollatingSequencePhrase

	return p
}

func (s *SortCollatingSequencePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortCollatingSequencePhraseContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEQUENCE, 0)
}

func (s *SortCollatingSequencePhraseContext) COLLATING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLLATING, 0)
}

func (s *SortCollatingSequencePhraseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SortCollatingSequencePhraseContext) AllAlphabetName() []IAlphabetNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem())
	var tst = make([]IAlphabetNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlphabetNameContext)
		}
	}

	return tst
}

func (s *SortCollatingSequencePhraseContext) AlphabetName(i int) IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *SortCollatingSequencePhraseContext) SortCollatingAlphanumeric() ISortCollatingAlphanumericContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortCollatingAlphanumericContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortCollatingAlphanumericContext)
}

func (s *SortCollatingSequencePhraseContext) SortCollatingNational() ISortCollatingNationalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortCollatingNationalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortCollatingNationalContext)
}

func (s *SortCollatingSequencePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortCollatingSequencePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortCollatingSequencePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortCollatingSequencePhrase(s)
	}
}

func (s *SortCollatingSequencePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortCollatingSequencePhrase(s)
	}
}

func (s *SortCollatingSequencePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortCollatingSequencePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortCollatingSequencePhrase() (localctx ISortCollatingSequencePhraseContext) {
	localctx = NewSortCollatingSequencePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 898, Cobol85ParserRULE_sortCollatingSequencePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5169)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOLLATING {
		{
			p.SetState(5168)
			p.Match(Cobol85ParserCOLLATING)
		}

	}
	{
		p.SetState(5171)
		p.Match(Cobol85ParserSEQUENCE)
	}
	p.SetState(5173)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5172)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(5176)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(5175)
				p.AlphabetName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(5178)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 784, p.GetParserRuleContext())
	}
	p.SetState(5181)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 785, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5180)
			p.SortCollatingAlphanumeric()
		}

	}
	p.SetState(5184)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR || _la == Cobol85ParserNATIONAL {
		{
			p.SetState(5183)
			p.SortCollatingNational()
		}

	}

	return localctx
}

// ISortCollatingAlphanumericContext is an interface to support dynamic dispatch.
type ISortCollatingAlphanumericContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortCollatingAlphanumericContext differentiates from other interfaces.
	IsSortCollatingAlphanumericContext()
}

type SortCollatingAlphanumericContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortCollatingAlphanumericContext() *SortCollatingAlphanumericContext {
	var p = new(SortCollatingAlphanumericContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortCollatingAlphanumeric
	return p
}

func (*SortCollatingAlphanumericContext) IsSortCollatingAlphanumericContext() {}

func NewSortCollatingAlphanumericContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortCollatingAlphanumericContext {
	var p = new(SortCollatingAlphanumericContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortCollatingAlphanumeric

	return p
}

func (s *SortCollatingAlphanumericContext) GetParser() antlr.Parser { return s.parser }

func (s *SortCollatingAlphanumericContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *SortCollatingAlphanumericContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SortCollatingAlphanumericContext) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *SortCollatingAlphanumericContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *SortCollatingAlphanumericContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortCollatingAlphanumericContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortCollatingAlphanumericContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortCollatingAlphanumeric(s)
	}
}

func (s *SortCollatingAlphanumericContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortCollatingAlphanumeric(s)
	}
}

func (s *SortCollatingAlphanumericContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortCollatingAlphanumeric(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortCollatingAlphanumeric() (localctx ISortCollatingAlphanumericContext) {
	localctx = NewSortCollatingAlphanumericContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 900, Cobol85ParserRULE_sortCollatingAlphanumeric)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5187)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(5186)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(5189)
		p.Match(Cobol85ParserALPHANUMERIC)
	}
	{
		p.SetState(5190)
		p.Match(Cobol85ParserIS)
	}
	{
		p.SetState(5191)
		p.AlphabetName()
	}

	return localctx
}

// ISortCollatingNationalContext is an interface to support dynamic dispatch.
type ISortCollatingNationalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortCollatingNationalContext differentiates from other interfaces.
	IsSortCollatingNationalContext()
}

type SortCollatingNationalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortCollatingNationalContext() *SortCollatingNationalContext {
	var p = new(SortCollatingNationalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortCollatingNational
	return p
}

func (*SortCollatingNationalContext) IsSortCollatingNationalContext() {}

func NewSortCollatingNationalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortCollatingNationalContext {
	var p = new(SortCollatingNationalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortCollatingNational

	return p
}

func (s *SortCollatingNationalContext) GetParser() antlr.Parser { return s.parser }

func (s *SortCollatingNationalContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *SortCollatingNationalContext) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *SortCollatingNationalContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *SortCollatingNationalContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SortCollatingNationalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortCollatingNationalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortCollatingNationalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortCollatingNational(s)
	}
}

func (s *SortCollatingNationalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortCollatingNational(s)
	}
}

func (s *SortCollatingNationalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortCollatingNational(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortCollatingNational() (localctx ISortCollatingNationalContext) {
	localctx = NewSortCollatingNationalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 902, Cobol85ParserRULE_sortCollatingNational)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5194)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(5193)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(5196)
		p.Match(Cobol85ParserNATIONAL)
	}
	p.SetState(5198)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5197)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(5200)
		p.AlphabetName()
	}

	return localctx
}

// ISortInputProcedurePhraseContext is an interface to support dynamic dispatch.
type ISortInputProcedurePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortInputProcedurePhraseContext differentiates from other interfaces.
	IsSortInputProcedurePhraseContext()
}

type SortInputProcedurePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortInputProcedurePhraseContext() *SortInputProcedurePhraseContext {
	var p = new(SortInputProcedurePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortInputProcedurePhrase
	return p
}

func (*SortInputProcedurePhraseContext) IsSortInputProcedurePhraseContext() {}

func NewSortInputProcedurePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortInputProcedurePhraseContext {
	var p = new(SortInputProcedurePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortInputProcedurePhrase

	return p
}

func (s *SortInputProcedurePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortInputProcedurePhraseContext) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *SortInputProcedurePhraseContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE, 0)
}

func (s *SortInputProcedurePhraseContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *SortInputProcedurePhraseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SortInputProcedurePhraseContext) SortInputThrough() ISortInputThroughContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortInputThroughContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortInputThroughContext)
}

func (s *SortInputProcedurePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortInputProcedurePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortInputProcedurePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortInputProcedurePhrase(s)
	}
}

func (s *SortInputProcedurePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortInputProcedurePhrase(s)
	}
}

func (s *SortInputProcedurePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortInputProcedurePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortInputProcedurePhrase() (localctx ISortInputProcedurePhraseContext) {
	localctx = NewSortInputProcedurePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 904, Cobol85ParserRULE_sortInputProcedurePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5202)
		p.Match(Cobol85ParserINPUT)
	}
	{
		p.SetState(5203)
		p.Match(Cobol85ParserPROCEDURE)
	}
	p.SetState(5205)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5204)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(5207)
		p.ProcedureName()
	}
	p.SetState(5209)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(5208)
			p.SortInputThrough()
		}

	}

	return localctx
}

// ISortInputThroughContext is an interface to support dynamic dispatch.
type ISortInputThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortInputThroughContext differentiates from other interfaces.
	IsSortInputThroughContext()
}

type SortInputThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortInputThroughContext() *SortInputThroughContext {
	var p = new(SortInputThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortInputThrough
	return p
}

func (*SortInputThroughContext) IsSortInputThroughContext() {}

func NewSortInputThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortInputThroughContext {
	var p = new(SortInputThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortInputThrough

	return p
}

func (s *SortInputThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *SortInputThroughContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *SortInputThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *SortInputThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *SortInputThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortInputThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortInputThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortInputThrough(s)
	}
}

func (s *SortInputThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortInputThrough(s)
	}
}

func (s *SortInputThroughContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortInputThrough(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortInputThrough() (localctx ISortInputThroughContext) {
	localctx = NewSortInputThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 906, Cobol85ParserRULE_sortInputThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5211)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(5212)
		p.ProcedureName()
	}

	return localctx
}

// ISortUsingContext is an interface to support dynamic dispatch.
type ISortUsingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortUsingContext differentiates from other interfaces.
	IsSortUsingContext()
}

type SortUsingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortUsingContext() *SortUsingContext {
	var p = new(SortUsingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortUsing
	return p
}

func (*SortUsingContext) IsSortUsingContext() {}

func NewSortUsingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortUsingContext {
	var p = new(SortUsingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortUsing

	return p
}

func (s *SortUsingContext) GetParser() antlr.Parser { return s.parser }

func (s *SortUsingContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *SortUsingContext) AllFileName() []IFileNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileNameContext)(nil)).Elem())
	var tst = make([]IFileNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileNameContext)
		}
	}

	return tst
}

func (s *SortUsingContext) FileName(i int) IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *SortUsingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortUsingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortUsingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortUsing(s)
	}
}

func (s *SortUsingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortUsing(s)
	}
}

func (s *SortUsingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortUsing(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortUsing() (localctx ISortUsingContext) {
	localctx = NewSortUsingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 908, Cobol85ParserRULE_sortUsing)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5214)
		p.Match(Cobol85ParserUSING)
	}
	p.SetState(5216)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(5215)
			p.FileName()
		}

		p.SetState(5218)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISortOutputProcedurePhraseContext is an interface to support dynamic dispatch.
type ISortOutputProcedurePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortOutputProcedurePhraseContext differentiates from other interfaces.
	IsSortOutputProcedurePhraseContext()
}

type SortOutputProcedurePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortOutputProcedurePhraseContext() *SortOutputProcedurePhraseContext {
	var p = new(SortOutputProcedurePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortOutputProcedurePhrase
	return p
}

func (*SortOutputProcedurePhraseContext) IsSortOutputProcedurePhraseContext() {}

func NewSortOutputProcedurePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortOutputProcedurePhraseContext {
	var p = new(SortOutputProcedurePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortOutputProcedurePhrase

	return p
}

func (s *SortOutputProcedurePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortOutputProcedurePhraseContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *SortOutputProcedurePhraseContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE, 0)
}

func (s *SortOutputProcedurePhraseContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *SortOutputProcedurePhraseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SortOutputProcedurePhraseContext) SortOutputThrough() ISortOutputThroughContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortOutputThroughContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortOutputThroughContext)
}

func (s *SortOutputProcedurePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortOutputProcedurePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortOutputProcedurePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortOutputProcedurePhrase(s)
	}
}

func (s *SortOutputProcedurePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortOutputProcedurePhrase(s)
	}
}

func (s *SortOutputProcedurePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortOutputProcedurePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortOutputProcedurePhrase() (localctx ISortOutputProcedurePhraseContext) {
	localctx = NewSortOutputProcedurePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 910, Cobol85ParserRULE_sortOutputProcedurePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5220)
		p.Match(Cobol85ParserOUTPUT)
	}
	{
		p.SetState(5221)
		p.Match(Cobol85ParserPROCEDURE)
	}
	p.SetState(5223)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5222)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(5225)
		p.ProcedureName()
	}
	p.SetState(5227)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(5226)
			p.SortOutputThrough()
		}

	}

	return localctx
}

// ISortOutputThroughContext is an interface to support dynamic dispatch.
type ISortOutputThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortOutputThroughContext differentiates from other interfaces.
	IsSortOutputThroughContext()
}

type SortOutputThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortOutputThroughContext() *SortOutputThroughContext {
	var p = new(SortOutputThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortOutputThrough
	return p
}

func (*SortOutputThroughContext) IsSortOutputThroughContext() {}

func NewSortOutputThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortOutputThroughContext {
	var p = new(SortOutputThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortOutputThrough

	return p
}

func (s *SortOutputThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *SortOutputThroughContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *SortOutputThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *SortOutputThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *SortOutputThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortOutputThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortOutputThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortOutputThrough(s)
	}
}

func (s *SortOutputThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortOutputThrough(s)
	}
}

func (s *SortOutputThroughContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortOutputThrough(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortOutputThrough() (localctx ISortOutputThroughContext) {
	localctx = NewSortOutputThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 912, Cobol85ParserRULE_sortOutputThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5229)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(5230)
		p.ProcedureName()
	}

	return localctx
}

// ISortGivingPhraseContext is an interface to support dynamic dispatch.
type ISortGivingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortGivingPhraseContext differentiates from other interfaces.
	IsSortGivingPhraseContext()
}

type SortGivingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortGivingPhraseContext() *SortGivingPhraseContext {
	var p = new(SortGivingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortGivingPhrase
	return p
}

func (*SortGivingPhraseContext) IsSortGivingPhraseContext() {}

func NewSortGivingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortGivingPhraseContext {
	var p = new(SortGivingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortGivingPhrase

	return p
}

func (s *SortGivingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortGivingPhraseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *SortGivingPhraseContext) AllSortGiving() []ISortGivingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortGivingContext)(nil)).Elem())
	var tst = make([]ISortGivingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortGivingContext)
		}
	}

	return tst
}

func (s *SortGivingPhraseContext) SortGiving(i int) ISortGivingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortGivingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortGivingContext)
}

func (s *SortGivingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortGivingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortGivingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortGivingPhrase(s)
	}
}

func (s *SortGivingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortGivingPhrase(s)
	}
}

func (s *SortGivingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortGivingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortGivingPhrase() (localctx ISortGivingPhraseContext) {
	localctx = NewSortGivingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 914, Cobol85ParserRULE_sortGivingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5232)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(5234)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(5233)
			p.SortGiving()
		}

		p.SetState(5236)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISortGivingContext is an interface to support dynamic dispatch.
type ISortGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortGivingContext differentiates from other interfaces.
	IsSortGivingContext()
}

type SortGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortGivingContext() *SortGivingContext {
	var p = new(SortGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortGiving
	return p
}

func (*SortGivingContext) IsSortGivingContext() {}

func NewSortGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortGivingContext {
	var p = new(SortGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortGiving

	return p
}

func (s *SortGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *SortGivingContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *SortGivingContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *SortGivingContext) SAVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSAVE, 0)
}

func (s *SortGivingContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *SortGivingContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *SortGivingContext) CRUNCH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCRUNCH, 0)
}

func (s *SortGivingContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRELEASE, 0)
}

func (s *SortGivingContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *SortGivingContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOVE, 0)
}

func (s *SortGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortGiving(s)
	}
}

func (s *SortGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortGiving(s)
	}
}

func (s *SortGivingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortGiving(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortGiving() (localctx ISortGivingContext) {
	localctx = NewSortGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 916, Cobol85ParserRULE_sortGiving)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5238)
		p.FileName()
	}
	p.SetState(5248)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 796, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5239)
			p.Match(Cobol85ParserLOCK)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 796, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(5240)
			p.Match(Cobol85ParserSAVE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 796, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(5241)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(5242)
			p.Match(Cobol85ParserREWIND)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 796, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(5243)
			p.Match(Cobol85ParserCRUNCH)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 796, p.GetParserRuleContext()) == 5 {
		{
			p.SetState(5244)
			p.Match(Cobol85ParserRELEASE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 796, p.GetParserRuleContext()) == 6 {
		{
			p.SetState(5245)
			p.Match(Cobol85ParserWITH)
		}
		{
			p.SetState(5246)
			p.Match(Cobol85ParserREMOVE)
		}
		{
			p.SetState(5247)
			p.Match(Cobol85ParserCRUNCH)
		}

	}

	return localctx
}

// IStartStatementContext is an interface to support dynamic dispatch.
type IStartStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartStatementContext differentiates from other interfaces.
	IsStartStatementContext()
}

type StartStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartStatementContext() *StartStatementContext {
	var p = new(StartStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_startStatement
	return p
}

func (*StartStatementContext) IsStartStatementContext() {}

func NewStartStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartStatementContext {
	var p = new(StartStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_startStatement

	return p
}

func (s *StartStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StartStatementContext) START() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTART, 0)
}

func (s *StartStatementContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *StartStatementContext) StartKey() IStartKeyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStartKeyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStartKeyContext)
}

func (s *StartStatementContext) InvalidKeyPhrase() IInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvalidKeyPhraseContext)
}

func (s *StartStatementContext) NotInvalidKeyPhrase() INotInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotInvalidKeyPhraseContext)
}

func (s *StartStatementContext) END_START() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_START, 0)
}

func (s *StartStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStartStatement(s)
	}
}

func (s *StartStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStartStatement(s)
	}
}

func (s *StartStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStartStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StartStatement() (localctx IStartStatementContext) {
	localctx = NewStartStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 918, Cobol85ParserRULE_startStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5250)
		p.Match(Cobol85ParserSTART)
	}
	{
		p.SetState(5251)
		p.FileName()
	}
	p.SetState(5253)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(5252)
			p.StartKey()
		}

	}
	p.SetState(5256)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 798, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5255)
			p.InvalidKeyPhrase()
		}

	}
	p.SetState(5259)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 799, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5258)
			p.NotInvalidKeyPhrase()
		}

	}
	p.SetState(5262)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 800, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5261)
			p.Match(Cobol85ParserEND_START)
		}

	}

	return localctx
}

// IStartKeyContext is an interface to support dynamic dispatch.
type IStartKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartKeyContext differentiates from other interfaces.
	IsStartKeyContext()
}

type StartKeyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartKeyContext() *StartKeyContext {
	var p = new(StartKeyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_startKey
	return p
}

func (*StartKeyContext) IsStartKeyContext() {}

func NewStartKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartKeyContext {
	var p = new(StartKeyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_startKey

	return p
}

func (s *StartKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *StartKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *StartKeyContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *StartKeyContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUAL, 0)
}

func (s *StartKeyContext) EQUALCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUALCHAR, 0)
}

func (s *StartKeyContext) GREATER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGREATER, 0)
}

func (s *StartKeyContext) MORETHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORETHANCHAR, 0)
}

func (s *StartKeyContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *StartKeyContext) LESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESS, 0)
}

func (s *StartKeyContext) LESSTHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESSTHANCHAR, 0)
}

func (s *StartKeyContext) OR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOR, 0)
}

func (s *StartKeyContext) MORETHANOREQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORETHANOREQUAL, 0)
}

func (s *StartKeyContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *StartKeyContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *StartKeyContext) THAN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHAN, 0)
}

func (s *StartKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStartKey(s)
	}
}

func (s *StartKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStartKey(s)
	}
}

func (s *StartKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStartKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StartKey() (localctx IStartKeyContext) {
	localctx = NewStartKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 920, Cobol85ParserRULE_startKey)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5264)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(5266)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5265)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(5295)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 807, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5268)
			p.Match(Cobol85ParserEQUAL)
		}
		p.SetState(5270)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTO {
			{
				p.SetState(5269)
				p.Match(Cobol85ParserTO)
			}

		}

	case 2:
		{
			p.SetState(5272)
			p.Match(Cobol85ParserEQUALCHAR)
		}

	case 3:
		{
			p.SetState(5273)
			p.Match(Cobol85ParserGREATER)
		}
		p.SetState(5275)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHAN {
			{
				p.SetState(5274)
				p.Match(Cobol85ParserTHAN)
			}

		}

	case 4:
		{
			p.SetState(5277)
			p.Match(Cobol85ParserMORETHANCHAR)
		}

	case 5:
		{
			p.SetState(5278)
			p.Match(Cobol85ParserNOT)
		}
		{
			p.SetState(5279)
			p.Match(Cobol85ParserLESS)
		}
		p.SetState(5281)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHAN {
			{
				p.SetState(5280)
				p.Match(Cobol85ParserTHAN)
			}

		}

	case 6:
		{
			p.SetState(5283)
			p.Match(Cobol85ParserNOT)
		}
		{
			p.SetState(5284)
			p.Match(Cobol85ParserLESSTHANCHAR)
		}

	case 7:
		{
			p.SetState(5285)
			p.Match(Cobol85ParserGREATER)
		}
		p.SetState(5287)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHAN {
			{
				p.SetState(5286)
				p.Match(Cobol85ParserTHAN)
			}

		}
		{
			p.SetState(5289)
			p.Match(Cobol85ParserOR)
		}
		{
			p.SetState(5290)
			p.Match(Cobol85ParserEQUAL)
		}
		p.SetState(5292)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTO {
			{
				p.SetState(5291)
				p.Match(Cobol85ParserTO)
			}

		}

	case 8:
		{
			p.SetState(5294)
			p.Match(Cobol85ParserMORETHANOREQUAL)
		}

	}
	{
		p.SetState(5297)
		p.QualifiedDataName()
	}

	return localctx
}

// IStopStatementContext is an interface to support dynamic dispatch.
type IStopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStopStatementContext differentiates from other interfaces.
	IsStopStatementContext()
}

type StopStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStopStatementContext() *StopStatementContext {
	var p = new(StopStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stopStatement
	return p
}

func (*StopStatementContext) IsStopStatementContext() {}

func NewStopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopStatementContext {
	var p = new(StopStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stopStatement

	return p
}

func (s *StopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StopStatementContext) STOP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTOP, 0)
}

func (s *StopStatementContext) RUN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRUN, 0)
}

func (s *StopStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *StopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StopStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStopStatement(s)
	}
}

func (s *StopStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStopStatement(s)
	}
}

func (s *StopStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStopStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StopStatement() (localctx IStopStatementContext) {
	localctx = NewStopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 922, Cobol85ParserRULE_stopStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5299)
		p.Match(Cobol85ParserSTOP)
	}
	p.SetState(5302)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserRUN:
		{
			p.SetState(5300)
			p.Match(Cobol85ParserRUN)
		}

	case Cobol85ParserALL, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserFALSE, Cobol85ParserHIGH_VALUE, Cobol85ParserHIGH_VALUES, Cobol85ParserLOW_VALUE, Cobol85ParserLOW_VALUES, Cobol85ParserNULL, Cobol85ParserNULLS, Cobol85ParserQUOTE, Cobol85ParserQUOTES, Cobol85ParserSPACE, Cobol85ParserSPACES, Cobol85ParserTRUE, Cobol85ParserZERO, Cobol85ParserZEROS, Cobol85ParserZEROES, Cobol85ParserNONNUMERICLITERAL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserNUMERICLITERAL:
		{
			p.SetState(5301)
			p.Literal()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStringStatementContext is an interface to support dynamic dispatch.
type IStringStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringStatementContext differentiates from other interfaces.
	IsStringStatementContext()
}

type StringStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringStatementContext() *StringStatementContext {
	var p = new(StringStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringStatement
	return p
}

func (*StringStatementContext) IsStringStatementContext() {}

func NewStringStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringStatementContext {
	var p = new(StringStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringStatement

	return p
}

func (s *StringStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StringStatementContext) STRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTRING, 0)
}

func (s *StringStatementContext) StringIntoPhrase() IStringIntoPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringIntoPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringIntoPhraseContext)
}

func (s *StringStatementContext) AllStringSendingPhrase() []IStringSendingPhraseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStringSendingPhraseContext)(nil)).Elem())
	var tst = make([]IStringSendingPhraseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStringSendingPhraseContext)
		}
	}

	return tst
}

func (s *StringStatementContext) StringSendingPhrase(i int) IStringSendingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringSendingPhraseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStringSendingPhraseContext)
}

func (s *StringStatementContext) StringWithPointerPhrase() IStringWithPointerPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringWithPointerPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringWithPointerPhraseContext)
}

func (s *StringStatementContext) OnOverflowPhrase() IOnOverflowPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnOverflowPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnOverflowPhraseContext)
}

func (s *StringStatementContext) NotOnOverflowPhrase() INotOnOverflowPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnOverflowPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnOverflowPhraseContext)
}

func (s *StringStatementContext) END_STRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_STRING, 0)
}

func (s *StringStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringStatement(s)
	}
}

func (s *StringStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringStatement(s)
	}
}

func (s *StringStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStringStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StringStatement() (localctx IStringStatementContext) {
	localctx = NewStringStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 924, Cobol85ParserRULE_stringStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5304)
		p.Match(Cobol85ParserSTRING)
	}
	p.SetState(5306)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184))|(1<<(Cobol85ParserFALSE-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserHIGH_VALUE-216))|(1<<(Cobol85ParserHIGH_VALUES-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserLOW_VALUE-286))|(1<<(Cobol85ParserLOW_VALUES-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286))|(1<<(Cobol85ParserNULL-286)))) != 0) || (((_la-318)&-(0x1f+1)) == 0 && ((1<<uint((_la-318)))&((1<<(Cobol85ParserNULLS-318))|(1<<(Cobol85ParserNUMERIC_DATE-318))|(1<<(Cobol85ParserNUMERIC_TIME-318))|(1<<(Cobol85ParserODT-318))|(1<<(Cobol85ParserOPTIMIZE-318))|(1<<(Cobol85ParserORDERLY-318))|(1<<(Cobol85ParserOVERLINE-318))|(1<<(Cobol85ParserOWN-318))|(1<<(Cobol85ParserPASSWORD-318)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserQUOTE-357))|(1<<(Cobol85ParserQUOTES-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434))|(1<<(Cobol85ParserSPACE-434))|(1<<(Cobol85ParserSPACES-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUE-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO-502))|(1<<(Cobol85ParserZERO_FILL-502))|(1<<(Cobol85ParserZEROS-502))|(1<<(Cobol85ParserZEROES-502)))) != 0) || (((_la-555)&-(0x1f+1)) == 0 && ((1<<uint((_la-555)))&((1<<(Cobol85ParserNONNUMERICLITERAL-555))|(1<<(Cobol85ParserLEVEL_NUMBER_66-555))|(1<<(Cobol85ParserLEVEL_NUMBER_77-555))|(1<<(Cobol85ParserLEVEL_NUMBER_88-555))|(1<<(Cobol85ParserINTEGERLITERAL-555))|(1<<(Cobol85ParserNUMERICLITERAL-555))|(1<<(Cobol85ParserIDENTIFIER-555)))) != 0) {
		{
			p.SetState(5305)
			p.StringSendingPhrase()
		}

		p.SetState(5308)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5310)
		p.StringIntoPhrase()
	}
	p.SetState(5312)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 810, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5311)
			p.StringWithPointerPhrase()
		}

	}
	p.SetState(5315)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 811, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5314)
			p.OnOverflowPhrase()
		}

	}
	p.SetState(5318)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 812, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5317)
			p.NotOnOverflowPhrase()
		}

	}
	p.SetState(5321)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 813, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5320)
			p.Match(Cobol85ParserEND_STRING)
		}

	}

	return localctx
}

// IStringSendingPhraseContext is an interface to support dynamic dispatch.
type IStringSendingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringSendingPhraseContext differentiates from other interfaces.
	IsStringSendingPhraseContext()
}

type StringSendingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringSendingPhraseContext() *StringSendingPhraseContext {
	var p = new(StringSendingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringSendingPhrase
	return p
}

func (*StringSendingPhraseContext) IsStringSendingPhraseContext() {}

func NewStringSendingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringSendingPhraseContext {
	var p = new(StringSendingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringSendingPhrase

	return p
}

func (s *StringSendingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *StringSendingPhraseContext) StringDelimitedByPhrase() IStringDelimitedByPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringDelimitedByPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringDelimitedByPhraseContext)
}

func (s *StringSendingPhraseContext) StringForPhrase() IStringForPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringForPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringForPhraseContext)
}

func (s *StringSendingPhraseContext) AllStringSending() []IStringSendingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStringSendingContext)(nil)).Elem())
	var tst = make([]IStringSendingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStringSendingContext)
		}
	}

	return tst
}

func (s *StringSendingPhraseContext) StringSending(i int) IStringSendingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringSendingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStringSendingContext)
}

func (s *StringSendingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringSendingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringSendingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringSendingPhrase(s)
	}
}

func (s *StringSendingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringSendingPhrase(s)
	}
}

func (s *StringSendingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStringSendingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StringSendingPhrase() (localctx IStringSendingPhraseContext) {
	localctx = NewStringSendingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 926, Cobol85ParserRULE_stringSendingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184))|(1<<(Cobol85ParserFALSE-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserHIGH_VALUE-216))|(1<<(Cobol85ParserHIGH_VALUES-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserLOW_VALUE-286))|(1<<(Cobol85ParserLOW_VALUES-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286))|(1<<(Cobol85ParserNULL-286)))) != 0) || (((_la-318)&-(0x1f+1)) == 0 && ((1<<uint((_la-318)))&((1<<(Cobol85ParserNULLS-318))|(1<<(Cobol85ParserNUMERIC_DATE-318))|(1<<(Cobol85ParserNUMERIC_TIME-318))|(1<<(Cobol85ParserODT-318))|(1<<(Cobol85ParserOPTIMIZE-318))|(1<<(Cobol85ParserORDERLY-318))|(1<<(Cobol85ParserOVERLINE-318))|(1<<(Cobol85ParserOWN-318))|(1<<(Cobol85ParserPASSWORD-318)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserQUOTE-357))|(1<<(Cobol85ParserQUOTES-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434))|(1<<(Cobol85ParserSPACE-434))|(1<<(Cobol85ParserSPACES-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUE-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO-502))|(1<<(Cobol85ParserZERO_FILL-502))|(1<<(Cobol85ParserZEROS-502))|(1<<(Cobol85ParserZEROES-502)))) != 0) || (((_la-555)&-(0x1f+1)) == 0 && ((1<<uint((_la-555)))&((1<<(Cobol85ParserNONNUMERICLITERAL-555))|(1<<(Cobol85ParserLEVEL_NUMBER_66-555))|(1<<(Cobol85ParserLEVEL_NUMBER_77-555))|(1<<(Cobol85ParserLEVEL_NUMBER_88-555))|(1<<(Cobol85ParserINTEGERLITERAL-555))|(1<<(Cobol85ParserNUMERICLITERAL-555))|(1<<(Cobol85ParserIDENTIFIER-555)))) != 0) {
		{
			p.SetState(5323)
			p.StringSending()
		}

		p.SetState(5326)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5330)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserDELIMITED:
		{
			p.SetState(5328)
			p.StringDelimitedByPhrase()
		}

	case Cobol85ParserFOR:
		{
			p.SetState(5329)
			p.StringForPhrase()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStringSendingContext is an interface to support dynamic dispatch.
type IStringSendingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringSendingContext differentiates from other interfaces.
	IsStringSendingContext()
}

type StringSendingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringSendingContext() *StringSendingContext {
	var p = new(StringSendingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringSending
	return p
}

func (*StringSendingContext) IsStringSendingContext() {}

func NewStringSendingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringSendingContext {
	var p = new(StringSendingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringSending

	return p
}

func (s *StringSendingContext) GetParser() antlr.Parser { return s.parser }

func (s *StringSendingContext) TableCall() ITableCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableCallContext)
}

func (s *StringSendingContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *StringSendingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringSendingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringSendingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringSending(s)
	}
}

func (s *StringSendingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringSending(s)
	}
}

func (s *StringSendingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStringSending(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StringSending() (localctx IStringSendingContext) {
	localctx = NewStringSendingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 928, Cobol85ParserRULE_stringSending)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5334)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 816, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5332)
			p.TableCall()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5333)
			p.Literal()
		}

	}

	return localctx
}

// IStringDelimitedByPhraseContext is an interface to support dynamic dispatch.
type IStringDelimitedByPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringDelimitedByPhraseContext differentiates from other interfaces.
	IsStringDelimitedByPhraseContext()
}

type StringDelimitedByPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringDelimitedByPhraseContext() *StringDelimitedByPhraseContext {
	var p = new(StringDelimitedByPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringDelimitedByPhrase
	return p
}

func (*StringDelimitedByPhraseContext) IsStringDelimitedByPhraseContext() {}

func NewStringDelimitedByPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringDelimitedByPhraseContext {
	var p = new(StringDelimitedByPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringDelimitedByPhrase

	return p
}

func (s *StringDelimitedByPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *StringDelimitedByPhraseContext) DELIMITED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDELIMITED, 0)
}

func (s *StringDelimitedByPhraseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *StringDelimitedByPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringDelimitedByPhraseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *StringDelimitedByPhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *StringDelimitedByPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringDelimitedByPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringDelimitedByPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringDelimitedByPhrase(s)
	}
}

func (s *StringDelimitedByPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringDelimitedByPhrase(s)
	}
}

func (s *StringDelimitedByPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStringDelimitedByPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StringDelimitedByPhrase() (localctx IStringDelimitedByPhraseContext) {
	localctx = NewStringDelimitedByPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 930, Cobol85ParserRULE_stringDelimitedByPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5336)
		p.Match(Cobol85ParserDELIMITED)
	}
	p.SetState(5338)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY {
		{
			p.SetState(5337)
			p.Match(Cobol85ParserBY)
		}

	}
	p.SetState(5343)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 818, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5340)
			p.Match(Cobol85ParserSIZE)
		}

	case 2:
		{
			p.SetState(5341)
			p.Identifier()
		}

	case 3:
		{
			p.SetState(5342)
			p.Literal()
		}

	}

	return localctx
}

// IStringForPhraseContext is an interface to support dynamic dispatch.
type IStringForPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringForPhraseContext differentiates from other interfaces.
	IsStringForPhraseContext()
}

type StringForPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringForPhraseContext() *StringForPhraseContext {
	var p = new(StringForPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringForPhrase
	return p
}

func (*StringForPhraseContext) IsStringForPhraseContext() {}

func NewStringForPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringForPhraseContext {
	var p = new(StringForPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringForPhrase

	return p
}

func (s *StringForPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *StringForPhraseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *StringForPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringForPhraseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *StringForPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringForPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringForPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringForPhrase(s)
	}
}

func (s *StringForPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringForPhrase(s)
	}
}

func (s *StringForPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStringForPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StringForPhrase() (localctx IStringForPhraseContext) {
	localctx = NewStringForPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 932, Cobol85ParserRULE_stringForPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5345)
		p.Match(Cobol85ParserFOR)
	}
	p.SetState(5348)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 819, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5346)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5347)
			p.Literal()
		}

	}

	return localctx
}

// IStringIntoPhraseContext is an interface to support dynamic dispatch.
type IStringIntoPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringIntoPhraseContext differentiates from other interfaces.
	IsStringIntoPhraseContext()
}

type StringIntoPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringIntoPhraseContext() *StringIntoPhraseContext {
	var p = new(StringIntoPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringIntoPhrase
	return p
}

func (*StringIntoPhraseContext) IsStringIntoPhraseContext() {}

func NewStringIntoPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringIntoPhraseContext {
	var p = new(StringIntoPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringIntoPhrase

	return p
}

func (s *StringIntoPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *StringIntoPhraseContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *StringIntoPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringIntoPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringIntoPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringIntoPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringIntoPhrase(s)
	}
}

func (s *StringIntoPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringIntoPhrase(s)
	}
}

func (s *StringIntoPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStringIntoPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StringIntoPhrase() (localctx IStringIntoPhraseContext) {
	localctx = NewStringIntoPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 934, Cobol85ParserRULE_stringIntoPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5350)
		p.Match(Cobol85ParserINTO)
	}
	{
		p.SetState(5351)
		p.Identifier()
	}

	return localctx
}

// IStringWithPointerPhraseContext is an interface to support dynamic dispatch.
type IStringWithPointerPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringWithPointerPhraseContext differentiates from other interfaces.
	IsStringWithPointerPhraseContext()
}

type StringWithPointerPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringWithPointerPhraseContext() *StringWithPointerPhraseContext {
	var p = new(StringWithPointerPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringWithPointerPhrase
	return p
}

func (*StringWithPointerPhraseContext) IsStringWithPointerPhraseContext() {}

func NewStringWithPointerPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringWithPointerPhraseContext {
	var p = new(StringWithPointerPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringWithPointerPhrase

	return p
}

func (s *StringWithPointerPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *StringWithPointerPhraseContext) POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPOINTER, 0)
}

func (s *StringWithPointerPhraseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *StringWithPointerPhraseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *StringWithPointerPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringWithPointerPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringWithPointerPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringWithPointerPhrase(s)
	}
}

func (s *StringWithPointerPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringWithPointerPhrase(s)
	}
}

func (s *StringWithPointerPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStringWithPointerPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StringWithPointerPhrase() (localctx IStringWithPointerPhraseContext) {
	localctx = NewStringWithPointerPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 936, Cobol85ParserRULE_stringWithPointerPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5354)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(5353)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(5356)
		p.Match(Cobol85ParserPOINTER)
	}
	{
		p.SetState(5357)
		p.QualifiedDataName()
	}

	return localctx
}

// ISubtractStatementContext is an interface to support dynamic dispatch.
type ISubtractStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractStatementContext differentiates from other interfaces.
	IsSubtractStatementContext()
}

type SubtractStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractStatementContext() *SubtractStatementContext {
	var p = new(SubtractStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractStatement
	return p
}

func (*SubtractStatementContext) IsSubtractStatementContext() {}

func NewSubtractStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractStatementContext {
	var p = new(SubtractStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractStatement

	return p
}

func (s *SubtractStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractStatementContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUBTRACT, 0)
}

func (s *SubtractStatementContext) SubtractFromStatement() ISubtractFromStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractFromStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtractFromStatementContext)
}

func (s *SubtractStatementContext) SubtractFromGivingStatement() ISubtractFromGivingStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractFromGivingStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtractFromGivingStatementContext)
}

func (s *SubtractStatementContext) SubtractCorrespondingStatement() ISubtractCorrespondingStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractCorrespondingStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtractCorrespondingStatementContext)
}

func (s *SubtractStatementContext) OnSizeErrorPhrase() IOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnSizeErrorPhraseContext)
}

func (s *SubtractStatementContext) NotOnSizeErrorPhrase() INotOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnSizeErrorPhraseContext)
}

func (s *SubtractStatementContext) END_SUBTRACT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_SUBTRACT, 0)
}

func (s *SubtractStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractStatement(s)
	}
}

func (s *SubtractStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractStatement(s)
	}
}

func (s *SubtractStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractStatement() (localctx ISubtractStatementContext) {
	localctx = NewSubtractStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 938, Cobol85ParserRULE_subtractStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5359)
		p.Match(Cobol85ParserSUBTRACT)
	}
	p.SetState(5363)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 821, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5360)
			p.SubtractFromStatement()
		}

	case 2:
		{
			p.SetState(5361)
			p.SubtractFromGivingStatement()
		}

	case 3:
		{
			p.SetState(5362)
			p.SubtractCorrespondingStatement()
		}

	}
	p.SetState(5366)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 822, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5365)
			p.OnSizeErrorPhrase()
		}

	}
	p.SetState(5369)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 823, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5368)
			p.NotOnSizeErrorPhrase()
		}

	}
	p.SetState(5372)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 824, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5371)
			p.Match(Cobol85ParserEND_SUBTRACT)
		}

	}

	return localctx
}

// ISubtractFromStatementContext is an interface to support dynamic dispatch.
type ISubtractFromStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractFromStatementContext differentiates from other interfaces.
	IsSubtractFromStatementContext()
}

type SubtractFromStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractFromStatementContext() *SubtractFromStatementContext {
	var p = new(SubtractFromStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractFromStatement
	return p
}

func (*SubtractFromStatementContext) IsSubtractFromStatementContext() {}

func NewSubtractFromStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractFromStatementContext {
	var p = new(SubtractFromStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractFromStatement

	return p
}

func (s *SubtractFromStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractFromStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *SubtractFromStatementContext) AllSubtractSubtrahend() []ISubtractSubtrahendContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubtractSubtrahendContext)(nil)).Elem())
	var tst = make([]ISubtractSubtrahendContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubtractSubtrahendContext)
		}
	}

	return tst
}

func (s *SubtractFromStatementContext) SubtractSubtrahend(i int) ISubtractSubtrahendContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractSubtrahendContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubtractSubtrahendContext)
}

func (s *SubtractFromStatementContext) AllSubtractMinuend() []ISubtractMinuendContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubtractMinuendContext)(nil)).Elem())
	var tst = make([]ISubtractMinuendContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubtractMinuendContext)
		}
	}

	return tst
}

func (s *SubtractFromStatementContext) SubtractMinuend(i int) ISubtractMinuendContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractMinuendContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubtractMinuendContext)
}

func (s *SubtractFromStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractFromStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractFromStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractFromStatement(s)
	}
}

func (s *SubtractFromStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractFromStatement(s)
	}
}

func (s *SubtractFromStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractFromStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractFromStatement() (localctx ISubtractFromStatementContext) {
	localctx = NewSubtractFromStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 940, Cobol85ParserRULE_subtractFromStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5375)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184))|(1<<(Cobol85ParserFALSE-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserHIGH_VALUE-216))|(1<<(Cobol85ParserHIGH_VALUES-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserLOW_VALUE-286))|(1<<(Cobol85ParserLOW_VALUES-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286))|(1<<(Cobol85ParserNULL-286)))) != 0) || (((_la-318)&-(0x1f+1)) == 0 && ((1<<uint((_la-318)))&((1<<(Cobol85ParserNULLS-318))|(1<<(Cobol85ParserNUMERIC_DATE-318))|(1<<(Cobol85ParserNUMERIC_TIME-318))|(1<<(Cobol85ParserODT-318))|(1<<(Cobol85ParserOPTIMIZE-318))|(1<<(Cobol85ParserORDERLY-318))|(1<<(Cobol85ParserOVERLINE-318))|(1<<(Cobol85ParserOWN-318))|(1<<(Cobol85ParserPAGE_COUNTER-318))|(1<<(Cobol85ParserPASSWORD-318)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserQUOTE-357))|(1<<(Cobol85ParserQUOTES-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434))|(1<<(Cobol85ParserSPACE-434))|(1<<(Cobol85ParserSPACES-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUE-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO-502))|(1<<(Cobol85ParserZERO_FILL-502))|(1<<(Cobol85ParserZEROS-502))|(1<<(Cobol85ParserZEROES-502)))) != 0) || (((_la-555)&-(0x1f+1)) == 0 && ((1<<uint((_la-555)))&((1<<(Cobol85ParserNONNUMERICLITERAL-555))|(1<<(Cobol85ParserLEVEL_NUMBER_66-555))|(1<<(Cobol85ParserLEVEL_NUMBER_77-555))|(1<<(Cobol85ParserLEVEL_NUMBER_88-555))|(1<<(Cobol85ParserINTEGERLITERAL-555))|(1<<(Cobol85ParserNUMERICLITERAL-555))|(1<<(Cobol85ParserIDENTIFIER-555)))) != 0) {
		{
			p.SetState(5374)
			p.SubtractSubtrahend()
		}

		p.SetState(5377)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5379)
		p.Match(Cobol85ParserFROM)
	}
	p.SetState(5381)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(5380)
			p.SubtractMinuend()
		}

		p.SetState(5383)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISubtractFromGivingStatementContext is an interface to support dynamic dispatch.
type ISubtractFromGivingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractFromGivingStatementContext differentiates from other interfaces.
	IsSubtractFromGivingStatementContext()
}

type SubtractFromGivingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractFromGivingStatementContext() *SubtractFromGivingStatementContext {
	var p = new(SubtractFromGivingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractFromGivingStatement
	return p
}

func (*SubtractFromGivingStatementContext) IsSubtractFromGivingStatementContext() {}

func NewSubtractFromGivingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractFromGivingStatementContext {
	var p = new(SubtractFromGivingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractFromGivingStatement

	return p
}

func (s *SubtractFromGivingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractFromGivingStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *SubtractFromGivingStatementContext) SubtractMinuendGiving() ISubtractMinuendGivingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractMinuendGivingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtractMinuendGivingContext)
}

func (s *SubtractFromGivingStatementContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *SubtractFromGivingStatementContext) AllSubtractSubtrahend() []ISubtractSubtrahendContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubtractSubtrahendContext)(nil)).Elem())
	var tst = make([]ISubtractSubtrahendContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubtractSubtrahendContext)
		}
	}

	return tst
}

func (s *SubtractFromGivingStatementContext) SubtractSubtrahend(i int) ISubtractSubtrahendContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractSubtrahendContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubtractSubtrahendContext)
}

func (s *SubtractFromGivingStatementContext) AllSubtractGiving() []ISubtractGivingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubtractGivingContext)(nil)).Elem())
	var tst = make([]ISubtractGivingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubtractGivingContext)
		}
	}

	return tst
}

func (s *SubtractFromGivingStatementContext) SubtractGiving(i int) ISubtractGivingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractGivingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubtractGivingContext)
}

func (s *SubtractFromGivingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractFromGivingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractFromGivingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractFromGivingStatement(s)
	}
}

func (s *SubtractFromGivingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractFromGivingStatement(s)
	}
}

func (s *SubtractFromGivingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractFromGivingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractFromGivingStatement() (localctx ISubtractFromGivingStatementContext) {
	localctx = NewSubtractFromGivingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 942, Cobol85ParserRULE_subtractFromGivingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5386)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184))|(1<<(Cobol85ParserFALSE-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserHIGH_VALUE-216))|(1<<(Cobol85ParserHIGH_VALUES-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserLOW_VALUE-286))|(1<<(Cobol85ParserLOW_VALUES-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286))|(1<<(Cobol85ParserNULL-286)))) != 0) || (((_la-318)&-(0x1f+1)) == 0 && ((1<<uint((_la-318)))&((1<<(Cobol85ParserNULLS-318))|(1<<(Cobol85ParserNUMERIC_DATE-318))|(1<<(Cobol85ParserNUMERIC_TIME-318))|(1<<(Cobol85ParserODT-318))|(1<<(Cobol85ParserOPTIMIZE-318))|(1<<(Cobol85ParserORDERLY-318))|(1<<(Cobol85ParserOVERLINE-318))|(1<<(Cobol85ParserOWN-318))|(1<<(Cobol85ParserPAGE_COUNTER-318))|(1<<(Cobol85ParserPASSWORD-318)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserQUOTE-357))|(1<<(Cobol85ParserQUOTES-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434))|(1<<(Cobol85ParserSPACE-434))|(1<<(Cobol85ParserSPACES-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUE-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO-502))|(1<<(Cobol85ParserZERO_FILL-502))|(1<<(Cobol85ParserZEROS-502))|(1<<(Cobol85ParserZEROES-502)))) != 0) || (((_la-555)&-(0x1f+1)) == 0 && ((1<<uint((_la-555)))&((1<<(Cobol85ParserNONNUMERICLITERAL-555))|(1<<(Cobol85ParserLEVEL_NUMBER_66-555))|(1<<(Cobol85ParserLEVEL_NUMBER_77-555))|(1<<(Cobol85ParserLEVEL_NUMBER_88-555))|(1<<(Cobol85ParserINTEGERLITERAL-555))|(1<<(Cobol85ParserNUMERICLITERAL-555))|(1<<(Cobol85ParserIDENTIFIER-555)))) != 0) {
		{
			p.SetState(5385)
			p.SubtractSubtrahend()
		}

		p.SetState(5388)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5390)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(5391)
		p.SubtractMinuendGiving()
	}
	{
		p.SetState(5392)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(5394)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(5393)
			p.SubtractGiving()
		}

		p.SetState(5396)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISubtractCorrespondingStatementContext is an interface to support dynamic dispatch.
type ISubtractCorrespondingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractCorrespondingStatementContext differentiates from other interfaces.
	IsSubtractCorrespondingStatementContext()
}

type SubtractCorrespondingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractCorrespondingStatementContext() *SubtractCorrespondingStatementContext {
	var p = new(SubtractCorrespondingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractCorrespondingStatement
	return p
}

func (*SubtractCorrespondingStatementContext) IsSubtractCorrespondingStatementContext() {}

func NewSubtractCorrespondingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractCorrespondingStatementContext {
	var p = new(SubtractCorrespondingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractCorrespondingStatement

	return p
}

func (s *SubtractCorrespondingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractCorrespondingStatementContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *SubtractCorrespondingStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *SubtractCorrespondingStatementContext) SubtractMinuendCorresponding() ISubtractMinuendCorrespondingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractMinuendCorrespondingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtractMinuendCorrespondingContext)
}

func (s *SubtractCorrespondingStatementContext) CORRESPONDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORRESPONDING, 0)
}

func (s *SubtractCorrespondingStatementContext) CORR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORR, 0)
}

func (s *SubtractCorrespondingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractCorrespondingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractCorrespondingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractCorrespondingStatement(s)
	}
}

func (s *SubtractCorrespondingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractCorrespondingStatement(s)
	}
}

func (s *SubtractCorrespondingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractCorrespondingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractCorrespondingStatement() (localctx ISubtractCorrespondingStatementContext) {
	localctx = NewSubtractCorrespondingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 944, Cobol85ParserRULE_subtractCorrespondingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5398)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserCORR || _la == Cobol85ParserCORRESPONDING) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(5399)
		p.QualifiedDataName()
	}
	{
		p.SetState(5400)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(5401)
		p.SubtractMinuendCorresponding()
	}

	return localctx
}

// ISubtractSubtrahendContext is an interface to support dynamic dispatch.
type ISubtractSubtrahendContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractSubtrahendContext differentiates from other interfaces.
	IsSubtractSubtrahendContext()
}

type SubtractSubtrahendContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractSubtrahendContext() *SubtractSubtrahendContext {
	var p = new(SubtractSubtrahendContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractSubtrahend
	return p
}

func (*SubtractSubtrahendContext) IsSubtractSubtrahendContext() {}

func NewSubtractSubtrahendContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractSubtrahendContext {
	var p = new(SubtractSubtrahendContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractSubtrahend

	return p
}

func (s *SubtractSubtrahendContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractSubtrahendContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubtractSubtrahendContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SubtractSubtrahendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractSubtrahendContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractSubtrahendContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractSubtrahend(s)
	}
}

func (s *SubtractSubtrahendContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractSubtrahend(s)
	}
}

func (s *SubtractSubtrahendContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractSubtrahend(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractSubtrahend() (localctx ISubtractSubtrahendContext) {
	localctx = NewSubtractSubtrahendContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 946, Cobol85ParserRULE_subtractSubtrahend)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5405)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 829, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5403)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5404)
			p.Literal()
		}

	}

	return localctx
}

// ISubtractMinuendContext is an interface to support dynamic dispatch.
type ISubtractMinuendContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractMinuendContext differentiates from other interfaces.
	IsSubtractMinuendContext()
}

type SubtractMinuendContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractMinuendContext() *SubtractMinuendContext {
	var p = new(SubtractMinuendContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractMinuend
	return p
}

func (*SubtractMinuendContext) IsSubtractMinuendContext() {}

func NewSubtractMinuendContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractMinuendContext {
	var p = new(SubtractMinuendContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractMinuend

	return p
}

func (s *SubtractMinuendContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractMinuendContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubtractMinuendContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *SubtractMinuendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractMinuendContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractMinuendContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractMinuend(s)
	}
}

func (s *SubtractMinuendContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractMinuend(s)
	}
}

func (s *SubtractMinuendContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractMinuend(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractMinuend() (localctx ISubtractMinuendContext) {
	localctx = NewSubtractMinuendContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 948, Cobol85ParserRULE_subtractMinuend)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5407)
		p.Identifier()
	}
	p.SetState(5409)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(5408)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// ISubtractMinuendGivingContext is an interface to support dynamic dispatch.
type ISubtractMinuendGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractMinuendGivingContext differentiates from other interfaces.
	IsSubtractMinuendGivingContext()
}

type SubtractMinuendGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractMinuendGivingContext() *SubtractMinuendGivingContext {
	var p = new(SubtractMinuendGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractMinuendGiving
	return p
}

func (*SubtractMinuendGivingContext) IsSubtractMinuendGivingContext() {}

func NewSubtractMinuendGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractMinuendGivingContext {
	var p = new(SubtractMinuendGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractMinuendGiving

	return p
}

func (s *SubtractMinuendGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractMinuendGivingContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubtractMinuendGivingContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SubtractMinuendGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractMinuendGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractMinuendGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractMinuendGiving(s)
	}
}

func (s *SubtractMinuendGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractMinuendGiving(s)
	}
}

func (s *SubtractMinuendGivingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractMinuendGiving(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractMinuendGiving() (localctx ISubtractMinuendGivingContext) {
	localctx = NewSubtractMinuendGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 950, Cobol85ParserRULE_subtractMinuendGiving)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5413)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 831, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5411)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5412)
			p.Literal()
		}

	}

	return localctx
}

// ISubtractGivingContext is an interface to support dynamic dispatch.
type ISubtractGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractGivingContext differentiates from other interfaces.
	IsSubtractGivingContext()
}

type SubtractGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractGivingContext() *SubtractGivingContext {
	var p = new(SubtractGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractGiving
	return p
}

func (*SubtractGivingContext) IsSubtractGivingContext() {}

func NewSubtractGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractGivingContext {
	var p = new(SubtractGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractGiving

	return p
}

func (s *SubtractGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractGivingContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubtractGivingContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *SubtractGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractGiving(s)
	}
}

func (s *SubtractGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractGiving(s)
	}
}

func (s *SubtractGivingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractGiving(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractGiving() (localctx ISubtractGivingContext) {
	localctx = NewSubtractGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 952, Cobol85ParserRULE_subtractGiving)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5415)
		p.Identifier()
	}
	p.SetState(5417)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(5416)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// ISubtractMinuendCorrespondingContext is an interface to support dynamic dispatch.
type ISubtractMinuendCorrespondingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractMinuendCorrespondingContext differentiates from other interfaces.
	IsSubtractMinuendCorrespondingContext()
}

type SubtractMinuendCorrespondingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractMinuendCorrespondingContext() *SubtractMinuendCorrespondingContext {
	var p = new(SubtractMinuendCorrespondingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractMinuendCorresponding
	return p
}

func (*SubtractMinuendCorrespondingContext) IsSubtractMinuendCorrespondingContext() {}

func NewSubtractMinuendCorrespondingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractMinuendCorrespondingContext {
	var p = new(SubtractMinuendCorrespondingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractMinuendCorresponding

	return p
}

func (s *SubtractMinuendCorrespondingContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractMinuendCorrespondingContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *SubtractMinuendCorrespondingContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *SubtractMinuendCorrespondingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractMinuendCorrespondingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractMinuendCorrespondingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractMinuendCorresponding(s)
	}
}

func (s *SubtractMinuendCorrespondingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractMinuendCorresponding(s)
	}
}

func (s *SubtractMinuendCorrespondingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractMinuendCorresponding(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractMinuendCorresponding() (localctx ISubtractMinuendCorrespondingContext) {
	localctx = NewSubtractMinuendCorrespondingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 954, Cobol85ParserRULE_subtractMinuendCorresponding)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5419)
		p.QualifiedDataName()
	}
	p.SetState(5421)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(5420)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// ITerminateStatementContext is an interface to support dynamic dispatch.
type ITerminateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTerminateStatementContext differentiates from other interfaces.
	IsTerminateStatementContext()
}

type TerminateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerminateStatementContext() *TerminateStatementContext {
	var p = new(TerminateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_terminateStatement
	return p
}

func (*TerminateStatementContext) IsTerminateStatementContext() {}

func NewTerminateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TerminateStatementContext {
	var p = new(TerminateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_terminateStatement

	return p
}

func (s *TerminateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TerminateStatementContext) TERMINATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTERMINATE, 0)
}

func (s *TerminateStatementContext) ReportName() IReportNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportNameContext)
}

func (s *TerminateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TerminateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TerminateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterTerminateStatement(s)
	}
}

func (s *TerminateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitTerminateStatement(s)
	}
}

func (s *TerminateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitTerminateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) TerminateStatement() (localctx ITerminateStatementContext) {
	localctx = NewTerminateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 956, Cobol85ParserRULE_terminateStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5423)
		p.Match(Cobol85ParserTERMINATE)
	}
	{
		p.SetState(5424)
		p.ReportName()
	}

	return localctx
}

// IUnstringStatementContext is an interface to support dynamic dispatch.
type IUnstringStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringStatementContext differentiates from other interfaces.
	IsUnstringStatementContext()
}

type UnstringStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringStatementContext() *UnstringStatementContext {
	var p = new(UnstringStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringStatement
	return p
}

func (*UnstringStatementContext) IsUnstringStatementContext() {}

func NewUnstringStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringStatementContext {
	var p = new(UnstringStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringStatement

	return p
}

func (s *UnstringStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringStatementContext) UNSTRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNSTRING, 0)
}

func (s *UnstringStatementContext) UnstringSendingPhrase() IUnstringSendingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringSendingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnstringSendingPhraseContext)
}

func (s *UnstringStatementContext) UnstringIntoPhrase() IUnstringIntoPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringIntoPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnstringIntoPhraseContext)
}

func (s *UnstringStatementContext) UnstringWithPointerPhrase() IUnstringWithPointerPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringWithPointerPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnstringWithPointerPhraseContext)
}

func (s *UnstringStatementContext) UnstringTallyingPhrase() IUnstringTallyingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringTallyingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnstringTallyingPhraseContext)
}

func (s *UnstringStatementContext) OnOverflowPhrase() IOnOverflowPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnOverflowPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnOverflowPhraseContext)
}

func (s *UnstringStatementContext) NotOnOverflowPhrase() INotOnOverflowPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnOverflowPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnOverflowPhraseContext)
}

func (s *UnstringStatementContext) END_UNSTRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_UNSTRING, 0)
}

func (s *UnstringStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringStatement(s)
	}
}

func (s *UnstringStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringStatement(s)
	}
}

func (s *UnstringStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringStatement() (localctx IUnstringStatementContext) {
	localctx = NewUnstringStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 958, Cobol85ParserRULE_unstringStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5426)
		p.Match(Cobol85ParserUNSTRING)
	}
	{
		p.SetState(5427)
		p.UnstringSendingPhrase()
	}
	{
		p.SetState(5428)
		p.UnstringIntoPhrase()
	}
	p.SetState(5430)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 834, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5429)
			p.UnstringWithPointerPhrase()
		}

	}
	p.SetState(5433)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTALLYING {
		{
			p.SetState(5432)
			p.UnstringTallyingPhrase()
		}

	}
	p.SetState(5436)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 836, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5435)
			p.OnOverflowPhrase()
		}

	}
	p.SetState(5439)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 837, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5438)
			p.NotOnOverflowPhrase()
		}

	}
	p.SetState(5442)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 838, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5441)
			p.Match(Cobol85ParserEND_UNSTRING)
		}

	}

	return localctx
}

// IUnstringSendingPhraseContext is an interface to support dynamic dispatch.
type IUnstringSendingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringSendingPhraseContext differentiates from other interfaces.
	IsUnstringSendingPhraseContext()
}

type UnstringSendingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringSendingPhraseContext() *UnstringSendingPhraseContext {
	var p = new(UnstringSendingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringSendingPhrase
	return p
}

func (*UnstringSendingPhraseContext) IsUnstringSendingPhraseContext() {}

func NewUnstringSendingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringSendingPhraseContext {
	var p = new(UnstringSendingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringSendingPhrase

	return p
}

func (s *UnstringSendingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringSendingPhraseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *UnstringSendingPhraseContext) UnstringDelimitedByPhrase() IUnstringDelimitedByPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringDelimitedByPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnstringDelimitedByPhraseContext)
}

func (s *UnstringSendingPhraseContext) AllUnstringOrAllPhrase() []IUnstringOrAllPhraseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnstringOrAllPhraseContext)(nil)).Elem())
	var tst = make([]IUnstringOrAllPhraseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnstringOrAllPhraseContext)
		}
	}

	return tst
}

func (s *UnstringSendingPhraseContext) UnstringOrAllPhrase(i int) IUnstringOrAllPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringOrAllPhraseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnstringOrAllPhraseContext)
}

func (s *UnstringSendingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringSendingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringSendingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringSendingPhrase(s)
	}
}

func (s *UnstringSendingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringSendingPhrase(s)
	}
}

func (s *UnstringSendingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringSendingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringSendingPhrase() (localctx IUnstringSendingPhraseContext) {
	localctx = NewUnstringSendingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 960, Cobol85ParserRULE_unstringSendingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5444)
		p.QualifiedDataName()
	}
	p.SetState(5452)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDELIMITED {
		{
			p.SetState(5445)
			p.UnstringDelimitedByPhrase()
		}
		p.SetState(5449)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Cobol85ParserOR {
			{
				p.SetState(5446)
				p.UnstringOrAllPhrase()
			}

			p.SetState(5451)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IUnstringDelimitedByPhraseContext is an interface to support dynamic dispatch.
type IUnstringDelimitedByPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringDelimitedByPhraseContext differentiates from other interfaces.
	IsUnstringDelimitedByPhraseContext()
}

type UnstringDelimitedByPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringDelimitedByPhraseContext() *UnstringDelimitedByPhraseContext {
	var p = new(UnstringDelimitedByPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringDelimitedByPhrase
	return p
}

func (*UnstringDelimitedByPhraseContext) IsUnstringDelimitedByPhraseContext() {}

func NewUnstringDelimitedByPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringDelimitedByPhraseContext {
	var p = new(UnstringDelimitedByPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringDelimitedByPhrase

	return p
}

func (s *UnstringDelimitedByPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringDelimitedByPhraseContext) DELIMITED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDELIMITED, 0)
}

func (s *UnstringDelimitedByPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnstringDelimitedByPhraseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *UnstringDelimitedByPhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *UnstringDelimitedByPhraseContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *UnstringDelimitedByPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringDelimitedByPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringDelimitedByPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringDelimitedByPhrase(s)
	}
}

func (s *UnstringDelimitedByPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringDelimitedByPhrase(s)
	}
}

func (s *UnstringDelimitedByPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringDelimitedByPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringDelimitedByPhrase() (localctx IUnstringDelimitedByPhraseContext) {
	localctx = NewUnstringDelimitedByPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 962, Cobol85ParserRULE_unstringDelimitedByPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5454)
		p.Match(Cobol85ParserDELIMITED)
	}
	p.SetState(5456)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY {
		{
			p.SetState(5455)
			p.Match(Cobol85ParserBY)
		}

	}
	p.SetState(5459)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 842, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5458)
			p.Match(Cobol85ParserALL)
		}

	}
	p.SetState(5463)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 843, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5461)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5462)
			p.Literal()
		}

	}

	return localctx
}

// IUnstringOrAllPhraseContext is an interface to support dynamic dispatch.
type IUnstringOrAllPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringOrAllPhraseContext differentiates from other interfaces.
	IsUnstringOrAllPhraseContext()
}

type UnstringOrAllPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringOrAllPhraseContext() *UnstringOrAllPhraseContext {
	var p = new(UnstringOrAllPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringOrAllPhrase
	return p
}

func (*UnstringOrAllPhraseContext) IsUnstringOrAllPhraseContext() {}

func NewUnstringOrAllPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringOrAllPhraseContext {
	var p = new(UnstringOrAllPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringOrAllPhrase

	return p
}

func (s *UnstringOrAllPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringOrAllPhraseContext) OR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOR, 0)
}

func (s *UnstringOrAllPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnstringOrAllPhraseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *UnstringOrAllPhraseContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *UnstringOrAllPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringOrAllPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringOrAllPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringOrAllPhrase(s)
	}
}

func (s *UnstringOrAllPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringOrAllPhrase(s)
	}
}

func (s *UnstringOrAllPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringOrAllPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringOrAllPhrase() (localctx IUnstringOrAllPhraseContext) {
	localctx = NewUnstringOrAllPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 964, Cobol85ParserRULE_unstringOrAllPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5465)
		p.Match(Cobol85ParserOR)
	}
	p.SetState(5467)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 844, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5466)
			p.Match(Cobol85ParserALL)
		}

	}
	p.SetState(5471)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 845, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5469)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5470)
			p.Literal()
		}

	}

	return localctx
}

// IUnstringIntoPhraseContext is an interface to support dynamic dispatch.
type IUnstringIntoPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringIntoPhraseContext differentiates from other interfaces.
	IsUnstringIntoPhraseContext()
}

type UnstringIntoPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringIntoPhraseContext() *UnstringIntoPhraseContext {
	var p = new(UnstringIntoPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringIntoPhrase
	return p
}

func (*UnstringIntoPhraseContext) IsUnstringIntoPhraseContext() {}

func NewUnstringIntoPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringIntoPhraseContext {
	var p = new(UnstringIntoPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringIntoPhrase

	return p
}

func (s *UnstringIntoPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringIntoPhraseContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *UnstringIntoPhraseContext) AllUnstringInto() []IUnstringIntoContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnstringIntoContext)(nil)).Elem())
	var tst = make([]IUnstringIntoContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnstringIntoContext)
		}
	}

	return tst
}

func (s *UnstringIntoPhraseContext) UnstringInto(i int) IUnstringIntoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringIntoContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnstringIntoContext)
}

func (s *UnstringIntoPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringIntoPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringIntoPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringIntoPhrase(s)
	}
}

func (s *UnstringIntoPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringIntoPhrase(s)
	}
}

func (s *UnstringIntoPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringIntoPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringIntoPhrase() (localctx IUnstringIntoPhraseContext) {
	localctx = NewUnstringIntoPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 966, Cobol85ParserRULE_unstringIntoPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5473)
		p.Match(Cobol85ParserINTO)
	}
	p.SetState(5475)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPAGE_COUNTER-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(5474)
			p.UnstringInto()
		}

		p.SetState(5477)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUnstringIntoContext is an interface to support dynamic dispatch.
type IUnstringIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringIntoContext differentiates from other interfaces.
	IsUnstringIntoContext()
}

type UnstringIntoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringIntoContext() *UnstringIntoContext {
	var p = new(UnstringIntoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringInto
	return p
}

func (*UnstringIntoContext) IsUnstringIntoContext() {}

func NewUnstringIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringIntoContext {
	var p = new(UnstringIntoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringInto

	return p
}

func (s *UnstringIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringIntoContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnstringIntoContext) UnstringDelimiterIn() IUnstringDelimiterInContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringDelimiterInContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnstringDelimiterInContext)
}

func (s *UnstringIntoContext) UnstringCountIn() IUnstringCountInContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringCountInContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnstringCountInContext)
}

func (s *UnstringIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringInto(s)
	}
}

func (s *UnstringIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringInto(s)
	}
}

func (s *UnstringIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringInto(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringInto() (localctx IUnstringIntoContext) {
	localctx = NewUnstringIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 968, Cobol85ParserRULE_unstringInto)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5479)
		p.Identifier()
	}
	p.SetState(5481)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDELIMITER {
		{
			p.SetState(5480)
			p.UnstringDelimiterIn()
		}

	}
	p.SetState(5484)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOUNT {
		{
			p.SetState(5483)
			p.UnstringCountIn()
		}

	}

	return localctx
}

// IUnstringDelimiterInContext is an interface to support dynamic dispatch.
type IUnstringDelimiterInContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringDelimiterInContext differentiates from other interfaces.
	IsUnstringDelimiterInContext()
}

type UnstringDelimiterInContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringDelimiterInContext() *UnstringDelimiterInContext {
	var p = new(UnstringDelimiterInContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringDelimiterIn
	return p
}

func (*UnstringDelimiterInContext) IsUnstringDelimiterInContext() {}

func NewUnstringDelimiterInContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringDelimiterInContext {
	var p = new(UnstringDelimiterInContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringDelimiterIn

	return p
}

func (s *UnstringDelimiterInContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringDelimiterInContext) DELIMITER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDELIMITER, 0)
}

func (s *UnstringDelimiterInContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnstringDelimiterInContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *UnstringDelimiterInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringDelimiterInContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringDelimiterInContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringDelimiterIn(s)
	}
}

func (s *UnstringDelimiterInContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringDelimiterIn(s)
	}
}

func (s *UnstringDelimiterInContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringDelimiterIn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringDelimiterIn() (localctx IUnstringDelimiterInContext) {
	localctx = NewUnstringDelimiterInContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 970, Cobol85ParserRULE_unstringDelimiterIn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5486)
		p.Match(Cobol85ParserDELIMITER)
	}
	p.SetState(5488)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(5487)
			p.Match(Cobol85ParserIN)
		}

	}
	{
		p.SetState(5490)
		p.Identifier()
	}

	return localctx
}

// IUnstringCountInContext is an interface to support dynamic dispatch.
type IUnstringCountInContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringCountInContext differentiates from other interfaces.
	IsUnstringCountInContext()
}

type UnstringCountInContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringCountInContext() *UnstringCountInContext {
	var p = new(UnstringCountInContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringCountIn
	return p
}

func (*UnstringCountInContext) IsUnstringCountInContext() {}

func NewUnstringCountInContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringCountInContext {
	var p = new(UnstringCountInContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringCountIn

	return p
}

func (s *UnstringCountInContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringCountInContext) COUNT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOUNT, 0)
}

func (s *UnstringCountInContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnstringCountInContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *UnstringCountInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringCountInContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringCountInContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringCountIn(s)
	}
}

func (s *UnstringCountInContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringCountIn(s)
	}
}

func (s *UnstringCountInContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringCountIn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringCountIn() (localctx IUnstringCountInContext) {
	localctx = NewUnstringCountInContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 972, Cobol85ParserRULE_unstringCountIn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5492)
		p.Match(Cobol85ParserCOUNT)
	}
	p.SetState(5494)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(5493)
			p.Match(Cobol85ParserIN)
		}

	}
	{
		p.SetState(5496)
		p.Identifier()
	}

	return localctx
}

// IUnstringWithPointerPhraseContext is an interface to support dynamic dispatch.
type IUnstringWithPointerPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringWithPointerPhraseContext differentiates from other interfaces.
	IsUnstringWithPointerPhraseContext()
}

type UnstringWithPointerPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringWithPointerPhraseContext() *UnstringWithPointerPhraseContext {
	var p = new(UnstringWithPointerPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringWithPointerPhrase
	return p
}

func (*UnstringWithPointerPhraseContext) IsUnstringWithPointerPhraseContext() {}

func NewUnstringWithPointerPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringWithPointerPhraseContext {
	var p = new(UnstringWithPointerPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringWithPointerPhrase

	return p
}

func (s *UnstringWithPointerPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringWithPointerPhraseContext) POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPOINTER, 0)
}

func (s *UnstringWithPointerPhraseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *UnstringWithPointerPhraseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *UnstringWithPointerPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringWithPointerPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringWithPointerPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringWithPointerPhrase(s)
	}
}

func (s *UnstringWithPointerPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringWithPointerPhrase(s)
	}
}

func (s *UnstringWithPointerPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringWithPointerPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringWithPointerPhrase() (localctx IUnstringWithPointerPhraseContext) {
	localctx = NewUnstringWithPointerPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 974, Cobol85ParserRULE_unstringWithPointerPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5499)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(5498)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(5501)
		p.Match(Cobol85ParserPOINTER)
	}
	{
		p.SetState(5502)
		p.QualifiedDataName()
	}

	return localctx
}

// IUnstringTallyingPhraseContext is an interface to support dynamic dispatch.
type IUnstringTallyingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringTallyingPhraseContext differentiates from other interfaces.
	IsUnstringTallyingPhraseContext()
}

type UnstringTallyingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringTallyingPhraseContext() *UnstringTallyingPhraseContext {
	var p = new(UnstringTallyingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringTallyingPhrase
	return p
}

func (*UnstringTallyingPhraseContext) IsUnstringTallyingPhraseContext() {}

func NewUnstringTallyingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringTallyingPhraseContext {
	var p = new(UnstringTallyingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringTallyingPhrase

	return p
}

func (s *UnstringTallyingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringTallyingPhraseContext) TALLYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTALLYING, 0)
}

func (s *UnstringTallyingPhraseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *UnstringTallyingPhraseContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *UnstringTallyingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringTallyingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringTallyingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringTallyingPhrase(s)
	}
}

func (s *UnstringTallyingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringTallyingPhrase(s)
	}
}

func (s *UnstringTallyingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringTallyingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringTallyingPhrase() (localctx IUnstringTallyingPhraseContext) {
	localctx = NewUnstringTallyingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 976, Cobol85ParserRULE_unstringTallyingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5504)
		p.Match(Cobol85ParserTALLYING)
	}
	p.SetState(5506)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(5505)
			p.Match(Cobol85ParserIN)
		}

	}
	{
		p.SetState(5508)
		p.QualifiedDataName()
	}

	return localctx
}

// IUseStatementContext is an interface to support dynamic dispatch.
type IUseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseStatementContext differentiates from other interfaces.
	IsUseStatementContext()
}

type UseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseStatementContext() *UseStatementContext {
	var p = new(UseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_useStatement
	return p
}

func (*UseStatementContext) IsUseStatementContext() {}

func NewUseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseStatementContext {
	var p = new(UseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_useStatement

	return p
}

func (s *UseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseStatementContext) USE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSE, 0)
}

func (s *UseStatementContext) UseAfterClause() IUseAfterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseAfterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUseAfterClauseContext)
}

func (s *UseStatementContext) UseDebugClause() IUseDebugClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseDebugClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUseDebugClauseContext)
}

func (s *UseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUseStatement(s)
	}
}

func (s *UseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUseStatement(s)
	}
}

func (s *UseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UseStatement() (localctx IUseStatementContext) {
	localctx = NewUseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 978, Cobol85ParserRULE_useStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5510)
		p.Match(Cobol85ParserUSE)
	}
	p.SetState(5513)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserAFTER, Cobol85ParserGLOBAL:
		{
			p.SetState(5511)
			p.UseAfterClause()
		}

	case Cobol85ParserDEBUGGING, Cobol85ParserFOR:
		{
			p.SetState(5512)
			p.UseDebugClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUseAfterClauseContext is an interface to support dynamic dispatch.
type IUseAfterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseAfterClauseContext differentiates from other interfaces.
	IsUseAfterClauseContext()
}

type UseAfterClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseAfterClauseContext() *UseAfterClauseContext {
	var p = new(UseAfterClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_useAfterClause
	return p
}

func (*UseAfterClauseContext) IsUseAfterClauseContext() {}

func NewUseAfterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseAfterClauseContext {
	var p = new(UseAfterClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_useAfterClause

	return p
}

func (s *UseAfterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UseAfterClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *UseAfterClauseContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE, 0)
}

func (s *UseAfterClauseContext) UseAfterOn() IUseAfterOnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseAfterOnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUseAfterOnContext)
}

func (s *UseAfterClauseContext) EXCEPTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXCEPTION, 0)
}

func (s *UseAfterClauseContext) ERROR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERROR, 0)
}

func (s *UseAfterClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGLOBAL, 0)
}

func (s *UseAfterClauseContext) STANDARD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTANDARD, 0)
}

func (s *UseAfterClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *UseAfterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseAfterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseAfterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUseAfterClause(s)
	}
}

func (s *UseAfterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUseAfterClause(s)
	}
}

func (s *UseAfterClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUseAfterClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UseAfterClause() (localctx IUseAfterClauseContext) {
	localctx = NewUseAfterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 980, Cobol85ParserRULE_useAfterClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5516)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGLOBAL {
		{
			p.SetState(5515)
			p.Match(Cobol85ParserGLOBAL)
		}

	}
	{
		p.SetState(5518)
		p.Match(Cobol85ParserAFTER)
	}
	p.SetState(5520)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSTANDARD {
		{
			p.SetState(5519)
			p.Match(Cobol85ParserSTANDARD)
		}

	}
	p.SetState(5522)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserERROR || _la == Cobol85ParserEXCEPTION) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(5523)
		p.Match(Cobol85ParserPROCEDURE)
	}
	p.SetState(5525)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5524)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5527)
		p.UseAfterOn()
	}

	return localctx
}

// IUseAfterOnContext is an interface to support dynamic dispatch.
type IUseAfterOnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseAfterOnContext differentiates from other interfaces.
	IsUseAfterOnContext()
}

type UseAfterOnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseAfterOnContext() *UseAfterOnContext {
	var p = new(UseAfterOnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_useAfterOn
	return p
}

func (*UseAfterOnContext) IsUseAfterOnContext() {}

func NewUseAfterOnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseAfterOnContext {
	var p = new(UseAfterOnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_useAfterOn

	return p
}

func (s *UseAfterOnContext) GetParser() antlr.Parser { return s.parser }

func (s *UseAfterOnContext) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *UseAfterOnContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *UseAfterOnContext) I_O() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O, 0)
}

func (s *UseAfterOnContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTEND, 0)
}

func (s *UseAfterOnContext) AllFileName() []IFileNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileNameContext)(nil)).Elem())
	var tst = make([]IFileNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileNameContext)
		}
	}

	return tst
}

func (s *UseAfterOnContext) FileName(i int) IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *UseAfterOnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseAfterOnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseAfterOnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUseAfterOn(s)
	}
}

func (s *UseAfterOnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUseAfterOn(s)
	}
}

func (s *UseAfterOnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUseAfterOn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UseAfterOn() (localctx IUseAfterOnContext) {
	localctx = NewUseAfterOnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 982, Cobol85ParserRULE_useAfterOn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5538)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserINPUT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5529)
			p.Match(Cobol85ParserINPUT)
		}

	case Cobol85ParserOUTPUT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5530)
			p.Match(Cobol85ParserOUTPUT)
		}

	case Cobol85ParserI_O:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5531)
			p.Match(Cobol85ParserI_O)
		}

	case Cobol85ParserEXTEND:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5532)
			p.Match(Cobol85ParserEXTEND)
		}

	case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(5534)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER {
			{
				p.SetState(5533)
				p.FileName()
			}

			p.SetState(5536)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUseDebugClauseContext is an interface to support dynamic dispatch.
type IUseDebugClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseDebugClauseContext differentiates from other interfaces.
	IsUseDebugClauseContext()
}

type UseDebugClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDebugClauseContext() *UseDebugClauseContext {
	var p = new(UseDebugClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_useDebugClause
	return p
}

func (*UseDebugClauseContext) IsUseDebugClauseContext() {}

func NewUseDebugClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDebugClauseContext {
	var p = new(UseDebugClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_useDebugClause

	return p
}

func (s *UseDebugClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDebugClauseContext) DEBUGGING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUGGING, 0)
}

func (s *UseDebugClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *UseDebugClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *UseDebugClauseContext) AllUseDebugOn() []IUseDebugOnContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUseDebugOnContext)(nil)).Elem())
	var tst = make([]IUseDebugOnContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUseDebugOnContext)
		}
	}

	return tst
}

func (s *UseDebugClauseContext) UseDebugOn(i int) IUseDebugOnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseDebugOnContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUseDebugOnContext)
}

func (s *UseDebugClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDebugClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDebugClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUseDebugClause(s)
	}
}

func (s *UseDebugClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUseDebugClause(s)
	}
}

func (s *UseDebugClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUseDebugClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UseDebugClause() (localctx IUseDebugClauseContext) {
	localctx = NewUseDebugClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 984, Cobol85ParserRULE_useDebugClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5541)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(5540)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(5543)
		p.Match(Cobol85ParserDEBUGGING)
	}
	p.SetState(5545)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5544)
			p.Match(Cobol85ParserON)
		}

	}
	p.SetState(5548)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || (((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556))|(1<<(Cobol85ParserIDENTIFIER-556)))) != 0) {
		{
			p.SetState(5547)
			p.UseDebugOn()
		}

		p.SetState(5550)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUseDebugOnContext is an interface to support dynamic dispatch.
type IUseDebugOnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseDebugOnContext differentiates from other interfaces.
	IsUseDebugOnContext()
}

type UseDebugOnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDebugOnContext() *UseDebugOnContext {
	var p = new(UseDebugOnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_useDebugOn
	return p
}

func (*UseDebugOnContext) IsUseDebugOnContext() {}

func NewUseDebugOnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDebugOnContext {
	var p = new(UseDebugOnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_useDebugOn

	return p
}

func (s *UseDebugOnContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDebugOnContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *UseDebugOnContext) PROCEDURES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURES, 0)
}

func (s *UseDebugOnContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UseDebugOnContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREFERENCES, 0)
}

func (s *UseDebugOnContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *UseDebugOnContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *UseDebugOnContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *UseDebugOnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDebugOnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDebugOnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUseDebugOn(s)
	}
}

func (s *UseDebugOnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUseDebugOn(s)
	}
}

func (s *UseDebugOnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUseDebugOn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UseDebugOn() (localctx IUseDebugOnContext) {
	localctx = NewUseDebugOnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 986, Cobol85ParserRULE_useDebugOn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5564)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 864, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5552)
			p.Match(Cobol85ParserALL)
		}
		{
			p.SetState(5553)
			p.Match(Cobol85ParserPROCEDURES)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5554)
			p.Match(Cobol85ParserALL)
		}
		p.SetState(5556)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserREFERENCES {
			{
				p.SetState(5555)
				p.Match(Cobol85ParserREFERENCES)
			}

		}
		p.SetState(5559)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserOF {
			{
				p.SetState(5558)
				p.Match(Cobol85ParserOF)
			}

		}
		{
			p.SetState(5561)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5562)
			p.ProcedureName()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5563)
			p.FileName()
		}

	}

	return localctx
}

// IWriteStatementContext is an interface to support dynamic dispatch.
type IWriteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteStatementContext differentiates from other interfaces.
	IsWriteStatementContext()
}

type WriteStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteStatementContext() *WriteStatementContext {
	var p = new(WriteStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeStatement
	return p
}

func (*WriteStatementContext) IsWriteStatementContext() {}

func NewWriteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteStatementContext {
	var p = new(WriteStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeStatement

	return p
}

func (s *WriteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteStatementContext) WRITE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWRITE, 0)
}

func (s *WriteStatementContext) RecordName() IRecordNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordNameContext)
}

func (s *WriteStatementContext) WriteFromPhrase() IWriteFromPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWriteFromPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWriteFromPhraseContext)
}

func (s *WriteStatementContext) WriteAdvancingPhrase() IWriteAdvancingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWriteAdvancingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWriteAdvancingPhraseContext)
}

func (s *WriteStatementContext) WriteAtEndOfPagePhrase() IWriteAtEndOfPagePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWriteAtEndOfPagePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWriteAtEndOfPagePhraseContext)
}

func (s *WriteStatementContext) WriteNotAtEndOfPagePhrase() IWriteNotAtEndOfPagePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWriteNotAtEndOfPagePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWriteNotAtEndOfPagePhraseContext)
}

func (s *WriteStatementContext) InvalidKeyPhrase() IInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvalidKeyPhraseContext)
}

func (s *WriteStatementContext) NotInvalidKeyPhrase() INotInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotInvalidKeyPhraseContext)
}

func (s *WriteStatementContext) END_WRITE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_WRITE, 0)
}

func (s *WriteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteStatement(s)
	}
}

func (s *WriteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteStatement(s)
	}
}

func (s *WriteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWriteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WriteStatement() (localctx IWriteStatementContext) {
	localctx = NewWriteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 988, Cobol85ParserRULE_writeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5566)
		p.Match(Cobol85ParserWRITE)
	}
	{
		p.SetState(5567)
		p.RecordName()
	}
	p.SetState(5569)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFROM {
		{
			p.SetState(5568)
			p.WriteFromPhrase()
		}

	}
	p.SetState(5572)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(5571)
			p.WriteAdvancingPhrase()
		}

	}
	p.SetState(5575)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 867, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5574)
			p.WriteAtEndOfPagePhrase()
		}

	}
	p.SetState(5578)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 868, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5577)
			p.WriteNotAtEndOfPagePhrase()
		}

	}
	p.SetState(5581)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 869, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5580)
			p.InvalidKeyPhrase()
		}

	}
	p.SetState(5584)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 870, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5583)
			p.NotInvalidKeyPhrase()
		}

	}
	p.SetState(5587)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 871, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5586)
			p.Match(Cobol85ParserEND_WRITE)
		}

	}

	return localctx
}

// IWriteFromPhraseContext is an interface to support dynamic dispatch.
type IWriteFromPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteFromPhraseContext differentiates from other interfaces.
	IsWriteFromPhraseContext()
}

type WriteFromPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteFromPhraseContext() *WriteFromPhraseContext {
	var p = new(WriteFromPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeFromPhrase
	return p
}

func (*WriteFromPhraseContext) IsWriteFromPhraseContext() {}

func NewWriteFromPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteFromPhraseContext {
	var p = new(WriteFromPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeFromPhrase

	return p
}

func (s *WriteFromPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteFromPhraseContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *WriteFromPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WriteFromPhraseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *WriteFromPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteFromPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteFromPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteFromPhrase(s)
	}
}

func (s *WriteFromPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteFromPhrase(s)
	}
}

func (s *WriteFromPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWriteFromPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WriteFromPhrase() (localctx IWriteFromPhraseContext) {
	localctx = NewWriteFromPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 990, Cobol85ParserRULE_writeFromPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5589)
		p.Match(Cobol85ParserFROM)
	}
	p.SetState(5592)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 872, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5590)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5591)
			p.Literal()
		}

	}

	return localctx
}

// IWriteAdvancingPhraseContext is an interface to support dynamic dispatch.
type IWriteAdvancingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteAdvancingPhraseContext differentiates from other interfaces.
	IsWriteAdvancingPhraseContext()
}

type WriteAdvancingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteAdvancingPhraseContext() *WriteAdvancingPhraseContext {
	var p = new(WriteAdvancingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingPhrase
	return p
}

func (*WriteAdvancingPhraseContext) IsWriteAdvancingPhraseContext() {}

func NewWriteAdvancingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteAdvancingPhraseContext {
	var p = new(WriteAdvancingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingPhrase

	return p
}

func (s *WriteAdvancingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteAdvancingPhraseContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEFORE, 0)
}

func (s *WriteAdvancingPhraseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *WriteAdvancingPhraseContext) WriteAdvancingPage() IWriteAdvancingPageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWriteAdvancingPageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWriteAdvancingPageContext)
}

func (s *WriteAdvancingPhraseContext) WriteAdvancingLines() IWriteAdvancingLinesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWriteAdvancingLinesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWriteAdvancingLinesContext)
}

func (s *WriteAdvancingPhraseContext) WriteAdvancingMnemonic() IWriteAdvancingMnemonicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWriteAdvancingMnemonicContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWriteAdvancingMnemonicContext)
}

func (s *WriteAdvancingPhraseContext) ADVANCING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADVANCING, 0)
}

func (s *WriteAdvancingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteAdvancingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteAdvancingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteAdvancingPhrase(s)
	}
}

func (s *WriteAdvancingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteAdvancingPhrase(s)
	}
}

func (s *WriteAdvancingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWriteAdvancingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WriteAdvancingPhrase() (localctx IWriteAdvancingPhraseContext) {
	localctx = NewWriteAdvancingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 992, Cobol85ParserRULE_writeAdvancingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5594)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(5596)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserADVANCING {
		{
			p.SetState(5595)
			p.Match(Cobol85ParserADVANCING)
		}

	}
	p.SetState(5601)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 874, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5598)
			p.WriteAdvancingPage()
		}

	case 2:
		{
			p.SetState(5599)
			p.WriteAdvancingLines()
		}

	case 3:
		{
			p.SetState(5600)
			p.WriteAdvancingMnemonic()
		}

	}

	return localctx
}

// IWriteAdvancingPageContext is an interface to support dynamic dispatch.
type IWriteAdvancingPageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteAdvancingPageContext differentiates from other interfaces.
	IsWriteAdvancingPageContext()
}

type WriteAdvancingPageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteAdvancingPageContext() *WriteAdvancingPageContext {
	var p = new(WriteAdvancingPageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingPage
	return p
}

func (*WriteAdvancingPageContext) IsWriteAdvancingPageContext() {}

func NewWriteAdvancingPageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteAdvancingPageContext {
	var p = new(WriteAdvancingPageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingPage

	return p
}

func (s *WriteAdvancingPageContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteAdvancingPageContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *WriteAdvancingPageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteAdvancingPageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteAdvancingPageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteAdvancingPage(s)
	}
}

func (s *WriteAdvancingPageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteAdvancingPage(s)
	}
}

func (s *WriteAdvancingPageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWriteAdvancingPage(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WriteAdvancingPage() (localctx IWriteAdvancingPageContext) {
	localctx = NewWriteAdvancingPageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 994, Cobol85ParserRULE_writeAdvancingPage)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5603)
		p.Match(Cobol85ParserPAGE)
	}

	return localctx
}

// IWriteAdvancingLinesContext is an interface to support dynamic dispatch.
type IWriteAdvancingLinesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteAdvancingLinesContext differentiates from other interfaces.
	IsWriteAdvancingLinesContext()
}

type WriteAdvancingLinesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteAdvancingLinesContext() *WriteAdvancingLinesContext {
	var p = new(WriteAdvancingLinesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingLines
	return p
}

func (*WriteAdvancingLinesContext) IsWriteAdvancingLinesContext() {}

func NewWriteAdvancingLinesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteAdvancingLinesContext {
	var p = new(WriteAdvancingLinesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingLines

	return p
}

func (s *WriteAdvancingLinesContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteAdvancingLinesContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WriteAdvancingLinesContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *WriteAdvancingLinesContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *WriteAdvancingLinesContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *WriteAdvancingLinesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteAdvancingLinesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteAdvancingLinesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteAdvancingLines(s)
	}
}

func (s *WriteAdvancingLinesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteAdvancingLines(s)
	}
}

func (s *WriteAdvancingLinesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWriteAdvancingLines(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WriteAdvancingLines() (localctx IWriteAdvancingLinesContext) {
	localctx = NewWriteAdvancingLinesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 996, Cobol85ParserRULE_writeAdvancingLines)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5607)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 875, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5605)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5606)
			p.Literal()
		}

	}
	p.SetState(5610)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINE || _la == Cobol85ParserLINES {
		p.SetState(5609)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserLINE || _la == Cobol85ParserLINES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// IWriteAdvancingMnemonicContext is an interface to support dynamic dispatch.
type IWriteAdvancingMnemonicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteAdvancingMnemonicContext differentiates from other interfaces.
	IsWriteAdvancingMnemonicContext()
}

type WriteAdvancingMnemonicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteAdvancingMnemonicContext() *WriteAdvancingMnemonicContext {
	var p = new(WriteAdvancingMnemonicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingMnemonic
	return p
}

func (*WriteAdvancingMnemonicContext) IsWriteAdvancingMnemonicContext() {}

func NewWriteAdvancingMnemonicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteAdvancingMnemonicContext {
	var p = new(WriteAdvancingMnemonicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingMnemonic

	return p
}

func (s *WriteAdvancingMnemonicContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteAdvancingMnemonicContext) MnemonicName() IMnemonicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMnemonicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *WriteAdvancingMnemonicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteAdvancingMnemonicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteAdvancingMnemonicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteAdvancingMnemonic(s)
	}
}

func (s *WriteAdvancingMnemonicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteAdvancingMnemonic(s)
	}
}

func (s *WriteAdvancingMnemonicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWriteAdvancingMnemonic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WriteAdvancingMnemonic() (localctx IWriteAdvancingMnemonicContext) {
	localctx = NewWriteAdvancingMnemonicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 998, Cobol85ParserRULE_writeAdvancingMnemonic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5612)
		p.MnemonicName()
	}

	return localctx
}

// IWriteAtEndOfPagePhraseContext is an interface to support dynamic dispatch.
type IWriteAtEndOfPagePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteAtEndOfPagePhraseContext differentiates from other interfaces.
	IsWriteAtEndOfPagePhraseContext()
}

type WriteAtEndOfPagePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteAtEndOfPagePhraseContext() *WriteAtEndOfPagePhraseContext {
	var p = new(WriteAtEndOfPagePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeAtEndOfPagePhrase
	return p
}

func (*WriteAtEndOfPagePhraseContext) IsWriteAtEndOfPagePhraseContext() {}

func NewWriteAtEndOfPagePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteAtEndOfPagePhraseContext {
	var p = new(WriteAtEndOfPagePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeAtEndOfPagePhrase

	return p
}

func (s *WriteAtEndOfPagePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteAtEndOfPagePhraseContext) END_OF_PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_OF_PAGE, 0)
}

func (s *WriteAtEndOfPagePhraseContext) EOP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOP, 0)
}

func (s *WriteAtEndOfPagePhraseContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *WriteAtEndOfPagePhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *WriteAtEndOfPagePhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WriteAtEndOfPagePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteAtEndOfPagePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteAtEndOfPagePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteAtEndOfPagePhrase(s)
	}
}

func (s *WriteAtEndOfPagePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteAtEndOfPagePhrase(s)
	}
}

func (s *WriteAtEndOfPagePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWriteAtEndOfPagePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WriteAtEndOfPagePhrase() (localctx IWriteAtEndOfPagePhraseContext) {
	localctx = NewWriteAtEndOfPagePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1000, Cobol85ParserRULE_writeAtEndOfPagePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5615)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(5614)
			p.Match(Cobol85ParserAT)
		}

	}
	p.SetState(5617)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserEND_OF_PAGE || _la == Cobol85ParserEOP) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(5621)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 878, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5618)
				p.Statement()
			}

		}
		p.SetState(5623)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 878, p.GetParserRuleContext())
	}

	return localctx
}

// IWriteNotAtEndOfPagePhraseContext is an interface to support dynamic dispatch.
type IWriteNotAtEndOfPagePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteNotAtEndOfPagePhraseContext differentiates from other interfaces.
	IsWriteNotAtEndOfPagePhraseContext()
}

type WriteNotAtEndOfPagePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteNotAtEndOfPagePhraseContext() *WriteNotAtEndOfPagePhraseContext {
	var p = new(WriteNotAtEndOfPagePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeNotAtEndOfPagePhrase
	return p
}

func (*WriteNotAtEndOfPagePhraseContext) IsWriteNotAtEndOfPagePhraseContext() {}

func NewWriteNotAtEndOfPagePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteNotAtEndOfPagePhraseContext {
	var p = new(WriteNotAtEndOfPagePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeNotAtEndOfPagePhrase

	return p
}

func (s *WriteNotAtEndOfPagePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteNotAtEndOfPagePhraseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *WriteNotAtEndOfPagePhraseContext) END_OF_PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_OF_PAGE, 0)
}

func (s *WriteNotAtEndOfPagePhraseContext) EOP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOP, 0)
}

func (s *WriteNotAtEndOfPagePhraseContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *WriteNotAtEndOfPagePhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *WriteNotAtEndOfPagePhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WriteNotAtEndOfPagePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteNotAtEndOfPagePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteNotAtEndOfPagePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteNotAtEndOfPagePhrase(s)
	}
}

func (s *WriteNotAtEndOfPagePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteNotAtEndOfPagePhrase(s)
	}
}

func (s *WriteNotAtEndOfPagePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWriteNotAtEndOfPagePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WriteNotAtEndOfPagePhrase() (localctx IWriteNotAtEndOfPagePhraseContext) {
	localctx = NewWriteNotAtEndOfPagePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1002, Cobol85ParserRULE_writeNotAtEndOfPagePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5624)
		p.Match(Cobol85ParserNOT)
	}
	p.SetState(5626)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(5625)
			p.Match(Cobol85ParserAT)
		}

	}
	p.SetState(5628)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserEND_OF_PAGE || _la == Cobol85ParserEOP) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(5632)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 880, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5629)
				p.Statement()
			}

		}
		p.SetState(5634)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 880, p.GetParserRuleContext())
	}

	return localctx
}

// IAtEndPhraseContext is an interface to support dynamic dispatch.
type IAtEndPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtEndPhraseContext differentiates from other interfaces.
	IsAtEndPhraseContext()
}

type AtEndPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtEndPhraseContext() *AtEndPhraseContext {
	var p = new(AtEndPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_atEndPhrase
	return p
}

func (*AtEndPhraseContext) IsAtEndPhraseContext() {}

func NewAtEndPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtEndPhraseContext {
	var p = new(AtEndPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_atEndPhrase

	return p
}

func (s *AtEndPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *AtEndPhraseContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *AtEndPhraseContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *AtEndPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *AtEndPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *AtEndPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtEndPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtEndPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAtEndPhrase(s)
	}
}

func (s *AtEndPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAtEndPhrase(s)
	}
}

func (s *AtEndPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAtEndPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AtEndPhrase() (localctx IAtEndPhraseContext) {
	localctx = NewAtEndPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1004, Cobol85ParserRULE_atEndPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5636)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(5635)
			p.Match(Cobol85ParserAT)
		}

	}
	{
		p.SetState(5638)
		p.Match(Cobol85ParserEND)
	}
	p.SetState(5642)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 882, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5639)
				p.Statement()
			}

		}
		p.SetState(5644)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 882, p.GetParserRuleContext())
	}

	return localctx
}

// INotAtEndPhraseContext is an interface to support dynamic dispatch.
type INotAtEndPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotAtEndPhraseContext differentiates from other interfaces.
	IsNotAtEndPhraseContext()
}

type NotAtEndPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotAtEndPhraseContext() *NotAtEndPhraseContext {
	var p = new(NotAtEndPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_notAtEndPhrase
	return p
}

func (*NotAtEndPhraseContext) IsNotAtEndPhraseContext() {}

func NewNotAtEndPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotAtEndPhraseContext {
	var p = new(NotAtEndPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_notAtEndPhrase

	return p
}

func (s *NotAtEndPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *NotAtEndPhraseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *NotAtEndPhraseContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *NotAtEndPhraseContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *NotAtEndPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *NotAtEndPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NotAtEndPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotAtEndPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotAtEndPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNotAtEndPhrase(s)
	}
}

func (s *NotAtEndPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNotAtEndPhrase(s)
	}
}

func (s *NotAtEndPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitNotAtEndPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) NotAtEndPhrase() (localctx INotAtEndPhraseContext) {
	localctx = NewNotAtEndPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1006, Cobol85ParserRULE_notAtEndPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5645)
		p.Match(Cobol85ParserNOT)
	}
	p.SetState(5647)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(5646)
			p.Match(Cobol85ParserAT)
		}

	}
	{
		p.SetState(5649)
		p.Match(Cobol85ParserEND)
	}
	p.SetState(5653)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 884, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5650)
				p.Statement()
			}

		}
		p.SetState(5655)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 884, p.GetParserRuleContext())
	}

	return localctx
}

// IInvalidKeyPhraseContext is an interface to support dynamic dispatch.
type IInvalidKeyPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInvalidKeyPhraseContext differentiates from other interfaces.
	IsInvalidKeyPhraseContext()
}

type InvalidKeyPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInvalidKeyPhraseContext() *InvalidKeyPhraseContext {
	var p = new(InvalidKeyPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_invalidKeyPhrase
	return p
}

func (*InvalidKeyPhraseContext) IsInvalidKeyPhraseContext() {}

func NewInvalidKeyPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InvalidKeyPhraseContext {
	var p = new(InvalidKeyPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_invalidKeyPhrase

	return p
}

func (s *InvalidKeyPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InvalidKeyPhraseContext) INVALID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINVALID, 0)
}

func (s *InvalidKeyPhraseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *InvalidKeyPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *InvalidKeyPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *InvalidKeyPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvalidKeyPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InvalidKeyPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInvalidKeyPhrase(s)
	}
}

func (s *InvalidKeyPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInvalidKeyPhrase(s)
	}
}

func (s *InvalidKeyPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInvalidKeyPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InvalidKeyPhrase() (localctx IInvalidKeyPhraseContext) {
	localctx = NewInvalidKeyPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1008, Cobol85ParserRULE_invalidKeyPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5656)
		p.Match(Cobol85ParserINVALID)
	}
	p.SetState(5658)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(5657)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(5663)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 886, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5660)
				p.Statement()
			}

		}
		p.SetState(5665)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 886, p.GetParserRuleContext())
	}

	return localctx
}

// INotInvalidKeyPhraseContext is an interface to support dynamic dispatch.
type INotInvalidKeyPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotInvalidKeyPhraseContext differentiates from other interfaces.
	IsNotInvalidKeyPhraseContext()
}

type NotInvalidKeyPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotInvalidKeyPhraseContext() *NotInvalidKeyPhraseContext {
	var p = new(NotInvalidKeyPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_notInvalidKeyPhrase
	return p
}

func (*NotInvalidKeyPhraseContext) IsNotInvalidKeyPhraseContext() {}

func NewNotInvalidKeyPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotInvalidKeyPhraseContext {
	var p = new(NotInvalidKeyPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_notInvalidKeyPhrase

	return p
}

func (s *NotInvalidKeyPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *NotInvalidKeyPhraseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *NotInvalidKeyPhraseContext) INVALID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINVALID, 0)
}

func (s *NotInvalidKeyPhraseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *NotInvalidKeyPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *NotInvalidKeyPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NotInvalidKeyPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotInvalidKeyPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotInvalidKeyPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNotInvalidKeyPhrase(s)
	}
}

func (s *NotInvalidKeyPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNotInvalidKeyPhrase(s)
	}
}

func (s *NotInvalidKeyPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitNotInvalidKeyPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) NotInvalidKeyPhrase() (localctx INotInvalidKeyPhraseContext) {
	localctx = NewNotInvalidKeyPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1010, Cobol85ParserRULE_notInvalidKeyPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5666)
		p.Match(Cobol85ParserNOT)
	}
	{
		p.SetState(5667)
		p.Match(Cobol85ParserINVALID)
	}
	p.SetState(5669)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(5668)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(5674)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 888, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5671)
				p.Statement()
			}

		}
		p.SetState(5676)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 888, p.GetParserRuleContext())
	}

	return localctx
}

// IOnOverflowPhraseContext is an interface to support dynamic dispatch.
type IOnOverflowPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnOverflowPhraseContext differentiates from other interfaces.
	IsOnOverflowPhraseContext()
}

type OnOverflowPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnOverflowPhraseContext() *OnOverflowPhraseContext {
	var p = new(OnOverflowPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_onOverflowPhrase
	return p
}

func (*OnOverflowPhraseContext) IsOnOverflowPhraseContext() {}

func NewOnOverflowPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnOverflowPhraseContext {
	var p = new(OnOverflowPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_onOverflowPhrase

	return p
}

func (s *OnOverflowPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *OnOverflowPhraseContext) OVERFLOW() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOVERFLOW, 0)
}

func (s *OnOverflowPhraseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *OnOverflowPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *OnOverflowPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *OnOverflowPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnOverflowPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnOverflowPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOnOverflowPhrase(s)
	}
}

func (s *OnOverflowPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOnOverflowPhrase(s)
	}
}

func (s *OnOverflowPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOnOverflowPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OnOverflowPhrase() (localctx IOnOverflowPhraseContext) {
	localctx = NewOnOverflowPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1012, Cobol85ParserRULE_onOverflowPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5678)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5677)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5680)
		p.Match(Cobol85ParserOVERFLOW)
	}
	p.SetState(5684)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 890, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5681)
				p.Statement()
			}

		}
		p.SetState(5686)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 890, p.GetParserRuleContext())
	}

	return localctx
}

// INotOnOverflowPhraseContext is an interface to support dynamic dispatch.
type INotOnOverflowPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotOnOverflowPhraseContext differentiates from other interfaces.
	IsNotOnOverflowPhraseContext()
}

type NotOnOverflowPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotOnOverflowPhraseContext() *NotOnOverflowPhraseContext {
	var p = new(NotOnOverflowPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_notOnOverflowPhrase
	return p
}

func (*NotOnOverflowPhraseContext) IsNotOnOverflowPhraseContext() {}

func NewNotOnOverflowPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotOnOverflowPhraseContext {
	var p = new(NotOnOverflowPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_notOnOverflowPhrase

	return p
}

func (s *NotOnOverflowPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *NotOnOverflowPhraseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *NotOnOverflowPhraseContext) OVERFLOW() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOVERFLOW, 0)
}

func (s *NotOnOverflowPhraseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *NotOnOverflowPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *NotOnOverflowPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NotOnOverflowPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotOnOverflowPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotOnOverflowPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNotOnOverflowPhrase(s)
	}
}

func (s *NotOnOverflowPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNotOnOverflowPhrase(s)
	}
}

func (s *NotOnOverflowPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitNotOnOverflowPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) NotOnOverflowPhrase() (localctx INotOnOverflowPhraseContext) {
	localctx = NewNotOnOverflowPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1014, Cobol85ParserRULE_notOnOverflowPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5687)
		p.Match(Cobol85ParserNOT)
	}
	p.SetState(5689)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5688)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5691)
		p.Match(Cobol85ParserOVERFLOW)
	}
	p.SetState(5695)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 892, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5692)
				p.Statement()
			}

		}
		p.SetState(5697)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 892, p.GetParserRuleContext())
	}

	return localctx
}

// IOnSizeErrorPhraseContext is an interface to support dynamic dispatch.
type IOnSizeErrorPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnSizeErrorPhraseContext differentiates from other interfaces.
	IsOnSizeErrorPhraseContext()
}

type OnSizeErrorPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnSizeErrorPhraseContext() *OnSizeErrorPhraseContext {
	var p = new(OnSizeErrorPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_onSizeErrorPhrase
	return p
}

func (*OnSizeErrorPhraseContext) IsOnSizeErrorPhraseContext() {}

func NewOnSizeErrorPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnSizeErrorPhraseContext {
	var p = new(OnSizeErrorPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_onSizeErrorPhrase

	return p
}

func (s *OnSizeErrorPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *OnSizeErrorPhraseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *OnSizeErrorPhraseContext) ERROR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERROR, 0)
}

func (s *OnSizeErrorPhraseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *OnSizeErrorPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *OnSizeErrorPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *OnSizeErrorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnSizeErrorPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnSizeErrorPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOnSizeErrorPhrase(s)
	}
}

func (s *OnSizeErrorPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOnSizeErrorPhrase(s)
	}
}

func (s *OnSizeErrorPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOnSizeErrorPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OnSizeErrorPhrase() (localctx IOnSizeErrorPhraseContext) {
	localctx = NewOnSizeErrorPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1016, Cobol85ParserRULE_onSizeErrorPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5699)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5698)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5701)
		p.Match(Cobol85ParserSIZE)
	}
	{
		p.SetState(5702)
		p.Match(Cobol85ParserERROR)
	}
	p.SetState(5706)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 894, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5703)
				p.Statement()
			}

		}
		p.SetState(5708)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 894, p.GetParserRuleContext())
	}

	return localctx
}

// INotOnSizeErrorPhraseContext is an interface to support dynamic dispatch.
type INotOnSizeErrorPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotOnSizeErrorPhraseContext differentiates from other interfaces.
	IsNotOnSizeErrorPhraseContext()
}

type NotOnSizeErrorPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotOnSizeErrorPhraseContext() *NotOnSizeErrorPhraseContext {
	var p = new(NotOnSizeErrorPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_notOnSizeErrorPhrase
	return p
}

func (*NotOnSizeErrorPhraseContext) IsNotOnSizeErrorPhraseContext() {}

func NewNotOnSizeErrorPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotOnSizeErrorPhraseContext {
	var p = new(NotOnSizeErrorPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_notOnSizeErrorPhrase

	return p
}

func (s *NotOnSizeErrorPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *NotOnSizeErrorPhraseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *NotOnSizeErrorPhraseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *NotOnSizeErrorPhraseContext) ERROR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERROR, 0)
}

func (s *NotOnSizeErrorPhraseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *NotOnSizeErrorPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *NotOnSizeErrorPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NotOnSizeErrorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotOnSizeErrorPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotOnSizeErrorPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNotOnSizeErrorPhrase(s)
	}
}

func (s *NotOnSizeErrorPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNotOnSizeErrorPhrase(s)
	}
}

func (s *NotOnSizeErrorPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitNotOnSizeErrorPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) NotOnSizeErrorPhrase() (localctx INotOnSizeErrorPhraseContext) {
	localctx = NewNotOnSizeErrorPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1018, Cobol85ParserRULE_notOnSizeErrorPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5709)
		p.Match(Cobol85ParserNOT)
	}
	p.SetState(5711)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5710)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5713)
		p.Match(Cobol85ParserSIZE)
	}
	{
		p.SetState(5714)
		p.Match(Cobol85ParserERROR)
	}
	p.SetState(5718)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 896, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5715)
				p.Statement()
			}

		}
		p.SetState(5720)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 896, p.GetParserRuleContext())
	}

	return localctx
}

// IOnExceptionClauseContext is an interface to support dynamic dispatch.
type IOnExceptionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnExceptionClauseContext differentiates from other interfaces.
	IsOnExceptionClauseContext()
}

type OnExceptionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnExceptionClauseContext() *OnExceptionClauseContext {
	var p = new(OnExceptionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_onExceptionClause
	return p
}

func (*OnExceptionClauseContext) IsOnExceptionClauseContext() {}

func NewOnExceptionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnExceptionClauseContext {
	var p = new(OnExceptionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_onExceptionClause

	return p
}

func (s *OnExceptionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OnExceptionClauseContext) EXCEPTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXCEPTION, 0)
}

func (s *OnExceptionClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *OnExceptionClauseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *OnExceptionClauseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *OnExceptionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnExceptionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnExceptionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOnExceptionClause(s)
	}
}

func (s *OnExceptionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOnExceptionClause(s)
	}
}

func (s *OnExceptionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOnExceptionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OnExceptionClause() (localctx IOnExceptionClauseContext) {
	localctx = NewOnExceptionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1020, Cobol85ParserRULE_onExceptionClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5722)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5721)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5724)
		p.Match(Cobol85ParserEXCEPTION)
	}
	p.SetState(5728)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 898, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5725)
				p.Statement()
			}

		}
		p.SetState(5730)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 898, p.GetParserRuleContext())
	}

	return localctx
}

// INotOnExceptionClauseContext is an interface to support dynamic dispatch.
type INotOnExceptionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotOnExceptionClauseContext differentiates from other interfaces.
	IsNotOnExceptionClauseContext()
}

type NotOnExceptionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotOnExceptionClauseContext() *NotOnExceptionClauseContext {
	var p = new(NotOnExceptionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_notOnExceptionClause
	return p
}

func (*NotOnExceptionClauseContext) IsNotOnExceptionClauseContext() {}

func NewNotOnExceptionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotOnExceptionClauseContext {
	var p = new(NotOnExceptionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_notOnExceptionClause

	return p
}

func (s *NotOnExceptionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *NotOnExceptionClauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *NotOnExceptionClauseContext) EXCEPTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXCEPTION, 0)
}

func (s *NotOnExceptionClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *NotOnExceptionClauseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *NotOnExceptionClauseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NotOnExceptionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotOnExceptionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotOnExceptionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNotOnExceptionClause(s)
	}
}

func (s *NotOnExceptionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNotOnExceptionClause(s)
	}
}

func (s *NotOnExceptionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitNotOnExceptionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) NotOnExceptionClause() (localctx INotOnExceptionClauseContext) {
	localctx = NewNotOnExceptionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1022, Cobol85ParserRULE_notOnExceptionClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5731)
		p.Match(Cobol85ParserNOT)
	}
	p.SetState(5733)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5732)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5735)
		p.Match(Cobol85ParserEXCEPTION)
	}
	p.SetState(5739)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 900, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5736)
				p.Statement()
			}

		}
		p.SetState(5741)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 900, p.GetParserRuleContext())
	}

	return localctx
}

// IArithmeticExpressionContext is an interface to support dynamic dispatch.
type IArithmeticExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArithmeticExpressionContext differentiates from other interfaces.
	IsArithmeticExpressionContext()
}

type ArithmeticExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArithmeticExpressionContext() *ArithmeticExpressionContext {
	var p = new(ArithmeticExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_arithmeticExpression
	return p
}

func (*ArithmeticExpressionContext) IsArithmeticExpressionContext() {}

func NewArithmeticExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArithmeticExpressionContext {
	var p = new(ArithmeticExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_arithmeticExpression

	return p
}

func (s *ArithmeticExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ArithmeticExpressionContext) MultDivs() IMultDivsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultDivsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultDivsContext)
}

func (s *ArithmeticExpressionContext) AllPlusMinus() []IPlusMinusContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPlusMinusContext)(nil)).Elem())
	var tst = make([]IPlusMinusContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPlusMinusContext)
		}
	}

	return tst
}

func (s *ArithmeticExpressionContext) PlusMinus(i int) IPlusMinusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPlusMinusContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPlusMinusContext)
}

func (s *ArithmeticExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArithmeticExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterArithmeticExpression(s)
	}
}

func (s *ArithmeticExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitArithmeticExpression(s)
	}
}

func (s *ArithmeticExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitArithmeticExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ArithmeticExpression() (localctx IArithmeticExpressionContext) {
	localctx = NewArithmeticExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1024, Cobol85ParserRULE_arithmeticExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5742)
		p.MultDivs()
	}
	p.SetState(5746)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 901, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5743)
				p.PlusMinus()
			}

		}
		p.SetState(5748)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 901, p.GetParserRuleContext())
	}

	return localctx
}

// IPlusMinusContext is an interface to support dynamic dispatch.
type IPlusMinusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPlusMinusContext differentiates from other interfaces.
	IsPlusMinusContext()
}

type PlusMinusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPlusMinusContext() *PlusMinusContext {
	var p = new(PlusMinusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_plusMinus
	return p
}

func (*PlusMinusContext) IsPlusMinusContext() {}

func NewPlusMinusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PlusMinusContext {
	var p = new(PlusMinusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_plusMinus

	return p
}

func (s *PlusMinusContext) GetParser() antlr.Parser { return s.parser }

func (s *PlusMinusContext) MultDivs() IMultDivsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultDivsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultDivsContext)
}

func (s *PlusMinusContext) PLUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUSCHAR, 0)
}

func (s *PlusMinusContext) MINUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMINUSCHAR, 0)
}

func (s *PlusMinusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlusMinusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PlusMinusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPlusMinus(s)
	}
}

func (s *PlusMinusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPlusMinus(s)
	}
}

func (s *PlusMinusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPlusMinus(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PlusMinus() (localctx IPlusMinusContext) {
	localctx = NewPlusMinusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1026, Cobol85ParserRULE_plusMinus)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5749)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(5750)
		p.MultDivs()
	}

	return localctx
}

// IMultDivsContext is an interface to support dynamic dispatch.
type IMultDivsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultDivsContext differentiates from other interfaces.
	IsMultDivsContext()
}

type MultDivsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultDivsContext() *MultDivsContext {
	var p = new(MultDivsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multDivs
	return p
}

func (*MultDivsContext) IsMultDivsContext() {}

func NewMultDivsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultDivsContext {
	var p = new(MultDivsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multDivs

	return p
}

func (s *MultDivsContext) GetParser() antlr.Parser { return s.parser }

func (s *MultDivsContext) Powers() IPowersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowersContext)
}

func (s *MultDivsContext) AllMultDiv() []IMultDivContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultDivContext)(nil)).Elem())
	var tst = make([]IMultDivContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultDivContext)
		}
	}

	return tst
}

func (s *MultDivsContext) MultDiv(i int) IMultDivContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultDivContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultDivContext)
}

func (s *MultDivsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultDivsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultDivsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultDivs(s)
	}
}

func (s *MultDivsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultDivs(s)
	}
}

func (s *MultDivsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultDivs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultDivs() (localctx IMultDivsContext) {
	localctx = NewMultDivsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1028, Cobol85ParserRULE_multDivs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5752)
		p.Powers()
	}
	p.SetState(5756)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserASTERISKCHAR || _la == Cobol85ParserSLASHCHAR {
		{
			p.SetState(5753)
			p.MultDiv()
		}

		p.SetState(5758)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMultDivContext is an interface to support dynamic dispatch.
type IMultDivContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultDivContext differentiates from other interfaces.
	IsMultDivContext()
}

type MultDivContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultDivContext() *MultDivContext {
	var p = new(MultDivContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multDiv
	return p
}

func (*MultDivContext) IsMultDivContext() {}

func NewMultDivContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultDivContext {
	var p = new(MultDivContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multDiv

	return p
}

func (s *MultDivContext) GetParser() antlr.Parser { return s.parser }

func (s *MultDivContext) Powers() IPowersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowersContext)
}

func (s *MultDivContext) ASTERISKCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASTERISKCHAR, 0)
}

func (s *MultDivContext) SLASHCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSLASHCHAR, 0)
}

func (s *MultDivContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultDivContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultDivContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultDiv(s)
	}
}

func (s *MultDivContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultDiv(s)
	}
}

func (s *MultDivContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultDiv(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultDiv() (localctx IMultDivContext) {
	localctx = NewMultDivContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1030, Cobol85ParserRULE_multDiv)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5759)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserASTERISKCHAR || _la == Cobol85ParserSLASHCHAR) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(5760)
		p.Powers()
	}

	return localctx
}

// IPowersContext is an interface to support dynamic dispatch.
type IPowersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowersContext differentiates from other interfaces.
	IsPowersContext()
}

type PowersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowersContext() *PowersContext {
	var p = new(PowersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_powers
	return p
}

func (*PowersContext) IsPowersContext() {}

func NewPowersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowersContext {
	var p = new(PowersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_powers

	return p
}

func (s *PowersContext) GetParser() antlr.Parser { return s.parser }

func (s *PowersContext) Basis() IBasisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBasisContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBasisContext)
}

func (s *PowersContext) AllPower() []IPowerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPowerContext)(nil)).Elem())
	var tst = make([]IPowerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPowerContext)
		}
	}

	return tst
}

func (s *PowersContext) Power(i int) IPowerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPowerContext)
}

func (s *PowersContext) PLUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUSCHAR, 0)
}

func (s *PowersContext) MINUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMINUSCHAR, 0)
}

func (s *PowersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPowers(s)
	}
}

func (s *PowersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPowers(s)
	}
}

func (s *PowersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPowers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Powers() (localctx IPowersContext) {
	localctx = NewPowersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1032, Cobol85ParserRULE_powers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5763)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR {
		p.SetState(5762)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	{
		p.SetState(5765)
		p.Basis()
	}
	p.SetState(5769)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserDOUBLEASTERISKCHAR {
		{
			p.SetState(5766)
			p.Power()
		}

		p.SetState(5771)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPowerContext is an interface to support dynamic dispatch.
type IPowerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerContext differentiates from other interfaces.
	IsPowerContext()
}

type PowerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerContext() *PowerContext {
	var p = new(PowerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_power
	return p
}

func (*PowerContext) IsPowerContext() {}

func NewPowerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerContext {
	var p = new(PowerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_power

	return p
}

func (s *PowerContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerContext) DOUBLEASTERISKCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOUBLEASTERISKCHAR, 0)
}

func (s *PowerContext) Basis() IBasisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBasisContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBasisContext)
}

func (s *PowerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPower(s)
	}
}

func (s *PowerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPower(s)
	}
}

func (s *PowerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPower(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Power() (localctx IPowerContext) {
	localctx = NewPowerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1034, Cobol85ParserRULE_power)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5772)
		p.Match(Cobol85ParserDOUBLEASTERISKCHAR)
	}
	{
		p.SetState(5773)
		p.Basis()
	}

	return localctx
}

// IBasisContext is an interface to support dynamic dispatch.
type IBasisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBasisContext differentiates from other interfaces.
	IsBasisContext()
}

type BasisContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBasisContext() *BasisContext {
	var p = new(BasisContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_basis
	return p
}

func (*BasisContext) IsBasisContext() {}

func NewBasisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BasisContext {
	var p = new(BasisContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_basis

	return p
}

func (s *BasisContext) GetParser() antlr.Parser { return s.parser }

func (s *BasisContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *BasisContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *BasisContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *BasisContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BasisContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *BasisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BasisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterBasis(s)
	}
}

func (s *BasisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitBasis(s)
	}
}

func (s *BasisContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitBasis(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Basis() (localctx IBasisContext) {
	localctx = NewBasisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1036, Cobol85ParserRULE_basis)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5781)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 905, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5775)
			p.Match(Cobol85ParserLPARENCHAR)
		}
		{
			p.SetState(5776)
			p.ArithmeticExpression()
		}
		{
			p.SetState(5777)
			p.Match(Cobol85ParserRPARENCHAR)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5779)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5780)
			p.Literal()
		}

	}

	return localctx
}

// IConditionContext is an interface to support dynamic dispatch.
type IConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionContext differentiates from other interfaces.
	IsConditionContext()
}

type ConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionContext() *ConditionContext {
	var p = new(ConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_condition
	return p
}

func (*ConditionContext) IsConditionContext() {}

func NewConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionContext {
	var p = new(ConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_condition

	return p
}

func (s *ConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionContext) CombinableCondition() ICombinableConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICombinableConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICombinableConditionContext)
}

func (s *ConditionContext) AllAndOrCondition() []IAndOrConditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAndOrConditionContext)(nil)).Elem())
	var tst = make([]IAndOrConditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAndOrConditionContext)
		}
	}

	return tst
}

func (s *ConditionContext) AndOrCondition(i int) IAndOrConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAndOrConditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAndOrConditionContext)
}

func (s *ConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCondition(s)
	}
}

func (s *ConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCondition(s)
	}
}

func (s *ConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Condition() (localctx IConditionContext) {
	localctx = NewConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1038, Cobol85ParserRULE_condition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5783)
		p.CombinableCondition()
	}
	p.SetState(5787)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAND || _la == Cobol85ParserOR {
		{
			p.SetState(5784)
			p.AndOrCondition()
		}

		p.SetState(5789)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAndOrConditionContext is an interface to support dynamic dispatch.
type IAndOrConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAndOrConditionContext differentiates from other interfaces.
	IsAndOrConditionContext()
}

type AndOrConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndOrConditionContext() *AndOrConditionContext {
	var p = new(AndOrConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_andOrCondition
	return p
}

func (*AndOrConditionContext) IsAndOrConditionContext() {}

func NewAndOrConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndOrConditionContext {
	var p = new(AndOrConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_andOrCondition

	return p
}

func (s *AndOrConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *AndOrConditionContext) AND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAND, 0)
}

func (s *AndOrConditionContext) OR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOR, 0)
}

func (s *AndOrConditionContext) CombinableCondition() ICombinableConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICombinableConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICombinableConditionContext)
}

func (s *AndOrConditionContext) AllAbbreviation() []IAbbreviationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAbbreviationContext)(nil)).Elem())
	var tst = make([]IAbbreviationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAbbreviationContext)
		}
	}

	return tst
}

func (s *AndOrConditionContext) Abbreviation(i int) IAbbreviationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbbreviationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAbbreviationContext)
}

func (s *AndOrConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndOrConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndOrConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAndOrCondition(s)
	}
}

func (s *AndOrConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAndOrCondition(s)
	}
}

func (s *AndOrConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAndOrCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AndOrCondition() (localctx IAndOrConditionContext) {
	localctx = NewAndOrConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1040, Cobol85ParserRULE_andOrCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5790)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserAND || _la == Cobol85ParserOR) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	p.SetState(5797)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 908, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5791)
			p.CombinableCondition()
		}

	case 2:
		p.SetState(5793)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(5792)
					p.Abbreviation()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(5795)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 907, p.GetParserRuleContext())
		}

	}

	return localctx
}

// ICombinableConditionContext is an interface to support dynamic dispatch.
type ICombinableConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCombinableConditionContext differentiates from other interfaces.
	IsCombinableConditionContext()
}

type CombinableConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCombinableConditionContext() *CombinableConditionContext {
	var p = new(CombinableConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_combinableCondition
	return p
}

func (*CombinableConditionContext) IsCombinableConditionContext() {}

func NewCombinableConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CombinableConditionContext {
	var p = new(CombinableConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_combinableCondition

	return p
}

func (s *CombinableConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *CombinableConditionContext) SimpleCondition() ISimpleConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleConditionContext)
}

func (s *CombinableConditionContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *CombinableConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CombinableConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CombinableConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCombinableCondition(s)
	}
}

func (s *CombinableConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCombinableCondition(s)
	}
}

func (s *CombinableConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCombinableCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CombinableCondition() (localctx ICombinableConditionContext) {
	localctx = NewCombinableConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1042, Cobol85ParserRULE_combinableCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5800)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNOT {
		{
			p.SetState(5799)
			p.Match(Cobol85ParserNOT)
		}

	}
	{
		p.SetState(5802)
		p.SimpleCondition()
	}

	return localctx
}

// ISimpleConditionContext is an interface to support dynamic dispatch.
type ISimpleConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleConditionContext differentiates from other interfaces.
	IsSimpleConditionContext()
}

type SimpleConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleConditionContext() *SimpleConditionContext {
	var p = new(SimpleConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_simpleCondition
	return p
}

func (*SimpleConditionContext) IsSimpleConditionContext() {}

func NewSimpleConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleConditionContext {
	var p = new(SimpleConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_simpleCondition

	return p
}

func (s *SimpleConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleConditionContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *SimpleConditionContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *SimpleConditionContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *SimpleConditionContext) RelationCondition() IRelationConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationConditionContext)
}

func (s *SimpleConditionContext) ClassCondition() IClassConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassConditionContext)
}

func (s *SimpleConditionContext) ConditionNameReference() IConditionNameReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionNameReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionNameReferenceContext)
}

func (s *SimpleConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSimpleCondition(s)
	}
}

func (s *SimpleConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSimpleCondition(s)
	}
}

func (s *SimpleConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSimpleCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SimpleCondition() (localctx ISimpleConditionContext) {
	localctx = NewSimpleConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1044, Cobol85ParserRULE_simpleCondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5811)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 910, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5804)
			p.Match(Cobol85ParserLPARENCHAR)
		}
		{
			p.SetState(5805)
			p.Condition()
		}
		{
			p.SetState(5806)
			p.Match(Cobol85ParserRPARENCHAR)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5808)
			p.RelationCondition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5809)
			p.ClassCondition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5810)
			p.ConditionNameReference()
		}

	}

	return localctx
}

// IClassConditionContext is an interface to support dynamic dispatch.
type IClassConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassConditionContext differentiates from other interfaces.
	IsClassConditionContext()
}

type ClassConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassConditionContext() *ClassConditionContext {
	var p = new(ClassConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_classCondition
	return p
}

func (*ClassConditionContext) IsClassConditionContext() {}

func NewClassConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassConditionContext {
	var p = new(ClassConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_classCondition

	return p
}

func (s *ClassConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassConditionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassConditionContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC, 0)
}

func (s *ClassConditionContext) ALPHABETIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABETIC, 0)
}

func (s *ClassConditionContext) ALPHABETIC_LOWER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABETIC_LOWER, 0)
}

func (s *ClassConditionContext) ALPHABETIC_UPPER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABETIC_UPPER, 0)
}

func (s *ClassConditionContext) DBCS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDBCS, 0)
}

func (s *ClassConditionContext) KANJI() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKANJI, 0)
}

func (s *ClassConditionContext) ClassName() IClassNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *ClassConditionContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ClassConditionContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *ClassConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassCondition(s)
	}
}

func (s *ClassConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassCondition(s)
	}
}

func (s *ClassConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClassCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClassCondition() (localctx IClassConditionContext) {
	localctx = NewClassConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1046, Cobol85ParserRULE_classCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5813)
		p.Identifier()
	}
	p.SetState(5815)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5814)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(5818)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNOT {
		{
			p.SetState(5817)
			p.Match(Cobol85ParserNOT)
		}

	}
	p.SetState(5827)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNUMERIC:
		{
			p.SetState(5820)
			p.Match(Cobol85ParserNUMERIC)
		}

	case Cobol85ParserALPHABETIC:
		{
			p.SetState(5821)
			p.Match(Cobol85ParserALPHABETIC)
		}

	case Cobol85ParserALPHABETIC_LOWER:
		{
			p.SetState(5822)
			p.Match(Cobol85ParserALPHABETIC_LOWER)
		}

	case Cobol85ParserALPHABETIC_UPPER:
		{
			p.SetState(5823)
			p.Match(Cobol85ParserALPHABETIC_UPPER)
		}

	case Cobol85ParserDBCS:
		{
			p.SetState(5824)
			p.Match(Cobol85ParserDBCS)
		}

	case Cobol85ParserKANJI:
		{
			p.SetState(5825)
			p.Match(Cobol85ParserKANJI)
		}

	case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(5826)
			p.ClassName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConditionNameReferenceContext is an interface to support dynamic dispatch.
type IConditionNameReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionNameReferenceContext differentiates from other interfaces.
	IsConditionNameReferenceContext()
}

type ConditionNameReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionNameReferenceContext() *ConditionNameReferenceContext {
	var p = new(ConditionNameReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_conditionNameReference
	return p
}

func (*ConditionNameReferenceContext) IsConditionNameReferenceContext() {}

func NewConditionNameReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionNameReferenceContext {
	var p = new(ConditionNameReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_conditionNameReference

	return p
}

func (s *ConditionNameReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionNameReferenceContext) ConditionName() IConditionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionNameContext)
}

func (s *ConditionNameReferenceContext) AllInData() []IInDataContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInDataContext)(nil)).Elem())
	var tst = make([]IInDataContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInDataContext)
		}
	}

	return tst
}

func (s *ConditionNameReferenceContext) InData(i int) IInDataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInDataContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInDataContext)
}

func (s *ConditionNameReferenceContext) InFile() IInFileContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInFileContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInFileContext)
}

func (s *ConditionNameReferenceContext) AllConditionNameSubscriptReference() []IConditionNameSubscriptReferenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConditionNameSubscriptReferenceContext)(nil)).Elem())
	var tst = make([]IConditionNameSubscriptReferenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConditionNameSubscriptReferenceContext)
		}
	}

	return tst
}

func (s *ConditionNameReferenceContext) ConditionNameSubscriptReference(i int) IConditionNameSubscriptReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionNameSubscriptReferenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConditionNameSubscriptReferenceContext)
}

func (s *ConditionNameReferenceContext) AllInMnemonic() []IInMnemonicContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInMnemonicContext)(nil)).Elem())
	var tst = make([]IInMnemonicContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInMnemonicContext)
		}
	}

	return tst
}

func (s *ConditionNameReferenceContext) InMnemonic(i int) IInMnemonicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInMnemonicContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInMnemonicContext)
}

func (s *ConditionNameReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionNameReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionNameReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterConditionNameReference(s)
	}
}

func (s *ConditionNameReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitConditionNameReference(s)
	}
}

func (s *ConditionNameReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitConditionNameReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ConditionNameReference() (localctx IConditionNameReferenceContext) {
	localctx = NewConditionNameReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1048, Cobol85ParserRULE_conditionNameReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5829)
		p.ConditionName()
	}
	p.SetState(5851)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 918, p.GetParserRuleContext()) {
	case 1:
		p.SetState(5833)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 914, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5830)
					p.InData()
				}

			}
			p.SetState(5835)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 914, p.GetParserRuleContext())
		}
		p.SetState(5837)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIN || _la == Cobol85ParserOF {
			{
				p.SetState(5836)
				p.InFile()
			}

		}
		p.SetState(5842)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Cobol85ParserLPARENCHAR {
			{
				p.SetState(5839)
				p.ConditionNameSubscriptReference()
			}

			p.SetState(5844)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.SetState(5848)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Cobol85ParserIN || _la == Cobol85ParserOF {
			{
				p.SetState(5845)
				p.InMnemonic()
			}

			p.SetState(5850)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IConditionNameSubscriptReferenceContext is an interface to support dynamic dispatch.
type IConditionNameSubscriptReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionNameSubscriptReferenceContext differentiates from other interfaces.
	IsConditionNameSubscriptReferenceContext()
}

type ConditionNameSubscriptReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionNameSubscriptReferenceContext() *ConditionNameSubscriptReferenceContext {
	var p = new(ConditionNameSubscriptReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_conditionNameSubscriptReference
	return p
}

func (*ConditionNameSubscriptReferenceContext) IsConditionNameSubscriptReferenceContext() {}

func NewConditionNameSubscriptReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionNameSubscriptReferenceContext {
	var p = new(ConditionNameSubscriptReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_conditionNameSubscriptReference

	return p
}

func (s *ConditionNameSubscriptReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionNameSubscriptReferenceContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *ConditionNameSubscriptReferenceContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *ConditionNameSubscriptReferenceContext) AllSubscript() []ISubscriptContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscriptContext)(nil)).Elem())
	var tst = make([]ISubscriptContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscriptContext)
		}
	}

	return tst
}

func (s *ConditionNameSubscriptReferenceContext) Subscript(i int) ISubscriptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscriptContext)
}

func (s *ConditionNameSubscriptReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionNameSubscriptReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionNameSubscriptReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterConditionNameSubscriptReference(s)
	}
}

func (s *ConditionNameSubscriptReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitConditionNameSubscriptReference(s)
	}
}

func (s *ConditionNameSubscriptReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitConditionNameSubscriptReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ConditionNameSubscriptReference() (localctx IConditionNameSubscriptReferenceContext) {
	localctx = NewConditionNameSubscriptReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1050, Cobol85ParserRULE_conditionNameSubscriptReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5853)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	p.SetState(5855)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184))|(1<<(Cobol85ParserFALSE-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserHIGH_VALUE-216))|(1<<(Cobol85ParserHIGH_VALUES-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserLOW_VALUE-286))|(1<<(Cobol85ParserLOW_VALUES-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286))|(1<<(Cobol85ParserNULL-286)))) != 0) || (((_la-318)&-(0x1f+1)) == 0 && ((1<<uint((_la-318)))&((1<<(Cobol85ParserNULLS-318))|(1<<(Cobol85ParserNUMERIC_DATE-318))|(1<<(Cobol85ParserNUMERIC_TIME-318))|(1<<(Cobol85ParserODT-318))|(1<<(Cobol85ParserOPTIMIZE-318))|(1<<(Cobol85ParserORDERLY-318))|(1<<(Cobol85ParserOVERLINE-318))|(1<<(Cobol85ParserOWN-318))|(1<<(Cobol85ParserPAGE_COUNTER-318))|(1<<(Cobol85ParserPASSWORD-318)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserQUOTE-357))|(1<<(Cobol85ParserQUOTES-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434))|(1<<(Cobol85ParserSPACE-434))|(1<<(Cobol85ParserSPACES-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUE-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO-502))|(1<<(Cobol85ParserZERO_FILL-502))|(1<<(Cobol85ParserZEROS-502))|(1<<(Cobol85ParserZEROES-502)))) != 0) || (((_la-547)&-(0x1f+1)) == 0 && ((1<<uint((_la-547)))&((1<<(Cobol85ParserLPARENCHAR-547))|(1<<(Cobol85ParserMINUSCHAR-547))|(1<<(Cobol85ParserPLUSCHAR-547))|(1<<(Cobol85ParserNONNUMERICLITERAL-547))|(1<<(Cobol85ParserLEVEL_NUMBER_66-547))|(1<<(Cobol85ParserLEVEL_NUMBER_77-547))|(1<<(Cobol85ParserLEVEL_NUMBER_88-547))|(1<<(Cobol85ParserINTEGERLITERAL-547))|(1<<(Cobol85ParserNUMERICLITERAL-547))|(1<<(Cobol85ParserIDENTIFIER-547)))) != 0) {
		{
			p.SetState(5854)
			p.Subscript()
		}

		p.SetState(5857)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5859)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// IRelationConditionContext is an interface to support dynamic dispatch.
type IRelationConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationConditionContext differentiates from other interfaces.
	IsRelationConditionContext()
}

type RelationConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationConditionContext() *RelationConditionContext {
	var p = new(RelationConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationCondition
	return p
}

func (*RelationConditionContext) IsRelationConditionContext() {}

func NewRelationConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationConditionContext {
	var p = new(RelationConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationCondition

	return p
}

func (s *RelationConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationConditionContext) RelationSignCondition() IRelationSignConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationSignConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationSignConditionContext)
}

func (s *RelationConditionContext) RelationArithmeticComparison() IRelationArithmeticComparisonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationArithmeticComparisonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationArithmeticComparisonContext)
}

func (s *RelationConditionContext) RelationCombinedComparison() IRelationCombinedComparisonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationCombinedComparisonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationCombinedComparisonContext)
}

func (s *RelationConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationCondition(s)
	}
}

func (s *RelationConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationCondition(s)
	}
}

func (s *RelationConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRelationCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RelationCondition() (localctx IRelationConditionContext) {
	localctx = NewRelationConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1052, Cobol85ParserRULE_relationCondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5864)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 920, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5861)
			p.RelationSignCondition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5862)
			p.RelationArithmeticComparison()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5863)
			p.RelationCombinedComparison()
		}

	}

	return localctx
}

// IRelationSignConditionContext is an interface to support dynamic dispatch.
type IRelationSignConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationSignConditionContext differentiates from other interfaces.
	IsRelationSignConditionContext()
}

type RelationSignConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationSignConditionContext() *RelationSignConditionContext {
	var p = new(RelationSignConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationSignCondition
	return p
}

func (*RelationSignConditionContext) IsRelationSignConditionContext() {}

func NewRelationSignConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationSignConditionContext {
	var p = new(RelationSignConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationSignCondition

	return p
}

func (s *RelationSignConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationSignConditionContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *RelationSignConditionContext) POSITIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPOSITIVE, 0)
}

func (s *RelationSignConditionContext) NEGATIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEGATIVE, 0)
}

func (s *RelationSignConditionContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *RelationSignConditionContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RelationSignConditionContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *RelationSignConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationSignConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationSignConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationSignCondition(s)
	}
}

func (s *RelationSignConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationSignCondition(s)
	}
}

func (s *RelationSignConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRelationSignCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RelationSignCondition() (localctx IRelationSignConditionContext) {
	localctx = NewRelationSignConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1054, Cobol85ParserRULE_relationSignCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5866)
		p.ArithmeticExpression()
	}
	p.SetState(5868)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5867)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(5871)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNOT {
		{
			p.SetState(5870)
			p.Match(Cobol85ParserNOT)
		}

	}
	p.SetState(5873)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserNEGATIVE || _la == Cobol85ParserPOSITIVE || _la == Cobol85ParserZERO) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IRelationArithmeticComparisonContext is an interface to support dynamic dispatch.
type IRelationArithmeticComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationArithmeticComparisonContext differentiates from other interfaces.
	IsRelationArithmeticComparisonContext()
}

type RelationArithmeticComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationArithmeticComparisonContext() *RelationArithmeticComparisonContext {
	var p = new(RelationArithmeticComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationArithmeticComparison
	return p
}

func (*RelationArithmeticComparisonContext) IsRelationArithmeticComparisonContext() {}

func NewRelationArithmeticComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationArithmeticComparisonContext {
	var p = new(RelationArithmeticComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationArithmeticComparison

	return p
}

func (s *RelationArithmeticComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationArithmeticComparisonContext) AllArithmeticExpression() []IArithmeticExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem())
	var tst = make([]IArithmeticExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArithmeticExpressionContext)
		}
	}

	return tst
}

func (s *RelationArithmeticComparisonContext) ArithmeticExpression(i int) IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *RelationArithmeticComparisonContext) RelationalOperator() IRelationalOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationalOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationalOperatorContext)
}

func (s *RelationArithmeticComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationArithmeticComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationArithmeticComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationArithmeticComparison(s)
	}
}

func (s *RelationArithmeticComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationArithmeticComparison(s)
	}
}

func (s *RelationArithmeticComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRelationArithmeticComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RelationArithmeticComparison() (localctx IRelationArithmeticComparisonContext) {
	localctx = NewRelationArithmeticComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1056, Cobol85ParserRULE_relationArithmeticComparison)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5875)
		p.ArithmeticExpression()
	}
	{
		p.SetState(5876)
		p.RelationalOperator()
	}
	{
		p.SetState(5877)
		p.ArithmeticExpression()
	}

	return localctx
}

// IRelationCombinedComparisonContext is an interface to support dynamic dispatch.
type IRelationCombinedComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationCombinedComparisonContext differentiates from other interfaces.
	IsRelationCombinedComparisonContext()
}

type RelationCombinedComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationCombinedComparisonContext() *RelationCombinedComparisonContext {
	var p = new(RelationCombinedComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationCombinedComparison
	return p
}

func (*RelationCombinedComparisonContext) IsRelationCombinedComparisonContext() {}

func NewRelationCombinedComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationCombinedComparisonContext {
	var p = new(RelationCombinedComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationCombinedComparison

	return p
}

func (s *RelationCombinedComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationCombinedComparisonContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *RelationCombinedComparisonContext) RelationalOperator() IRelationalOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationalOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationalOperatorContext)
}

func (s *RelationCombinedComparisonContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *RelationCombinedComparisonContext) RelationCombinedCondition() IRelationCombinedConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationCombinedConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationCombinedConditionContext)
}

func (s *RelationCombinedComparisonContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *RelationCombinedComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationCombinedComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationCombinedComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationCombinedComparison(s)
	}
}

func (s *RelationCombinedComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationCombinedComparison(s)
	}
}

func (s *RelationCombinedComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRelationCombinedComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RelationCombinedComparison() (localctx IRelationCombinedComparisonContext) {
	localctx = NewRelationCombinedComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1058, Cobol85ParserRULE_relationCombinedComparison)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5879)
		p.ArithmeticExpression()
	}
	{
		p.SetState(5880)
		p.RelationalOperator()
	}
	{
		p.SetState(5881)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	{
		p.SetState(5882)
		p.RelationCombinedCondition()
	}
	{
		p.SetState(5883)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// IRelationCombinedConditionContext is an interface to support dynamic dispatch.
type IRelationCombinedConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationCombinedConditionContext differentiates from other interfaces.
	IsRelationCombinedConditionContext()
}

type RelationCombinedConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationCombinedConditionContext() *RelationCombinedConditionContext {
	var p = new(RelationCombinedConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationCombinedCondition
	return p
}

func (*RelationCombinedConditionContext) IsRelationCombinedConditionContext() {}

func NewRelationCombinedConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationCombinedConditionContext {
	var p = new(RelationCombinedConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationCombinedCondition

	return p
}

func (s *RelationCombinedConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationCombinedConditionContext) AllArithmeticExpression() []IArithmeticExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem())
	var tst = make([]IArithmeticExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArithmeticExpressionContext)
		}
	}

	return tst
}

func (s *RelationCombinedConditionContext) ArithmeticExpression(i int) IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *RelationCombinedConditionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserOR)
}

func (s *RelationCombinedConditionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOR, i)
}

func (s *RelationCombinedConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationCombinedConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationCombinedConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationCombinedCondition(s)
	}
}

func (s *RelationCombinedConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationCombinedCondition(s)
	}
}

func (s *RelationCombinedConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRelationCombinedCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RelationCombinedCondition() (localctx IRelationCombinedConditionContext) {
	localctx = NewRelationCombinedConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1060, Cobol85ParserRULE_relationCombinedCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5885)
		p.ArithmeticExpression()
	}
	p.SetState(5888)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserOR {
		{
			p.SetState(5886)
			p.Match(Cobol85ParserOR)
		}
		{
			p.SetState(5887)
			p.ArithmeticExpression()
		}

		p.SetState(5890)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRelationalOperatorContext is an interface to support dynamic dispatch.
type IRelationalOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationalOperatorContext differentiates from other interfaces.
	IsRelationalOperatorContext()
}

type RelationalOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationalOperatorContext() *RelationalOperatorContext {
	var p = new(RelationalOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationalOperator
	return p
}

func (*RelationalOperatorContext) IsRelationalOperatorContext() {}

func NewRelationalOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationalOperatorContext {
	var p = new(RelationalOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationalOperator

	return p
}

func (s *RelationalOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationalOperatorContext) GREATER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGREATER, 0)
}

func (s *RelationalOperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOR, 0)
}

func (s *RelationalOperatorContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUAL, 0)
}

func (s *RelationalOperatorContext) MORETHANOREQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORETHANOREQUAL, 0)
}

func (s *RelationalOperatorContext) LESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESS, 0)
}

func (s *RelationalOperatorContext) LESSTHANOREQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESSTHANOREQUAL, 0)
}

func (s *RelationalOperatorContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RelationalOperatorContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *RelationalOperatorContext) MORETHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORETHANCHAR, 0)
}

func (s *RelationalOperatorContext) LESSTHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESSTHANCHAR, 0)
}

func (s *RelationalOperatorContext) EQUALCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUALCHAR, 0)
}

func (s *RelationalOperatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *RelationalOperatorContext) THAN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHAN, 0)
}

func (s *RelationalOperatorContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *RelationalOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationalOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationalOperator(s)
	}
}

func (s *RelationalOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationalOperator(s)
	}
}

func (s *RelationalOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRelationalOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RelationalOperator() (localctx IRelationalOperatorContext) {
	localctx = NewRelationalOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1062, Cobol85ParserRULE_relationalOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5893)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserARE || _la == Cobol85ParserIS {
		p.SetState(5892)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserARE || _la == Cobol85ParserIS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	p.SetState(5935)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 934, p.GetParserRuleContext()) {
	case 1:
		p.SetState(5896)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserNOT {
			{
				p.SetState(5895)
				p.Match(Cobol85ParserNOT)
			}

		}
		p.SetState(5913)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserGREATER:
			{
				p.SetState(5898)
				p.Match(Cobol85ParserGREATER)
			}
			p.SetState(5900)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserTHAN {
				{
					p.SetState(5899)
					p.Match(Cobol85ParserTHAN)
				}

			}

		case Cobol85ParserMORETHANCHAR:
			{
				p.SetState(5902)
				p.Match(Cobol85ParserMORETHANCHAR)
			}

		case Cobol85ParserLESS:
			{
				p.SetState(5903)
				p.Match(Cobol85ParserLESS)
			}
			p.SetState(5905)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserTHAN {
				{
					p.SetState(5904)
					p.Match(Cobol85ParserTHAN)
				}

			}

		case Cobol85ParserLESSTHANCHAR:
			{
				p.SetState(5907)
				p.Match(Cobol85ParserLESSTHANCHAR)
			}

		case Cobol85ParserEQUAL:
			{
				p.SetState(5908)
				p.Match(Cobol85ParserEQUAL)
			}
			p.SetState(5910)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserTO {
				{
					p.SetState(5909)
					p.Match(Cobol85ParserTO)
				}

			}

		case Cobol85ParserEQUALCHAR:
			{
				p.SetState(5912)
				p.Match(Cobol85ParserEQUALCHAR)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		{
			p.SetState(5915)
			p.Match(Cobol85ParserGREATER)
		}
		p.SetState(5917)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHAN {
			{
				p.SetState(5916)
				p.Match(Cobol85ParserTHAN)
			}

		}
		{
			p.SetState(5919)
			p.Match(Cobol85ParserOR)
		}
		{
			p.SetState(5920)
			p.Match(Cobol85ParserEQUAL)
		}
		p.SetState(5922)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTO {
			{
				p.SetState(5921)
				p.Match(Cobol85ParserTO)
			}

		}

	case 3:
		{
			p.SetState(5924)
			p.Match(Cobol85ParserMORETHANOREQUAL)
		}

	case 4:
		{
			p.SetState(5925)
			p.Match(Cobol85ParserLESS)
		}
		p.SetState(5927)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHAN {
			{
				p.SetState(5926)
				p.Match(Cobol85ParserTHAN)
			}

		}
		{
			p.SetState(5929)
			p.Match(Cobol85ParserOR)
		}
		{
			p.SetState(5930)
			p.Match(Cobol85ParserEQUAL)
		}
		p.SetState(5932)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTO {
			{
				p.SetState(5931)
				p.Match(Cobol85ParserTO)
			}

		}

	case 5:
		{
			p.SetState(5934)
			p.Match(Cobol85ParserLESSTHANOREQUAL)
		}

	}

	return localctx
}

// IAbbreviationContext is an interface to support dynamic dispatch.
type IAbbreviationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbbreviationContext differentiates from other interfaces.
	IsAbbreviationContext()
}

type AbbreviationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbbreviationContext() *AbbreviationContext {
	var p = new(AbbreviationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_abbreviation
	return p
}

func (*AbbreviationContext) IsAbbreviationContext() {}

func NewAbbreviationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbbreviationContext {
	var p = new(AbbreviationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_abbreviation

	return p
}

func (s *AbbreviationContext) GetParser() antlr.Parser { return s.parser }

func (s *AbbreviationContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *AbbreviationContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *AbbreviationContext) Abbreviation() IAbbreviationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbbreviationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbbreviationContext)
}

func (s *AbbreviationContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *AbbreviationContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *AbbreviationContext) RelationalOperator() IRelationalOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationalOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationalOperatorContext)
}

func (s *AbbreviationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbbreviationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbbreviationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAbbreviation(s)
	}
}

func (s *AbbreviationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAbbreviation(s)
	}
}

func (s *AbbreviationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAbbreviation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Abbreviation() (localctx IAbbreviationContext) {
	localctx = NewAbbreviationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1064, Cobol85ParserRULE_abbreviation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5938)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 935, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5937)
			p.Match(Cobol85ParserNOT)
		}

	}
	p.SetState(5941)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserARE || _la == Cobol85ParserEQUAL || _la == Cobol85ParserGREATER || _la == Cobol85ParserIS || _la == Cobol85ParserLESS || _la == Cobol85ParserNOT || (((_la-541)&-(0x1f+1)) == 0 && ((1<<uint((_la-541)))&((1<<(Cobol85ParserEQUALCHAR-541))|(1<<(Cobol85ParserLESSTHANCHAR-541))|(1<<(Cobol85ParserLESSTHANOREQUAL-541))|(1<<(Cobol85ParserMORETHANCHAR-541))|(1<<(Cobol85ParserMORETHANOREQUAL-541)))) != 0) {
		{
			p.SetState(5940)
			p.RelationalOperator()
		}

	}
	p.SetState(5949)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 937, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5943)
			p.ArithmeticExpression()
		}

	case 2:
		{
			p.SetState(5944)
			p.Match(Cobol85ParserLPARENCHAR)
		}
		{
			p.SetState(5945)
			p.ArithmeticExpression()
		}
		{
			p.SetState(5946)
			p.Abbreviation()
		}
		{
			p.SetState(5947)
			p.Match(Cobol85ParserRPARENCHAR)
		}

	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *IdentifierContext) TableCall() ITableCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableCallContext)
}

func (s *IdentifierContext) FunctionCall() IFunctionCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *IdentifierContext) SpecialRegister() ISpecialRegisterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecialRegisterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecialRegisterContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1066, Cobol85ParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5955)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 938, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5951)
			p.QualifiedDataName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5952)
			p.TableCall()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5953)
			p.FunctionCall()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5954)
			p.SpecialRegister()
		}

	}

	return localctx
}

// ITableCallContext is an interface to support dynamic dispatch.
type ITableCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableCallContext differentiates from other interfaces.
	IsTableCallContext()
}

type TableCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableCallContext() *TableCallContext {
	var p = new(TableCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_tableCall
	return p
}

func (*TableCallContext) IsTableCallContext() {}

func NewTableCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableCallContext {
	var p = new(TableCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_tableCall

	return p
}

func (s *TableCallContext) GetParser() antlr.Parser { return s.parser }

func (s *TableCallContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *TableCallContext) AllLPARENCHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserLPARENCHAR)
}

func (s *TableCallContext) LPARENCHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, i)
}

func (s *TableCallContext) AllSubscript() []ISubscriptContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscriptContext)(nil)).Elem())
	var tst = make([]ISubscriptContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscriptContext)
		}
	}

	return tst
}

func (s *TableCallContext) Subscript(i int) ISubscriptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscriptContext)
}

func (s *TableCallContext) AllRPARENCHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserRPARENCHAR)
}

func (s *TableCallContext) RPARENCHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, i)
}

func (s *TableCallContext) ReferenceModifier() IReferenceModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceModifierContext)
}

func (s *TableCallContext) AllCOMMACHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserCOMMACHAR)
}

func (s *TableCallContext) COMMACHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMACHAR, i)
}

func (s *TableCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterTableCall(s)
	}
}

func (s *TableCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitTableCall(s)
	}
}

func (s *TableCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitTableCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) TableCall() (localctx ITableCallContext) {
	localctx = NewTableCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1068, Cobol85ParserRULE_tableCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5957)
		p.QualifiedDataName()
	}
	p.SetState(5973)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 941, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5958)
				p.Match(Cobol85ParserLPARENCHAR)
			}
			{
				p.SetState(5959)
				p.Subscript()
			}
			p.SetState(5966)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184))|(1<<(Cobol85ParserFALSE-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserHIGH_VALUE-216))|(1<<(Cobol85ParserHIGH_VALUES-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserLOW_VALUE-286))|(1<<(Cobol85ParserLOW_VALUES-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286))|(1<<(Cobol85ParserNULL-286)))) != 0) || (((_la-318)&-(0x1f+1)) == 0 && ((1<<uint((_la-318)))&((1<<(Cobol85ParserNULLS-318))|(1<<(Cobol85ParserNUMERIC_DATE-318))|(1<<(Cobol85ParserNUMERIC_TIME-318))|(1<<(Cobol85ParserODT-318))|(1<<(Cobol85ParserOPTIMIZE-318))|(1<<(Cobol85ParserORDERLY-318))|(1<<(Cobol85ParserOVERLINE-318))|(1<<(Cobol85ParserOWN-318))|(1<<(Cobol85ParserPAGE_COUNTER-318))|(1<<(Cobol85ParserPASSWORD-318)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserQUOTE-357))|(1<<(Cobol85ParserQUOTES-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434))|(1<<(Cobol85ParserSPACE-434))|(1<<(Cobol85ParserSPACES-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUE-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO-502))|(1<<(Cobol85ParserZERO_FILL-502))|(1<<(Cobol85ParserZEROS-502))|(1<<(Cobol85ParserZEROES-502)))) != 0) || (((_la-534)&-(0x1f+1)) == 0 && ((1<<uint((_la-534)))&((1<<(Cobol85ParserCOMMACHAR-534))|(1<<(Cobol85ParserLPARENCHAR-534))|(1<<(Cobol85ParserMINUSCHAR-534))|(1<<(Cobol85ParserPLUSCHAR-534))|(1<<(Cobol85ParserNONNUMERICLITERAL-534))|(1<<(Cobol85ParserLEVEL_NUMBER_66-534))|(1<<(Cobol85ParserLEVEL_NUMBER_77-534))|(1<<(Cobol85ParserLEVEL_NUMBER_88-534))|(1<<(Cobol85ParserINTEGERLITERAL-534))|(1<<(Cobol85ParserNUMERICLITERAL-534))|(1<<(Cobol85ParserIDENTIFIER-534)))) != 0) {
				p.SetState(5961)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == Cobol85ParserCOMMACHAR {
					{
						p.SetState(5960)
						p.Match(Cobol85ParserCOMMACHAR)
					}

				}
				{
					p.SetState(5963)
					p.Subscript()
				}

				p.SetState(5968)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(5969)
				p.Match(Cobol85ParserRPARENCHAR)
			}

		}
		p.SetState(5975)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 941, p.GetParserRuleContext())
	}
	p.SetState(5977)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 942, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5976)
			p.ReferenceModifier()
		}

	}

	return localctx
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_functionCall
	return p
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFUNCTION, 0)
}

func (s *FunctionCallContext) FunctionName() IFunctionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *FunctionCallContext) AllLPARENCHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserLPARENCHAR)
}

func (s *FunctionCallContext) LPARENCHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, i)
}

func (s *FunctionCallContext) AllArgument() []IArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentContext)(nil)).Elem())
	var tst = make([]IArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentContext)
		}
	}

	return tst
}

func (s *FunctionCallContext) Argument(i int) IArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *FunctionCallContext) AllRPARENCHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserRPARENCHAR)
}

func (s *FunctionCallContext) RPARENCHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, i)
}

func (s *FunctionCallContext) ReferenceModifier() IReferenceModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceModifierContext)
}

func (s *FunctionCallContext) AllCOMMACHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserCOMMACHAR)
}

func (s *FunctionCallContext) COMMACHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMACHAR, i)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (s *FunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1070, Cobol85ParserRULE_functionCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5979)
		p.Match(Cobol85ParserFUNCTION)
	}
	{
		p.SetState(5980)
		p.FunctionName()
	}
	p.SetState(5996)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 945, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5981)
				p.Match(Cobol85ParserLPARENCHAR)
			}
			{
				p.SetState(5982)
				p.Argument()
			}
			p.SetState(5989)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184))|(1<<(Cobol85ParserFALSE-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserHIGH_VALUE-216))|(1<<(Cobol85ParserHIGH_VALUES-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserLOW_VALUE-286))|(1<<(Cobol85ParserLOW_VALUES-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286))|(1<<(Cobol85ParserNULL-286)))) != 0) || (((_la-318)&-(0x1f+1)) == 0 && ((1<<uint((_la-318)))&((1<<(Cobol85ParserNULLS-318))|(1<<(Cobol85ParserNUMERIC_DATE-318))|(1<<(Cobol85ParserNUMERIC_TIME-318))|(1<<(Cobol85ParserODT-318))|(1<<(Cobol85ParserOPTIMIZE-318))|(1<<(Cobol85ParserORDERLY-318))|(1<<(Cobol85ParserOVERLINE-318))|(1<<(Cobol85ParserOWN-318))|(1<<(Cobol85ParserPAGE_COUNTER-318))|(1<<(Cobol85ParserPASSWORD-318)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserQUOTE-357))|(1<<(Cobol85ParserQUOTES-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434))|(1<<(Cobol85ParserSPACE-434))|(1<<(Cobol85ParserSPACES-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUE-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO-502))|(1<<(Cobol85ParserZERO_FILL-502))|(1<<(Cobol85ParserZEROS-502))|(1<<(Cobol85ParserZEROES-502)))) != 0) || (((_la-534)&-(0x1f+1)) == 0 && ((1<<uint((_la-534)))&((1<<(Cobol85ParserCOMMACHAR-534))|(1<<(Cobol85ParserLPARENCHAR-534))|(1<<(Cobol85ParserMINUSCHAR-534))|(1<<(Cobol85ParserPLUSCHAR-534))|(1<<(Cobol85ParserNONNUMERICLITERAL-534))|(1<<(Cobol85ParserLEVEL_NUMBER_66-534))|(1<<(Cobol85ParserLEVEL_NUMBER_77-534))|(1<<(Cobol85ParserLEVEL_NUMBER_88-534))|(1<<(Cobol85ParserINTEGERLITERAL-534))|(1<<(Cobol85ParserNUMERICLITERAL-534))|(1<<(Cobol85ParserIDENTIFIER-534)))) != 0) {
				p.SetState(5984)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == Cobol85ParserCOMMACHAR {
					{
						p.SetState(5983)
						p.Match(Cobol85ParserCOMMACHAR)
					}

				}
				{
					p.SetState(5986)
					p.Argument()
				}

				p.SetState(5991)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(5992)
				p.Match(Cobol85ParserRPARENCHAR)
			}

		}
		p.SetState(5998)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 945, p.GetParserRuleContext())
	}
	p.SetState(6000)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 946, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5999)
			p.ReferenceModifier()
		}

	}

	return localctx
}

// IReferenceModifierContext is an interface to support dynamic dispatch.
type IReferenceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceModifierContext differentiates from other interfaces.
	IsReferenceModifierContext()
}

type ReferenceModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceModifierContext() *ReferenceModifierContext {
	var p = new(ReferenceModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_referenceModifier
	return p
}

func (*ReferenceModifierContext) IsReferenceModifierContext() {}

func NewReferenceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceModifierContext {
	var p = new(ReferenceModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_referenceModifier

	return p
}

func (s *ReferenceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceModifierContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *ReferenceModifierContext) CharacterPosition() ICharacterPositionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharacterPositionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharacterPositionContext)
}

func (s *ReferenceModifierContext) COLONCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLONCHAR, 0)
}

func (s *ReferenceModifierContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *ReferenceModifierContext) Length() ILengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILengthContext)
}

func (s *ReferenceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReferenceModifier(s)
	}
}

func (s *ReferenceModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReferenceModifier(s)
	}
}

func (s *ReferenceModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReferenceModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReferenceModifier() (localctx IReferenceModifierContext) {
	localctx = NewReferenceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1072, Cobol85ParserRULE_referenceModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6002)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	{
		p.SetState(6003)
		p.CharacterPosition()
	}
	{
		p.SetState(6004)
		p.Match(Cobol85ParserCOLONCHAR)
	}
	p.SetState(6006)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDATE-103))|(1<<(Cobol85ParserDAY-103))|(1<<(Cobol85ParserDAY_OF_WEEK-103))|(1<<(Cobol85ParserDEBUG_CONTENTS-103))|(1<<(Cobol85ParserDEBUG_ITEM-103))|(1<<(Cobol85ParserDEBUG_LINE-103))|(1<<(Cobol85ParserDEBUG_NAME-103))|(1<<(Cobol85ParserDEBUG_SUB_1-103))|(1<<(Cobol85ParserDEBUG_SUB_2-103))|(1<<(Cobol85ParserDEBUG_SUB_3-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184))|(1<<(Cobol85ParserFALSE-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTION-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserHIGH_VALUE-216))|(1<<(Cobol85ParserHIGH_VALUES-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253))|(1<<(Cobol85ParserLINAGE_COUNTER-253))|(1<<(Cobol85ParserLINE_COUNTER-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserLOW_VALUE-286))|(1<<(Cobol85ParserLOW_VALUES-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286))|(1<<(Cobol85ParserNULL-286)))) != 0) || (((_la-318)&-(0x1f+1)) == 0 && ((1<<uint((_la-318)))&((1<<(Cobol85ParserNULLS-318))|(1<<(Cobol85ParserNUMERIC_DATE-318))|(1<<(Cobol85ParserNUMERIC_TIME-318))|(1<<(Cobol85ParserODT-318))|(1<<(Cobol85ParserOPTIMIZE-318))|(1<<(Cobol85ParserORDERLY-318))|(1<<(Cobol85ParserOVERLINE-318))|(1<<(Cobol85ParserOWN-318))|(1<<(Cobol85ParserPAGE_COUNTER-318))|(1<<(Cobol85ParserPASSWORD-318)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserQUOTE-357))|(1<<(Cobol85ParserQUOTES-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserRETURN_CODE-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHIFT_IN-434))|(1<<(Cobol85ParserSHIFT_OUT-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSORT_CONTROL-434))|(1<<(Cobol85ParserSORT_CORE_SIZE-434))|(1<<(Cobol85ParserSORT_FILE_SIZE-434))|(1<<(Cobol85ParserSORT_MESSAGE-434))|(1<<(Cobol85ParserSORT_MODE_SIZE-434))|(1<<(Cobol85ParserSORT_RETURN-434))|(1<<(Cobol85ParserSP-434))|(1<<(Cobol85ParserSPACE-434))|(1<<(Cobol85ParserSPACES-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTALLY-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIME-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUE-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserWHEN_COMPILED-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO-502))|(1<<(Cobol85ParserZERO_FILL-502))|(1<<(Cobol85ParserZEROS-502))|(1<<(Cobol85ParserZEROES-502)))) != 0) || (((_la-547)&-(0x1f+1)) == 0 && ((1<<uint((_la-547)))&((1<<(Cobol85ParserLPARENCHAR-547))|(1<<(Cobol85ParserMINUSCHAR-547))|(1<<(Cobol85ParserPLUSCHAR-547))|(1<<(Cobol85ParserNONNUMERICLITERAL-547))|(1<<(Cobol85ParserLEVEL_NUMBER_66-547))|(1<<(Cobol85ParserLEVEL_NUMBER_77-547))|(1<<(Cobol85ParserLEVEL_NUMBER_88-547))|(1<<(Cobol85ParserINTEGERLITERAL-547))|(1<<(Cobol85ParserNUMERICLITERAL-547))|(1<<(Cobol85ParserIDENTIFIER-547)))) != 0) {
		{
			p.SetState(6005)
			p.Length()
		}

	}
	{
		p.SetState(6008)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// ICharacterPositionContext is an interface to support dynamic dispatch.
type ICharacterPositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharacterPositionContext differentiates from other interfaces.
	IsCharacterPositionContext()
}

type CharacterPositionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacterPositionContext() *CharacterPositionContext {
	var p = new(CharacterPositionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_characterPosition
	return p
}

func (*CharacterPositionContext) IsCharacterPositionContext() {}

func NewCharacterPositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharacterPositionContext {
	var p = new(CharacterPositionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_characterPosition

	return p
}

func (s *CharacterPositionContext) GetParser() antlr.Parser { return s.parser }

func (s *CharacterPositionContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *CharacterPositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharacterPositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharacterPositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCharacterPosition(s)
	}
}

func (s *CharacterPositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCharacterPosition(s)
	}
}

func (s *CharacterPositionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCharacterPosition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CharacterPosition() (localctx ICharacterPositionContext) {
	localctx = NewCharacterPositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1074, Cobol85ParserRULE_characterPosition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6010)
		p.ArithmeticExpression()
	}

	return localctx
}

// ILengthContext is an interface to support dynamic dispatch.
type ILengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLengthContext differentiates from other interfaces.
	IsLengthContext()
}

type LengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthContext() *LengthContext {
	var p = new(LengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_length
	return p
}

func (*LengthContext) IsLengthContext() {}

func NewLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthContext {
	var p = new(LengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_length

	return p
}

func (s *LengthContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *LengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLength(s)
	}
}

func (s *LengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLength(s)
	}
}

func (s *LengthContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLength(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Length() (localctx ILengthContext) {
	localctx = NewLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1076, Cobol85ParserRULE_length)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6012)
		p.ArithmeticExpression()
	}

	return localctx
}

// ISubscriptContext is an interface to support dynamic dispatch.
type ISubscriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscriptContext differentiates from other interfaces.
	IsSubscriptContext()
}

type SubscriptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptContext() *SubscriptContext {
	var p = new(SubscriptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subscript
	return p
}

func (*SubscriptContext) IsSubscriptContext() {}

func NewSubscriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptContext {
	var p = new(SubscriptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subscript

	return p
}

func (s *SubscriptContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *SubscriptContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *SubscriptContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *SubscriptContext) IndexName() IIndexNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *SubscriptContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubscript(s)
	}
}

func (s *SubscriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubscript(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Subscript() (localctx ISubscriptContext) {
	localctx = NewSubscriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1078, Cobol85ParserRULE_subscript)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6025)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 950, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6014)
			p.Match(Cobol85ParserALL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6015)
			p.IntegerLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6016)
			p.QualifiedDataName()
		}
		p.SetState(6018)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 948, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6017)
				p.IntegerLiteral()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6020)
			p.IndexName()
		}
		p.SetState(6022)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 949, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6021)
				p.IntegerLiteral()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6024)
			p.ArithmeticExpression()
		}

	}

	return localctx
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_argument
	return p
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ArgumentContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ArgumentContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ArgumentContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ArgumentContext) IndexName() IIndexNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *ArgumentContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitArgument(s)
	}
}

func (s *ArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1080, Cobol85ParserRULE_argument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6038)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 953, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6027)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6028)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6029)
			p.QualifiedDataName()
		}
		p.SetState(6031)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 951, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6030)
				p.IntegerLiteral()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6033)
			p.IndexName()
		}
		p.SetState(6035)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 952, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6034)
				p.IntegerLiteral()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6037)
			p.ArithmeticExpression()
		}

	}

	return localctx
}

// IQualifiedDataNameContext is an interface to support dynamic dispatch.
type IQualifiedDataNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedDataNameContext differentiates from other interfaces.
	IsQualifiedDataNameContext()
}

type QualifiedDataNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedDataNameContext() *QualifiedDataNameContext {
	var p = new(QualifiedDataNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataName
	return p
}

func (*QualifiedDataNameContext) IsQualifiedDataNameContext() {}

func NewQualifiedDataNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedDataNameContext {
	var p = new(QualifiedDataNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataName

	return p
}

func (s *QualifiedDataNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedDataNameContext) QualifiedDataNameFormat1() IQualifiedDataNameFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameFormat1Context)
}

func (s *QualifiedDataNameContext) QualifiedDataNameFormat2() IQualifiedDataNameFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameFormat2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameFormat2Context)
}

func (s *QualifiedDataNameContext) QualifiedDataNameFormat3() IQualifiedDataNameFormat3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameFormat3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameFormat3Context)
}

func (s *QualifiedDataNameContext) QualifiedDataNameFormat4() IQualifiedDataNameFormat4Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameFormat4Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameFormat4Context)
}

func (s *QualifiedDataNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedDataNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedDataNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedDataName(s)
	}
}

func (s *QualifiedDataNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedDataName(s)
	}
}

func (s *QualifiedDataNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitQualifiedDataName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) QualifiedDataName() (localctx IQualifiedDataNameContext) {
	localctx = NewQualifiedDataNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1082, Cobol85ParserRULE_qualifiedDataName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6044)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 954, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6040)
			p.QualifiedDataNameFormat1()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6041)
			p.QualifiedDataNameFormat2()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6042)
			p.QualifiedDataNameFormat3()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6043)
			p.QualifiedDataNameFormat4()
		}

	}

	return localctx
}

// IQualifiedDataNameFormat1Context is an interface to support dynamic dispatch.
type IQualifiedDataNameFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedDataNameFormat1Context differentiates from other interfaces.
	IsQualifiedDataNameFormat1Context()
}

type QualifiedDataNameFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedDataNameFormat1Context() *QualifiedDataNameFormat1Context {
	var p = new(QualifiedDataNameFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat1
	return p
}

func (*QualifiedDataNameFormat1Context) IsQualifiedDataNameFormat1Context() {}

func NewQualifiedDataNameFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedDataNameFormat1Context {
	var p = new(QualifiedDataNameFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat1

	return p
}

func (s *QualifiedDataNameFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedDataNameFormat1Context) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *QualifiedDataNameFormat1Context) ConditionName() IConditionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionNameContext)
}

func (s *QualifiedDataNameFormat1Context) InFile() IInFileContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInFileContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInFileContext)
}

func (s *QualifiedDataNameFormat1Context) AllQualifiedInData() []IQualifiedInDataContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedInDataContext)(nil)).Elem())
	var tst = make([]IQualifiedInDataContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedInDataContext)
		}
	}

	return tst
}

func (s *QualifiedDataNameFormat1Context) QualifiedInData(i int) IQualifiedInDataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedInDataContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedInDataContext)
}

func (s *QualifiedDataNameFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedDataNameFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedDataNameFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedDataNameFormat1(s)
	}
}

func (s *QualifiedDataNameFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedDataNameFormat1(s)
	}
}

func (s *QualifiedDataNameFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitQualifiedDataNameFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) QualifiedDataNameFormat1() (localctx IQualifiedDataNameFormat1Context) {
	localctx = NewQualifiedDataNameFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1084, Cobol85ParserRULE_qualifiedDataNameFormat1)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6048)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 955, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6046)
			p.DataName()
		}

	case 2:
		{
			p.SetState(6047)
			p.ConditionName()
		}

	}
	p.SetState(6059)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 958, p.GetParserRuleContext()) == 1 {
		p.SetState(6051)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(6050)
					p.QualifiedInData()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(6053)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 956, p.GetParserRuleContext())
		}
		p.SetState(6056)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 957, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6055)
				p.InFile()
			}

		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 958, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(6058)
			p.InFile()
		}

	}

	return localctx
}

// IQualifiedDataNameFormat2Context is an interface to support dynamic dispatch.
type IQualifiedDataNameFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedDataNameFormat2Context differentiates from other interfaces.
	IsQualifiedDataNameFormat2Context()
}

type QualifiedDataNameFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedDataNameFormat2Context() *QualifiedDataNameFormat2Context {
	var p = new(QualifiedDataNameFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat2
	return p
}

func (*QualifiedDataNameFormat2Context) IsQualifiedDataNameFormat2Context() {}

func NewQualifiedDataNameFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedDataNameFormat2Context {
	var p = new(QualifiedDataNameFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat2

	return p
}

func (s *QualifiedDataNameFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedDataNameFormat2Context) ParagraphName() IParagraphNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphNameContext)
}

func (s *QualifiedDataNameFormat2Context) InSection() IInSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInSectionContext)
}

func (s *QualifiedDataNameFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedDataNameFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedDataNameFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedDataNameFormat2(s)
	}
}

func (s *QualifiedDataNameFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedDataNameFormat2(s)
	}
}

func (s *QualifiedDataNameFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitQualifiedDataNameFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) QualifiedDataNameFormat2() (localctx IQualifiedDataNameFormat2Context) {
	localctx = NewQualifiedDataNameFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1086, Cobol85ParserRULE_qualifiedDataNameFormat2)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6061)
		p.ParagraphName()
	}
	{
		p.SetState(6062)
		p.InSection()
	}

	return localctx
}

// IQualifiedDataNameFormat3Context is an interface to support dynamic dispatch.
type IQualifiedDataNameFormat3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedDataNameFormat3Context differentiates from other interfaces.
	IsQualifiedDataNameFormat3Context()
}

type QualifiedDataNameFormat3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedDataNameFormat3Context() *QualifiedDataNameFormat3Context {
	var p = new(QualifiedDataNameFormat3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat3
	return p
}

func (*QualifiedDataNameFormat3Context) IsQualifiedDataNameFormat3Context() {}

func NewQualifiedDataNameFormat3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedDataNameFormat3Context {
	var p = new(QualifiedDataNameFormat3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat3

	return p
}

func (s *QualifiedDataNameFormat3Context) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedDataNameFormat3Context) TextName() ITextNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITextNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITextNameContext)
}

func (s *QualifiedDataNameFormat3Context) InLibrary() IInLibraryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInLibraryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInLibraryContext)
}

func (s *QualifiedDataNameFormat3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedDataNameFormat3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedDataNameFormat3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedDataNameFormat3(s)
	}
}

func (s *QualifiedDataNameFormat3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedDataNameFormat3(s)
	}
}

func (s *QualifiedDataNameFormat3Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitQualifiedDataNameFormat3(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) QualifiedDataNameFormat3() (localctx IQualifiedDataNameFormat3Context) {
	localctx = NewQualifiedDataNameFormat3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1088, Cobol85ParserRULE_qualifiedDataNameFormat3)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6064)
		p.TextName()
	}
	{
		p.SetState(6065)
		p.InLibrary()
	}

	return localctx
}

// IQualifiedDataNameFormat4Context is an interface to support dynamic dispatch.
type IQualifiedDataNameFormat4Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedDataNameFormat4Context differentiates from other interfaces.
	IsQualifiedDataNameFormat4Context()
}

type QualifiedDataNameFormat4Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedDataNameFormat4Context() *QualifiedDataNameFormat4Context {
	var p = new(QualifiedDataNameFormat4Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat4
	return p
}

func (*QualifiedDataNameFormat4Context) IsQualifiedDataNameFormat4Context() {}

func NewQualifiedDataNameFormat4Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedDataNameFormat4Context {
	var p = new(QualifiedDataNameFormat4Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat4

	return p
}

func (s *QualifiedDataNameFormat4Context) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedDataNameFormat4Context) LINAGE_COUNTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINAGE_COUNTER, 0)
}

func (s *QualifiedDataNameFormat4Context) InFile() IInFileContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInFileContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInFileContext)
}

func (s *QualifiedDataNameFormat4Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedDataNameFormat4Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedDataNameFormat4Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedDataNameFormat4(s)
	}
}

func (s *QualifiedDataNameFormat4Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedDataNameFormat4(s)
	}
}

func (s *QualifiedDataNameFormat4Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitQualifiedDataNameFormat4(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) QualifiedDataNameFormat4() (localctx IQualifiedDataNameFormat4Context) {
	localctx = NewQualifiedDataNameFormat4Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1090, Cobol85ParserRULE_qualifiedDataNameFormat4)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6067)
		p.Match(Cobol85ParserLINAGE_COUNTER)
	}
	{
		p.SetState(6068)
		p.InFile()
	}

	return localctx
}

// IQualifiedInDataContext is an interface to support dynamic dispatch.
type IQualifiedInDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedInDataContext differentiates from other interfaces.
	IsQualifiedInDataContext()
}

type QualifiedInDataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedInDataContext() *QualifiedInDataContext {
	var p = new(QualifiedInDataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedInData
	return p
}

func (*QualifiedInDataContext) IsQualifiedInDataContext() {}

func NewQualifiedInDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedInDataContext {
	var p = new(QualifiedInDataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedInData

	return p
}

func (s *QualifiedInDataContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedInDataContext) InData() IInDataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInDataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInDataContext)
}

func (s *QualifiedInDataContext) InTable() IInTableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInTableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInTableContext)
}

func (s *QualifiedInDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedInDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedInDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedInData(s)
	}
}

func (s *QualifiedInDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedInData(s)
	}
}

func (s *QualifiedInDataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitQualifiedInData(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) QualifiedInData() (localctx IQualifiedInDataContext) {
	localctx = NewQualifiedInDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1092, Cobol85ParserRULE_qualifiedInData)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6072)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 959, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6070)
			p.InData()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6071)
			p.InTable()
		}

	}

	return localctx
}

// IInDataContext is an interface to support dynamic dispatch.
type IInDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInDataContext differentiates from other interfaces.
	IsInDataContext()
}

type InDataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInDataContext() *InDataContext {
	var p = new(InDataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inData
	return p
}

func (*InDataContext) IsInDataContext() {}

func NewInDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InDataContext {
	var p = new(InDataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inData

	return p
}

func (s *InDataContext) GetParser() antlr.Parser { return s.parser }

func (s *InDataContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *InDataContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InDataContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInData(s)
	}
}

func (s *InDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInData(s)
	}
}

func (s *InDataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInData(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InData() (localctx IInDataContext) {
	localctx = NewInDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1094, Cobol85ParserRULE_inData)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6074)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(6075)
		p.DataName()
	}

	return localctx
}

// IInFileContext is an interface to support dynamic dispatch.
type IInFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInFileContext differentiates from other interfaces.
	IsInFileContext()
}

type InFileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInFileContext() *InFileContext {
	var p = new(InFileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inFile
	return p
}

func (*InFileContext) IsInFileContext() {}

func NewInFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InFileContext {
	var p = new(InFileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inFile

	return p
}

func (s *InFileContext) GetParser() antlr.Parser { return s.parser }

func (s *InFileContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *InFileContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InFileContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InFileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInFile(s)
	}
}

func (s *InFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInFile(s)
	}
}

func (s *InFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInFile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InFile() (localctx IInFileContext) {
	localctx = NewInFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1096, Cobol85ParserRULE_inFile)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6077)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(6078)
		p.FileName()
	}

	return localctx
}

// IInMnemonicContext is an interface to support dynamic dispatch.
type IInMnemonicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInMnemonicContext differentiates from other interfaces.
	IsInMnemonicContext()
}

type InMnemonicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInMnemonicContext() *InMnemonicContext {
	var p = new(InMnemonicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inMnemonic
	return p
}

func (*InMnemonicContext) IsInMnemonicContext() {}

func NewInMnemonicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InMnemonicContext {
	var p = new(InMnemonicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inMnemonic

	return p
}

func (s *InMnemonicContext) GetParser() antlr.Parser { return s.parser }

func (s *InMnemonicContext) MnemonicName() IMnemonicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMnemonicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *InMnemonicContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InMnemonicContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InMnemonicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InMnemonicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InMnemonicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInMnemonic(s)
	}
}

func (s *InMnemonicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInMnemonic(s)
	}
}

func (s *InMnemonicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInMnemonic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InMnemonic() (localctx IInMnemonicContext) {
	localctx = NewInMnemonicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1098, Cobol85ParserRULE_inMnemonic)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6080)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(6081)
		p.MnemonicName()
	}

	return localctx
}

// IInSectionContext is an interface to support dynamic dispatch.
type IInSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInSectionContext differentiates from other interfaces.
	IsInSectionContext()
}

type InSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInSectionContext() *InSectionContext {
	var p = new(InSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inSection
	return p
}

func (*InSectionContext) IsInSectionContext() {}

func NewInSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InSectionContext {
	var p = new(InSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inSection

	return p
}

func (s *InSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *InSectionContext) SectionName() ISectionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISectionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISectionNameContext)
}

func (s *InSectionContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InSectionContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInSection(s)
	}
}

func (s *InSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInSection(s)
	}
}

func (s *InSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InSection() (localctx IInSectionContext) {
	localctx = NewInSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1100, Cobol85ParserRULE_inSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6083)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(6084)
		p.SectionName()
	}

	return localctx
}

// IInLibraryContext is an interface to support dynamic dispatch.
type IInLibraryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInLibraryContext differentiates from other interfaces.
	IsInLibraryContext()
}

type InLibraryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInLibraryContext() *InLibraryContext {
	var p = new(InLibraryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inLibrary
	return p
}

func (*InLibraryContext) IsInLibraryContext() {}

func NewInLibraryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InLibraryContext {
	var p = new(InLibraryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inLibrary

	return p
}

func (s *InLibraryContext) GetParser() antlr.Parser { return s.parser }

func (s *InLibraryContext) LibraryName() ILibraryNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryNameContext)
}

func (s *InLibraryContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InLibraryContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InLibraryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InLibraryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InLibraryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInLibrary(s)
	}
}

func (s *InLibraryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInLibrary(s)
	}
}

func (s *InLibraryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInLibrary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InLibrary() (localctx IInLibraryContext) {
	localctx = NewInLibraryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1102, Cobol85ParserRULE_inLibrary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6086)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(6087)
		p.LibraryName()
	}

	return localctx
}

// IInTableContext is an interface to support dynamic dispatch.
type IInTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInTableContext differentiates from other interfaces.
	IsInTableContext()
}

type InTableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInTableContext() *InTableContext {
	var p = new(InTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inTable
	return p
}

func (*InTableContext) IsInTableContext() {}

func NewInTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InTableContext {
	var p = new(InTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inTable

	return p
}

func (s *InTableContext) GetParser() antlr.Parser { return s.parser }

func (s *InTableContext) TableCall() ITableCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableCallContext)
}

func (s *InTableContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InTableContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInTable(s)
	}
}

func (s *InTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInTable(s)
	}
}

func (s *InTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InTable() (localctx IInTableContext) {
	localctx = NewInTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1104, Cobol85ParserRULE_inTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6089)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(6090)
		p.TableCall()
	}

	return localctx
}

// IAlphabetNameContext is an interface to support dynamic dispatch.
type IAlphabetNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetNameContext differentiates from other interfaces.
	IsAlphabetNameContext()
}

type AlphabetNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetNameContext() *AlphabetNameContext {
	var p = new(AlphabetNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetName
	return p
}

func (*AlphabetNameContext) IsAlphabetNameContext() {}

func NewAlphabetNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetNameContext {
	var p = new(AlphabetNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetName

	return p
}

func (s *AlphabetNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *AlphabetNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetName(s)
	}
}

func (s *AlphabetNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetName(s)
	}
}

func (s *AlphabetNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlphabetName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlphabetName() (localctx IAlphabetNameContext) {
	localctx = NewAlphabetNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1106, Cobol85ParserRULE_alphabetName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6092)
		p.CobolWord()
	}

	return localctx
}

// IAssignmentNameContext is an interface to support dynamic dispatch.
type IAssignmentNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentNameContext differentiates from other interfaces.
	IsAssignmentNameContext()
}

type AssignmentNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentNameContext() *AssignmentNameContext {
	var p = new(AssignmentNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_assignmentName
	return p
}

func (*AssignmentNameContext) IsAssignmentNameContext() {}

func NewAssignmentNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentNameContext {
	var p = new(AssignmentNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_assignmentName

	return p
}

func (s *AssignmentNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentNameContext) SystemName() ISystemNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystemNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystemNameContext)
}

func (s *AssignmentNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAssignmentName(s)
	}
}

func (s *AssignmentNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAssignmentName(s)
	}
}

func (s *AssignmentNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAssignmentName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AssignmentName() (localctx IAssignmentNameContext) {
	localctx = NewAssignmentNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1108, Cobol85ParserRULE_assignmentName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6094)
		p.SystemName()
	}

	return localctx
}

// IBasisNameContext is an interface to support dynamic dispatch.
type IBasisNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBasisNameContext differentiates from other interfaces.
	IsBasisNameContext()
}

type BasisNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBasisNameContext() *BasisNameContext {
	var p = new(BasisNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_basisName
	return p
}

func (*BasisNameContext) IsBasisNameContext() {}

func NewBasisNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BasisNameContext {
	var p = new(BasisNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_basisName

	return p
}

func (s *BasisNameContext) GetParser() antlr.Parser { return s.parser }

func (s *BasisNameContext) ProgramName() IProgramNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgramNameContext)
}

func (s *BasisNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasisNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BasisNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterBasisName(s)
	}
}

func (s *BasisNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitBasisName(s)
	}
}

func (s *BasisNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitBasisName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) BasisName() (localctx IBasisNameContext) {
	localctx = NewBasisNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1110, Cobol85ParserRULE_basisName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6096)
		p.ProgramName()
	}

	return localctx
}

// ICdNameContext is an interface to support dynamic dispatch.
type ICdNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCdNameContext differentiates from other interfaces.
	IsCdNameContext()
}

type CdNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCdNameContext() *CdNameContext {
	var p = new(CdNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cdName
	return p
}

func (*CdNameContext) IsCdNameContext() {}

func NewCdNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CdNameContext {
	var p = new(CdNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cdName

	return p
}

func (s *CdNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CdNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *CdNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CdNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CdNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCdName(s)
	}
}

func (s *CdNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCdName(s)
	}
}

func (s *CdNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCdName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CdName() (localctx ICdNameContext) {
	localctx = NewCdNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1112, Cobol85ParserRULE_cdName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6098)
		p.CobolWord()
	}

	return localctx
}

// IClassNameContext is an interface to support dynamic dispatch.
type IClassNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassNameContext differentiates from other interfaces.
	IsClassNameContext()
}

type ClassNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassNameContext() *ClassNameContext {
	var p = new(ClassNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_className
	return p
}

func (*ClassNameContext) IsClassNameContext() {}

func NewClassNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassNameContext {
	var p = new(ClassNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_className

	return p
}

func (s *ClassNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ClassNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassName(s)
	}
}

func (s *ClassNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassName(s)
	}
}

func (s *ClassNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClassName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClassName() (localctx IClassNameContext) {
	localctx = NewClassNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1114, Cobol85ParserRULE_className)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6100)
		p.CobolWord()
	}

	return localctx
}

// IComputerNameContext is an interface to support dynamic dispatch.
type IComputerNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComputerNameContext differentiates from other interfaces.
	IsComputerNameContext()
}

type ComputerNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComputerNameContext() *ComputerNameContext {
	var p = new(ComputerNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_computerName
	return p
}

func (*ComputerNameContext) IsComputerNameContext() {}

func NewComputerNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComputerNameContext {
	var p = new(ComputerNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_computerName

	return p
}

func (s *ComputerNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ComputerNameContext) SystemName() ISystemNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystemNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystemNameContext)
}

func (s *ComputerNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputerNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComputerNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterComputerName(s)
	}
}

func (s *ComputerNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitComputerName(s)
	}
}

func (s *ComputerNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitComputerName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ComputerName() (localctx IComputerNameContext) {
	localctx = NewComputerNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1116, Cobol85ParserRULE_computerName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6102)
		p.SystemName()
	}

	return localctx
}

// IConditionNameContext is an interface to support dynamic dispatch.
type IConditionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionNameContext differentiates from other interfaces.
	IsConditionNameContext()
}

type ConditionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionNameContext() *ConditionNameContext {
	var p = new(ConditionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_conditionName
	return p
}

func (*ConditionNameContext) IsConditionNameContext() {}

func NewConditionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionNameContext {
	var p = new(ConditionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_conditionName

	return p
}

func (s *ConditionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ConditionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterConditionName(s)
	}
}

func (s *ConditionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitConditionName(s)
	}
}

func (s *ConditionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitConditionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ConditionName() (localctx IConditionNameContext) {
	localctx = NewConditionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1118, Cobol85ParserRULE_conditionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6104)
		p.CobolWord()
	}

	return localctx
}

// IDataNameContext is an interface to support dynamic dispatch.
type IDataNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataNameContext differentiates from other interfaces.
	IsDataNameContext()
}

type DataNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataNameContext() *DataNameContext {
	var p = new(DataNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataName
	return p
}

func (*DataNameContext) IsDataNameContext() {}

func NewDataNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataNameContext {
	var p = new(DataNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataName

	return p
}

func (s *DataNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DataNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *DataNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataName(s)
	}
}

func (s *DataNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataName(s)
	}
}

func (s *DataNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataName() (localctx IDataNameContext) {
	localctx = NewDataNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1120, Cobol85ParserRULE_dataName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6106)
		p.CobolWord()
	}

	return localctx
}

// IDataDescNameContext is an interface to support dynamic dispatch.
type IDataDescNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescNameContext differentiates from other interfaces.
	IsDataDescNameContext()
}

type DataDescNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescNameContext() *DataDescNameContext {
	var p = new(DataDescNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescName
	return p
}

func (*DataDescNameContext) IsDataDescNameContext() {}

func NewDataDescNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescNameContext {
	var p = new(DataDescNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescName

	return p
}

func (s *DataDescNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescNameContext) FILLER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILLER, 0)
}

func (s *DataDescNameContext) CURSOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCURSOR, 0)
}

func (s *DataDescNameContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataDescNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescName(s)
	}
}

func (s *DataDescNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescName(s)
	}
}

func (s *DataDescNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataDescName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataDescName() (localctx IDataDescNameContext) {
	localctx = NewDataDescNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1122, Cobol85ParserRULE_dataDescName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6111)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 960, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6108)
			p.Match(Cobol85ParserFILLER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6109)
			p.Match(Cobol85ParserCURSOR)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6110)
			p.DataName()
		}

	}

	return localctx
}

// IEnvironmentNameContext is an interface to support dynamic dispatch.
type IEnvironmentNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnvironmentNameContext differentiates from other interfaces.
	IsEnvironmentNameContext()
}

type EnvironmentNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnvironmentNameContext() *EnvironmentNameContext {
	var p = new(EnvironmentNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_environmentName
	return p
}

func (*EnvironmentNameContext) IsEnvironmentNameContext() {}

func NewEnvironmentNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnvironmentNameContext {
	var p = new(EnvironmentNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_environmentName

	return p
}

func (s *EnvironmentNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EnvironmentNameContext) SystemName() ISystemNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystemNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystemNameContext)
}

func (s *EnvironmentNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnvironmentNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnvironmentNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnvironmentName(s)
	}
}

func (s *EnvironmentNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnvironmentName(s)
	}
}

func (s *EnvironmentNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEnvironmentName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EnvironmentName() (localctx IEnvironmentNameContext) {
	localctx = NewEnvironmentNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1124, Cobol85ParserRULE_environmentName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6113)
		p.SystemName()
	}

	return localctx
}

// IFileNameContext is an interface to support dynamic dispatch.
type IFileNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileNameContext differentiates from other interfaces.
	IsFileNameContext()
}

type FileNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileNameContext() *FileNameContext {
	var p = new(FileNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileName
	return p
}

func (*FileNameContext) IsFileNameContext() {}

func NewFileNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileNameContext {
	var p = new(FileNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileName

	return p
}

func (s *FileNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FileNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *FileNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileName(s)
	}
}

func (s *FileNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileName(s)
	}
}

func (s *FileNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFileName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FileName() (localctx IFileNameContext) {
	localctx = NewFileNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1126, Cobol85ParserRULE_fileName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6115)
		p.CobolWord()
	}

	return localctx
}

// IFunctionNameContext is an interface to support dynamic dispatch.
type IFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionNameContext differentiates from other interfaces.
	IsFunctionNameContext()
}

type FunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameContext() *FunctionNameContext {
	var p = new(FunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_functionName
	return p
}

func (*FunctionNameContext) IsFunctionNameContext() {}

func NewFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameContext {
	var p = new(FunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_functionName

	return p
}

func (s *FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGER, 0)
}

func (s *FunctionNameContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH, 0)
}

func (s *FunctionNameContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRANDOM, 0)
}

func (s *FunctionNameContext) SUM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUM, 0)
}

func (s *FunctionNameContext) WHEN_COMPILED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN_COMPILED, 0)
}

func (s *FunctionNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFunctionName(s)
	}
}

func (s *FunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFunctionName(s)
	}
}

func (s *FunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FunctionName() (localctx IFunctionNameContext) {
	localctx = NewFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1128, Cobol85ParserRULE_functionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6123)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 961, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6117)
			p.Match(Cobol85ParserINTEGER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6118)
			p.Match(Cobol85ParserLENGTH)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6119)
			p.Match(Cobol85ParserRANDOM)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6120)
			p.Match(Cobol85ParserSUM)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6121)
			p.Match(Cobol85ParserWHEN_COMPILED)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6122)
			p.CobolWord()
		}

	}

	return localctx
}

// IIndexNameContext is an interface to support dynamic dispatch.
type IIndexNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexNameContext differentiates from other interfaces.
	IsIndexNameContext()
}

type IndexNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexNameContext() *IndexNameContext {
	var p = new(IndexNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_indexName
	return p
}

func (*IndexNameContext) IsIndexNameContext() {}

func NewIndexNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexNameContext {
	var p = new(IndexNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_indexName

	return p
}

func (s *IndexNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *IndexNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIndexName(s)
	}
}

func (s *IndexNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIndexName(s)
	}
}

func (s *IndexNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIndexName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IndexName() (localctx IIndexNameContext) {
	localctx = NewIndexNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1130, Cobol85ParserRULE_indexName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6125)
		p.CobolWord()
	}

	return localctx
}

// ILanguageNameContext is an interface to support dynamic dispatch.
type ILanguageNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLanguageNameContext differentiates from other interfaces.
	IsLanguageNameContext()
}

type LanguageNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLanguageNameContext() *LanguageNameContext {
	var p = new(LanguageNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_languageName
	return p
}

func (*LanguageNameContext) IsLanguageNameContext() {}

func NewLanguageNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LanguageNameContext {
	var p = new(LanguageNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_languageName

	return p
}

func (s *LanguageNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LanguageNameContext) SystemName() ISystemNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystemNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystemNameContext)
}

func (s *LanguageNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LanguageNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LanguageNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLanguageName(s)
	}
}

func (s *LanguageNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLanguageName(s)
	}
}

func (s *LanguageNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLanguageName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LanguageName() (localctx ILanguageNameContext) {
	localctx = NewLanguageNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1132, Cobol85ParserRULE_languageName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6127)
		p.SystemName()
	}

	return localctx
}

// ILibraryNameContext is an interface to support dynamic dispatch.
type ILibraryNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryNameContext differentiates from other interfaces.
	IsLibraryNameContext()
}

type LibraryNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryNameContext() *LibraryNameContext {
	var p = new(LibraryNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryName
	return p
}

func (*LibraryNameContext) IsLibraryNameContext() {}

func NewLibraryNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryNameContext {
	var p = new(LibraryNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryName

	return p
}

func (s *LibraryNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *LibraryNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryName(s)
	}
}

func (s *LibraryNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryName(s)
	}
}

func (s *LibraryNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryName() (localctx ILibraryNameContext) {
	localctx = NewLibraryNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1134, Cobol85ParserRULE_libraryName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6129)
		p.CobolWord()
	}

	return localctx
}

// ILocalNameContext is an interface to support dynamic dispatch.
type ILocalNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalNameContext differentiates from other interfaces.
	IsLocalNameContext()
}

type LocalNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalNameContext() *LocalNameContext {
	var p = new(LocalNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_localName
	return p
}

func (*LocalNameContext) IsLocalNameContext() {}

func NewLocalNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalNameContext {
	var p = new(LocalNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_localName

	return p
}

func (s *LocalNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *LocalNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLocalName(s)
	}
}

func (s *LocalNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLocalName(s)
	}
}

func (s *LocalNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLocalName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LocalName() (localctx ILocalNameContext) {
	localctx = NewLocalNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1136, Cobol85ParserRULE_localName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6131)
		p.CobolWord()
	}

	return localctx
}

// IMnemonicNameContext is an interface to support dynamic dispatch.
type IMnemonicNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMnemonicNameContext differentiates from other interfaces.
	IsMnemonicNameContext()
}

type MnemonicNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMnemonicNameContext() *MnemonicNameContext {
	var p = new(MnemonicNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mnemonicName
	return p
}

func (*MnemonicNameContext) IsMnemonicNameContext() {}

func NewMnemonicNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MnemonicNameContext {
	var p = new(MnemonicNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mnemonicName

	return p
}

func (s *MnemonicNameContext) GetParser() antlr.Parser { return s.parser }

func (s *MnemonicNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *MnemonicNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MnemonicNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MnemonicNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMnemonicName(s)
	}
}

func (s *MnemonicNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMnemonicName(s)
	}
}

func (s *MnemonicNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMnemonicName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MnemonicName() (localctx IMnemonicNameContext) {
	localctx = NewMnemonicNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1138, Cobol85ParserRULE_mnemonicName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6133)
		p.CobolWord()
	}

	return localctx
}

// IParagraphNameContext is an interface to support dynamic dispatch.
type IParagraphNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParagraphNameContext differentiates from other interfaces.
	IsParagraphNameContext()
}

type ParagraphNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraphNameContext() *ParagraphNameContext {
	var p = new(ParagraphNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_paragraphName
	return p
}

func (*ParagraphNameContext) IsParagraphNameContext() {}

func NewParagraphNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParagraphNameContext {
	var p = new(ParagraphNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_paragraphName

	return p
}

func (s *ParagraphNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ParagraphNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ParagraphNameContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ParagraphNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParagraphNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParagraphNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterParagraphName(s)
	}
}

func (s *ParagraphNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitParagraphName(s)
	}
}

func (s *ParagraphNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitParagraphName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ParagraphName() (localctx IParagraphNameContext) {
	localctx = NewParagraphNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1140, Cobol85ParserRULE_paragraphName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6137)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6135)
			p.CobolWord()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6136)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProcedureNameContext is an interface to support dynamic dispatch.
type IProcedureNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureNameContext differentiates from other interfaces.
	IsProcedureNameContext()
}

type ProcedureNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureNameContext() *ProcedureNameContext {
	var p = new(ProcedureNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureName
	return p
}

func (*ProcedureNameContext) IsProcedureNameContext() {}

func NewProcedureNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureNameContext {
	var p = new(ProcedureNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureName

	return p
}

func (s *ProcedureNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureNameContext) ParagraphName() IParagraphNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphNameContext)
}

func (s *ProcedureNameContext) InSection() IInSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInSectionContext)
}

func (s *ProcedureNameContext) SectionName() ISectionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISectionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISectionNameContext)
}

func (s *ProcedureNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureName(s)
	}
}

func (s *ProcedureNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureName(s)
	}
}

func (s *ProcedureNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureName() (localctx IProcedureNameContext) {
	localctx = NewProcedureNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1142, Cobol85ParserRULE_procedureName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6144)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 964, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6139)
			p.ParagraphName()
		}
		p.SetState(6141)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIN || _la == Cobol85ParserOF {
			{
				p.SetState(6140)
				p.InSection()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6143)
			p.SectionName()
		}

	}

	return localctx
}

// IProgramNameContext is an interface to support dynamic dispatch.
type IProgramNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramNameContext differentiates from other interfaces.
	IsProgramNameContext()
}

type ProgramNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramNameContext() *ProgramNameContext {
	var p = new(ProgramNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_programName
	return p
}

func (*ProgramNameContext) IsProgramNameContext() {}

func NewProgramNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramNameContext {
	var p = new(ProgramNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_programName

	return p
}

func (s *ProgramNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramNameContext) NONNUMERICLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNONNUMERICLITERAL, 0)
}

func (s *ProgramNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ProgramNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProgramName(s)
	}
}

func (s *ProgramNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProgramName(s)
	}
}

func (s *ProgramNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProgramName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProgramName() (localctx IProgramNameContext) {
	localctx = NewProgramNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1144, Cobol85ParserRULE_programName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6148)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNONNUMERICLITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6146)
			p.Match(Cobol85ParserNONNUMERICLITERAL)
		}

	case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6147)
			p.CobolWord()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRecordNameContext is an interface to support dynamic dispatch.
type IRecordNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordNameContext differentiates from other interfaces.
	IsRecordNameContext()
}

type RecordNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordNameContext() *RecordNameContext {
	var p = new(RecordNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordName
	return p
}

func (*RecordNameContext) IsRecordNameContext() {}

func NewRecordNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordNameContext {
	var p = new(RecordNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordName

	return p
}

func (s *RecordNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordNameContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *RecordNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordName(s)
	}
}

func (s *RecordNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordName(s)
	}
}

func (s *RecordNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordName() (localctx IRecordNameContext) {
	localctx = NewRecordNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1146, Cobol85ParserRULE_recordName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6150)
		p.QualifiedDataName()
	}

	return localctx
}

// IReportNameContext is an interface to support dynamic dispatch.
type IReportNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportNameContext differentiates from other interfaces.
	IsReportNameContext()
}

type ReportNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportNameContext() *ReportNameContext {
	var p = new(ReportNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportName
	return p
}

func (*ReportNameContext) IsReportNameContext() {}

func NewReportNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportNameContext {
	var p = new(ReportNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportName

	return p
}

func (s *ReportNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportNameContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ReportNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportName(s)
	}
}

func (s *ReportNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportName(s)
	}
}

func (s *ReportNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportName() (localctx IReportNameContext) {
	localctx = NewReportNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1148, Cobol85ParserRULE_reportName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6152)
		p.QualifiedDataName()
	}

	return localctx
}

// IRoutineNameContext is an interface to support dynamic dispatch.
type IRoutineNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutineNameContext differentiates from other interfaces.
	IsRoutineNameContext()
}

type RoutineNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineNameContext() *RoutineNameContext {
	var p = new(RoutineNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_routineName
	return p
}

func (*RoutineNameContext) IsRoutineNameContext() {}

func NewRoutineNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineNameContext {
	var p = new(RoutineNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_routineName

	return p
}

func (s *RoutineNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *RoutineNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRoutineName(s)
	}
}

func (s *RoutineNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRoutineName(s)
	}
}

func (s *RoutineNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRoutineName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RoutineName() (localctx IRoutineNameContext) {
	localctx = NewRoutineNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1150, Cobol85ParserRULE_routineName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6154)
		p.CobolWord()
	}

	return localctx
}

// IScreenNameContext is an interface to support dynamic dispatch.
type IScreenNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenNameContext differentiates from other interfaces.
	IsScreenNameContext()
}

type ScreenNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenNameContext() *ScreenNameContext {
	var p = new(ScreenNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenName
	return p
}

func (*ScreenNameContext) IsScreenNameContext() {}

func NewScreenNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenNameContext {
	var p = new(ScreenNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenName

	return p
}

func (s *ScreenNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ScreenNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenName(s)
	}
}

func (s *ScreenNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenName(s)
	}
}

func (s *ScreenNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenName() (localctx IScreenNameContext) {
	localctx = NewScreenNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1152, Cobol85ParserRULE_screenName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6156)
		p.CobolWord()
	}

	return localctx
}

// ISectionNameContext is an interface to support dynamic dispatch.
type ISectionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSectionNameContext differentiates from other interfaces.
	IsSectionNameContext()
}

type SectionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySectionNameContext() *SectionNameContext {
	var p = new(SectionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sectionName
	return p
}

func (*SectionNameContext) IsSectionNameContext() {}

func NewSectionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SectionNameContext {
	var p = new(SectionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sectionName

	return p
}

func (s *SectionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SectionNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *SectionNameContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *SectionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SectionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SectionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSectionName(s)
	}
}

func (s *SectionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSectionName(s)
	}
}

func (s *SectionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSectionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SectionName() (localctx ISectionNameContext) {
	localctx = NewSectionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1154, Cobol85ParserRULE_sectionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6160)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAPOST, Cobol85ParserARITH, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCODEPAGE, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIB, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNOSEQ, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIMIZE, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSP, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserXOPTS, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6158)
			p.CobolWord()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6159)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISystemNameContext is an interface to support dynamic dispatch.
type ISystemNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystemNameContext differentiates from other interfaces.
	IsSystemNameContext()
}

type SystemNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystemNameContext() *SystemNameContext {
	var p = new(SystemNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_systemName
	return p
}

func (*SystemNameContext) IsSystemNameContext() {}

func NewSystemNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SystemNameContext {
	var p = new(SystemNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_systemName

	return p
}

func (s *SystemNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SystemNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *SystemNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SystemNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSystemName(s)
	}
}

func (s *SystemNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSystemName(s)
	}
}

func (s *SystemNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSystemName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SystemName() (localctx ISystemNameContext) {
	localctx = NewSystemNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1156, Cobol85ParserRULE_systemName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6162)
		p.CobolWord()
	}

	return localctx
}

// ISymbolicCharacterContext is an interface to support dynamic dispatch.
type ISymbolicCharacterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicCharacterContext differentiates from other interfaces.
	IsSymbolicCharacterContext()
}

type SymbolicCharacterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicCharacterContext() *SymbolicCharacterContext {
	var p = new(SymbolicCharacterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicCharacter
	return p
}

func (*SymbolicCharacterContext) IsSymbolicCharacterContext() {}

func NewSymbolicCharacterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicCharacterContext {
	var p = new(SymbolicCharacterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicCharacter

	return p
}

func (s *SymbolicCharacterContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicCharacterContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *SymbolicCharacterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicCharacterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicCharacterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicCharacter(s)
	}
}

func (s *SymbolicCharacterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicCharacter(s)
	}
}

func (s *SymbolicCharacterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSymbolicCharacter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SymbolicCharacter() (localctx ISymbolicCharacterContext) {
	localctx = NewSymbolicCharacterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1158, Cobol85ParserRULE_symbolicCharacter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6164)
		p.CobolWord()
	}

	return localctx
}

// ITextNameContext is an interface to support dynamic dispatch.
type ITextNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTextNameContext differentiates from other interfaces.
	IsTextNameContext()
}

type TextNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextNameContext() *TextNameContext {
	var p = new(TextNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_textName
	return p
}

func (*TextNameContext) IsTextNameContext() {}

func NewTextNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextNameContext {
	var p = new(TextNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_textName

	return p
}

func (s *TextNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TextNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *TextNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterTextName(s)
	}
}

func (s *TextNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitTextName(s)
	}
}

func (s *TextNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitTextName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) TextName() (localctx ITextNameContext) {
	localctx = NewTextNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1160, Cobol85ParserRULE_textName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6166)
		p.CobolWord()
	}

	return localctx
}

// ICobolWordContext is an interface to support dynamic dispatch.
type ICobolWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCobolWordContext differentiates from other interfaces.
	IsCobolWordContext()
}

type CobolWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCobolWordContext() *CobolWordContext {
	var p = new(CobolWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cobolWord
	return p
}

func (*CobolWordContext) IsCobolWordContext() {}

func NewCobolWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CobolWordContext {
	var p = new(CobolWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cobolWord

	return p
}

func (s *CobolWordContext) GetParser() antlr.Parser { return s.parser }

func (s *CobolWordContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIDENTIFIER, 0)
}

func (s *CobolWordContext) COBOL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOBOL, 0)
}

func (s *CobolWordContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM, 0)
}

func (s *CobolWordContext) ABORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserABORT, 0)
}

func (s *CobolWordContext) APOST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAPOST, 0)
}

func (s *CobolWordContext) ARITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARITH, 0)
}

func (s *CobolWordContext) AS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAS, 0)
}

func (s *CobolWordContext) ASCII() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASCII, 0)
}

func (s *CobolWordContext) ASSOCIATED_DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASSOCIATED_DATA, 0)
}

func (s *CobolWordContext) ASSOCIATED_DATA_LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASSOCIATED_DATA_LENGTH, 0)
}

func (s *CobolWordContext) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserATTRIBUTE, 0)
}

func (s *CobolWordContext) AUTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAUTO, 0)
}

func (s *CobolWordContext) AUTO_SKIP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAUTO_SKIP, 0)
}

func (s *CobolWordContext) BACKGROUND_COLOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBACKGROUND_COLOR, 0)
}

func (s *CobolWordContext) BACKGROUND_COLOUR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBACKGROUND_COLOUR, 0)
}

func (s *CobolWordContext) BEEP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEEP, 0)
}

func (s *CobolWordContext) BELL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBELL, 0)
}

func (s *CobolWordContext) BIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBIT, 0)
}

func (s *CobolWordContext) BLINK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLINK, 0)
}

func (s *CobolWordContext) BOUNDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBOUNDS, 0)
}

func (s *CobolWordContext) CAPABLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCAPABLE, 0)
}

func (s *CobolWordContext) CCSVERSION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCCSVERSION, 0)
}

func (s *CobolWordContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHANGED, 0)
}

func (s *CobolWordContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHANNEL, 0)
}

func (s *CobolWordContext) CLOSE_DISPOSITION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCLOSE_DISPOSITION, 0)
}

func (s *CobolWordContext) CODEPAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCODEPAGE, 0)
}

func (s *CobolWordContext) COMMITMENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMITMENT, 0)
}

func (s *CobolWordContext) CONTROL_POINT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL_POINT, 0)
}

func (s *CobolWordContext) CONVENTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONVENTION, 0)
}

func (s *CobolWordContext) CRUNCH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCRUNCH, 0)
}

func (s *CobolWordContext) CURSOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCURSOR, 0)
}

func (s *CobolWordContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFAULT, 0)
}

func (s *CobolWordContext) DEFAULT_DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFAULT_DISPLAY, 0)
}

func (s *CobolWordContext) DEFINITION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFINITION, 0)
}

func (s *CobolWordContext) DFHRESP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDFHRESP, 0)
}

func (s *CobolWordContext) DFHVALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDFHVALUE, 0)
}

func (s *CobolWordContext) DISK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISK, 0)
}

func (s *CobolWordContext) DONTCARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDONTCARE, 0)
}

func (s *CobolWordContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOUBLE, 0)
}

func (s *CobolWordContext) EBCDIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEBCDIC, 0)
}

func (s *CobolWordContext) EMPTY_CHECK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEMPTY_CHECK, 0)
}

func (s *CobolWordContext) ENTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENTER, 0)
}

func (s *CobolWordContext) ENTRY_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENTRY_PROCEDURE, 0)
}

func (s *CobolWordContext) EOL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOL, 0)
}

func (s *CobolWordContext) EOS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOS, 0)
}

func (s *CobolWordContext) ERASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERASE, 0)
}

func (s *CobolWordContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserESCAPE, 0)
}

func (s *CobolWordContext) EVENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEVENT, 0)
}

func (s *CobolWordContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXCLUSIVE, 0)
}

func (s *CobolWordContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXPORT, 0)
}

func (s *CobolWordContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTENDED, 0)
}

func (s *CobolWordContext) FOREGROUND_COLOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOREGROUND_COLOR, 0)
}

func (s *CobolWordContext) FOREGROUND_COLOUR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOREGROUND_COLOUR, 0)
}

func (s *CobolWordContext) FULL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFULL, 0)
}

func (s *CobolWordContext) FUNCTIONNAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFUNCTIONNAME, 0)
}

func (s *CobolWordContext) FUNCTION_POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFUNCTION_POINTER, 0)
}

func (s *CobolWordContext) GRID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGRID, 0)
}

func (s *CobolWordContext) HIGHLIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHIGHLIGHT, 0)
}

func (s *CobolWordContext) IMPLICIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIMPLICIT, 0)
}

func (s *CobolWordContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIMPORT, 0)
}

func (s *CobolWordContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGER, 0)
}

func (s *CobolWordContext) KEPT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEPT, 0)
}

func (s *CobolWordContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLANGUAGE, 0)
}

func (s *CobolWordContext) LB() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLB, 0)
}

func (s *CobolWordContext) LD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLD, 0)
}

func (s *CobolWordContext) LEFTLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEFTLINE, 0)
}

func (s *CobolWordContext) LENGTH_CHECK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH_CHECK, 0)
}

func (s *CobolWordContext) LIB() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIB, 0)
}

func (s *CobolWordContext) LIBACCESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBACCESS, 0)
}

func (s *CobolWordContext) LIBPARAMETER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBPARAMETER, 0)
}

func (s *CobolWordContext) LIBRARY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBRARY, 0)
}

func (s *CobolWordContext) LIST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIST, 0)
}

func (s *CobolWordContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCAL, 0)
}

func (s *CobolWordContext) LONG_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLONG_DATE, 0)
}

func (s *CobolWordContext) LONG_TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLONG_TIME, 0)
}

func (s *CobolWordContext) LOWER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOWER, 0)
}

func (s *CobolWordContext) LOWLIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOWLIGHT, 0)
}

func (s *CobolWordContext) MMDDYYYY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMMDDYYYY, 0)
}

func (s *CobolWordContext) NAMED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNAMED, 0)
}

func (s *CobolWordContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *CobolWordContext) NETWORK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNETWORK, 0)
}

func (s *CobolWordContext) NO_ECHO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO_ECHO, 0)
}

func (s *CobolWordContext) NOSEQ() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOSEQ, 0)
}

func (s *CobolWordContext) NUMERIC_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC_DATE, 0)
}

func (s *CobolWordContext) NUMERIC_TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC_TIME, 0)
}

func (s *CobolWordContext) ODT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserODT, 0)
}

func (s *CobolWordContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOPTIMIZE, 0)
}

func (s *CobolWordContext) ORDERLY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserORDERLY, 0)
}

func (s *CobolWordContext) OVERLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOVERLINE, 0)
}

func (s *CobolWordContext) OWN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOWN, 0)
}

func (s *CobolWordContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPASSWORD, 0)
}

func (s *CobolWordContext) PORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPORT, 0)
}

func (s *CobolWordContext) PRINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPRINTER, 0)
}

func (s *CobolWordContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPRIVATE, 0)
}

func (s *CobolWordContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCESS, 0)
}

func (s *CobolWordContext) PROMPT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROMPT, 0)
}

func (s *CobolWordContext) READER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREADER, 0)
}

func (s *CobolWordContext) REAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREAL, 0)
}

func (s *CobolWordContext) RECEIVED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECEIVED, 0)
}

func (s *CobolWordContext) REF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREF, 0)
}

func (s *CobolWordContext) REMOTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOTE, 0)
}

func (s *CobolWordContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOVE, 0)
}

func (s *CobolWordContext) REQUIRED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREQUIRED, 0)
}

func (s *CobolWordContext) REVERSE_VIDEO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREVERSE_VIDEO, 0)
}

func (s *CobolWordContext) SAVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSAVE, 0)
}

func (s *CobolWordContext) SECURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECURE, 0)
}

func (s *CobolWordContext) SHARED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHARED, 0)
}

func (s *CobolWordContext) SHAREDBYALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHAREDBYALL, 0)
}

func (s *CobolWordContext) SHAREDBYRUNUNIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHAREDBYRUNUNIT, 0)
}

func (s *CobolWordContext) SHARING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHARING, 0)
}

func (s *CobolWordContext) SHORT_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHORT_DATE, 0)
}

func (s *CobolWordContext) SP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSP, 0)
}

func (s *CobolWordContext) SYMBOL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOL, 0)
}

func (s *CobolWordContext) TASK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTASK, 0)
}

func (s *CobolWordContext) THREAD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHREAD, 0)
}

func (s *CobolWordContext) THREAD_LOCAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHREAD_LOCAL, 0)
}

func (s *CobolWordContext) TIMER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMER, 0)
}

func (s *CobolWordContext) TODAYS_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTODAYS_DATE, 0)
}

func (s *CobolWordContext) TODAYS_NAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTODAYS_NAME, 0)
}

func (s *CobolWordContext) TRUNCATED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRUNCATED, 0)
}

func (s *CobolWordContext) TYPEDEF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTYPEDEF, 0)
}

func (s *CobolWordContext) UNDERLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNDERLINE, 0)
}

func (s *CobolWordContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVIRTUAL, 0)
}

func (s *CobolWordContext) WAIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWAIT, 0)
}

func (s *CobolWordContext) XOPTS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserXOPTS, 0)
}

func (s *CobolWordContext) YEAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYEAR, 0)
}

func (s *CobolWordContext) YYYYMMDD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYYYYMMDD, 0)
}

func (s *CobolWordContext) YYYYDDD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYYYYDDD, 0)
}

func (s *CobolWordContext) ZERO_FILL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO_FILL, 0)
}

func (s *CobolWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CobolWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CobolWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCobolWord(s)
	}
}

func (s *CobolWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCobolWord(s)
	}
}

func (s *CobolWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCobolWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CobolWord() (localctx ICobolWordContext) {
	localctx = NewCobolWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1162, Cobol85ParserRULE_cobolWord)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6168)
	_la = p.GetTokenStream().LA(1)

	if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAPOST)|(1<<Cobol85ParserARITH)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserATTRIBUTE-33))|(1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-70))|(1<<(Cobol85ParserCOBOL-70))|(1<<(Cobol85ParserCODEPAGE-70))|(1<<(Cobol85ParserCOMMITMENT-70))|(1<<(Cobol85ParserCONTROL_POINT-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(Cobol85ParserCONVENTION-103))|(1<<(Cobol85ParserCRUNCH-103))|(1<<(Cobol85ParserCURSOR-103))|(1<<(Cobol85ParserDEFAULT-103))|(1<<(Cobol85ParserDEFAULT_DISPLAY-103))|(1<<(Cobol85ParserDEFINITION-103)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(Cobol85ParserDFHRESP-141))|(1<<(Cobol85ParserDFHVALUE-141))|(1<<(Cobol85ParserDISK-141))|(1<<(Cobol85ParserDONTCARE-141))|(1<<(Cobol85ParserDOUBLE-141))|(1<<(Cobol85ParserEBCDIC-141))|(1<<(Cobol85ParserEMPTY_CHECK-141)))) != 0) || (((_la-184)&-(0x1f+1)) == 0 && ((1<<uint((_la-184)))&((1<<(Cobol85ParserENTER-184))|(1<<(Cobol85ParserENTRY_PROCEDURE-184))|(1<<(Cobol85ParserERASE-184))|(1<<(Cobol85ParserEOL-184))|(1<<(Cobol85ParserEOS-184))|(1<<(Cobol85ParserESCAPE-184))|(1<<(Cobol85ParserEVENT-184))|(1<<(Cobol85ParserEXCLUSIVE-184))|(1<<(Cobol85ParserEXPORT-184))|(1<<(Cobol85ParserEXTENDED-184)))) != 0) || (((_la-216)&-(0x1f+1)) == 0 && ((1<<uint((_la-216)))&((1<<(Cobol85ParserFOREGROUND_COLOR-216))|(1<<(Cobol85ParserFOREGROUND_COLOUR-216))|(1<<(Cobol85ParserFULL-216))|(1<<(Cobol85ParserFUNCTIONNAME-216))|(1<<(Cobol85ParserFUNCTION_POINTER-216))|(1<<(Cobol85ParserGRID-216))|(1<<(Cobol85ParserHIGHLIGHT-216))|(1<<(Cobol85ParserIMPLICIT-216))|(1<<(Cobol85ParserIMPORT-216)))) != 0) || (((_la-253)&-(0x1f+1)) == 0 && ((1<<uint((_la-253)))&((1<<(Cobol85ParserINTEGER-253))|(1<<(Cobol85ParserKEPT-253))|(1<<(Cobol85ParserLANGUAGE-253))|(1<<(Cobol85ParserLB-253))|(1<<(Cobol85ParserLD-253))|(1<<(Cobol85ParserLEFTLINE-253))|(1<<(Cobol85ParserLENGTH_CHECK-253))|(1<<(Cobol85ParserLIB-253))|(1<<(Cobol85ParserLIBACCESS-253))|(1<<(Cobol85ParserLIBPARAMETER-253))|(1<<(Cobol85ParserLIBRARY-253)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(Cobol85ParserLIST-286))|(1<<(Cobol85ParserLOCAL-286))|(1<<(Cobol85ParserLONG_DATE-286))|(1<<(Cobol85ParserLONG_TIME-286))|(1<<(Cobol85ParserLOWER-286))|(1<<(Cobol85ParserLOWLIGHT-286))|(1<<(Cobol85ParserMMDDYYYY-286))|(1<<(Cobol85ParserNAMED-286))|(1<<(Cobol85ParserNATIONAL-286))|(1<<(Cobol85ParserNETWORK-286))|(1<<(Cobol85ParserNO_ECHO-286))|(1<<(Cobol85ParserNOSEQ-286)))) != 0) || (((_la-321)&-(0x1f+1)) == 0 && ((1<<uint((_la-321)))&((1<<(Cobol85ParserNUMERIC_DATE-321))|(1<<(Cobol85ParserNUMERIC_TIME-321))|(1<<(Cobol85ParserODT-321))|(1<<(Cobol85ParserOPTIMIZE-321))|(1<<(Cobol85ParserORDERLY-321))|(1<<(Cobol85ParserOVERLINE-321))|(1<<(Cobol85ParserOWN-321))|(1<<(Cobol85ParserPASSWORD-321)))) != 0) || (((_la-357)&-(0x1f+1)) == 0 && ((1<<uint((_la-357)))&((1<<(Cobol85ParserPORT-357))|(1<<(Cobol85ParserPRINTER-357))|(1<<(Cobol85ParserPRIVATE-357))|(1<<(Cobol85ParserPROCESS-357))|(1<<(Cobol85ParserPROGRAM-357))|(1<<(Cobol85ParserPROMPT-357))|(1<<(Cobol85ParserREADER-357))|(1<<(Cobol85ParserREMOTE-357))|(1<<(Cobol85ParserREAL-357))|(1<<(Cobol85ParserRECEIVED-357))|(1<<(Cobol85ParserREF-357)))) != 0) || (((_la-395)&-(0x1f+1)) == 0 && ((1<<uint((_la-395)))&((1<<(Cobol85ParserREMOVE-395))|(1<<(Cobol85ParserREQUIRED-395))|(1<<(Cobol85ParserREVERSE_VIDEO-395))|(1<<(Cobol85ParserSAVE-395))|(1<<(Cobol85ParserSECURE-395)))) != 0) || (((_la-434)&-(0x1f+1)) == 0 && ((1<<uint((_la-434)))&((1<<(Cobol85ParserSHARED-434))|(1<<(Cobol85ParserSHAREDBYALL-434))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-434))|(1<<(Cobol85ParserSHARING-434))|(1<<(Cobol85ParserSHORT_DATE-434))|(1<<(Cobol85ParserSP-434)))) != 0) || (((_la-470)&-(0x1f+1)) == 0 && ((1<<uint((_la-470)))&((1<<(Cobol85ParserSYMBOL-470))|(1<<(Cobol85ParserTASK-470))|(1<<(Cobol85ParserTHREAD-470))|(1<<(Cobol85ParserTHREAD_LOCAL-470))|(1<<(Cobol85ParserTIMER-470))|(1<<(Cobol85ParserTODAYS_DATE-470))|(1<<(Cobol85ParserTODAYS_NAME-470))|(1<<(Cobol85ParserTRUNCATED-470))|(1<<(Cobol85ParserTYPEDEF-470)))) != 0) || (((_la-502)&-(0x1f+1)) == 0 && ((1<<uint((_la-502)))&((1<<(Cobol85ParserUNDERLINE-502))|(1<<(Cobol85ParserVIRTUAL-502))|(1<<(Cobol85ParserWAIT-502))|(1<<(Cobol85ParserXOPTS-502))|(1<<(Cobol85ParserYEAR-502))|(1<<(Cobol85ParserYYYYMMDD-502))|(1<<(Cobol85ParserYYYYDDD-502))|(1<<(Cobol85ParserZERO_FILL-502)))) != 0) || _la == Cobol85ParserIDENTIFIER) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NONNUMERICLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNONNUMERICLITERAL, 0)
}

func (s *LiteralContext) FigurativeConstant() IFigurativeConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFigurativeConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFigurativeConstantContext)
}

func (s *LiteralContext) NumericLiteral() INumericLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *LiteralContext) BooleanLiteral() IBooleanLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *LiteralContext) CicsDfhRespLiteral() ICicsDfhRespLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICicsDfhRespLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICicsDfhRespLiteralContext)
}

func (s *LiteralContext) CicsDfhValueLiteral() ICicsDfhValueLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICicsDfhValueLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICicsDfhValueLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1164, Cobol85ParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6176)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 967, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6170)
			p.Match(Cobol85ParserNONNUMERICLITERAL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6171)
			p.FigurativeConstant()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6172)
			p.NumericLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6173)
			p.BooleanLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6174)
			p.CicsDfhRespLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6175)
			p.CicsDfhValueLiteral()
		}

	}

	return localctx
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_booleanLiteral
	return p
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1166, Cobol85ParserRULE_booleanLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6178)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Cobol85ParserFALSE || _la == Cobol85ParserTRUE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// INumericLiteralContext is an interface to support dynamic dispatch.
type INumericLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericLiteralContext differentiates from other interfaces.
	IsNumericLiteralContext()
}

type NumericLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericLiteralContext() *NumericLiteralContext {
	var p = new(NumericLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_numericLiteral
	return p
}

func (*NumericLiteralContext) IsNumericLiteralContext() {}

func NewNumericLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_numericLiteral

	return p
}

func (s *NumericLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericLiteralContext) NUMERICLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERICLITERAL, 0)
}

func (s *NumericLiteralContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *NumericLiteralContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitNumericLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) NumericLiteral() (localctx INumericLiteralContext) {
	localctx = NewNumericLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1168, Cobol85ParserRULE_numericLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6183)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNUMERICLITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6180)
			p.Match(Cobol85ParserNUMERICLITERAL)
		}

	case Cobol85ParserZERO:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6181)
			p.Match(Cobol85ParserZERO)
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6182)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIntegerLiteralContext is an interface to support dynamic dispatch.
type IIntegerLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerLiteralContext differentiates from other interfaces.
	IsIntegerLiteralContext()
}

type IntegerLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerLiteralContext() *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_integerLiteral
	return p
}

func (*IntegerLiteralContext) IsIntegerLiteralContext() {}

func NewIntegerLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_integerLiteral

	return p
}

func (s *IntegerLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerLiteralContext) INTEGERLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGERLITERAL, 0)
}

func (s *IntegerLiteralContext) LEVEL_NUMBER_66() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_66, 0)
}

func (s *IntegerLiteralContext) LEVEL_NUMBER_77() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_77, 0)
}

func (s *IntegerLiteralContext) LEVEL_NUMBER_88() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_88, 0)
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIntegerLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IntegerLiteral() (localctx IIntegerLiteralContext) {
	localctx = NewIntegerLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1170, Cobol85ParserRULE_integerLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6185)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-556)&-(0x1f+1)) == 0 && ((1<<uint((_la-556)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-556))|(1<<(Cobol85ParserLEVEL_NUMBER_77-556))|(1<<(Cobol85ParserLEVEL_NUMBER_88-556))|(1<<(Cobol85ParserINTEGERLITERAL-556)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// ICicsDfhRespLiteralContext is an interface to support dynamic dispatch.
type ICicsDfhRespLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCicsDfhRespLiteralContext differentiates from other interfaces.
	IsCicsDfhRespLiteralContext()
}

type CicsDfhRespLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCicsDfhRespLiteralContext() *CicsDfhRespLiteralContext {
	var p = new(CicsDfhRespLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cicsDfhRespLiteral
	return p
}

func (*CicsDfhRespLiteralContext) IsCicsDfhRespLiteralContext() {}

func NewCicsDfhRespLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CicsDfhRespLiteralContext {
	var p = new(CicsDfhRespLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cicsDfhRespLiteral

	return p
}

func (s *CicsDfhRespLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *CicsDfhRespLiteralContext) DFHRESP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDFHRESP, 0)
}

func (s *CicsDfhRespLiteralContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *CicsDfhRespLiteralContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *CicsDfhRespLiteralContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *CicsDfhRespLiteralContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CicsDfhRespLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CicsDfhRespLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CicsDfhRespLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCicsDfhRespLiteral(s)
	}
}

func (s *CicsDfhRespLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCicsDfhRespLiteral(s)
	}
}

func (s *CicsDfhRespLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCicsDfhRespLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CicsDfhRespLiteral() (localctx ICicsDfhRespLiteralContext) {
	localctx = NewCicsDfhRespLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1172, Cobol85ParserRULE_cicsDfhRespLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6187)
		p.Match(Cobol85ParserDFHRESP)
	}
	{
		p.SetState(6188)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	p.SetState(6191)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 969, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6189)
			p.CobolWord()
		}

	case 2:
		{
			p.SetState(6190)
			p.Literal()
		}

	}
	{
		p.SetState(6193)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// ICicsDfhValueLiteralContext is an interface to support dynamic dispatch.
type ICicsDfhValueLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCicsDfhValueLiteralContext differentiates from other interfaces.
	IsCicsDfhValueLiteralContext()
}

type CicsDfhValueLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCicsDfhValueLiteralContext() *CicsDfhValueLiteralContext {
	var p = new(CicsDfhValueLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cicsDfhValueLiteral
	return p
}

func (*CicsDfhValueLiteralContext) IsCicsDfhValueLiteralContext() {}

func NewCicsDfhValueLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CicsDfhValueLiteralContext {
	var p = new(CicsDfhValueLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cicsDfhValueLiteral

	return p
}

func (s *CicsDfhValueLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *CicsDfhValueLiteralContext) DFHVALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDFHVALUE, 0)
}

func (s *CicsDfhValueLiteralContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *CicsDfhValueLiteralContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *CicsDfhValueLiteralContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *CicsDfhValueLiteralContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CicsDfhValueLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CicsDfhValueLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CicsDfhValueLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCicsDfhValueLiteral(s)
	}
}

func (s *CicsDfhValueLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCicsDfhValueLiteral(s)
	}
}

func (s *CicsDfhValueLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCicsDfhValueLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CicsDfhValueLiteral() (localctx ICicsDfhValueLiteralContext) {
	localctx = NewCicsDfhValueLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1174, Cobol85ParserRULE_cicsDfhValueLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6195)
		p.Match(Cobol85ParserDFHVALUE)
	}
	{
		p.SetState(6196)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	p.SetState(6199)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 970, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6197)
			p.CobolWord()
		}

	case 2:
		{
			p.SetState(6198)
			p.Literal()
		}

	}
	{
		p.SetState(6201)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// IFigurativeConstantContext is an interface to support dynamic dispatch.
type IFigurativeConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFigurativeConstantContext differentiates from other interfaces.
	IsFigurativeConstantContext()
}

type FigurativeConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFigurativeConstantContext() *FigurativeConstantContext {
	var p = new(FigurativeConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_figurativeConstant
	return p
}

func (*FigurativeConstantContext) IsFigurativeConstantContext() {}

func NewFigurativeConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FigurativeConstantContext {
	var p = new(FigurativeConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_figurativeConstant

	return p
}

func (s *FigurativeConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *FigurativeConstantContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *FigurativeConstantContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *FigurativeConstantContext) HIGH_VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHIGH_VALUE, 0)
}

func (s *FigurativeConstantContext) HIGH_VALUES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHIGH_VALUES, 0)
}

func (s *FigurativeConstantContext) LOW_VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOW_VALUE, 0)
}

func (s *FigurativeConstantContext) LOW_VALUES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOW_VALUES, 0)
}

func (s *FigurativeConstantContext) NULL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNULL, 0)
}

func (s *FigurativeConstantContext) NULLS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNULLS, 0)
}

func (s *FigurativeConstantContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserQUOTE, 0)
}

func (s *FigurativeConstantContext) QUOTES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserQUOTES, 0)
}

func (s *FigurativeConstantContext) SPACE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSPACE, 0)
}

func (s *FigurativeConstantContext) SPACES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSPACES, 0)
}

func (s *FigurativeConstantContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *FigurativeConstantContext) ZEROS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZEROS, 0)
}

func (s *FigurativeConstantContext) ZEROES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZEROES, 0)
}

func (s *FigurativeConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FigurativeConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FigurativeConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFigurativeConstant(s)
	}
}

func (s *FigurativeConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFigurativeConstant(s)
	}
}

func (s *FigurativeConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFigurativeConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FigurativeConstant() (localctx IFigurativeConstantContext) {
	localctx = NewFigurativeConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1176, Cobol85ParserRULE_figurativeConstant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6218)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6203)
			p.Match(Cobol85ParserALL)
		}
		{
			p.SetState(6204)
			p.Literal()
		}

	case Cobol85ParserHIGH_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6205)
			p.Match(Cobol85ParserHIGH_VALUE)
		}

	case Cobol85ParserHIGH_VALUES:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6206)
			p.Match(Cobol85ParserHIGH_VALUES)
		}

	case Cobol85ParserLOW_VALUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6207)
			p.Match(Cobol85ParserLOW_VALUE)
		}

	case Cobol85ParserLOW_VALUES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6208)
			p.Match(Cobol85ParserLOW_VALUES)
		}

	case Cobol85ParserNULL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6209)
			p.Match(Cobol85ParserNULL)
		}

	case Cobol85ParserNULLS:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6210)
			p.Match(Cobol85ParserNULLS)
		}

	case Cobol85ParserQUOTE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6211)
			p.Match(Cobol85ParserQUOTE)
		}

	case Cobol85ParserQUOTES:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6212)
			p.Match(Cobol85ParserQUOTES)
		}

	case Cobol85ParserSPACE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6213)
			p.Match(Cobol85ParserSPACE)
		}

	case Cobol85ParserSPACES:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6214)
			p.Match(Cobol85ParserSPACES)
		}

	case Cobol85ParserZERO:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6215)
			p.Match(Cobol85ParserZERO)
		}

	case Cobol85ParserZEROS:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6216)
			p.Match(Cobol85ParserZEROS)
		}

	case Cobol85ParserZEROES:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6217)
			p.Match(Cobol85ParserZEROES)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISpecialRegisterContext is an interface to support dynamic dispatch.
type ISpecialRegisterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecialRegisterContext differentiates from other interfaces.
	IsSpecialRegisterContext()
}

type SpecialRegisterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialRegisterContext() *SpecialRegisterContext {
	var p = new(SpecialRegisterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_specialRegister
	return p
}

func (*SpecialRegisterContext) IsSpecialRegisterContext() {}

func NewSpecialRegisterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialRegisterContext {
	var p = new(SpecialRegisterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_specialRegister

	return p
}

func (s *SpecialRegisterContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialRegisterContext) ADDRESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADDRESS, 0)
}

func (s *SpecialRegisterContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *SpecialRegisterContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SpecialRegisterContext) DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE, 0)
}

func (s *SpecialRegisterContext) DAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDAY, 0)
}

func (s *SpecialRegisterContext) DAY_OF_WEEK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDAY_OF_WEEK, 0)
}

func (s *SpecialRegisterContext) DEBUG_CONTENTS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_CONTENTS, 0)
}

func (s *SpecialRegisterContext) DEBUG_ITEM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_ITEM, 0)
}

func (s *SpecialRegisterContext) DEBUG_LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_LINE, 0)
}

func (s *SpecialRegisterContext) DEBUG_NAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_NAME, 0)
}

func (s *SpecialRegisterContext) DEBUG_SUB_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_SUB_1, 0)
}

func (s *SpecialRegisterContext) DEBUG_SUB_2() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_SUB_2, 0)
}

func (s *SpecialRegisterContext) DEBUG_SUB_3() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_SUB_3, 0)
}

func (s *SpecialRegisterContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH, 0)
}

func (s *SpecialRegisterContext) LINAGE_COUNTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINAGE_COUNTER, 0)
}

func (s *SpecialRegisterContext) LINE_COUNTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE_COUNTER, 0)
}

func (s *SpecialRegisterContext) PAGE_COUNTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE_COUNTER, 0)
}

func (s *SpecialRegisterContext) RETURN_CODE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRETURN_CODE, 0)
}

func (s *SpecialRegisterContext) SHIFT_IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHIFT_IN, 0)
}

func (s *SpecialRegisterContext) SHIFT_OUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHIFT_OUT, 0)
}

func (s *SpecialRegisterContext) SORT_CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_CONTROL, 0)
}

func (s *SpecialRegisterContext) SORT_CORE_SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_CORE_SIZE, 0)
}

func (s *SpecialRegisterContext) SORT_FILE_SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_FILE_SIZE, 0)
}

func (s *SpecialRegisterContext) SORT_MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_MESSAGE, 0)
}

func (s *SpecialRegisterContext) SORT_MODE_SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_MODE_SIZE, 0)
}

func (s *SpecialRegisterContext) SORT_RETURN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_RETURN, 0)
}

func (s *SpecialRegisterContext) TALLY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTALLY, 0)
}

func (s *SpecialRegisterContext) TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIME, 0)
}

func (s *SpecialRegisterContext) WHEN_COMPILED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN_COMPILED, 0)
}

func (s *SpecialRegisterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialRegisterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialRegisterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSpecialRegister(s)
	}
}

func (s *SpecialRegisterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSpecialRegister(s)
	}
}

func (s *SpecialRegisterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSpecialRegister(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SpecialRegister() (localctx ISpecialRegisterContext) {
	localctx = NewSpecialRegisterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1178, Cobol85ParserRULE_specialRegister)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6251)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserADDRESS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6220)
			p.Match(Cobol85ParserADDRESS)
		}
		{
			p.SetState(6221)
			p.Match(Cobol85ParserOF)
		}
		{
			p.SetState(6222)
			p.Identifier()
		}

	case Cobol85ParserDATE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6223)
			p.Match(Cobol85ParserDATE)
		}

	case Cobol85ParserDAY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6224)
			p.Match(Cobol85ParserDAY)
		}

	case Cobol85ParserDAY_OF_WEEK:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6225)
			p.Match(Cobol85ParserDAY_OF_WEEK)
		}

	case Cobol85ParserDEBUG_CONTENTS:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6226)
			p.Match(Cobol85ParserDEBUG_CONTENTS)
		}

	case Cobol85ParserDEBUG_ITEM:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6227)
			p.Match(Cobol85ParserDEBUG_ITEM)
		}

	case Cobol85ParserDEBUG_LINE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6228)
			p.Match(Cobol85ParserDEBUG_LINE)
		}

	case Cobol85ParserDEBUG_NAME:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6229)
			p.Match(Cobol85ParserDEBUG_NAME)
		}

	case Cobol85ParserDEBUG_SUB_1:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6230)
			p.Match(Cobol85ParserDEBUG_SUB_1)
		}

	case Cobol85ParserDEBUG_SUB_2:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6231)
			p.Match(Cobol85ParserDEBUG_SUB_2)
		}

	case Cobol85ParserDEBUG_SUB_3:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6232)
			p.Match(Cobol85ParserDEBUG_SUB_3)
		}

	case Cobol85ParserLENGTH:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6233)
			p.Match(Cobol85ParserLENGTH)
		}
		{
			p.SetState(6234)
			p.Match(Cobol85ParserOF)
		}
		{
			p.SetState(6235)
			p.Identifier()
		}

	case Cobol85ParserLINAGE_COUNTER:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6236)
			p.Match(Cobol85ParserLINAGE_COUNTER)
		}

	case Cobol85ParserLINE_COUNTER:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6237)
			p.Match(Cobol85ParserLINE_COUNTER)
		}

	case Cobol85ParserPAGE_COUNTER:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(6238)
			p.Match(Cobol85ParserPAGE_COUNTER)
		}

	case Cobol85ParserRETURN_CODE:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(6239)
			p.Match(Cobol85ParserRETURN_CODE)
		}

	case Cobol85ParserSHIFT_IN:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(6240)
			p.Match(Cobol85ParserSHIFT_IN)
		}

	case Cobol85ParserSHIFT_OUT:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(6241)
			p.Match(Cobol85ParserSHIFT_OUT)
		}

	case Cobol85ParserSORT_CONTROL:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(6242)
			p.Match(Cobol85ParserSORT_CONTROL)
		}

	case Cobol85ParserSORT_CORE_SIZE:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(6243)
			p.Match(Cobol85ParserSORT_CORE_SIZE)
		}

	case Cobol85ParserSORT_FILE_SIZE:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(6244)
			p.Match(Cobol85ParserSORT_FILE_SIZE)
		}

	case Cobol85ParserSORT_MESSAGE:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(6245)
			p.Match(Cobol85ParserSORT_MESSAGE)
		}

	case Cobol85ParserSORT_MODE_SIZE:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(6246)
			p.Match(Cobol85ParserSORT_MODE_SIZE)
		}

	case Cobol85ParserSORT_RETURN:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(6247)
			p.Match(Cobol85ParserSORT_RETURN)
		}

	case Cobol85ParserTALLY:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(6248)
			p.Match(Cobol85ParserTALLY)
		}

	case Cobol85ParserTIME:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(6249)
			p.Match(Cobol85ParserTIME)
		}

	case Cobol85ParserWHEN_COMPILED:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(6250)
			p.Match(Cobol85ParserWHEN_COMPILED)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICommentEntryContext is an interface to support dynamic dispatch.
type ICommentEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommentEntryContext differentiates from other interfaces.
	IsCommentEntryContext()
}

type CommentEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentEntryContext() *CommentEntryContext {
	var p = new(CommentEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_commentEntry
	return p
}

func (*CommentEntryContext) IsCommentEntryContext() {}

func NewCommentEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentEntryContext {
	var p = new(CommentEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_commentEntry

	return p
}

func (s *CommentEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentEntryContext) AllCOMMENTENTRYLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserCOMMENTENTRYLINE)
}

func (s *CommentEntryContext) COMMENTENTRYLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMENTENTRYLINE, i)
}

func (s *CommentEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommentEntry(s)
	}
}

func (s *CommentEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommentEntry(s)
	}
}

func (s *CommentEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCommentEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CommentEntry() (localctx ICommentEntryContext) {
	localctx = NewCommentEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1180, Cobol85ParserRULE_commentEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6254)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(6253)
			p.Match(Cobol85ParserCOMMENTENTRYLINE)
		}

		p.SetState(6256)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}
