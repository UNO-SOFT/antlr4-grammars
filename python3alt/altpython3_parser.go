// Generated from AltPython3.g4 by ANTLR 4.7.

package python3alt // AltPython3
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa


var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 97, 1141, 
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7, 
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13, 
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9, 
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23, 
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4, 
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34, 
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9, 
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44, 
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4, 
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55, 
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9, 
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65, 
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4, 
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76, 
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9, 
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86, 
	3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 5, 2, 178, 10, 2, 3, 3, 3, 3, 7, 3, 182, 
	10, 3, 12, 3, 14, 3, 185, 11, 3, 3, 3, 3, 3, 3, 4, 3, 4, 7, 4, 191, 10, 
	4, 12, 4, 14, 4, 194, 11, 4, 3, 4, 3, 4, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 
	202, 10, 5, 3, 5, 5, 5, 205, 10, 5, 3, 5, 3, 5, 3, 6, 6, 6, 210, 10, 6, 
	13, 6, 14, 6, 211, 3, 7, 3, 7, 3, 7, 5, 7, 217, 10, 7, 3, 8, 3, 8, 3, 8, 
	3, 8, 3, 8, 5, 8, 224, 10, 8, 3, 8, 3, 8, 3, 8, 3, 9, 3, 9, 5, 9, 231, 
	10, 9, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 5, 10, 238, 10, 10, 3, 10, 3, 10, 
	3, 10, 3, 10, 5, 10, 244, 10, 10, 7, 10, 246, 10, 10, 12, 10, 14, 10, 249, 
	11, 10, 3, 10, 3, 10, 3, 10, 5, 10, 254, 10, 10, 3, 10, 3, 10, 3, 10, 3, 
	10, 5, 10, 260, 10, 10, 7, 10, 262, 10, 10, 12, 10, 14, 10, 265, 11, 10, 
	3, 10, 3, 10, 3, 10, 5, 10, 270, 10, 10, 3, 10, 3, 10, 5, 10, 274, 10, 
	10, 5, 10, 276, 10, 10, 3, 10, 3, 10, 5, 10, 280, 10, 10, 3, 10, 3, 10, 
	3, 10, 3, 10, 5, 10, 286, 10, 10, 7, 10, 288, 10, 10, 12, 10, 14, 10, 291, 
	11, 10, 3, 10, 3, 10, 3, 10, 5, 10, 296, 10, 10, 3, 10, 3, 10, 5, 10, 300, 
	10, 10, 3, 11, 3, 11, 3, 11, 5, 11, 305, 10, 11, 3, 12, 3, 12, 3, 12, 5, 
	12, 310, 10, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 316, 10, 12, 7, 12, 
	318, 10, 12, 12, 12, 14, 12, 321, 11, 12, 3, 12, 3, 12, 3, 12, 5, 12, 326, 
	10, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 332, 10, 12, 7, 12, 334, 10, 
	12, 12, 12, 14, 12, 337, 11, 12, 3, 12, 3, 12, 3, 12, 5, 12, 342, 10, 12, 
	3, 12, 3, 12, 5, 12, 346, 10, 12, 5, 12, 348, 10, 12, 3, 12, 3, 12, 5, 
	12, 352, 10, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 358, 10, 12, 7, 12, 
	360, 10, 12, 12, 12, 14, 12, 363, 11, 12, 3, 12, 3, 12, 3, 12, 5, 12, 368, 
	10, 12, 3, 12, 3, 12, 5, 12, 372, 10, 12, 3, 13, 3, 13, 3, 14, 3, 14, 5, 
	14, 378, 10, 14, 3, 15, 3, 15, 3, 15, 7, 15, 383, 10, 15, 12, 15, 14, 15, 
	386, 11, 15, 3, 15, 5, 15, 389, 10, 15, 3, 15, 3, 15, 3, 16, 3, 16, 3, 
	16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 5, 16, 402, 10, 16, 3, 17, 
	3, 17, 3, 17, 3, 17, 3, 17, 7, 17, 409, 10, 17, 12, 17, 14, 17, 412, 11, 
	17, 3, 17, 5, 17, 415, 10, 17, 5, 17, 417, 10, 17, 3, 17, 3, 17, 3, 17, 
	3, 17, 6, 17, 423, 10, 17, 13, 17, 14, 17, 424, 3, 17, 5, 17, 428, 10, 
	17, 5, 17, 430, 10, 17, 5, 17, 432, 10, 17, 3, 17, 3, 17, 3, 17, 3, 17, 
	3, 17, 7, 17, 439, 10, 17, 12, 17, 14, 17, 442, 11, 17, 3, 17, 5, 17, 445, 
	10, 17, 5, 17, 447, 10, 17, 3, 17, 3, 17, 3, 17, 3, 17, 6, 17, 453, 10, 
	17, 13, 17, 14, 17, 454, 3, 17, 5, 17, 458, 10, 17, 5, 17, 460, 10, 17, 
	5, 17, 462, 10, 17, 3, 17, 5, 17, 465, 10, 17, 3, 18, 3, 18, 3, 18, 3, 
	18, 5, 18, 471, 10, 18, 3, 18, 3, 18, 3, 18, 5, 18, 476, 10, 18, 7, 18, 
	478, 10, 18, 12, 18, 14, 18, 481, 11, 18, 5, 18, 483, 10, 18, 3, 19, 3, 
	19, 5, 19, 487, 10, 19, 3, 19, 3, 19, 3, 19, 5, 19, 492, 10, 19, 7, 19, 
	494, 10, 19, 12, 19, 14, 19, 497, 11, 19, 3, 19, 5, 19, 500, 10, 19, 3, 
	20, 3, 20, 3, 21, 3, 21, 3, 21, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 3, 23, 
	3, 23, 5, 23, 514, 10, 23, 3, 24, 3, 24, 3, 25, 3, 25, 3, 26, 3, 26, 5, 
	26, 522, 10, 26, 3, 27, 3, 27, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28, 530, 
	10, 28, 5, 28, 532, 10, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 5, 
	28, 540, 10, 28, 3, 29, 3, 29, 5, 29, 544, 10, 29, 3, 30, 3, 30, 3, 30, 
	3, 31, 3, 31, 7, 31, 551, 10, 31, 12, 31, 14, 31, 554, 11, 31, 3, 31, 3, 
	31, 6, 31, 558, 10, 31, 13, 31, 14, 31, 559, 5, 31, 562, 10, 31, 3, 31, 
	3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 5, 31, 571, 10, 31, 3, 32, 3, 
	32, 3, 32, 5, 32, 576, 10, 32, 3, 33, 3, 33, 3, 33, 5, 33, 581, 10, 33, 
	3, 34, 3, 34, 3, 34, 7, 34, 586, 10, 34, 12, 34, 14, 34, 589, 11, 34, 3, 
	34, 5, 34, 592, 10, 34, 3, 35, 3, 35, 3, 35, 7, 35, 597, 10, 35, 12, 35, 
	14, 35, 600, 11, 35, 3, 36, 3, 36, 3, 36, 7, 36, 605, 10, 36, 12, 36, 14, 
	36, 608, 11, 36, 3, 37, 3, 37, 3, 37, 3, 37, 7, 37, 614, 10, 37, 12, 37, 
	14, 37, 617, 11, 37, 3, 38, 3, 38, 3, 38, 3, 38, 7, 38, 623, 10, 38, 12, 
	38, 14, 38, 626, 11, 38, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 632, 10, 39, 
	3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40, 642, 10, 
	40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 7, 41, 
	653, 10, 41, 12, 41, 14, 41, 656, 11, 41, 3, 41, 3, 41, 3, 41, 5, 41, 661, 
	10, 41, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 670, 10, 
	42, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43, 
	681, 10, 43, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 6, 44, 690, 
	10, 44, 13, 44, 14, 44, 691, 3, 44, 3, 44, 3, 44, 5, 44, 697, 10, 44, 3, 
	44, 3, 44, 3, 44, 5, 44, 702, 10, 44, 3, 44, 3, 44, 3, 44, 5, 44, 707, 
	10, 44, 3, 45, 3, 45, 3, 45, 3, 45, 7, 45, 713, 10, 45, 12, 45, 14, 45, 
	716, 11, 45, 3, 45, 3, 45, 3, 45, 3, 46, 3, 46, 3, 46, 5, 46, 724, 10, 
	46, 3, 47, 3, 47, 3, 47, 3, 47, 5, 47, 730, 10, 47, 5, 47, 732, 10, 47, 
	3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 5, 47, 739, 10, 47, 3, 48, 3, 48, 3, 
	48, 3, 48, 6, 48, 745, 10, 48, 13, 48, 14, 48, 746, 3, 48, 3, 48, 5, 48, 
	751, 10, 48, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 5, 49, 759, 10, 
	49, 3, 49, 5, 49, 762, 10, 49, 3, 50, 3, 50, 5, 50, 766, 10, 50, 3, 51, 
	3, 51, 5, 51, 770, 10, 51, 3, 51, 3, 51, 3, 51, 3, 52, 3, 52, 5, 52, 777, 
	10, 52, 3, 52, 3, 52, 3, 52, 3, 53, 3, 53, 3, 53, 7, 53, 785, 10, 53, 12, 
	53, 14, 53, 788, 11, 53, 3, 54, 3, 54, 3, 54, 7, 54, 793, 10, 54, 12, 54, 
	14, 54, 796, 11, 54, 3, 55, 3, 55, 3, 55, 5, 55, 801, 10, 55, 3, 56, 3, 
	56, 3, 56, 3, 56, 7, 56, 807, 10, 56, 12, 56, 14, 56, 810, 11, 56, 3, 57, 
	3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 
	57, 3, 57, 5, 57, 825, 10, 57, 3, 58, 5, 58, 828, 10, 58, 3, 58, 3, 58, 
	3, 59, 3, 59, 3, 59, 7, 59, 835, 10, 59, 12, 59, 14, 59, 838, 11, 59, 3, 
	60, 3, 60, 3, 60, 7, 60, 843, 10, 60, 12, 60, 14, 60, 846, 11, 60, 3, 61, 
	3, 61, 3, 61, 7, 61, 851, 10, 61, 12, 61, 14, 61, 854, 11, 61, 3, 62, 3, 
	62, 3, 62, 3, 62, 3, 62, 7, 62, 861, 10, 62, 12, 62, 14, 62, 864, 11, 62, 
	3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 7, 63, 871, 10, 63, 12, 63, 14, 63, 
	874, 11, 63, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 
	64, 3, 64, 3, 64, 7, 64, 887, 10, 64, 12, 64, 14, 64, 890, 11, 64, 3, 65, 
	3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 5, 65, 899, 10, 65, 3, 66, 3, 
	66, 7, 66, 903, 10, 66, 12, 66, 14, 66, 906, 11, 66, 3, 66, 3, 66, 5, 66, 
	910, 10, 66, 3, 67, 3, 67, 3, 67, 5, 67, 915, 10, 67, 3, 67, 3, 67, 3, 
	67, 5, 67, 920, 10, 67, 3, 67, 3, 67, 3, 67, 5, 67, 925, 10, 67, 3, 67, 
	3, 67, 3, 67, 3, 67, 3, 67, 6, 67, 932, 10, 67, 13, 67, 14, 67, 933, 3, 
	67, 3, 67, 3, 67, 3, 67, 5, 67, 940, 10, 67, 3, 68, 3, 68, 3, 68, 3, 68, 
	7, 68, 946, 10, 68, 12, 68, 14, 68, 949, 11, 68, 3, 68, 5, 68, 952, 10, 
	68, 5, 68, 954, 10, 68, 3, 69, 3, 69, 5, 69, 958, 10, 69, 3, 69, 3, 69, 
	3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 968, 10, 69, 3, 70, 3, 
	70, 3, 70, 7, 70, 973, 10, 70, 12, 70, 14, 70, 976, 11, 70, 3, 70, 5, 70, 
	979, 10, 70, 3, 71, 3, 71, 5, 71, 983, 10, 71, 3, 71, 3, 71, 5, 71, 987, 
	10, 71, 3, 71, 5, 71, 990, 10, 71, 5, 71, 992, 10, 71, 3, 72, 3, 72, 5, 
	72, 996, 10, 72, 3, 73, 3, 73, 3, 73, 7, 73, 1001, 10, 73, 12, 73, 14, 
	73, 1004, 11, 73, 3, 73, 5, 73, 1007, 10, 73, 3, 74, 3, 74, 3, 74, 7, 74, 
	1012, 10, 74, 12, 74, 14, 74, 1015, 11, 74, 3, 74, 5, 74, 1018, 10, 74, 
	3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 7, 75, 1029, 
	10, 75, 12, 75, 14, 75, 1032, 11, 75, 3, 75, 5, 75, 1035, 10, 75, 5, 75, 
	1037, 10, 75, 3, 75, 3, 75, 3, 75, 3, 75, 7, 75, 1043, 10, 75, 12, 75, 
	14, 75, 1046, 11, 75, 3, 75, 5, 75, 1049, 10, 75, 5, 75, 1051, 10, 75, 
	5, 75, 1053, 10, 75, 3, 76, 3, 76, 3, 76, 3, 76, 5, 76, 1059, 10, 76, 3, 
	76, 5, 76, 1062, 10, 76, 3, 76, 3, 76, 3, 76, 3, 77, 3, 77, 3, 77, 7, 77, 
	1070, 10, 77, 12, 77, 14, 77, 1073, 11, 77, 3, 77, 3, 77, 5, 77, 1077, 
	10, 77, 3, 77, 3, 77, 3, 77, 3, 77, 7, 77, 1083, 10, 77, 12, 77, 14, 77, 
	1086, 11, 77, 3, 77, 3, 77, 3, 77, 5, 77, 1091, 10, 77, 3, 77, 3, 77, 5, 
	77, 1095, 10, 77, 3, 78, 3, 78, 5, 78, 1099, 10, 78, 3, 78, 3, 78, 3, 78, 
	3, 78, 5, 78, 1105, 10, 78, 3, 79, 3, 79, 5, 79, 1109, 10, 79, 3, 80, 3, 
	80, 3, 80, 3, 80, 3, 80, 5, 80, 1116, 10, 80, 3, 81, 3, 81, 3, 81, 5, 81, 
	1121, 10, 81, 3, 82, 3, 82, 5, 82, 1125, 10, 82, 3, 83, 3, 83, 3, 83, 5, 
	83, 1130, 10, 83, 3, 84, 3, 84, 3, 85, 3, 85, 3, 85, 5, 85, 1137, 10, 85, 
	3, 86, 3, 86, 3, 86, 2, 2, 87, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 
	24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 
	60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 
	96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 
	126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 
	156, 158, 160, 162, 164, 166, 168, 170, 2, 6, 3, 2, 81, 93, 3, 2, 47, 48, 
	3, 2, 39, 40, 3, 2, 41, 44, 2, 1270, 2, 177, 3, 2, 2, 2, 4, 183, 3, 2, 
	2, 2, 6, 188, 3, 2, 2, 2, 8, 197, 3, 2, 2, 2, 10, 209, 3, 2, 2, 2, 12, 
	213, 3, 2, 2, 2, 14, 218, 3, 2, 2, 2, 16, 228, 3, 2, 2, 2, 18, 299, 3, 
	2, 2, 2, 20, 301, 3, 2, 2, 2, 22, 371, 3, 2, 2, 2, 24, 373, 3, 2, 2, 2, 
	26, 377, 3, 2, 2, 2, 28, 379, 3, 2, 2, 2, 30, 401, 3, 2, 2, 2, 32, 464, 
	3, 2, 2, 2, 34, 466, 3, 2, 2, 2, 36, 486, 3, 2, 2, 2, 38, 501, 3, 2, 2, 
	2, 40, 503, 3, 2, 2, 2, 42, 506, 3, 2, 2, 2, 44, 513, 3, 2, 2, 2, 46, 515, 
	3, 2, 2, 2, 48, 517, 3, 2, 2, 2, 50, 519, 3, 2, 2, 2, 52, 523, 3, 2, 2, 
	2, 54, 539, 3, 2, 2, 2, 56, 543, 3, 2, 2, 2, 58, 545, 3, 2, 2, 2, 60, 548, 
	3, 2, 2, 2, 62, 572, 3, 2, 2, 2, 64, 577, 3, 2, 2, 2, 66, 582, 3, 2, 2, 
	2, 68, 593, 3, 2, 2, 2, 70, 601, 3, 2, 2, 2, 72, 609, 3, 2, 2, 2, 74, 618, 
	3, 2, 2, 2, 76, 627, 3, 2, 2, 2, 78, 641, 3, 2, 2, 2, 80, 643, 3, 2, 2, 
	2, 82, 662, 3, 2, 2, 2, 84, 671, 3, 2, 2, 2, 86, 682, 3, 2, 2, 2, 88, 708, 
	3, 2, 2, 2, 90, 720, 3, 2, 2, 2, 92, 738, 3, 2, 2, 2, 94, 750, 3, 2, 2, 
	2, 96, 761, 3, 2, 2, 2, 98, 765, 3, 2, 2, 2, 100, 767, 3, 2, 2, 2, 102, 
	774, 3, 2, 2, 2, 104, 781, 3, 2, 2, 2, 106, 789, 3, 2, 2, 2, 108, 800, 
	3, 2, 2, 2, 110, 802, 3, 2, 2, 2, 112, 824, 3, 2, 2, 2, 114, 827, 3, 2, 
	2, 2, 116, 831, 3, 2, 2, 2, 118, 839, 3, 2, 2, 2, 120, 847, 3, 2, 2, 2, 
	122, 855, 3, 2, 2, 2, 124, 865, 3, 2, 2, 2, 126, 875, 3, 2, 2, 2, 128, 
	898, 3, 2, 2, 2, 130, 900, 3, 2, 2, 2, 132, 939, 3, 2, 2, 2, 134, 941, 
	3, 2, 2, 2, 136, 967, 3, 2, 2, 2, 138, 969, 3, 2, 2, 2, 140, 991, 3, 2, 
	2, 2, 142, 993, 3, 2, 2, 2, 144, 997, 3, 2, 2, 2, 146, 1008, 3, 2, 2, 2, 
	148, 1052, 3, 2, 2, 2, 150, 1054, 3, 2, 2, 2, 152, 1071, 3, 2, 2, 2, 154, 
	1104, 3, 2, 2, 2, 156, 1108, 3, 2, 2, 2, 158, 1110, 3, 2, 2, 2, 160, 1117, 
	3, 2, 2, 2, 162, 1122, 3, 2, 2, 2, 164, 1129, 3, 2, 2, 2, 166, 1131, 3, 
	2, 2, 2, 168, 1136, 3, 2, 2, 2, 170, 1138, 3, 2, 2, 2, 172, 178, 7, 37, 
	2, 2, 173, 178, 5, 28, 15, 2, 174, 175, 5, 78, 40, 2, 175, 176, 7, 37, 
	2, 2, 176, 178, 3, 2, 2, 2, 177, 172, 3, 2, 2, 2, 177, 173, 3, 2, 2, 2, 
	177, 174, 3, 2, 2, 2, 178, 3, 3, 2, 2, 2, 179, 182, 7, 37, 2, 2, 180, 182, 
	5, 26, 14, 2, 181, 179, 3, 2, 2, 2, 181, 180, 3, 2, 2, 2, 182, 185, 3, 
	2, 2, 2, 183, 181, 3, 2, 2, 2, 183, 184, 3, 2, 2, 2, 184, 186, 3, 2, 2, 
	2, 185, 183, 3, 2, 2, 2, 186, 187, 7, 2, 2, 3, 187, 5, 3, 2, 2, 2, 188, 
	192, 5, 146, 74, 2, 189, 191, 7, 37, 2, 2, 190, 189, 3, 2, 2, 2, 191, 194, 
	3, 2, 2, 2, 192, 190, 3, 2, 2, 2, 192, 193, 3, 2, 2, 2, 193, 195, 3, 2, 
	2, 2, 194, 192, 3, 2, 2, 2, 195, 196, 7, 2, 2, 3, 196, 7, 3, 2, 2, 2, 197, 
	198, 7, 79, 2, 2, 198, 204, 5, 70, 36, 2, 199, 201, 7, 50, 2, 2, 200, 202, 
	5, 152, 77, 2, 201, 200, 3, 2, 2, 2, 201, 202, 3, 2, 2, 2, 202, 203, 3, 
	2, 2, 2, 203, 205, 7, 51, 2, 2, 204, 199, 3, 2, 2, 2, 204, 205, 3, 2, 2, 
	2, 205, 206, 3, 2, 2, 2, 206, 207, 7, 37, 2, 2, 207, 9, 3, 2, 2, 2, 208, 
	210, 5, 8, 5, 2, 209, 208, 3, 2, 2, 2, 210, 211, 3, 2, 2, 2, 211, 209, 
	3, 2, 2, 2, 211, 212, 3, 2, 2, 2, 212, 11, 3, 2, 2, 2, 213, 216, 5, 10, 
	6, 2, 214, 217, 5, 150, 76, 2, 215, 217, 5, 14, 8, 2, 216, 214, 3, 2, 2, 
	2, 216, 215, 3, 2, 2, 2, 217, 13, 3, 2, 2, 2, 218, 219, 7, 4, 2, 2, 219, 
	220, 7, 38, 2, 2, 220, 223, 5, 16, 9, 2, 221, 222, 7, 80, 2, 2, 222, 224, 
	5, 96, 49, 2, 223, 221, 3, 2, 2, 2, 223, 224, 3, 2, 2, 2, 224, 225, 3, 
	2, 2, 2, 225, 226, 7, 53, 2, 2, 226, 227, 5, 94, 48, 2, 227, 15, 3, 2, 
	2, 2, 228, 230, 7, 50, 2, 2, 229, 231, 5, 18, 10, 2, 230, 229, 3, 2, 2, 
	2, 230, 231, 3, 2, 2, 2, 231, 232, 3, 2, 2, 2, 232, 233, 7, 51, 2, 2, 233, 
	17, 3, 2, 2, 2, 234, 237, 5, 20, 11, 2, 235, 236, 7, 56, 2, 2, 236, 238, 
	5, 96, 49, 2, 237, 235, 3, 2, 2, 2, 237, 238, 3, 2, 2, 2, 238, 247, 3, 
	2, 2, 2, 239, 240, 7, 52, 2, 2, 240, 243, 5, 20, 11, 2, 241, 242, 7, 56, 
	2, 2, 242, 244, 5, 96, 49, 2, 243, 241, 3, 2, 2, 2, 243, 244, 3, 2, 2, 
	2, 244, 246, 3, 2, 2, 2, 245, 239, 3, 2, 2, 2, 246, 249, 3, 2, 2, 2, 247, 
	245, 3, 2, 2, 2, 247, 248, 3, 2, 2, 2, 248, 275, 3, 2, 2, 2, 249, 247, 
	3, 2, 2, 2, 250, 273, 7, 52, 2, 2, 251, 253, 7, 49, 2, 2, 252, 254, 5, 
	20, 11, 2, 253, 252, 3, 2, 2, 2, 253, 254, 3, 2, 2, 2, 254, 263, 3, 2, 
	2, 2, 255, 256, 7, 52, 2, 2, 256, 259, 5, 20, 11, 2, 257, 258, 7, 56, 2, 
	2, 258, 260, 5, 96, 49, 2, 259, 257, 3, 2, 2, 2, 259, 260, 3, 2, 2, 2, 
	260, 262, 3, 2, 2, 2, 261, 255, 3, 2, 2, 2, 262, 265, 3, 2, 2, 2, 263, 
	261, 3, 2, 2, 2, 263, 264, 3, 2, 2, 2, 264, 269, 3, 2, 2, 2, 265, 263, 
	3, 2, 2, 2, 266, 267, 7, 52, 2, 2, 267, 268, 7, 55, 2, 2, 268, 270, 5, 
	20, 11, 2, 269, 266, 3, 2, 2, 2, 269, 270, 3, 2, 2, 2, 270, 274, 3, 2, 
	2, 2, 271, 272, 7, 55, 2, 2, 272, 274, 5, 20, 11, 2, 273, 251, 3, 2, 2, 
	2, 273, 271, 3, 2, 2, 2, 273, 274, 3, 2, 2, 2, 274, 276, 3, 2, 2, 2, 275, 
	250, 3, 2, 2, 2, 275, 276, 3, 2, 2, 2, 276, 300, 3, 2, 2, 2, 277, 279, 
	7, 49, 2, 2, 278, 280, 5, 20, 11, 2, 279, 278, 3, 2, 2, 2, 279, 280, 3, 
	2, 2, 2, 280, 289, 3, 2, 2, 2, 281, 282, 7, 52, 2, 2, 282, 285, 5, 20, 
	11, 2, 283, 284, 7, 56, 2, 2, 284, 286, 5, 96, 49, 2, 285, 283, 3, 2, 2, 
	2, 285, 286, 3, 2, 2, 2, 286, 288, 3, 2, 2, 2, 287, 281, 3, 2, 2, 2, 288, 
	291, 3, 2, 2, 2, 289, 287, 3, 2, 2, 2, 289, 290, 3, 2, 2, 2, 290, 295, 
	3, 2, 2, 2, 291, 289, 3, 2, 2, 2, 292, 293, 7, 52, 2, 2, 293, 294, 7, 55, 
	2, 2, 294, 296, 5, 20, 11, 2, 295, 292, 3, 2, 2, 2, 295, 296, 3, 2, 2, 
	2, 296, 300, 3, 2, 2, 2, 297, 298, 7, 55, 2, 2, 298, 300, 5, 20, 11, 2, 
	299, 234, 3, 2, 2, 2, 299, 277, 3, 2, 2, 2, 299, 297, 3, 2, 2, 2, 300, 
	19, 3, 2, 2, 2, 301, 304, 7, 38, 2, 2, 302, 303, 7, 53, 2, 2, 303, 305, 
	5, 96, 49, 2, 304, 302, 3, 2, 2, 2, 304, 305, 3, 2, 2, 2, 305, 21, 3, 2, 
	2, 2, 306, 309, 5, 24, 13, 2, 307, 308, 7, 56, 2, 2, 308, 310, 5, 96, 49, 
	2, 309, 307, 3, 2, 2, 2, 309, 310, 3, 2, 2, 2, 310, 319, 3, 2, 2, 2, 311, 
	312, 7, 52, 2, 2, 312, 315, 5, 24, 13, 2, 313, 314, 7, 56, 2, 2, 314, 316, 
	5, 96, 49, 2, 315, 313, 3, 2, 2, 2, 315, 316, 3, 2, 2, 2, 316, 318, 3, 
	2, 2, 2, 317, 311, 3, 2, 2, 2, 318, 321, 3, 2, 2, 2, 319, 317, 3, 2, 2, 
	2, 319, 320, 3, 2, 2, 2, 320, 347, 3, 2, 2, 2, 321, 319, 3, 2, 2, 2, 322, 
	345, 7, 52, 2, 2, 323, 325, 7, 49, 2, 2, 324, 326, 5, 24, 13, 2, 325, 324, 
	3, 2, 2, 2, 325, 326, 3, 2, 2, 2, 326, 335, 3, 2, 2, 2, 327, 328, 7, 52, 
	2, 2, 328, 331, 5, 24, 13, 2, 329, 330, 7, 56, 2, 2, 330, 332, 5, 96, 49, 
	2, 331, 329, 3, 2, 2, 2, 331, 332, 3, 2, 2, 2, 332, 334, 3, 2, 2, 2, 333, 
	327, 3, 2, 2, 2, 334, 337, 3, 2, 2, 2, 335, 333, 3, 2, 2, 2, 335, 336, 
	3, 2, 2, 2, 336, 341, 3, 2, 2, 2, 337, 335, 3, 2, 2, 2, 338, 339, 7, 52, 
	2, 2, 339, 340, 7, 55, 2, 2, 340, 342, 5, 24, 13, 2, 341, 338, 3, 2, 2, 
	2, 341, 342, 3, 2, 2, 2, 342, 346, 3, 2, 2, 2, 343, 344, 7, 55, 2, 2, 344, 
	346, 5, 24, 13, 2, 345, 323, 3, 2, 2, 2, 345, 343, 3, 2, 2, 2, 345, 346, 
	3, 2, 2, 2, 346, 348, 3, 2, 2, 2, 347, 322, 3, 2, 2, 2, 347, 348, 3, 2, 
	2, 2, 348, 372, 3, 2, 2, 2, 349, 351, 7, 49, 2, 2, 350, 352, 5, 24, 13, 
	2, 351, 350, 3, 2, 2, 2, 351, 352, 3, 2, 2, 2, 352, 361, 3, 2, 2, 2, 353, 
	354, 7, 52, 2, 2, 354, 357, 5, 24, 13, 2, 355, 356, 7, 56, 2, 2, 356, 358, 
	5, 96, 49, 2, 357, 355, 3, 2, 2, 2, 357, 358, 3, 2, 2, 2, 358, 360, 3, 
	2, 2, 2, 359, 353, 3, 2, 2, 2, 360, 363, 3, 2, 2, 2, 361, 359, 3, 2, 2, 
	2, 361, 362, 3, 2, 2, 2, 362, 367, 3, 2, 2, 2, 363, 361, 3, 2, 2, 2, 364, 
	365, 7, 52, 2, 2, 365, 366, 7, 55, 2, 2, 366, 368, 5, 24, 13, 2, 367, 364, 
	3, 2, 2, 2, 367, 368, 3, 2, 2, 2, 368, 372, 3, 2, 2, 2, 369, 370, 7, 55, 
	2, 2, 370, 372, 5, 24, 13, 2, 371, 306, 3, 2, 2, 2, 371, 349, 3, 2, 2, 
	2, 371, 369, 3, 2, 2, 2, 372, 23, 3, 2, 2, 2, 373, 374, 7, 38, 2, 2, 374, 
	25, 3, 2, 2, 2, 375, 378, 5, 28, 15, 2, 376, 378, 5, 78, 40, 2, 377, 375, 
	3, 2, 2, 2, 377, 376, 3, 2, 2, 2, 378, 27, 3, 2, 2, 2, 379, 384, 5, 30, 
	16, 2, 380, 381, 7, 54, 2, 2, 381, 383, 5, 30, 16, 2, 382, 380, 3, 2, 2, 
	2, 383, 386, 3, 2, 2, 2, 384, 382, 3, 2, 2, 2, 384, 385, 3, 2, 2, 2, 385, 
	388, 3, 2, 2, 2, 386, 384, 3, 2, 2, 2, 387, 389, 7, 54, 2, 2, 388, 387, 
	3, 2, 2, 2, 388, 389, 3, 2, 2, 2, 389, 390, 3, 2, 2, 2, 390, 391, 7, 37, 
	2, 2, 391, 29, 3, 2, 2, 2, 392, 402, 5, 32, 17, 2, 393, 402, 5, 34, 18, 
	2, 394, 402, 5, 40, 21, 2, 395, 402, 5, 42, 22, 2, 396, 402, 5, 44, 23, 
	2, 397, 402, 5, 56, 29, 2, 398, 402, 5, 72, 37, 2, 399, 402, 5, 74, 38, 
	2, 400, 402, 5, 76, 39, 2, 401, 392, 3, 2, 2, 2, 401, 393, 3, 2, 2, 2, 
	401, 394, 3, 2, 2, 2, 401, 395, 3, 2, 2, 2, 401, 396, 3, 2, 2, 2, 401, 
	397, 3, 2, 2, 2, 401, 398, 3, 2, 2, 2, 401, 399, 3, 2, 2, 2, 401, 400, 
	3, 2, 2, 2, 402, 31, 3, 2, 2, 2, 403, 404, 7, 3, 2, 2, 404, 431, 7, 50, 
	2, 2, 405, 410, 5, 96, 49, 2, 406, 407, 7, 52, 2, 2, 407, 409, 5, 96, 49, 
	2, 408, 406, 3, 2, 2, 2, 409, 412, 3, 2, 2, 2, 410, 408, 3, 2, 2, 2, 410, 
	411, 3, 2, 2, 2, 411, 414, 3, 2, 2, 2, 412, 410, 3, 2, 2, 2, 413, 415, 
	7, 52, 2, 2, 414, 413, 3, 2, 2, 2, 414, 415, 3, 2, 2, 2, 415, 417, 3, 2, 
	2, 2, 416, 405, 3, 2, 2, 2, 416, 417, 3, 2, 2, 2, 417, 432, 3, 2, 2, 2, 
	418, 419, 7, 63, 2, 2, 419, 429, 5, 96, 49, 2, 420, 421, 7, 52, 2, 2, 421, 
	423, 5, 96, 49, 2, 422, 420, 3, 2, 2, 2, 423, 424, 3, 2, 2, 2, 424, 422, 
	3, 2, 2, 2, 424, 425, 3, 2, 2, 2, 425, 427, 3, 2, 2, 2, 426, 428, 7, 52, 
	2, 2, 427, 426, 3, 2, 2, 2, 427, 428, 3, 2, 2, 2, 428, 430, 3, 2, 2, 2, 
	429, 422, 3, 2, 2, 2, 429, 430, 3, 2, 2, 2, 430, 432, 3, 2, 2, 2, 431, 
	416, 3, 2, 2, 2, 431, 418, 3, 2, 2, 2, 432, 433, 3, 2, 2, 2, 433, 465, 
	7, 51, 2, 2, 434, 461, 7, 3, 2, 2, 435, 440, 5, 96, 49, 2, 436, 437, 7, 
	52, 2, 2, 437, 439, 5, 96, 49, 2, 438, 436, 3, 2, 2, 2, 439, 442, 3, 2, 
	2, 2, 440, 438, 3, 2, 2, 2, 440, 441, 3, 2, 2, 2, 441, 444, 3, 2, 2, 2, 
	442, 440, 3, 2, 2, 2, 443, 445, 7, 52, 2, 2, 444, 443, 3, 2, 2, 2, 444, 
	445, 3, 2, 2, 2, 445, 447, 3, 2, 2, 2, 446, 435, 3, 2, 2, 2, 446, 447, 
	3, 2, 2, 2, 447, 462, 3, 2, 2, 2, 448, 449, 7, 63, 2, 2, 449, 459, 5, 96, 
	49, 2, 450, 451, 7, 52, 2, 2, 451, 453, 5, 96, 49, 2, 452, 450, 3, 2, 2, 
	2, 453, 454, 3, 2, 2, 2, 454, 452, 3, 2, 2, 2, 454, 455, 3, 2, 2, 2, 455, 
	457, 3, 2, 2, 2, 456, 458, 7, 52, 2, 2, 457, 456, 3, 2, 2, 2, 457, 458, 
	3, 2, 2, 2, 458, 460, 3, 2, 2, 2, 459, 452, 3, 2, 2, 2, 459, 460, 3, 2, 
	2, 2, 460, 462, 3, 2, 2, 2, 461, 446, 3, 2, 2, 2, 461, 448, 3, 2, 2, 2, 
	462, 463, 3, 2, 2, 2, 463, 465, 8, 17, 1, 2, 464, 403, 3, 2, 2, 2, 464, 
	434, 3, 2, 2, 2, 465, 33, 3, 2, 2, 2, 466, 482, 5, 36, 19, 2, 467, 470, 
	5, 38, 20, 2, 468, 471, 5, 162, 82, 2, 469, 471, 5, 146, 74, 2, 470, 468, 
	3, 2, 2, 2, 470, 469, 3, 2, 2, 2, 471, 483, 3, 2, 2, 2, 472, 475, 7, 56, 
	2, 2, 473, 476, 5, 162, 82, 2, 474, 476, 5, 36, 19, 2, 475, 473, 3, 2, 
	2, 2, 475, 474, 3, 2, 2, 2, 476, 478, 3, 2, 2, 2, 477, 472, 3, 2, 2, 2, 
	478, 481, 3, 2, 2, 2, 479, 477, 3, 2, 2, 2, 479, 480, 3, 2, 2, 2, 480, 
	483, 3, 2, 2, 2, 481, 479, 3, 2, 2, 2, 482, 467, 3, 2, 2, 2, 482, 479, 
	3, 2, 2, 2, 483, 35, 3, 2, 2, 2, 484, 487, 5, 96, 49, 2, 485, 487, 5, 114, 
	58, 2, 486, 484, 3, 2, 2, 2, 486, 485, 3, 2, 2, 2, 487, 495, 3, 2, 2, 2, 
	488, 491, 7, 52, 2, 2, 489, 492, 5, 96, 49, 2, 490, 492, 5, 114, 58, 2, 
	491, 489, 3, 2, 2, 2, 491, 490, 3, 2, 2, 2, 492, 494, 3, 2, 2, 2, 493, 
	488, 3, 2, 2, 2, 494, 497, 3, 2, 2, 2, 495, 493, 3, 2, 2, 2, 495, 496, 
	3, 2, 2, 2, 496, 499, 3, 2, 2, 2, 497, 495, 3, 2, 2, 2, 498, 500, 7, 52, 
	2, 2, 499, 498, 3, 2, 2, 2, 499, 500, 3, 2, 2, 2, 500, 37, 3, 2, 2, 2, 
	501, 502, 9, 2, 2, 2, 502, 39, 3, 2, 2, 2, 503, 504, 7, 33, 2, 2, 504, 
	505, 5, 144, 73, 2, 505, 41, 3, 2, 2, 2, 506, 507, 7, 34, 2, 2, 507, 43, 
	3, 2, 2, 2, 508, 514, 5, 46, 24, 2, 509, 514, 5, 48, 25, 2, 510, 514, 5, 
	50, 26, 2, 511, 514, 5, 54, 28, 2, 512, 514, 5, 52, 27, 2, 513, 508, 3, 
	2, 2, 2, 513, 509, 3, 2, 2, 2, 513, 510, 3, 2, 2, 2, 513, 511, 3, 2, 2, 
	2, 513, 512, 3, 2, 2, 2, 514, 45, 3, 2, 2, 2, 515, 516, 7, 36, 2, 2, 516, 
	47, 3, 2, 2, 2, 517, 518, 7, 35, 2, 2, 518, 49, 3, 2, 2, 2, 519, 521, 7, 
	5, 2, 2, 520, 522, 5, 146, 74, 2, 521, 520, 3, 2, 2, 2, 521, 522, 3, 2, 
	2, 2, 522, 51, 3, 2, 2, 2, 523, 524, 5, 162, 82, 2, 524, 53, 3, 2, 2, 2, 
	525, 531, 7, 6, 2, 2, 526, 529, 5, 96, 49, 2, 527, 528, 7, 7, 2, 2, 528, 
	530, 5, 96, 49, 2, 529, 527, 3, 2, 2, 2, 529, 530, 3, 2, 2, 2, 530, 532, 
	3, 2, 2, 2, 531, 526, 3, 2, 2, 2, 531, 532, 3, 2, 2, 2, 532, 540, 3, 2, 
	2, 2, 533, 534, 7, 6, 2, 2, 534, 535, 7, 38, 2, 2, 535, 536, 7, 52, 2, 
	2, 536, 537, 5, 166, 84, 2, 537, 538, 8, 28, 1, 2, 538, 540, 3, 2, 2, 2, 
	539, 525, 3, 2, 2, 2, 539, 533, 3, 2, 2, 2, 540, 55, 3, 2, 2, 2, 541, 544, 
	5, 58, 30, 2, 542, 544, 5, 60, 31, 2, 543, 541, 3, 2, 2, 2, 543, 542, 3, 
	2, 2, 2, 544, 57, 3, 2, 2, 2, 545, 546, 7, 8, 2, 2, 546, 547, 5, 68, 35, 
	2, 547, 59, 3, 2, 2, 2, 548, 561, 7, 7, 2, 2, 549, 551, 9, 3, 2, 2, 550, 
	549, 3, 2, 2, 2, 551, 554, 3, 2, 2, 2, 552, 550, 3, 2, 2, 2, 552, 553, 
	3, 2, 2, 2, 553, 555, 3, 2, 2, 2, 554, 552, 3, 2, 2, 2, 555, 562, 5, 70, 
	36, 2, 556, 558, 9, 3, 2, 2, 557, 556, 3, 2, 2, 2, 558, 559, 3, 2, 2, 2, 
	559, 557, 3, 2, 2, 2, 559, 560, 3, 2, 2, 2, 560, 562, 3, 2, 2, 2, 561, 
	552, 3, 2, 2, 2, 561, 557, 3, 2, 2, 2, 562, 563, 3, 2, 2, 2, 563, 570, 
	7, 8, 2, 2, 564, 571, 7, 49, 2, 2, 565, 566, 7, 50, 2, 2, 566, 567, 5, 
	66, 34, 2, 567, 568, 7, 51, 2, 2, 568, 571, 3, 2, 2, 2, 569, 571, 5, 66, 
	34, 2, 570, 564, 3, 2, 2, 2, 570, 565, 3, 2, 2, 2, 570, 569, 3, 2, 2, 2, 
	571, 61, 3, 2, 2, 2, 572, 575, 7, 38, 2, 2, 573, 574, 7, 9, 2, 2, 574, 
	576, 7, 38, 2, 2, 575, 573, 3, 2, 2, 2, 575, 576, 3, 2, 2, 2, 576, 63, 
	3, 2, 2, 2, 577, 580, 5, 70, 36, 2, 578, 579, 7, 9, 2, 2, 579, 581, 7, 
	38, 2, 2, 580, 578, 3, 2, 2, 2, 580, 581, 3, 2, 2, 2, 581, 65, 3, 2, 2, 
	2, 582, 587, 5, 62, 32, 2, 583, 584, 7, 52, 2, 2, 584, 586, 5, 62, 32, 
	2, 585, 583, 3, 2, 2, 2, 586, 589, 3, 2, 2, 2, 587, 585, 3, 2, 2, 2, 587, 
	588, 3, 2, 2, 2, 588, 591, 3, 2, 2, 2, 589, 587, 3, 2, 2, 2, 590, 592, 
	7, 52, 2, 2, 591, 590, 3, 2, 2, 2, 591, 592, 3, 2, 2, 2, 592, 67, 3, 2, 
	2, 2, 593, 598, 5, 64, 33, 2, 594, 595, 7, 52, 2, 2, 595, 597, 5, 64, 33, 
	2, 596, 594, 3, 2, 2, 2, 597, 600, 3, 2, 2, 2, 598, 596, 3, 2, 2, 2, 598, 
	599, 3, 2, 2, 2, 599, 69, 3, 2, 2, 2, 600, 598, 3, 2, 2, 2, 601, 606, 7, 
	38, 2, 2, 602, 603, 7, 47, 2, 2, 603, 605, 7, 38, 2, 2, 604, 602, 3, 2, 
	2, 2, 605, 608, 3, 2, 2, 2, 606, 604, 3, 2, 2, 2, 606, 607, 3, 2, 2, 2, 
	607, 71, 3, 2, 2, 2, 608, 606, 3, 2, 2, 2, 609, 610, 7, 10, 2, 2, 610, 
	615, 7, 38, 2, 2, 611, 612, 7, 52, 2, 2, 612, 614, 7, 38, 2, 2, 613, 611, 
	3, 2, 2, 2, 614, 617, 3, 2, 2, 2, 615, 613, 3, 2, 2, 2, 615, 616, 3, 2, 
	2, 2, 616, 73, 3, 2, 2, 2, 617, 615, 3, 2, 2, 2, 618, 619, 7, 11, 2, 2, 
	619, 624, 7, 38, 2, 2, 620, 621, 7, 52, 2, 2, 621, 623, 7, 38, 2, 2, 622, 
	620, 3, 2, 2, 2, 623, 626, 3, 2, 2, 2, 624, 622, 3, 2, 2, 2, 624, 625, 
	3, 2, 2, 2, 625, 75, 3, 2, 2, 2, 626, 624, 3, 2, 2, 2, 627, 628, 7, 12, 
	2, 2, 628, 631, 5, 96, 49, 2, 629, 630, 7, 52, 2, 2, 630, 632, 5, 96, 49, 
	2, 631, 629, 3, 2, 2, 2, 631, 632, 3, 2, 2, 2, 632, 77, 3, 2, 2, 2, 633, 
	642, 5, 80, 41, 2, 634, 642, 5, 82, 42, 2, 635, 642, 5, 84, 43, 2, 636, 
	642, 5, 86, 44, 2, 637, 642, 5, 88, 45, 2, 638, 642, 5, 14, 8, 2, 639, 
	642, 5, 150, 76, 2, 640, 642, 5, 12, 7, 2, 641, 633, 3, 2, 2, 2, 641, 634, 
	3, 2, 2, 2, 641, 635, 3, 2, 2, 2, 641, 636, 3, 2, 2, 2, 641, 637, 3, 2, 
	2, 2, 641, 638, 3, 2, 2, 2, 641, 639, 3, 2, 2, 2, 641, 640, 3, 2, 2, 2, 
	642, 79, 3, 2, 2, 2, 643, 644, 7, 13, 2, 2, 644, 645, 5, 96, 49, 2, 645, 
	646, 7, 53, 2, 2, 646, 654, 5, 94, 48, 2, 647, 648, 7, 14, 2, 2, 648, 649, 
	5, 96, 49, 2, 649, 650, 7, 53, 2, 2, 650, 651, 5, 94, 48, 2, 651, 653, 
	3, 2, 2, 2, 652, 647, 3, 2, 2, 2, 653, 656, 3, 2, 2, 2, 654, 652, 3, 2, 
	2, 2, 654, 655, 3, 2, 2, 2, 655, 660, 3, 2, 2, 2, 656, 654, 3, 2, 2, 2, 
	657, 658, 7, 15, 2, 2, 658, 659, 7, 53, 2, 2, 659, 661, 5, 94, 48, 2, 660, 
	657, 3, 2, 2, 2, 660, 661, 3, 2, 2, 2, 661, 81, 3, 2, 2, 2, 662, 663, 7, 
	16, 2, 2, 663, 664, 5, 96, 49, 2, 664, 665, 7, 53, 2, 2, 665, 669, 5, 94, 
	48, 2, 666, 667, 7, 15, 2, 2, 667, 668, 7, 53, 2, 2, 668, 670, 5, 94, 48, 
	2, 669, 666, 3, 2, 2, 2, 669, 670, 3, 2, 2, 2, 670, 83, 3, 2, 2, 2, 671, 
	672, 7, 17, 2, 2, 672, 673, 5, 144, 73, 2, 673, 674, 7, 18, 2, 2, 674, 
	675, 5, 146, 74, 2, 675, 676, 7, 53, 2, 2, 676, 680, 5, 94, 48, 2, 677, 
	678, 7, 15, 2, 2, 678, 679, 7, 53, 2, 2, 679, 681, 5, 94, 48, 2, 680, 677, 
	3, 2, 2, 2, 680, 681, 3, 2, 2, 2, 681, 85, 3, 2, 2, 2, 682, 683, 7, 19, 
	2, 2, 683, 684, 7, 53, 2, 2, 684, 706, 5, 94, 48, 2, 685, 686, 5, 92, 47, 
	2, 686, 687, 7, 53, 2, 2, 687, 688, 5, 94, 48, 2, 688, 690, 3, 2, 2, 2, 
	689, 685, 3, 2, 2, 2, 690, 691, 3, 2, 2, 2, 691, 689, 3, 2, 2, 2, 691, 
	692, 3, 2, 2, 2, 692, 696, 3, 2, 2, 2, 693, 694, 7, 15, 2, 2, 694, 695, 
	7, 53, 2, 2, 695, 697, 5, 94, 48, 2, 696, 693, 3, 2, 2, 2, 696, 697, 3, 
	2, 2, 2, 697, 701, 3, 2, 2, 2, 698, 699, 7, 20, 2, 2, 699, 700, 7, 53, 
	2, 2, 700, 702, 5, 94, 48, 2, 701, 698, 3, 2, 2, 2, 701, 702, 3, 2, 2, 
	2, 702, 707, 3, 2, 2, 2, 703, 704, 7, 20, 2, 2, 704, 705, 7, 53, 2, 2, 
	705, 707, 5, 94, 48, 2, 706, 689, 3, 2, 2, 2, 706, 703, 3, 2, 2, 2, 707, 
	87, 3, 2, 2, 2, 708, 709, 7, 21, 2, 2, 709, 714, 5, 90, 46, 2, 710, 711, 
	7, 52, 2, 2, 711, 713, 5, 90, 46, 2, 712, 710, 3, 2, 2, 2, 713, 716, 3, 
	2, 2, 2, 714, 712, 3, 2, 2, 2, 714, 715, 3, 2, 2, 2, 715, 717, 3, 2, 2, 
	2, 716, 714, 3, 2, 2, 2, 717, 718, 7, 53, 2, 2, 718, 719, 5, 94, 48, 2, 
	719, 89, 3, 2, 2, 2, 720, 723, 5, 96, 49, 2, 721, 722, 7, 9, 2, 2, 722, 
	724, 5, 116, 59, 2, 723, 721, 3, 2, 2, 2, 723, 724, 3, 2, 2, 2, 724, 91, 
	3, 2, 2, 2, 725, 731, 7, 22, 2, 2, 726, 729, 5, 96, 49, 2, 727, 728, 7, 
	9, 2, 2, 728, 730, 7, 38, 2, 2, 729, 727, 3, 2, 2, 2, 729, 730, 3, 2, 2, 
	2, 730, 732, 3, 2, 2, 2, 731, 726, 3, 2, 2, 2, 731, 732, 3, 2, 2, 2, 732, 
	739, 3, 2, 2, 2, 733, 734, 7, 22, 2, 2, 734, 735, 7, 38, 2, 2, 735, 736, 
	7, 52, 2, 2, 736, 737, 7, 38, 2, 2, 737, 739, 8, 47, 1, 2, 738, 725, 3, 
	2, 2, 2, 738, 733, 3, 2, 2, 2, 739, 93, 3, 2, 2, 2, 740, 751, 5, 28, 15, 
	2, 741, 742, 7, 37, 2, 2, 742, 744, 7, 96, 2, 2, 743, 745, 5, 26, 14, 2, 
	744, 743, 3, 2, 2, 2, 745, 746, 3, 2, 2, 2, 746, 744, 3, 2, 2, 2, 746, 
	747, 3, 2, 2, 2, 747, 748, 3, 2, 2, 2, 748, 749, 7, 97, 2, 2, 749, 751, 
	3, 2, 2, 2, 750, 740, 3, 2, 2, 2, 750, 741, 3, 2, 2, 2, 751, 95, 3, 2, 
	2, 2, 752, 758, 5, 104, 53, 2, 753, 754, 7, 13, 2, 2, 754, 755, 5, 104, 
	53, 2, 755, 756, 7, 15, 2, 2, 756, 757, 5, 96, 49, 2, 757, 759, 3, 2, 2, 
	2, 758, 753, 3, 2, 2, 2, 758, 759, 3, 2, 2, 2, 759, 762, 3, 2, 2, 2, 760, 
	762, 5, 100, 51, 2, 761, 752, 3, 2, 2, 2, 761, 760, 3, 2, 2, 2, 762, 97, 
	3, 2, 2, 2, 763, 766, 5, 104, 53, 2, 764, 766, 5, 102, 52, 2, 765, 763, 
	3, 2, 2, 2, 765, 764, 3, 2, 2, 2, 766, 99, 3, 2, 2, 2, 767, 769, 7, 23, 
	2, 2, 768, 770, 5, 22, 12, 2, 769, 768, 3, 2, 2, 2, 769, 770, 3, 2, 2, 
	2, 770, 771, 3, 2, 2, 2, 771, 772, 7, 53, 2, 2, 772, 773, 5, 96, 49, 2, 
	773, 101, 3, 2, 2, 2, 774, 776, 7, 23, 2, 2, 775, 777, 5, 22, 12, 2, 776, 
	775, 3, 2, 2, 2, 776, 777, 3, 2, 2, 2, 777, 778, 3, 2, 2, 2, 778, 779, 
	7, 53, 2, 2, 779, 780, 5, 98, 50, 2, 780, 103, 3, 2, 2, 2, 781, 786, 5, 
	106, 54, 2, 782, 783, 7, 24, 2, 2, 783, 785, 5, 106, 54, 2, 784, 782, 3, 
	2, 2, 2, 785, 788, 3, 2, 2, 2, 786, 784, 3, 2, 2, 2, 786, 787, 3, 2, 2, 
	2, 787, 105, 3, 2, 2, 2, 788, 786, 3, 2, 2, 2, 789, 794, 5, 108, 55, 2, 
	790, 791, 7, 25, 2, 2, 791, 793, 5, 108, 55, 2, 792, 790, 3, 2, 2, 2, 793, 
	796, 3, 2, 2, 2, 794, 792, 3, 2, 2, 2, 794, 795, 3, 2, 2, 2, 795, 107, 
	3, 2, 2, 2, 796, 794, 3, 2, 2, 2, 797, 798, 7, 26, 2, 2, 798, 801, 5, 108, 
	55, 2, 799, 801, 5, 110, 56, 2, 800, 797, 3, 2, 2, 2, 800, 799, 3, 2, 2, 
	2, 801, 109, 3, 2, 2, 2, 802, 808, 5, 114, 58, 2, 803, 804, 5, 112, 57, 
	2, 804, 805, 5, 114, 58, 2, 805, 807, 3, 2, 2, 2, 806, 803, 3, 2, 2, 2, 
	807, 810, 3, 2, 2, 2, 808, 806, 3, 2, 2, 2, 808, 809, 3, 2, 2, 2, 809, 
	111, 3, 2, 2, 2, 810, 808, 3, 2, 2, 2, 811, 825, 7, 72, 2, 2, 812, 825, 
	7, 73, 2, 2, 813, 825, 7, 74, 2, 2, 814, 825, 7, 75, 2, 2, 815, 825, 7, 
	76, 2, 2, 816, 825, 7, 77, 2, 2, 817, 825, 7, 78, 2, 2, 818, 825, 7, 18, 
	2, 2, 819, 820, 7, 26, 2, 2, 820, 825, 7, 18, 2, 2, 821, 825, 7, 27, 2, 
	2, 822, 823, 7, 27, 2, 2, 823, 825, 7, 26, 2, 2, 824, 811, 3, 2, 2, 2, 
	824, 812, 3, 2, 2, 2, 824, 813, 3, 2, 2, 2, 824, 814, 3, 2, 2, 2, 824, 
	815, 3, 2, 2, 2, 824, 816, 3, 2, 2, 2, 824, 817, 3, 2, 2, 2, 824, 818, 
	3, 2, 2, 2, 824, 819, 3, 2, 2, 2, 824, 821, 3, 2, 2, 2, 824, 822, 3, 2, 
	2, 2, 825, 113, 3, 2, 2, 2, 826, 828, 7, 49, 2, 2, 827, 826, 3, 2, 2, 2, 
	827, 828, 3, 2, 2, 2, 828, 829, 3, 2, 2, 2, 829, 830, 5, 116, 59, 2, 830, 
	115, 3, 2, 2, 2, 831, 836, 5, 118, 60, 2, 832, 833, 7, 59, 2, 2, 833, 835, 
	5, 118, 60, 2, 834, 832, 3, 2, 2, 2, 835, 838, 3, 2, 2, 2, 836, 834, 3, 
	2, 2, 2, 836, 837, 3, 2, 2, 2, 837, 117, 3, 2, 2, 2, 838, 836, 3, 2, 2, 
	2, 839, 844, 5, 120, 61, 2, 840, 841, 7, 60, 2, 2, 841, 843, 5, 120, 61, 
	2, 842, 840, 3, 2, 2, 2, 843, 846, 3, 2, 2, 2, 844, 842, 3, 2, 2, 2, 844, 
	845, 3, 2, 2, 2, 845, 119, 3, 2, 2, 2, 846, 844, 3, 2, 2, 2, 847, 852, 
	5, 122, 62, 2, 848, 849, 7, 61, 2, 2, 849, 851, 5, 122, 62, 2, 850, 848, 
	3, 2, 2, 2, 851, 854, 3, 2, 2, 2, 852, 850, 3, 2, 2, 2, 852, 853, 3, 2, 
	2, 2, 853, 121, 3, 2, 2, 2, 854, 852, 3, 2, 2, 2, 855, 862, 5, 124, 63, 
	2, 856, 857, 7, 62, 2, 2, 857, 861, 5, 124, 63, 2, 858, 859, 7, 63, 2, 
	2, 859, 861, 5, 124, 63, 2, 860, 856, 3, 2, 2, 2, 860, 858, 3, 2, 2, 2, 
	861, 864, 3, 2, 2, 2, 862, 860, 3, 2, 2, 2, 862, 863, 3, 2, 2, 2, 863, 
	123, 3, 2, 2, 2, 864, 862, 3, 2, 2, 2, 865, 872, 5, 126, 64, 2, 866, 867, 
	7, 64, 2, 2, 867, 871, 5, 126, 64, 2, 868, 869, 7, 65, 2, 2, 869, 871, 
	5, 126, 64, 2, 870, 866, 3, 2, 2, 2, 870, 868, 3, 2, 2, 2, 871, 874, 3, 
	2, 2, 2, 872, 870, 3, 2, 2, 2, 872, 873, 3, 2, 2, 2, 873, 125, 3, 2, 2, 
	2, 874, 872, 3, 2, 2, 2, 875, 888, 5, 128, 65, 2, 876, 877, 7, 49, 2, 2, 
	877, 887, 5, 128, 65, 2, 878, 879, 7, 66, 2, 2, 879, 887, 5, 128, 65, 2, 
	880, 881, 7, 67, 2, 2, 881, 887, 5, 128, 65, 2, 882, 883, 7, 68, 2, 2, 
	883, 887, 5, 128, 65, 2, 884, 885, 7, 79, 2, 2, 885, 887, 5, 128, 65, 2, 
	886, 876, 3, 2, 2, 2, 886, 878, 3, 2, 2, 2, 886, 880, 3, 2, 2, 2, 886, 
	882, 3, 2, 2, 2, 886, 884, 3, 2, 2, 2, 887, 890, 3, 2, 2, 2, 888, 886, 
	3, 2, 2, 2, 888, 889, 3, 2, 2, 2, 889, 127, 3, 2, 2, 2, 890, 888, 3, 2, 
	2, 2, 891, 892, 7, 64, 2, 2, 892, 899, 5, 128, 65, 2, 893, 894, 7, 65, 
	2, 2, 894, 899, 5, 128, 65, 2, 895, 896, 7, 69, 2, 2, 896, 899, 5, 128, 
	65, 2, 897, 899, 5, 130, 66, 2, 898, 891, 3, 2, 2, 2, 898, 893, 3, 2, 2, 
	2, 898, 895, 3, 2, 2, 2, 898, 897, 3, 2, 2, 2, 899, 129, 3, 2, 2, 2, 900, 
	904, 5, 132, 67, 2, 901, 903, 5, 136, 69, 2, 902, 901, 3, 2, 2, 2, 903, 
	906, 3, 2, 2, 2, 904, 902, 3, 2, 2, 2, 904, 905, 3, 2, 2, 2, 905, 909, 
	3, 2, 2, 2, 906, 904, 3, 2, 2, 2, 907, 908, 7, 55, 2, 2, 908, 910, 5, 128, 
	65, 2, 909, 907, 3, 2, 2, 2, 909, 910, 3, 2, 2, 2, 910, 131, 3, 2, 2, 2, 
	911, 914, 7, 50, 2, 2, 912, 915, 5, 162, 82, 2, 913, 915, 5, 134, 68, 2, 
	914, 912, 3, 2, 2, 2, 914, 913, 3, 2, 2, 2, 914, 915, 3, 2, 2, 2, 915, 
	916, 3, 2, 2, 2, 916, 940, 7, 51, 2, 2, 917, 919, 7, 57, 2, 2, 918, 920, 
	5, 134, 68, 2, 919, 918, 3, 2, 2, 2, 919, 920, 3, 2, 2, 2, 920, 921, 3, 
	2, 2, 2, 921, 940, 7, 58, 2, 2, 922, 924, 7, 70, 2, 2, 923, 925, 5, 148, 
	75, 2, 924, 923, 3, 2, 2, 2, 924, 925, 3, 2, 2, 2, 925, 926, 3, 2, 2, 2, 
	926, 940, 7, 71, 2, 2, 927, 928, 8, 67, 1, 2, 928, 940, 7, 38, 2, 2, 929, 
	940, 5, 168, 85, 2, 930, 932, 5, 166, 84, 2, 931, 930, 3, 2, 2, 2, 932, 
	933, 3, 2, 2, 2, 933, 931, 3, 2, 2, 2, 933, 934, 3, 2, 2, 2, 934, 940, 
	3, 2, 2, 2, 935, 940, 7, 48, 2, 2, 936, 940, 7, 28, 2, 2, 937, 940, 7, 
	29, 2, 2, 938, 940, 7, 30, 2, 2, 939, 911, 3, 2, 2, 2, 939, 917, 3, 2, 
	2, 2, 939, 922, 3, 2, 2, 2, 939, 927, 3, 2, 2, 2, 939, 929, 3, 2, 2, 2, 
	939, 931, 3, 2, 2, 2, 939, 935, 3, 2, 2, 2, 939, 936, 3, 2, 2, 2, 939, 
	937, 3, 2, 2, 2, 939, 938, 3, 2, 2, 2, 940, 133, 3, 2, 2, 2, 941, 953, 
	5, 96, 49, 2, 942, 954, 5, 158, 80, 2, 943, 944, 7, 52, 2, 2, 944, 946, 
	5, 96, 49, 2, 945, 943, 3, 2, 2, 2, 946, 949, 3, 2, 2, 2, 947, 945, 3, 
	2, 2, 2, 947, 948, 3, 2, 2, 2, 948, 951, 3, 2, 2, 2, 949, 947, 3, 2, 2, 
	2, 950, 952, 7, 52, 2, 2, 951, 950, 3, 2, 2, 2, 951, 952, 3, 2, 2, 2, 952, 
	954, 3, 2, 2, 2, 953, 942, 3, 2, 2, 2, 953, 947, 3, 2, 2, 2, 954, 135, 
	3, 2, 2, 2, 955, 957, 7, 50, 2, 2, 956, 958, 5, 152, 77, 2, 957, 956, 3, 
	2, 2, 2, 957, 958, 3, 2, 2, 2, 958, 959, 3, 2, 2, 2, 959, 968, 7, 51, 2, 
	2, 960, 961, 7, 57, 2, 2, 961, 962, 5, 138, 70, 2, 962, 963, 7, 58, 2, 
	2, 963, 968, 3, 2, 2, 2, 964, 965, 7, 47, 2, 2, 965, 966, 7, 38, 2, 2, 
	966, 968, 8, 69, 1, 2, 967, 955, 3, 2, 2, 2, 967, 960, 3, 2, 2, 2, 967, 
	964, 3, 2, 2, 2, 968, 137, 3, 2, 2, 2, 969, 974, 5, 140, 71, 2, 970, 971, 
	7, 52, 2, 2, 971, 973, 5, 140, 71, 2, 972, 970, 3, 2, 2, 2, 973, 976, 3, 
	2, 2, 2, 974, 972, 3, 2, 2, 2, 974, 975, 3, 2, 2, 2, 975, 978, 3, 2, 2, 
	2, 976, 974, 3, 2, 2, 2, 977, 979, 7, 52, 2, 2, 978, 977, 3, 2, 2, 2, 978, 
	979, 3, 2, 2, 2, 979, 139, 3, 2, 2, 2, 980, 992, 5, 96, 49, 2, 981, 983, 
	5, 96, 49, 2, 982, 981, 3, 2, 2, 2, 982, 983, 3, 2, 2, 2, 983, 984, 3, 
	2, 2, 2, 984, 986, 7, 53, 2, 2, 985, 987, 5, 96, 49, 2, 986, 985, 3, 2, 
	2, 2, 986, 987, 3, 2, 2, 2, 987, 989, 3, 2, 2, 2, 988, 990, 5, 142, 72, 
	2, 989, 988, 3, 2, 2, 2, 989, 990, 3, 2, 2, 2, 990, 992, 3, 2, 2, 2, 991, 
	980, 3, 2, 2, 2, 991, 982, 3, 2, 2, 2, 992, 141, 3, 2, 2, 2, 993, 995, 
	7, 53, 2, 2, 994, 996, 5, 96, 49, 2, 995, 994, 3, 2, 2, 2, 995, 996, 3, 
	2, 2, 2, 996, 143, 3, 2, 2, 2, 997, 1002, 5, 114, 58, 2, 998, 999, 7, 52, 
	2, 2, 999, 1001, 5, 114, 58, 2, 1000, 998, 3, 2, 2, 2, 1001, 1004, 3, 2, 
	2, 2, 1002, 1000, 3, 2, 2, 2, 1002, 1003, 3, 2, 2, 2, 1003, 1006, 3, 2, 
	2, 2, 1004, 1002, 3, 2, 2, 2, 1005, 1007, 7, 52, 2, 2, 1006, 1005, 3, 2, 
	2, 2, 1006, 1007, 3, 2, 2, 2, 1007, 145, 3, 2, 2, 2, 1008, 1013, 5, 96, 
	49, 2, 1009, 1010, 7, 52, 2, 2, 1010, 1012, 5, 96, 49, 2, 1011, 1009, 3, 
	2, 2, 2, 1012, 1015, 3, 2, 2, 2, 1013, 1011, 3, 2, 2, 2, 1013, 1014, 3, 
	2, 2, 2, 1014, 1017, 3, 2, 2, 2, 1015, 1013, 3, 2, 2, 2, 1016, 1018, 7, 
	52, 2, 2, 1017, 1016, 3, 2, 2, 2, 1017, 1018, 3, 2, 2, 2, 1018, 147, 3, 
	2, 2, 2, 1019, 1020, 5, 96, 49, 2, 1020, 1021, 7, 53, 2, 2, 1021, 1036, 
	5, 96, 49, 2, 1022, 1037, 5, 158, 80, 2, 1023, 1024, 7, 52, 2, 2, 1024, 
	1025, 5, 96, 49, 2, 1025, 1026, 7, 53, 2, 2, 1026, 1027, 5, 96, 49, 2, 
	1027, 1029, 3, 2, 2, 2, 1028, 1023, 3, 2, 2, 2, 1029, 1032, 3, 2, 2, 2, 
	1030, 1028, 3, 2, 2, 2, 1030, 1031, 3, 2, 2, 2, 1031, 1034, 3, 2, 2, 2, 
	1032, 1030, 3, 2, 2, 2, 1033, 1035, 7, 52, 2, 2, 1034, 1033, 3, 2, 2, 2, 
	1034, 1035, 3, 2, 2, 2, 1035, 1037, 3, 2, 2, 2, 1036, 1022, 3, 2, 2, 2, 
	1036, 1030, 3, 2, 2, 2, 1037, 1053, 3, 2, 2, 2, 1038, 1050, 5, 96, 49, 
	2, 1039, 1051, 5, 158, 80, 2, 1040, 1041, 7, 52, 2, 2, 1041, 1043, 5, 96, 
	49, 2, 1042, 1040, 3, 2, 2, 2, 1043, 1046, 3, 2, 2, 2, 1044, 1042, 3, 2, 
	2, 2, 1044, 1045, 3, 2, 2, 2, 1045, 1048, 3, 2, 2, 2, 1046, 1044, 3, 2, 
	2, 2, 1047, 1049, 7, 52, 2, 2, 1048, 1047, 3, 2, 2, 2, 1048, 1049, 3, 2, 
	2, 2, 1049, 1051, 3, 2, 2, 2, 1050, 1039, 3, 2, 2, 2, 1050, 1044, 3, 2, 
	2, 2, 1051, 1053, 3, 2, 2, 2, 1052, 1019, 3, 2, 2, 2, 1052, 1038, 3, 2, 
	2, 2, 1053, 149, 3, 2, 2, 2, 1054, 1055, 7, 31, 2, 2, 1055, 1061, 7, 38, 
	2, 2, 1056, 1058, 7, 50, 2, 2, 1057, 1059, 5, 152, 77, 2, 1058, 1057, 3, 
	2, 2, 2, 1058, 1059, 3, 2, 2, 2, 1059, 1060, 3, 2, 2, 2, 1060, 1062, 7, 
	51, 2, 2, 1061, 1056, 3, 2, 2, 2, 1061, 1062, 3, 2, 2, 2, 1062, 1063, 3, 
	2, 2, 2, 1063, 1064, 7, 53, 2, 2, 1064, 1065, 5, 94, 48, 2, 1065, 151, 
	3, 2, 2, 2, 1066, 1067, 5, 154, 78, 2, 1067, 1068, 7, 52, 2, 2, 1068, 1070, 
	3, 2, 2, 2, 1069, 1066, 3, 2, 2, 2, 1070, 1073, 3, 2, 2, 2, 1071, 1069, 
	3, 2, 2, 2, 1071, 1072, 3, 2, 2, 2, 1072, 1094, 3, 2, 2, 2, 1073, 1071, 
	3, 2, 2, 2, 1074, 1076, 5, 154, 78, 2, 1075, 1077, 7, 52, 2, 2, 1076, 1075, 
	3, 2, 2, 2, 1076, 1077, 3, 2, 2, 2, 1077, 1095, 3, 2, 2, 2, 1078, 1079, 
	7, 49, 2, 2, 1079, 1084, 5, 96, 49, 2, 1080, 1081, 7, 52, 2, 2, 1081, 1083, 
	5, 154, 78, 2, 1082, 1080, 3, 2, 2, 2, 1083, 1086, 3, 2, 2, 2, 1084, 1082, 
	3, 2, 2, 2, 1084, 1085, 3, 2, 2, 2, 1085, 1090, 3, 2, 2, 2, 1086, 1084, 
	3, 2, 2, 2, 1087, 1088, 7, 52, 2, 2, 1088, 1089, 7, 55, 2, 2, 1089, 1091, 
	5, 96, 49, 2, 1090, 1087, 3, 2, 2, 2, 1090, 1091, 3, 2, 2, 2, 1091, 1095, 
	3, 2, 2, 2, 1092, 1093, 7, 55, 2, 2, 1093, 1095, 5, 96, 49, 2, 1094, 1074, 
	3, 2, 2, 2, 1094, 1078, 3, 2, 2, 2, 1094, 1092, 3, 2, 2, 2, 1095, 153, 
	3, 2, 2, 2, 1096, 1098, 5, 96, 49, 2, 1097, 1099, 5, 158, 80, 2, 1098, 
	1097, 3, 2, 2, 2, 1098, 1099, 3, 2, 2, 2, 1099, 1105, 3, 2, 2, 2, 1100, 
	1101, 5, 96, 49, 2, 1101, 1102, 7, 56, 2, 2, 1102, 1103, 5, 96, 49, 2, 
	1103, 1105, 3, 2, 2, 2, 1104, 1096, 3, 2, 2, 2, 1104, 1100, 3, 2, 2, 2, 
	1105, 155, 3, 2, 2, 2, 1106, 1109, 5, 158, 80, 2, 1107, 1109, 5, 160, 81, 
	2, 1108, 1106, 3, 2, 2, 2, 1108, 1107, 3, 2, 2, 2, 1109, 157, 3, 2, 2, 
	2, 1110, 1111, 7, 17, 2, 2, 1111, 1112, 5, 144, 73, 2, 1112, 1113, 7, 18, 
	2, 2, 1113, 1115, 5, 104, 53, 2, 1114, 1116, 5, 156, 79, 2, 1115, 1114, 
	3, 2, 2, 2, 1115, 1116, 3, 2, 2, 2, 1116, 159, 3, 2, 2, 2, 1117, 1118, 
	7, 13, 2, 2, 1118, 1120, 5, 98, 50, 2, 1119, 1121, 5, 156, 79, 2, 1120, 
	1119, 3, 2, 2, 2, 1120, 1121, 3, 2, 2, 2, 1121, 161, 3, 2, 2, 2, 1122, 
	1124, 7, 32, 2, 2, 1123, 1125, 5, 164, 83, 2, 1124, 1123, 3, 2, 2, 2, 1124, 
	1125, 3, 2, 2, 2, 1125, 163, 3, 2, 2, 2, 1126, 1127, 7, 7, 2, 2, 1127, 
	1130, 5, 96, 49, 2, 1128, 1130, 5, 146, 74, 2, 1129, 1126, 3, 2, 2, 2, 
	1129, 1128, 3, 2, 2, 2, 1130, 165, 3, 2, 2, 2, 1131, 1132, 9, 4, 2, 2, 
	1132, 167, 3, 2, 2, 2, 1133, 1137, 5, 170, 86, 2, 1134, 1137, 7, 45, 2, 
	2, 1135, 1137, 7, 46, 2, 2, 1136, 1133, 3, 2, 2, 2, 1136, 1134, 3, 2, 2, 
	2, 1136, 1135, 3, 2, 2, 2, 1137, 169, 3, 2, 2, 2, 1138, 1139, 9, 5, 2, 
	2, 1139, 171, 3, 2, 2, 2, 169, 177, 181, 183, 192, 201, 204, 211, 216, 
	223, 230, 237, 243, 247, 253, 259, 263, 269, 273, 275, 279, 285, 289, 295, 
	299, 304, 309, 315, 319, 325, 331, 335, 341, 345, 347, 351, 357, 361, 367, 
	371, 377, 384, 388, 401, 410, 414, 416, 424, 427, 429, 431, 440, 444, 446, 
	454, 457, 459, 461, 464, 470, 475, 479, 482, 486, 491, 495, 499, 513, 521, 
	529, 531, 539, 543, 552, 559, 561, 570, 575, 580, 587, 591, 598, 606, 615, 
	624, 631, 641, 654, 660, 669, 680, 691, 696, 701, 706, 714, 723, 729, 731, 
	738, 746, 750, 758, 761, 765, 769, 776, 786, 794, 800, 808, 824, 827, 836, 
	844, 852, 860, 862, 870, 872, 886, 888, 898, 904, 909, 914, 919, 924, 933, 
	939, 947, 951, 953, 957, 967, 974, 978, 982, 986, 989, 991, 995, 1002, 
	1006, 1013, 1017, 1030, 1034, 1036, 1044, 1048, 1050, 1052, 1058, 1061, 
	1071, 1076, 1084, 1090, 1094, 1098, 1104, 1108, 1115, 1120, 1124, 1129, 
	1136,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'print'", "'def'", "'return'", "'raise'", "'from'", "'import'", "'as'", 
	"'global'", "'nonlocal'", "'assert'", "'if'", "'elif'", "'else'", "'while'", 
	"'for'", "'in'", "'try'", "'finally'", "'with'", "'except'", "'lambda'", 
	"'or'", "'and'", "'not'", "'is'", "'None'", "'True'", "'False'", "'class'", 
	"'yield'", "'del'", "'pass'", "'continue'", "'break'", "", "", "", "", 
	"", "", "", "", "", "", "'.'", "'...'", "'*'", "'('", "')'", "','", "':'", 
	"';'", "'**'", "'='", "'['", "']'", "'|'", "'^'", "'&'", "'<<'", "'>>'", 
	"'+'", "'-'", "'/'", "'%'", "'//'", "'~'", "'{'", "'}'", "'<'", "'>'", 
	"'=='", "'>='", "'<='", "'<>'", "'!='", "'@'", "'->'", "'+='", "'-='", 
	"'*='", "'@='", "'/='", "'%='", "'&='", "'|='", "'^='", "'<<='", "'>>='", 
	"'**='", "'//='",
}
var symbolicNames = []string{
	"", "PRINT", "DEF", "RETURN", "RAISE", "FROM", "IMPORT", "AS", "GLOBAL", 
	"NONLOCAL", "ASSERT", "IF", "ELIF", "ELSE", "WHILE", "FOR", "IN", "TRY", 
	"FINALLY", "WITH", "EXCEPT", "LAMBDA", "OR", "AND", "NOT", "IS", "NONE", 
	"TRUE", "FALSE", "CLASS", "YIELD", "DEL", "PASS", "CONTINUE", "BREAK", 
	"NEWLINE", "NAME", "STRING_LITERAL", "BYTES_LITERAL", "DECIMAL_INTEGER", 
	"OCT_INTEGER", "HEX_INTEGER", "BIN_INTEGER", "FLOAT_NUMBER", "IMAG_NUMBER", 
	"DOT", "ELLIPSIS", "STAR", "OPEN_PAREN", "CLOSE_PAREN", "COMMA", "COLON", 
	"SEMI_COLON", "POWER", "ASSIGN", "OPEN_BRACK", "CLOSE_BRACK", "OR_OP", 
	"XOR", "AND_OP", "LEFT_SHIFT", "RIGHT_SHIFT", "ADD", "MINUS", "DIV", "MOD", 
	"IDIV", "NOT_OP", "OPEN_BRACE", "CLOSE_BRACE", "LESS_THAN", "GREATER_THAN", 
	"EQUALS", "GT_EQ", "LT_EQ", "NOT_EQ_1", "NOT_EQ_2", "AT", "ARROW", "ADD_ASSIGN", 
	"SUB_ASSIGN", "MULT_ASSIGN", "AT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", 
	"OR_ASSIGN", "XOR_ASSIGN", "LEFT_SHIFT_ASSIGN", "RIGHT_SHIFT_ASSIGN", "POWER_ASSIGN", 
	"IDIV_ASSIGN", "SKIP_", "UNKNOWN_CHAR", "INDENT", "DEDENT",
}

var ruleNames = []string{
	"single_input", "file_input", "eval_input", "decorator", "decorators", 
	"decorated", "funcdef", "parameters", "typedargslist", "tfpdef", "varargslist", 
	"vfpdef", "stmt", "simple_stmt", "small_stmt", "print_stmt", "expr_stmt", 
	"testlist_star_expr", "augassign", "del_stmt", "pass_stmt", "flow_stmt", 
	"break_stmt", "continue_stmt", "return_stmt", "yield_stmt", "raise_stmt", 
	"import_stmt", "import_name", "import_from", "import_as_name", "dotted_as_name", 
	"import_as_names", "dotted_as_names", "dotted_name", "global_stmt", "nonlocal_stmt", 
	"assert_stmt", "compound_stmt", "if_stmt", "while_stmt", "for_stmt", "try_stmt", 
	"with_stmt", "with_item", "except_clause", "suite", "test", "test_nocond", 
	"lambdef", "lambdef_nocond", "or_test", "and_test", "not_test", "comparison", 
	"comp_op", "star_expr", "expr", "xor_expr", "and_expr", "shift_expr", "arith_expr", 
	"term", "factor", "power", "atom", "testlist_comp", "trailer", "subscriptlist", 
	"subscript", "sliceop", "exprlist", "testlist", "dictorsetmaker", "classdef", 
	"arglist", "argument", "comp_iter", "comp_for", "comp_if", "yield_expr", 
	"yield_arg", "str", "number", "integer",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type AltPython3Parser struct {
	*antlr.BaseParser
}

func NewAltPython3Parser(input antlr.TokenStream) *AltPython3Parser {
	this := new(AltPython3Parser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "AltPython3.g4"

	return this
}



  // Used in preventing double NoViableAltException throws on the current context's same start token.
  static protected final int ALREADY_THROWN_TOKEN_TYPE = Integer.MIN_VALUE + 23;


  // Whether we've encountered something that is legal Python2
  private boolean likelyIsPython2 = false;

  // This overly long variable denotes whether we should emit exceptions on illegal Python 3 items
  //	(for example, no parens used in a print statement.) If you wish to use this parser to detect
  //	legal Python2, this should be set to false via setStrictPython3Parsing(boolean).
  private boolean throwNoViableAltExceptionOnLegalPython2ButIllegalPython3 = true;

  // This will return an invalid value if getStrictPython3Parsing() returned true prior to parsing.
  public boolean parsedCodeWasPython2 () {
  	return this.likelyIsPython2;
  }

  public boolean getStrictPython3Parsing () {
  	return this.throwNoViableAltExceptionOnLegalPython2ButIllegalPython3;
  }

  // Setting this to true will throw NoViableAltExceptions upon encountering Python2-only code facets; this is true
  //	by default. Set this to false prior to parsing if you wish to invoke parsedCodeWasPython2() after parsing.
  public void setStrictPython3Parsing (boolean flag) {
  	this.throwNoViableAltExceptionOnLegalPython2ButIllegalPython3 = flag;
  }




// AltPython3Parser tokens.
const (
	AltPython3ParserEOF = antlr.TokenEOF
	AltPython3ParserPRINT = 1
	AltPython3ParserDEF = 2
	AltPython3ParserRETURN = 3
	AltPython3ParserRAISE = 4
	AltPython3ParserFROM = 5
	AltPython3ParserIMPORT = 6
	AltPython3ParserAS = 7
	AltPython3ParserGLOBAL = 8
	AltPython3ParserNONLOCAL = 9
	AltPython3ParserASSERT = 10
	AltPython3ParserIF = 11
	AltPython3ParserELIF = 12
	AltPython3ParserELSE = 13
	AltPython3ParserWHILE = 14
	AltPython3ParserFOR = 15
	AltPython3ParserIN = 16
	AltPython3ParserTRY = 17
	AltPython3ParserFINALLY = 18
	AltPython3ParserWITH = 19
	AltPython3ParserEXCEPT = 20
	AltPython3ParserLAMBDA = 21
	AltPython3ParserOR = 22
	AltPython3ParserAND = 23
	AltPython3ParserNOT = 24
	AltPython3ParserIS = 25
	AltPython3ParserNONE = 26
	AltPython3ParserTRUE = 27
	AltPython3ParserFALSE = 28
	AltPython3ParserCLASS = 29
	AltPython3ParserYIELD = 30
	AltPython3ParserDEL = 31
	AltPython3ParserPASS = 32
	AltPython3ParserCONTINUE = 33
	AltPython3ParserBREAK = 34
	AltPython3ParserNEWLINE = 35
	AltPython3ParserNAME = 36
	AltPython3ParserSTRING_LITERAL = 37
	AltPython3ParserBYTES_LITERAL = 38
	AltPython3ParserDECIMAL_INTEGER = 39
	AltPython3ParserOCT_INTEGER = 40
	AltPython3ParserHEX_INTEGER = 41
	AltPython3ParserBIN_INTEGER = 42
	AltPython3ParserFLOAT_NUMBER = 43
	AltPython3ParserIMAG_NUMBER = 44
	AltPython3ParserDOT = 45
	AltPython3ParserELLIPSIS = 46
	AltPython3ParserSTAR = 47
	AltPython3ParserOPEN_PAREN = 48
	AltPython3ParserCLOSE_PAREN = 49
	AltPython3ParserCOMMA = 50
	AltPython3ParserCOLON = 51
	AltPython3ParserSEMI_COLON = 52
	AltPython3ParserPOWER = 53
	AltPython3ParserASSIGN = 54
	AltPython3ParserOPEN_BRACK = 55
	AltPython3ParserCLOSE_BRACK = 56
	AltPython3ParserOR_OP = 57
	AltPython3ParserXOR = 58
	AltPython3ParserAND_OP = 59
	AltPython3ParserLEFT_SHIFT = 60
	AltPython3ParserRIGHT_SHIFT = 61
	AltPython3ParserADD = 62
	AltPython3ParserMINUS = 63
	AltPython3ParserDIV = 64
	AltPython3ParserMOD = 65
	AltPython3ParserIDIV = 66
	AltPython3ParserNOT_OP = 67
	AltPython3ParserOPEN_BRACE = 68
	AltPython3ParserCLOSE_BRACE = 69
	AltPython3ParserLESS_THAN = 70
	AltPython3ParserGREATER_THAN = 71
	AltPython3ParserEQUALS = 72
	AltPython3ParserGT_EQ = 73
	AltPython3ParserLT_EQ = 74
	AltPython3ParserNOT_EQ_1 = 75
	AltPython3ParserNOT_EQ_2 = 76
	AltPython3ParserAT = 77
	AltPython3ParserARROW = 78
	AltPython3ParserADD_ASSIGN = 79
	AltPython3ParserSUB_ASSIGN = 80
	AltPython3ParserMULT_ASSIGN = 81
	AltPython3ParserAT_ASSIGN = 82
	AltPython3ParserDIV_ASSIGN = 83
	AltPython3ParserMOD_ASSIGN = 84
	AltPython3ParserAND_ASSIGN = 85
	AltPython3ParserOR_ASSIGN = 86
	AltPython3ParserXOR_ASSIGN = 87
	AltPython3ParserLEFT_SHIFT_ASSIGN = 88
	AltPython3ParserRIGHT_SHIFT_ASSIGN = 89
	AltPython3ParserPOWER_ASSIGN = 90
	AltPython3ParserIDIV_ASSIGN = 91
	AltPython3ParserSKIP_ = 92
	AltPython3ParserUNKNOWN_CHAR = 93
	AltPython3ParserINDENT = 94
	AltPython3ParserDEDENT = 95
)

// AltPython3Parser rules.
const (
	AltPython3ParserRULE_single_input = 0
	AltPython3ParserRULE_file_input = 1
	AltPython3ParserRULE_eval_input = 2
	AltPython3ParserRULE_decorator = 3
	AltPython3ParserRULE_decorators = 4
	AltPython3ParserRULE_decorated = 5
	AltPython3ParserRULE_funcdef = 6
	AltPython3ParserRULE_parameters = 7
	AltPython3ParserRULE_typedargslist = 8
	AltPython3ParserRULE_tfpdef = 9
	AltPython3ParserRULE_varargslist = 10
	AltPython3ParserRULE_vfpdef = 11
	AltPython3ParserRULE_stmt = 12
	AltPython3ParserRULE_simple_stmt = 13
	AltPython3ParserRULE_small_stmt = 14
	AltPython3ParserRULE_print_stmt = 15
	AltPython3ParserRULE_expr_stmt = 16
	AltPython3ParserRULE_testlist_star_expr = 17
	AltPython3ParserRULE_augassign = 18
	AltPython3ParserRULE_del_stmt = 19
	AltPython3ParserRULE_pass_stmt = 20
	AltPython3ParserRULE_flow_stmt = 21
	AltPython3ParserRULE_break_stmt = 22
	AltPython3ParserRULE_continue_stmt = 23
	AltPython3ParserRULE_return_stmt = 24
	AltPython3ParserRULE_yield_stmt = 25
	AltPython3ParserRULE_raise_stmt = 26
	AltPython3ParserRULE_import_stmt = 27
	AltPython3ParserRULE_import_name = 28
	AltPython3ParserRULE_import_from = 29
	AltPython3ParserRULE_import_as_name = 30
	AltPython3ParserRULE_dotted_as_name = 31
	AltPython3ParserRULE_import_as_names = 32
	AltPython3ParserRULE_dotted_as_names = 33
	AltPython3ParserRULE_dotted_name = 34
	AltPython3ParserRULE_global_stmt = 35
	AltPython3ParserRULE_nonlocal_stmt = 36
	AltPython3ParserRULE_assert_stmt = 37
	AltPython3ParserRULE_compound_stmt = 38
	AltPython3ParserRULE_if_stmt = 39
	AltPython3ParserRULE_while_stmt = 40
	AltPython3ParserRULE_for_stmt = 41
	AltPython3ParserRULE_try_stmt = 42
	AltPython3ParserRULE_with_stmt = 43
	AltPython3ParserRULE_with_item = 44
	AltPython3ParserRULE_except_clause = 45
	AltPython3ParserRULE_suite = 46
	AltPython3ParserRULE_test = 47
	AltPython3ParserRULE_test_nocond = 48
	AltPython3ParserRULE_lambdef = 49
	AltPython3ParserRULE_lambdef_nocond = 50
	AltPython3ParserRULE_or_test = 51
	AltPython3ParserRULE_and_test = 52
	AltPython3ParserRULE_not_test = 53
	AltPython3ParserRULE_comparison = 54
	AltPython3ParserRULE_comp_op = 55
	AltPython3ParserRULE_star_expr = 56
	AltPython3ParserRULE_expr = 57
	AltPython3ParserRULE_xor_expr = 58
	AltPython3ParserRULE_and_expr = 59
	AltPython3ParserRULE_shift_expr = 60
	AltPython3ParserRULE_arith_expr = 61
	AltPython3ParserRULE_term = 62
	AltPython3ParserRULE_factor = 63
	AltPython3ParserRULE_power = 64
	AltPython3ParserRULE_atom = 65
	AltPython3ParserRULE_testlist_comp = 66
	AltPython3ParserRULE_trailer = 67
	AltPython3ParserRULE_subscriptlist = 68
	AltPython3ParserRULE_subscript = 69
	AltPython3ParserRULE_sliceop = 70
	AltPython3ParserRULE_exprlist = 71
	AltPython3ParserRULE_testlist = 72
	AltPython3ParserRULE_dictorsetmaker = 73
	AltPython3ParserRULE_classdef = 74
	AltPython3ParserRULE_arglist = 75
	AltPython3ParserRULE_argument = 76
	AltPython3ParserRULE_comp_iter = 77
	AltPython3ParserRULE_comp_for = 78
	AltPython3ParserRULE_comp_if = 79
	AltPython3ParserRULE_yield_expr = 80
	AltPython3ParserRULE_yield_arg = 81
	AltPython3ParserRULE_str = 82
	AltPython3ParserRULE_number = 83
	AltPython3ParserRULE_integer = 84
)

// ISingle_inputContext is an interface to support dynamic dispatch.
type ISingle_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingle_inputContext differentiates from other interfaces.
	IsSingle_inputContext()
}

type Single_inputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_inputContext() *Single_inputContext {
	var p = new(Single_inputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_single_input
	return p
}

func (*Single_inputContext) IsSingle_inputContext() {}

func NewSingle_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_inputContext {
	var p = new(Single_inputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_single_input

	return p
}

func (s *Single_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_inputContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNEWLINE, 0)
}

func (s *Single_inputContext) Simple_stmt() ISimple_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *Single_inputContext) Compound_stmt() ICompound_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_stmtContext)
}

func (s *Single_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Single_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterSingle_input(s)
	}
}

func (s *Single_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitSingle_input(s)
	}
}

func (s *Single_inputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitSingle_input(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Single_input() (localctx ISingle_inputContext) {
	localctx = NewSingle_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, AltPython3ParserRULE_single_input)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(175)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserNEWLINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(170)
			p.Match(AltPython3ParserNEWLINE)
		}


	case AltPython3ParserPRINT, AltPython3ParserRETURN, AltPython3ParserRAISE, AltPython3ParserFROM, AltPython3ParserIMPORT, AltPython3ParserGLOBAL, AltPython3ParserNONLOCAL, AltPython3ParserASSERT, AltPython3ParserLAMBDA, AltPython3ParserNOT, AltPython3ParserNONE, AltPython3ParserTRUE, AltPython3ParserFALSE, AltPython3ParserYIELD, AltPython3ParserDEL, AltPython3ParserPASS, AltPython3ParserCONTINUE, AltPython3ParserBREAK, AltPython3ParserNAME, AltPython3ParserSTRING_LITERAL, AltPython3ParserBYTES_LITERAL, AltPython3ParserDECIMAL_INTEGER, AltPython3ParserOCT_INTEGER, AltPython3ParserHEX_INTEGER, AltPython3ParserBIN_INTEGER, AltPython3ParserFLOAT_NUMBER, AltPython3ParserIMAG_NUMBER, AltPython3ParserELLIPSIS, AltPython3ParserSTAR, AltPython3ParserOPEN_PAREN, AltPython3ParserOPEN_BRACK, AltPython3ParserADD, AltPython3ParserMINUS, AltPython3ParserNOT_OP, AltPython3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(171)
			p.Simple_stmt()
		}


	case AltPython3ParserDEF, AltPython3ParserIF, AltPython3ParserWHILE, AltPython3ParserFOR, AltPython3ParserTRY, AltPython3ParserWITH, AltPython3ParserCLASS, AltPython3ParserAT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(172)
			p.Compound_stmt()
		}
		{
			p.SetState(173)
			p.Match(AltPython3ParserNEWLINE)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IFile_inputContext is an interface to support dynamic dispatch.
type IFile_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_inputContext differentiates from other interfaces.
	IsFile_inputContext()
}

type File_inputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_inputContext() *File_inputContext {
	var p = new(File_inputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_file_input
	return p
}

func (*File_inputContext) IsFile_inputContext() {}

func NewFile_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_inputContext {
	var p = new(File_inputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_file_input

	return p
}

func (s *File_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *File_inputContext) EOF() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserEOF, 0)
}

func (s *File_inputContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(AltPython3ParserNEWLINE)
}

func (s *File_inputContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNEWLINE, i)
}

func (s *File_inputContext) AllStmt() []IStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStmtContext)(nil)).Elem())
	var tst = make([]IStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStmtContext)
		}
	}

	return tst
}

func (s *File_inputContext) Stmt(i int) IStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *File_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *File_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterFile_input(s)
	}
}

func (s *File_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitFile_input(s)
	}
}

func (s *File_inputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitFile_input(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) File_input() (localctx IFile_inputContext) {
	localctx = NewFile_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, AltPython3ParserRULE_file_input)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(181)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << AltPython3ParserPRINT) | (1 << AltPython3ParserDEF) | (1 << AltPython3ParserRETURN) | (1 << AltPython3ParserRAISE) | (1 << AltPython3ParserFROM) | (1 << AltPython3ParserIMPORT) | (1 << AltPython3ParserGLOBAL) | (1 << AltPython3ParserNONLOCAL) | (1 << AltPython3ParserASSERT) | (1 << AltPython3ParserIF) | (1 << AltPython3ParserWHILE) | (1 << AltPython3ParserFOR) | (1 << AltPython3ParserTRY) | (1 << AltPython3ParserWITH) | (1 << AltPython3ParserLAMBDA) | (1 << AltPython3ParserNOT) | (1 << AltPython3ParserNONE) | (1 << AltPython3ParserTRUE) | (1 << AltPython3ParserFALSE) | (1 << AltPython3ParserCLASS) | (1 << AltPython3ParserYIELD) | (1 << AltPython3ParserDEL))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (AltPython3ParserPASS - 32)) | (1 << (AltPython3ParserCONTINUE - 32)) | (1 << (AltPython3ParserBREAK - 32)) | (1 << (AltPython3ParserNEWLINE - 32)) | (1 << (AltPython3ParserNAME - 32)) | (1 << (AltPython3ParserSTRING_LITERAL - 32)) | (1 << (AltPython3ParserBYTES_LITERAL - 32)) | (1 << (AltPython3ParserDECIMAL_INTEGER - 32)) | (1 << (AltPython3ParserOCT_INTEGER - 32)) | (1 << (AltPython3ParserHEX_INTEGER - 32)) | (1 << (AltPython3ParserBIN_INTEGER - 32)) | (1 << (AltPython3ParserFLOAT_NUMBER - 32)) | (1 << (AltPython3ParserIMAG_NUMBER - 32)) | (1 << (AltPython3ParserELLIPSIS - 32)) | (1 << (AltPython3ParserSTAR - 32)) | (1 << (AltPython3ParserOPEN_PAREN - 32)) | (1 << (AltPython3ParserOPEN_BRACK - 32)) | (1 << (AltPython3ParserADD - 32)) | (1 << (AltPython3ParserMINUS - 32)))) != 0) || ((((_la - 67)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 67))) & ((1 << (AltPython3ParserNOT_OP - 67)) | (1 << (AltPython3ParserOPEN_BRACE - 67)) | (1 << (AltPython3ParserAT - 67)))) != 0) {
		p.SetState(179)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case AltPython3ParserNEWLINE:
			{
				p.SetState(177)
				p.Match(AltPython3ParserNEWLINE)
			}


		case AltPython3ParserPRINT, AltPython3ParserDEF, AltPython3ParserRETURN, AltPython3ParserRAISE, AltPython3ParserFROM, AltPython3ParserIMPORT, AltPython3ParserGLOBAL, AltPython3ParserNONLOCAL, AltPython3ParserASSERT, AltPython3ParserIF, AltPython3ParserWHILE, AltPython3ParserFOR, AltPython3ParserTRY, AltPython3ParserWITH, AltPython3ParserLAMBDA, AltPython3ParserNOT, AltPython3ParserNONE, AltPython3ParserTRUE, AltPython3ParserFALSE, AltPython3ParserCLASS, AltPython3ParserYIELD, AltPython3ParserDEL, AltPython3ParserPASS, AltPython3ParserCONTINUE, AltPython3ParserBREAK, AltPython3ParserNAME, AltPython3ParserSTRING_LITERAL, AltPython3ParserBYTES_LITERAL, AltPython3ParserDECIMAL_INTEGER, AltPython3ParserOCT_INTEGER, AltPython3ParserHEX_INTEGER, AltPython3ParserBIN_INTEGER, AltPython3ParserFLOAT_NUMBER, AltPython3ParserIMAG_NUMBER, AltPython3ParserELLIPSIS, AltPython3ParserSTAR, AltPython3ParserOPEN_PAREN, AltPython3ParserOPEN_BRACK, AltPython3ParserADD, AltPython3ParserMINUS, AltPython3ParserNOT_OP, AltPython3ParserOPEN_BRACE, AltPython3ParserAT:
			{
				p.SetState(178)
				p.Stmt()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(183)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(184)
		p.Match(AltPython3ParserEOF)
	}



	return localctx
}


// IEval_inputContext is an interface to support dynamic dispatch.
type IEval_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEval_inputContext differentiates from other interfaces.
	IsEval_inputContext()
}

type Eval_inputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEval_inputContext() *Eval_inputContext {
	var p = new(Eval_inputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_eval_input
	return p
}

func (*Eval_inputContext) IsEval_inputContext() {}

func NewEval_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Eval_inputContext {
	var p = new(Eval_inputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_eval_input

	return p
}

func (s *Eval_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *Eval_inputContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Eval_inputContext) EOF() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserEOF, 0)
}

func (s *Eval_inputContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(AltPython3ParserNEWLINE)
}

func (s *Eval_inputContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNEWLINE, i)
}

func (s *Eval_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Eval_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Eval_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterEval_input(s)
	}
}

func (s *Eval_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitEval_input(s)
	}
}

func (s *Eval_inputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitEval_input(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Eval_input() (localctx IEval_inputContext) {
	localctx = NewEval_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, AltPython3ParserRULE_eval_input)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(186)
		p.Testlist()
	}
	p.SetState(190)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == AltPython3ParserNEWLINE {
		{
			p.SetState(187)
			p.Match(AltPython3ParserNEWLINE)
		}


		p.SetState(192)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(193)
		p.Match(AltPython3ParserEOF)
	}



	return localctx
}


// IDecoratorContext is an interface to support dynamic dispatch.
type IDecoratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecoratorContext differentiates from other interfaces.
	IsDecoratorContext()
}

type DecoratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorContext() *DecoratorContext {
	var p = new(DecoratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_decorator
	return p
}

func (*DecoratorContext) IsDecoratorContext() {}

func NewDecoratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorContext {
	var p = new(DecoratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_decorator

	return p
}

func (s *DecoratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorContext) Dotted_name() IDotted_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *DecoratorContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNEWLINE, 0)
}

func (s *DecoratorContext) Arglist() IArglistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArglistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *DecoratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DecoratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterDecorator(s)
	}
}

func (s *DecoratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitDecorator(s)
	}
}

func (s *DecoratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitDecorator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Decorator() (localctx IDecoratorContext) {
	localctx = NewDecoratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, AltPython3ParserRULE_decorator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(195)
		p.Match(AltPython3ParserAT)
	}
	{
		p.SetState(196)
		p.Dotted_name()
	}
	p.SetState(202)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserOPEN_PAREN {
		{
			p.SetState(197)
			p.Match(AltPython3ParserOPEN_PAREN)
		}
		p.SetState(199)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 21)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 21))) & ((1 << (AltPython3ParserLAMBDA - 21)) | (1 << (AltPython3ParserNOT - 21)) | (1 << (AltPython3ParserNONE - 21)) | (1 << (AltPython3ParserTRUE - 21)) | (1 << (AltPython3ParserFALSE - 21)) | (1 << (AltPython3ParserNAME - 21)) | (1 << (AltPython3ParserSTRING_LITERAL - 21)) | (1 << (AltPython3ParserBYTES_LITERAL - 21)) | (1 << (AltPython3ParserDECIMAL_INTEGER - 21)) | (1 << (AltPython3ParserOCT_INTEGER - 21)) | (1 << (AltPython3ParserHEX_INTEGER - 21)) | (1 << (AltPython3ParserBIN_INTEGER - 21)) | (1 << (AltPython3ParserFLOAT_NUMBER - 21)) | (1 << (AltPython3ParserIMAG_NUMBER - 21)) | (1 << (AltPython3ParserELLIPSIS - 21)) | (1 << (AltPython3ParserSTAR - 21)) | (1 << (AltPython3ParserOPEN_PAREN - 21)))) != 0) || ((((_la - 53)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 53))) & ((1 << (AltPython3ParserPOWER - 53)) | (1 << (AltPython3ParserOPEN_BRACK - 53)) | (1 << (AltPython3ParserADD - 53)) | (1 << (AltPython3ParserMINUS - 53)) | (1 << (AltPython3ParserNOT_OP - 53)) | (1 << (AltPython3ParserOPEN_BRACE - 53)))) != 0) {
			{
				p.SetState(198)
				p.Arglist()
			}

		}
		{
			p.SetState(201)
			p.Match(AltPython3ParserCLOSE_PAREN)
		}

	}
	{
		p.SetState(204)
		p.Match(AltPython3ParserNEWLINE)
	}



	return localctx
}


// IDecoratorsContext is an interface to support dynamic dispatch.
type IDecoratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecoratorsContext differentiates from other interfaces.
	IsDecoratorsContext()
}

type DecoratorsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorsContext() *DecoratorsContext {
	var p = new(DecoratorsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_decorators
	return p
}

func (*DecoratorsContext) IsDecoratorsContext() {}

func NewDecoratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorsContext {
	var p = new(DecoratorsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_decorators

	return p
}

func (s *DecoratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorsContext) AllDecorator() []IDecoratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDecoratorContext)(nil)).Elem())
	var tst = make([]IDecoratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDecoratorContext)
		}
	}

	return tst
}

func (s *DecoratorsContext) Decorator(i int) IDecoratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecoratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDecoratorContext)
}

func (s *DecoratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DecoratorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterDecorators(s)
	}
}

func (s *DecoratorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitDecorators(s)
	}
}

func (s *DecoratorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitDecorators(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Decorators() (localctx IDecoratorsContext) {
	localctx = NewDecoratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, AltPython3ParserRULE_decorators)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(207)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == AltPython3ParserAT {
		{
			p.SetState(206)
			p.Decorator()
		}


		p.SetState(209)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IDecoratedContext is an interface to support dynamic dispatch.
type IDecoratedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecoratedContext differentiates from other interfaces.
	IsDecoratedContext()
}

type DecoratedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratedContext() *DecoratedContext {
	var p = new(DecoratedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_decorated
	return p
}

func (*DecoratedContext) IsDecoratedContext() {}

func NewDecoratedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratedContext {
	var p = new(DecoratedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_decorated

	return p
}

func (s *DecoratedContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratedContext) Decorators() IDecoratorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecoratorsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecoratorsContext)
}

func (s *DecoratedContext) Classdef() IClassdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassdefContext)
}

func (s *DecoratedContext) Funcdef() IFuncdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *DecoratedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DecoratedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterDecorated(s)
	}
}

func (s *DecoratedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitDecorated(s)
	}
}

func (s *DecoratedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitDecorated(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Decorated() (localctx IDecoratedContext) {
	localctx = NewDecoratedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, AltPython3ParserRULE_decorated)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(211)
		p.Decorators()
	}
	p.SetState(214)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserCLASS:
		{
			p.SetState(212)
			p.Classdef()
		}


	case AltPython3ParserDEF:
		{
			p.SetState(213)
			p.Funcdef()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IFuncdefContext is an interface to support dynamic dispatch.
type IFuncdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFuncdefContext differentiates from other interfaces.
	IsFuncdefContext()
}

type FuncdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncdefContext() *FuncdefContext {
	var p = new(FuncdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_funcdef
	return p
}

func (*FuncdefContext) IsFuncdefContext() {}

func NewFuncdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncdefContext {
	var p = new(FuncdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_funcdef

	return p
}

func (s *FuncdefContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncdefContext) DEF() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserDEF, 0)
}

func (s *FuncdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNAME, 0)
}

func (s *FuncdefContext) Parameters() IParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FuncdefContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *FuncdefContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *FuncdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FuncdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterFuncdef(s)
	}
}

func (s *FuncdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitFuncdef(s)
	}
}

func (s *FuncdefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitFuncdef(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Funcdef() (localctx IFuncdefContext) {
	localctx = NewFuncdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, AltPython3ParserRULE_funcdef)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(216)
		p.Match(AltPython3ParserDEF)
	}
	{
		p.SetState(217)
		p.Match(AltPython3ParserNAME)
	}
	{
		p.SetState(218)
		p.Parameters()
	}
	p.SetState(221)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserARROW {
		{
			p.SetState(219)
			p.Match(AltPython3ParserARROW)
		}
		{
			p.SetState(220)
			p.Test()
		}

	}
	{
		p.SetState(223)
		p.Match(AltPython3ParserCOLON)
	}
	{
		p.SetState(224)
		p.Suite()
	}



	return localctx
}


// IParametersContext is an interface to support dynamic dispatch.
type IParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParametersContext differentiates from other interfaces.
	IsParametersContext()
}

type ParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersContext() *ParametersContext {
	var p = new(ParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_parameters
	return p
}

func (*ParametersContext) IsParametersContext() {}

func NewParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersContext {
	var p = new(ParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_parameters

	return p
}

func (s *ParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersContext) Typedargslist() ITypedargslistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedargslistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedargslistContext)
}

func (s *ParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterParameters(s)
	}
}

func (s *ParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitParameters(s)
	}
}

func (s *ParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitParameters(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Parameters() (localctx IParametersContext) {
	localctx = NewParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, AltPython3ParserRULE_parameters)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(226)
		p.Match(AltPython3ParserOPEN_PAREN)
	}
	p.SetState(228)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 36)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 36))) & ((1 << (AltPython3ParserNAME - 36)) | (1 << (AltPython3ParserSTAR - 36)) | (1 << (AltPython3ParserPOWER - 36)))) != 0) {
		{
			p.SetState(227)
			p.Typedargslist()
		}

	}
	{
		p.SetState(230)
		p.Match(AltPython3ParserCLOSE_PAREN)
	}



	return localctx
}


// ITypedargslistContext is an interface to support dynamic dispatch.
type ITypedargslistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedargslistContext differentiates from other interfaces.
	IsTypedargslistContext()
}

type TypedargslistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedargslistContext() *TypedargslistContext {
	var p = new(TypedargslistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_typedargslist
	return p
}

func (*TypedargslistContext) IsTypedargslistContext() {}

func NewTypedargslistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedargslistContext {
	var p = new(TypedargslistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_typedargslist

	return p
}

func (s *TypedargslistContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedargslistContext) AllTfpdef() []ITfpdefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITfpdefContext)(nil)).Elem())
	var tst = make([]ITfpdefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITfpdefContext)
		}
	}

	return tst
}

func (s *TypedargslistContext) Tfpdef(i int) ITfpdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITfpdefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITfpdefContext)
}

func (s *TypedargslistContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *TypedargslistContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TypedargslistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedargslistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypedargslistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterTypedargslist(s)
	}
}

func (s *TypedargslistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitTypedargslist(s)
	}
}

func (s *TypedargslistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitTypedargslist(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Typedargslist() (localctx ITypedargslistContext) {
	localctx = NewTypedargslistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, AltPython3ParserRULE_typedargslist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(297)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(232)
			p.Tfpdef()
		}
		p.SetState(235)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == AltPython3ParserASSIGN {
			{
				p.SetState(233)
				p.Match(AltPython3ParserASSIGN)
			}
			{
				p.SetState(234)
				p.Test()
			}

		}
		p.SetState(245)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(237)
					p.Match(AltPython3ParserCOMMA)
				}
				{
					p.SetState(238)
					p.Tfpdef()
				}
				p.SetState(241)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == AltPython3ParserASSIGN {
					{
						p.SetState(239)
						p.Match(AltPython3ParserASSIGN)
					}
					{
						p.SetState(240)
						p.Test()
					}

				}


			}
			p.SetState(247)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())
		}
		p.SetState(273)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == AltPython3ParserCOMMA {
			{
				p.SetState(248)
				p.Match(AltPython3ParserCOMMA)
			}
			p.SetState(271)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case AltPython3ParserSTAR:
				{
					p.SetState(249)
					p.Match(AltPython3ParserSTAR)
				}
				p.SetState(251)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == AltPython3ParserNAME {
					{
						p.SetState(250)
						p.Tfpdef()
					}

				}
				p.SetState(261)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(253)
							p.Match(AltPython3ParserCOMMA)
						}
						{
							p.SetState(254)
							p.Tfpdef()
						}
						p.SetState(257)
						p.GetErrorHandler().Sync(p)
						_la = p.GetTokenStream().LA(1)


						if _la == AltPython3ParserASSIGN {
							{
								p.SetState(255)
								p.Match(AltPython3ParserASSIGN)
							}
							{
								p.SetState(256)
								p.Test()
							}

						}


					}
					p.SetState(263)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext())
				}
				p.SetState(267)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == AltPython3ParserCOMMA {
					{
						p.SetState(264)
						p.Match(AltPython3ParserCOMMA)
					}
					{
						p.SetState(265)
						p.Match(AltPython3ParserPOWER)
					}
					{
						p.SetState(266)
						p.Tfpdef()
					}

				}


			case AltPython3ParserPOWER:
				{
					p.SetState(269)
					p.Match(AltPython3ParserPOWER)
				}
				{
					p.SetState(270)
					p.Tfpdef()
				}


			case AltPython3ParserCLOSE_PAREN:



			default:
			}

		}


	case AltPython3ParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(275)
			p.Match(AltPython3ParserSTAR)
		}
		p.SetState(277)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == AltPython3ParserNAME {
			{
				p.SetState(276)
				p.Tfpdef()
			}

		}
		p.SetState(287)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(279)
					p.Match(AltPython3ParserCOMMA)
				}
				{
					p.SetState(280)
					p.Tfpdef()
				}
				p.SetState(283)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == AltPython3ParserASSIGN {
					{
						p.SetState(281)
						p.Match(AltPython3ParserASSIGN)
					}
					{
						p.SetState(282)
						p.Test()
					}

				}


			}
			p.SetState(289)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
		}
		p.SetState(293)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == AltPython3ParserCOMMA {
			{
				p.SetState(290)
				p.Match(AltPython3ParserCOMMA)
			}
			{
				p.SetState(291)
				p.Match(AltPython3ParserPOWER)
			}
			{
				p.SetState(292)
				p.Tfpdef()
			}

		}


	case AltPython3ParserPOWER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(295)
			p.Match(AltPython3ParserPOWER)
		}
		{
			p.SetState(296)
			p.Tfpdef()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ITfpdefContext is an interface to support dynamic dispatch.
type ITfpdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTfpdefContext differentiates from other interfaces.
	IsTfpdefContext()
}

type TfpdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTfpdefContext() *TfpdefContext {
	var p = new(TfpdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_tfpdef
	return p
}

func (*TfpdefContext) IsTfpdefContext() {}

func NewTfpdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TfpdefContext {
	var p = new(TfpdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_tfpdef

	return p
}

func (s *TfpdefContext) GetParser() antlr.Parser { return s.parser }

func (s *TfpdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNAME, 0)
}

func (s *TfpdefContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TfpdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TfpdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TfpdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterTfpdef(s)
	}
}

func (s *TfpdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitTfpdef(s)
	}
}

func (s *TfpdefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitTfpdef(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Tfpdef() (localctx ITfpdefContext) {
	localctx = NewTfpdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, AltPython3ParserRULE_tfpdef)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(299)
		p.Match(AltPython3ParserNAME)
	}
	p.SetState(302)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserCOLON {
		{
			p.SetState(300)
			p.Match(AltPython3ParserCOLON)
		}
		{
			p.SetState(301)
			p.Test()
		}

	}



	return localctx
}


// IVarargslistContext is an interface to support dynamic dispatch.
type IVarargslistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarargslistContext differentiates from other interfaces.
	IsVarargslistContext()
}

type VarargslistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarargslistContext() *VarargslistContext {
	var p = new(VarargslistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_varargslist
	return p
}

func (*VarargslistContext) IsVarargslistContext() {}

func NewVarargslistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarargslistContext {
	var p = new(VarargslistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_varargslist

	return p
}

func (s *VarargslistContext) GetParser() antlr.Parser { return s.parser }

func (s *VarargslistContext) AllVfpdef() []IVfpdefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVfpdefContext)(nil)).Elem())
	var tst = make([]IVfpdefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVfpdefContext)
		}
	}

	return tst
}

func (s *VarargslistContext) Vfpdef(i int) IVfpdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVfpdefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVfpdefContext)
}

func (s *VarargslistContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *VarargslistContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *VarargslistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarargslistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VarargslistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterVarargslist(s)
	}
}

func (s *VarargslistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitVarargslist(s)
	}
}

func (s *VarargslistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitVarargslist(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Varargslist() (localctx IVarargslistContext) {
	localctx = NewVarargslistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, AltPython3ParserRULE_varargslist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(369)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(304)
			p.Vfpdef()
		}
		p.SetState(307)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == AltPython3ParserASSIGN {
			{
				p.SetState(305)
				p.Match(AltPython3ParserASSIGN)
			}
			{
				p.SetState(306)
				p.Test()
			}

		}
		p.SetState(317)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(309)
					p.Match(AltPython3ParserCOMMA)
				}
				{
					p.SetState(310)
					p.Vfpdef()
				}
				p.SetState(313)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == AltPython3ParserASSIGN {
					{
						p.SetState(311)
						p.Match(AltPython3ParserASSIGN)
					}
					{
						p.SetState(312)
						p.Test()
					}

				}


			}
			p.SetState(319)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())
		}
		p.SetState(345)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == AltPython3ParserCOMMA {
			{
				p.SetState(320)
				p.Match(AltPython3ParserCOMMA)
			}
			p.SetState(343)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case AltPython3ParserSTAR:
				{
					p.SetState(321)
					p.Match(AltPython3ParserSTAR)
				}
				p.SetState(323)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == AltPython3ParserNAME {
					{
						p.SetState(322)
						p.Vfpdef()
					}

				}
				p.SetState(333)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(325)
							p.Match(AltPython3ParserCOMMA)
						}
						{
							p.SetState(326)
							p.Vfpdef()
						}
						p.SetState(329)
						p.GetErrorHandler().Sync(p)
						_la = p.GetTokenStream().LA(1)


						if _la == AltPython3ParserASSIGN {
							{
								p.SetState(327)
								p.Match(AltPython3ParserASSIGN)
							}
							{
								p.SetState(328)
								p.Test()
							}

						}


					}
					p.SetState(335)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())
				}
				p.SetState(339)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == AltPython3ParserCOMMA {
					{
						p.SetState(336)
						p.Match(AltPython3ParserCOMMA)
					}
					{
						p.SetState(337)
						p.Match(AltPython3ParserPOWER)
					}
					{
						p.SetState(338)
						p.Vfpdef()
					}

				}


			case AltPython3ParserPOWER:
				{
					p.SetState(341)
					p.Match(AltPython3ParserPOWER)
				}
				{
					p.SetState(342)
					p.Vfpdef()
				}


			case AltPython3ParserCOLON:



			default:
			}

		}


	case AltPython3ParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(347)
			p.Match(AltPython3ParserSTAR)
		}
		p.SetState(349)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == AltPython3ParserNAME {
			{
				p.SetState(348)
				p.Vfpdef()
			}

		}
		p.SetState(359)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(351)
					p.Match(AltPython3ParserCOMMA)
				}
				{
					p.SetState(352)
					p.Vfpdef()
				}
				p.SetState(355)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == AltPython3ParserASSIGN {
					{
						p.SetState(353)
						p.Match(AltPython3ParserASSIGN)
					}
					{
						p.SetState(354)
						p.Test()
					}

				}


			}
			p.SetState(361)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())
		}
		p.SetState(365)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == AltPython3ParserCOMMA {
			{
				p.SetState(362)
				p.Match(AltPython3ParserCOMMA)
			}
			{
				p.SetState(363)
				p.Match(AltPython3ParserPOWER)
			}
			{
				p.SetState(364)
				p.Vfpdef()
			}

		}


	case AltPython3ParserPOWER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(367)
			p.Match(AltPython3ParserPOWER)
		}
		{
			p.SetState(368)
			p.Vfpdef()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IVfpdefContext is an interface to support dynamic dispatch.
type IVfpdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVfpdefContext differentiates from other interfaces.
	IsVfpdefContext()
}

type VfpdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVfpdefContext() *VfpdefContext {
	var p = new(VfpdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_vfpdef
	return p
}

func (*VfpdefContext) IsVfpdefContext() {}

func NewVfpdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VfpdefContext {
	var p = new(VfpdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_vfpdef

	return p
}

func (s *VfpdefContext) GetParser() antlr.Parser { return s.parser }

func (s *VfpdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNAME, 0)
}

func (s *VfpdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VfpdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VfpdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterVfpdef(s)
	}
}

func (s *VfpdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitVfpdef(s)
	}
}

func (s *VfpdefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitVfpdef(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Vfpdef() (localctx IVfpdefContext) {
	localctx = NewVfpdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, AltPython3ParserRULE_vfpdef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(371)
		p.Match(AltPython3ParserNAME)
	}



	return localctx
}


// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_stmt
	return p
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) Simple_stmt() ISimple_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *StmtContext) Compound_stmt() ICompound_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_stmtContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitStmt(s)
	}
}

func (s *StmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitStmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, AltPython3ParserRULE_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(375)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserPRINT, AltPython3ParserRETURN, AltPython3ParserRAISE, AltPython3ParserFROM, AltPython3ParserIMPORT, AltPython3ParserGLOBAL, AltPython3ParserNONLOCAL, AltPython3ParserASSERT, AltPython3ParserLAMBDA, AltPython3ParserNOT, AltPython3ParserNONE, AltPython3ParserTRUE, AltPython3ParserFALSE, AltPython3ParserYIELD, AltPython3ParserDEL, AltPython3ParserPASS, AltPython3ParserCONTINUE, AltPython3ParserBREAK, AltPython3ParserNAME, AltPython3ParserSTRING_LITERAL, AltPython3ParserBYTES_LITERAL, AltPython3ParserDECIMAL_INTEGER, AltPython3ParserOCT_INTEGER, AltPython3ParserHEX_INTEGER, AltPython3ParserBIN_INTEGER, AltPython3ParserFLOAT_NUMBER, AltPython3ParserIMAG_NUMBER, AltPython3ParserELLIPSIS, AltPython3ParserSTAR, AltPython3ParserOPEN_PAREN, AltPython3ParserOPEN_BRACK, AltPython3ParserADD, AltPython3ParserMINUS, AltPython3ParserNOT_OP, AltPython3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(373)
			p.Simple_stmt()
		}


	case AltPython3ParserDEF, AltPython3ParserIF, AltPython3ParserWHILE, AltPython3ParserFOR, AltPython3ParserTRY, AltPython3ParserWITH, AltPython3ParserCLASS, AltPython3ParserAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(374)
			p.Compound_stmt()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ISimple_stmtContext is an interface to support dynamic dispatch.
type ISimple_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_stmtContext differentiates from other interfaces.
	IsSimple_stmtContext()
}

type Simple_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_stmtContext() *Simple_stmtContext {
	var p = new(Simple_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_simple_stmt
	return p
}

func (*Simple_stmtContext) IsSimple_stmtContext() {}

func NewSimple_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_stmtContext {
	var p = new(Simple_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_simple_stmt

	return p
}

func (s *Simple_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_stmtContext) AllSmall_stmt() []ISmall_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISmall_stmtContext)(nil)).Elem())
	var tst = make([]ISmall_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISmall_stmtContext)
		}
	}

	return tst
}

func (s *Simple_stmtContext) Small_stmt(i int) ISmall_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISmall_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISmall_stmtContext)
}

func (s *Simple_stmtContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNEWLINE, 0)
}

func (s *Simple_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Simple_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterSimple_stmt(s)
	}
}

func (s *Simple_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitSimple_stmt(s)
	}
}

func (s *Simple_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitSimple_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Simple_stmt() (localctx ISimple_stmtContext) {
	localctx = NewSimple_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, AltPython3ParserRULE_simple_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(377)
		p.Small_stmt()
	}
	p.SetState(382)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(378)
				p.Match(AltPython3ParserSEMI_COLON)
			}
			{
				p.SetState(379)
				p.Small_stmt()
			}


		}
		p.SetState(384)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())
	}
	p.SetState(386)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserSEMI_COLON {
		{
			p.SetState(385)
			p.Match(AltPython3ParserSEMI_COLON)
		}

	}
	{
		p.SetState(388)
		p.Match(AltPython3ParserNEWLINE)
	}



	return localctx
}


// ISmall_stmtContext is an interface to support dynamic dispatch.
type ISmall_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSmall_stmtContext differentiates from other interfaces.
	IsSmall_stmtContext()
}

type Small_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySmall_stmtContext() *Small_stmtContext {
	var p = new(Small_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_small_stmt
	return p
}

func (*Small_stmtContext) IsSmall_stmtContext() {}

func NewSmall_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Small_stmtContext {
	var p = new(Small_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_small_stmt

	return p
}

func (s *Small_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Small_stmtContext) Print_stmt() IPrint_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrint_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrint_stmtContext)
}

func (s *Small_stmtContext) Expr_stmt() IExpr_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_stmtContext)
}

func (s *Small_stmtContext) Del_stmt() IDel_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDel_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDel_stmtContext)
}

func (s *Small_stmtContext) Pass_stmt() IPass_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_stmtContext)
}

func (s *Small_stmtContext) Flow_stmt() IFlow_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_stmtContext)
}

func (s *Small_stmtContext) Import_stmt() IImport_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_stmtContext)
}

func (s *Small_stmtContext) Global_stmt() IGlobal_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobal_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobal_stmtContext)
}

func (s *Small_stmtContext) Nonlocal_stmt() INonlocal_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonlocal_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonlocal_stmtContext)
}

func (s *Small_stmtContext) Assert_stmt() IAssert_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssert_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssert_stmtContext)
}

func (s *Small_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Small_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Small_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterSmall_stmt(s)
	}
}

func (s *Small_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitSmall_stmt(s)
	}
}

func (s *Small_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitSmall_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Small_stmt() (localctx ISmall_stmtContext) {
	localctx = NewSmall_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, AltPython3ParserRULE_small_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(399)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserPRINT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(390)
			p.Print_stmt()
		}


	case AltPython3ParserLAMBDA, AltPython3ParserNOT, AltPython3ParserNONE, AltPython3ParserTRUE, AltPython3ParserFALSE, AltPython3ParserNAME, AltPython3ParserSTRING_LITERAL, AltPython3ParserBYTES_LITERAL, AltPython3ParserDECIMAL_INTEGER, AltPython3ParserOCT_INTEGER, AltPython3ParserHEX_INTEGER, AltPython3ParserBIN_INTEGER, AltPython3ParserFLOAT_NUMBER, AltPython3ParserIMAG_NUMBER, AltPython3ParserELLIPSIS, AltPython3ParserSTAR, AltPython3ParserOPEN_PAREN, AltPython3ParserOPEN_BRACK, AltPython3ParserADD, AltPython3ParserMINUS, AltPython3ParserNOT_OP, AltPython3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(391)
			p.Expr_stmt()
		}


	case AltPython3ParserDEL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(392)
			p.Del_stmt()
		}


	case AltPython3ParserPASS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(393)
			p.Pass_stmt()
		}


	case AltPython3ParserRETURN, AltPython3ParserRAISE, AltPython3ParserYIELD, AltPython3ParserCONTINUE, AltPython3ParserBREAK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(394)
			p.Flow_stmt()
		}


	case AltPython3ParserFROM, AltPython3ParserIMPORT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(395)
			p.Import_stmt()
		}


	case AltPython3ParserGLOBAL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(396)
			p.Global_stmt()
		}


	case AltPython3ParserNONLOCAL:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(397)
			p.Nonlocal_stmt()
		}


	case AltPython3ParserASSERT:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(398)
			p.Assert_stmt()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IPrint_stmtContext is an interface to support dynamic dispatch.
type IPrint_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrint_stmtContext differentiates from other interfaces.
	IsPrint_stmtContext()
}

type Print_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrint_stmtContext() *Print_stmtContext {
	var p = new(Print_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_print_stmt
	return p
}

func (*Print_stmtContext) IsPrint_stmtContext() {}

func NewPrint_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Print_stmtContext {
	var p = new(Print_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_print_stmt

	return p
}

func (s *Print_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Print_stmtContext) PRINT() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserPRINT, 0)
}

func (s *Print_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Print_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Print_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Print_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Print_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterPrint_stmt(s)
	}
}

func (s *Print_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitPrint_stmt(s)
	}
}

func (s *Print_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitPrint_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Print_stmt() (localctx IPrint_stmtContext) {
	localctx = NewPrint_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, AltPython3ParserRULE_print_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(462)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(401)
			p.Match(AltPython3ParserPRINT)
		}
		{
			p.SetState(402)
			p.Match(AltPython3ParserOPEN_PAREN)
		}
		p.SetState(429)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case AltPython3ParserLAMBDA, AltPython3ParserNOT, AltPython3ParserNONE, AltPython3ParserTRUE, AltPython3ParserFALSE, AltPython3ParserNAME, AltPython3ParserSTRING_LITERAL, AltPython3ParserBYTES_LITERAL, AltPython3ParserDECIMAL_INTEGER, AltPython3ParserOCT_INTEGER, AltPython3ParserHEX_INTEGER, AltPython3ParserBIN_INTEGER, AltPython3ParserFLOAT_NUMBER, AltPython3ParserIMAG_NUMBER, AltPython3ParserELLIPSIS, AltPython3ParserSTAR, AltPython3ParserOPEN_PAREN, AltPython3ParserCLOSE_PAREN, AltPython3ParserOPEN_BRACK, AltPython3ParserADD, AltPython3ParserMINUS, AltPython3ParserNOT_OP, AltPython3ParserOPEN_BRACE:
			p.SetState(414)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if ((((_la - 21)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 21))) & ((1 << (AltPython3ParserLAMBDA - 21)) | (1 << (AltPython3ParserNOT - 21)) | (1 << (AltPython3ParserNONE - 21)) | (1 << (AltPython3ParserTRUE - 21)) | (1 << (AltPython3ParserFALSE - 21)) | (1 << (AltPython3ParserNAME - 21)) | (1 << (AltPython3ParserSTRING_LITERAL - 21)) | (1 << (AltPython3ParserBYTES_LITERAL - 21)) | (1 << (AltPython3ParserDECIMAL_INTEGER - 21)) | (1 << (AltPython3ParserOCT_INTEGER - 21)) | (1 << (AltPython3ParserHEX_INTEGER - 21)) | (1 << (AltPython3ParserBIN_INTEGER - 21)) | (1 << (AltPython3ParserFLOAT_NUMBER - 21)) | (1 << (AltPython3ParserIMAG_NUMBER - 21)) | (1 << (AltPython3ParserELLIPSIS - 21)) | (1 << (AltPython3ParserSTAR - 21)) | (1 << (AltPython3ParserOPEN_PAREN - 21)))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (AltPython3ParserOPEN_BRACK - 55)) | (1 << (AltPython3ParserADD - 55)) | (1 << (AltPython3ParserMINUS - 55)) | (1 << (AltPython3ParserNOT_OP - 55)) | (1 << (AltPython3ParserOPEN_BRACE - 55)))) != 0) {
				{
					p.SetState(403)
					p.Test()
				}
				p.SetState(408)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(404)
							p.Match(AltPython3ParserCOMMA)
						}
						{
							p.SetState(405)
							p.Test()
						}


					}
					p.SetState(410)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())
				}
				p.SetState(412)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == AltPython3ParserCOMMA {
					{
						p.SetState(411)
						p.Match(AltPython3ParserCOMMA)
					}

				}

			}


		case AltPython3ParserRIGHT_SHIFT:
			{
				p.SetState(416)
				p.Match(AltPython3ParserRIGHT_SHIFT)
			}
			{
				p.SetState(417)
				p.Test()
			}
			p.SetState(427)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == AltPython3ParserCOMMA {
				p.SetState(420)
				p.GetErrorHandler().Sync(p)
				_alt = 1
				for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					switch _alt {
					case 1:
							{
								p.SetState(418)
								p.Match(AltPython3ParserCOMMA)
							}
							{
								p.SetState(419)
								p.Test()
							}




					default:
						panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					}

					p.SetState(422)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())
				}
				p.SetState(425)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == AltPython3ParserCOMMA {
					{
						p.SetState(424)
						p.Match(AltPython3ParserCOMMA)
					}

				}

			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(431)
			p.Match(AltPython3ParserCLOSE_PAREN)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(432)
			p.Match(AltPython3ParserPRINT)
		}
		p.SetState(459)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case AltPython3ParserLAMBDA, AltPython3ParserNOT, AltPython3ParserNONE, AltPython3ParserTRUE, AltPython3ParserFALSE, AltPython3ParserNEWLINE, AltPython3ParserNAME, AltPython3ParserSTRING_LITERAL, AltPython3ParserBYTES_LITERAL, AltPython3ParserDECIMAL_INTEGER, AltPython3ParserOCT_INTEGER, AltPython3ParserHEX_INTEGER, AltPython3ParserBIN_INTEGER, AltPython3ParserFLOAT_NUMBER, AltPython3ParserIMAG_NUMBER, AltPython3ParserELLIPSIS, AltPython3ParserSTAR, AltPython3ParserOPEN_PAREN, AltPython3ParserSEMI_COLON, AltPython3ParserOPEN_BRACK, AltPython3ParserADD, AltPython3ParserMINUS, AltPython3ParserNOT_OP, AltPython3ParserOPEN_BRACE:
			p.SetState(444)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if ((((_la - 21)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 21))) & ((1 << (AltPython3ParserLAMBDA - 21)) | (1 << (AltPython3ParserNOT - 21)) | (1 << (AltPython3ParserNONE - 21)) | (1 << (AltPython3ParserTRUE - 21)) | (1 << (AltPython3ParserFALSE - 21)) | (1 << (AltPython3ParserNAME - 21)) | (1 << (AltPython3ParserSTRING_LITERAL - 21)) | (1 << (AltPython3ParserBYTES_LITERAL - 21)) | (1 << (AltPython3ParserDECIMAL_INTEGER - 21)) | (1 << (AltPython3ParserOCT_INTEGER - 21)) | (1 << (AltPython3ParserHEX_INTEGER - 21)) | (1 << (AltPython3ParserBIN_INTEGER - 21)) | (1 << (AltPython3ParserFLOAT_NUMBER - 21)) | (1 << (AltPython3ParserIMAG_NUMBER - 21)) | (1 << (AltPython3ParserELLIPSIS - 21)) | (1 << (AltPython3ParserSTAR - 21)) | (1 << (AltPython3ParserOPEN_PAREN - 21)))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (AltPython3ParserOPEN_BRACK - 55)) | (1 << (AltPython3ParserADD - 55)) | (1 << (AltPython3ParserMINUS - 55)) | (1 << (AltPython3ParserNOT_OP - 55)) | (1 << (AltPython3ParserOPEN_BRACE - 55)))) != 0) {
				{
					p.SetState(433)
					p.Test()
				}
				p.SetState(438)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(434)
							p.Match(AltPython3ParserCOMMA)
						}
						{
							p.SetState(435)
							p.Test()
						}


					}
					p.SetState(440)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())
				}
				p.SetState(442)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == AltPython3ParserCOMMA {
					{
						p.SetState(441)
						p.Match(AltPython3ParserCOMMA)
					}

				}

			}


		case AltPython3ParserRIGHT_SHIFT:
			{
				p.SetState(446)
				p.Match(AltPython3ParserRIGHT_SHIFT)
			}
			{
				p.SetState(447)
				p.Test()
			}
			p.SetState(457)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == AltPython3ParserCOMMA {
				p.SetState(450)
				p.GetErrorHandler().Sync(p)
				_alt = 1
				for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					switch _alt {
					case 1:
							{
								p.SetState(448)
								p.Match(AltPython3ParserCOMMA)
							}
							{
								p.SetState(449)
								p.Test()
							}




					default:
						panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					}

					p.SetState(452)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext())
				}
				p.SetState(455)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)


				if _la == AltPython3ParserCOMMA {
					{
						p.SetState(454)
						p.Match(AltPython3ParserCOMMA)
					}

				}

			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		 	if (this.getStrictPython3Parsing()) {
				Token printToken = ((org.antlr.v4.runtime.tree.TerminalNodeImpl)this._ctx.children.get(0)).getSymbol();
				Token startingOffender = ((org.antlr.v4.runtime.ParserRuleContext)this._ctx.children.get(1)).getStart();

				throw new NoViableAltException(this, this.getInputStream(), printToken, startingOffender, null,
											   this._ctx);
		 	}
		 	else {
		 		this.likelyIsPython2 = true;
		 	}
		 

	}


	return localctx
}


// IExpr_stmtContext is an interface to support dynamic dispatch.
type IExpr_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_stmtContext differentiates from other interfaces.
	IsExpr_stmtContext()
}

type Expr_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_stmtContext() *Expr_stmtContext {
	var p = new(Expr_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_expr_stmt
	return p
}

func (*Expr_stmtContext) IsExpr_stmtContext() {}

func NewExpr_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_stmtContext {
	var p = new(Expr_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_expr_stmt

	return p
}

func (s *Expr_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_stmtContext) AllTestlist_star_expr() []ITestlist_star_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestlist_star_exprContext)(nil)).Elem())
	var tst = make([]ITestlist_star_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestlist_star_exprContext)
		}
	}

	return tst
}

func (s *Expr_stmtContext) Testlist_star_expr(i int) ITestlist_star_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlist_star_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestlist_star_exprContext)
}

func (s *Expr_stmtContext) Augassign() IAugassignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAugassignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAugassignContext)
}

func (s *Expr_stmtContext) AllYield_expr() []IYield_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IYield_exprContext)(nil)).Elem())
	var tst = make([]IYield_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IYield_exprContext)
		}
	}

	return tst
}

func (s *Expr_stmtContext) Yield_expr(i int) IYield_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *Expr_stmtContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Expr_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitExpr_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Expr_stmt() (localctx IExpr_stmtContext) {
	localctx = NewExpr_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, AltPython3ParserRULE_expr_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(464)
		p.Testlist_star_expr()
	}
	p.SetState(480)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserADD_ASSIGN, AltPython3ParserSUB_ASSIGN, AltPython3ParserMULT_ASSIGN, AltPython3ParserAT_ASSIGN, AltPython3ParserDIV_ASSIGN, AltPython3ParserMOD_ASSIGN, AltPython3ParserAND_ASSIGN, AltPython3ParserOR_ASSIGN, AltPython3ParserXOR_ASSIGN, AltPython3ParserLEFT_SHIFT_ASSIGN, AltPython3ParserRIGHT_SHIFT_ASSIGN, AltPython3ParserPOWER_ASSIGN, AltPython3ParserIDIV_ASSIGN:
		{
			p.SetState(465)
			p.Augassign()
		}
		p.SetState(468)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case AltPython3ParserYIELD:
			{
				p.SetState(466)
				p.Yield_expr()
			}


		case AltPython3ParserLAMBDA, AltPython3ParserNOT, AltPython3ParserNONE, AltPython3ParserTRUE, AltPython3ParserFALSE, AltPython3ParserNAME, AltPython3ParserSTRING_LITERAL, AltPython3ParserBYTES_LITERAL, AltPython3ParserDECIMAL_INTEGER, AltPython3ParserOCT_INTEGER, AltPython3ParserHEX_INTEGER, AltPython3ParserBIN_INTEGER, AltPython3ParserFLOAT_NUMBER, AltPython3ParserIMAG_NUMBER, AltPython3ParserELLIPSIS, AltPython3ParserSTAR, AltPython3ParserOPEN_PAREN, AltPython3ParserOPEN_BRACK, AltPython3ParserADD, AltPython3ParserMINUS, AltPython3ParserNOT_OP, AltPython3ParserOPEN_BRACE:
			{
				p.SetState(467)
				p.Testlist()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}


	case AltPython3ParserNEWLINE, AltPython3ParserSEMI_COLON, AltPython3ParserASSIGN:
		p.SetState(477)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == AltPython3ParserASSIGN {
			{
				p.SetState(470)
				p.Match(AltPython3ParserASSIGN)
			}
			p.SetState(473)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case AltPython3ParserYIELD:
				{
					p.SetState(471)
					p.Yield_expr()
				}


			case AltPython3ParserLAMBDA, AltPython3ParserNOT, AltPython3ParserNONE, AltPython3ParserTRUE, AltPython3ParserFALSE, AltPython3ParserNAME, AltPython3ParserSTRING_LITERAL, AltPython3ParserBYTES_LITERAL, AltPython3ParserDECIMAL_INTEGER, AltPython3ParserOCT_INTEGER, AltPython3ParserHEX_INTEGER, AltPython3ParserBIN_INTEGER, AltPython3ParserFLOAT_NUMBER, AltPython3ParserIMAG_NUMBER, AltPython3ParserELLIPSIS, AltPython3ParserSTAR, AltPython3ParserOPEN_PAREN, AltPython3ParserOPEN_BRACK, AltPython3ParserADD, AltPython3ParserMINUS, AltPython3ParserNOT_OP, AltPython3ParserOPEN_BRACE:
				{
					p.SetState(472)
					p.Testlist_star_expr()
				}



			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}


			p.SetState(479)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// ITestlist_star_exprContext is an interface to support dynamic dispatch.
type ITestlist_star_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestlist_star_exprContext differentiates from other interfaces.
	IsTestlist_star_exprContext()
}

type Testlist_star_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlist_star_exprContext() *Testlist_star_exprContext {
	var p = new(Testlist_star_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_testlist_star_expr
	return p
}

func (*Testlist_star_exprContext) IsTestlist_star_exprContext() {}

func NewTestlist_star_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Testlist_star_exprContext {
	var p = new(Testlist_star_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_testlist_star_expr

	return p
}

func (s *Testlist_star_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Testlist_star_exprContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Testlist_star_exprContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Testlist_star_exprContext) AllStar_expr() []IStar_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStar_exprContext)(nil)).Elem())
	var tst = make([]IStar_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStar_exprContext)
		}
	}

	return tst
}

func (s *Testlist_star_exprContext) Star_expr(i int) IStar_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStar_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *Testlist_star_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Testlist_star_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Testlist_star_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterTestlist_star_expr(s)
	}
}

func (s *Testlist_star_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitTestlist_star_expr(s)
	}
}

func (s *Testlist_star_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitTestlist_star_expr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Testlist_star_expr() (localctx ITestlist_star_exprContext) {
	localctx = NewTestlist_star_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, AltPython3ParserRULE_testlist_star_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(484)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(482)
			p.Test()
		}


	case 2:
		{
			p.SetState(483)
			p.Star_expr()
		}

	}
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(486)
				p.Match(AltPython3ParserCOMMA)
			}
			p.SetState(489)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(487)
					p.Test()
				}


			case 2:
				{
					p.SetState(488)
					p.Star_expr()
				}

			}


		}
		p.SetState(495)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())
	}
	p.SetState(497)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserCOMMA {
		{
			p.SetState(496)
			p.Match(AltPython3ParserCOMMA)
		}

	}



	return localctx
}


// IAugassignContext is an interface to support dynamic dispatch.
type IAugassignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAugassignContext differentiates from other interfaces.
	IsAugassignContext()
}

type AugassignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAugassignContext() *AugassignContext {
	var p = new(AugassignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_augassign
	return p
}

func (*AugassignContext) IsAugassignContext() {}

func NewAugassignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AugassignContext {
	var p = new(AugassignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_augassign

	return p
}

func (s *AugassignContext) GetParser() antlr.Parser { return s.parser }
func (s *AugassignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AugassignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AugassignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterAugassign(s)
	}
}

func (s *AugassignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitAugassign(s)
	}
}

func (s *AugassignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitAugassign(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Augassign() (localctx IAugassignContext) {
	localctx = NewAugassignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, AltPython3ParserRULE_augassign)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(499)
	_la = p.GetTokenStream().LA(1)

	if !(((((_la - 79)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 79))) & ((1 << (AltPython3ParserADD_ASSIGN - 79)) | (1 << (AltPython3ParserSUB_ASSIGN - 79)) | (1 << (AltPython3ParserMULT_ASSIGN - 79)) | (1 << (AltPython3ParserAT_ASSIGN - 79)) | (1 << (AltPython3ParserDIV_ASSIGN - 79)) | (1 << (AltPython3ParserMOD_ASSIGN - 79)) | (1 << (AltPython3ParserAND_ASSIGN - 79)) | (1 << (AltPython3ParserOR_ASSIGN - 79)) | (1 << (AltPython3ParserXOR_ASSIGN - 79)) | (1 << (AltPython3ParserLEFT_SHIFT_ASSIGN - 79)) | (1 << (AltPython3ParserRIGHT_SHIFT_ASSIGN - 79)) | (1 << (AltPython3ParserPOWER_ASSIGN - 79)) | (1 << (AltPython3ParserIDIV_ASSIGN - 79)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}



	return localctx
}


// IDel_stmtContext is an interface to support dynamic dispatch.
type IDel_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDel_stmtContext differentiates from other interfaces.
	IsDel_stmtContext()
}

type Del_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDel_stmtContext() *Del_stmtContext {
	var p = new(Del_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_del_stmt
	return p
}

func (*Del_stmtContext) IsDel_stmtContext() {}

func NewDel_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Del_stmtContext {
	var p = new(Del_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_del_stmt

	return p
}

func (s *Del_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Del_stmtContext) DEL() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserDEL, 0)
}

func (s *Del_stmtContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *Del_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Del_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Del_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterDel_stmt(s)
	}
}

func (s *Del_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitDel_stmt(s)
	}
}

func (s *Del_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitDel_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Del_stmt() (localctx IDel_stmtContext) {
	localctx = NewDel_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, AltPython3ParserRULE_del_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(501)
		p.Match(AltPython3ParserDEL)
	}
	{
		p.SetState(502)
		p.Exprlist()
	}



	return localctx
}


// IPass_stmtContext is an interface to support dynamic dispatch.
type IPass_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_stmtContext differentiates from other interfaces.
	IsPass_stmtContext()
}

type Pass_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_stmtContext() *Pass_stmtContext {
	var p = new(Pass_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_pass_stmt
	return p
}

func (*Pass_stmtContext) IsPass_stmtContext() {}

func NewPass_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_stmtContext {
	var p = new(Pass_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_pass_stmt

	return p
}

func (s *Pass_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_stmtContext) PASS() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserPASS, 0)
}

func (s *Pass_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Pass_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterPass_stmt(s)
	}
}

func (s *Pass_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitPass_stmt(s)
	}
}

func (s *Pass_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitPass_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Pass_stmt() (localctx IPass_stmtContext) {
	localctx = NewPass_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, AltPython3ParserRULE_pass_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(504)
		p.Match(AltPython3ParserPASS)
	}



	return localctx
}


// IFlow_stmtContext is an interface to support dynamic dispatch.
type IFlow_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_stmtContext differentiates from other interfaces.
	IsFlow_stmtContext()
}

type Flow_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_stmtContext() *Flow_stmtContext {
	var p = new(Flow_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_flow_stmt
	return p
}

func (*Flow_stmtContext) IsFlow_stmtContext() {}

func NewFlow_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_stmtContext {
	var p = new(Flow_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_flow_stmt

	return p
}

func (s *Flow_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Flow_stmtContext) Break_stmt() IBreak_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreak_stmtContext)
}

func (s *Flow_stmtContext) Continue_stmt() IContinue_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinue_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinue_stmtContext)
}

func (s *Flow_stmtContext) Return_stmt() IReturn_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturn_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturn_stmtContext)
}

func (s *Flow_stmtContext) Raise_stmt() IRaise_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRaise_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRaise_stmtContext)
}

func (s *Flow_stmtContext) Yield_stmt() IYield_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_stmtContext)
}

func (s *Flow_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Flow_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterFlow_stmt(s)
	}
}

func (s *Flow_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitFlow_stmt(s)
	}
}

func (s *Flow_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitFlow_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Flow_stmt() (localctx IFlow_stmtContext) {
	localctx = NewFlow_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, AltPython3ParserRULE_flow_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(511)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserBREAK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(506)
			p.Break_stmt()
		}


	case AltPython3ParserCONTINUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(507)
			p.Continue_stmt()
		}


	case AltPython3ParserRETURN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(508)
			p.Return_stmt()
		}


	case AltPython3ParserRAISE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(509)
			p.Raise_stmt()
		}


	case AltPython3ParserYIELD:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(510)
			p.Yield_stmt()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IBreak_stmtContext is an interface to support dynamic dispatch.
type IBreak_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreak_stmtContext differentiates from other interfaces.
	IsBreak_stmtContext()
}

type Break_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_stmtContext() *Break_stmtContext {
	var p = new(Break_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_break_stmt
	return p
}

func (*Break_stmtContext) IsBreak_stmtContext() {}

func NewBreak_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_stmtContext {
	var p = new(Break_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_break_stmt

	return p
}

func (s *Break_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_stmtContext) BREAK() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserBREAK, 0)
}

func (s *Break_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Break_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterBreak_stmt(s)
	}
}

func (s *Break_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitBreak_stmt(s)
	}
}

func (s *Break_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitBreak_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Break_stmt() (localctx IBreak_stmtContext) {
	localctx = NewBreak_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, AltPython3ParserRULE_break_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(513)
		p.Match(AltPython3ParserBREAK)
	}



	return localctx
}


// IContinue_stmtContext is an interface to support dynamic dispatch.
type IContinue_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinue_stmtContext differentiates from other interfaces.
	IsContinue_stmtContext()
}

type Continue_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinue_stmtContext() *Continue_stmtContext {
	var p = new(Continue_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_continue_stmt
	return p
}

func (*Continue_stmtContext) IsContinue_stmtContext() {}

func NewContinue_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Continue_stmtContext {
	var p = new(Continue_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_continue_stmt

	return p
}

func (s *Continue_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Continue_stmtContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserCONTINUE, 0)
}

func (s *Continue_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Continue_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Continue_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterContinue_stmt(s)
	}
}

func (s *Continue_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitContinue_stmt(s)
	}
}

func (s *Continue_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitContinue_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Continue_stmt() (localctx IContinue_stmtContext) {
	localctx = NewContinue_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, AltPython3ParserRULE_continue_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(515)
		p.Match(AltPython3ParserCONTINUE)
	}



	return localctx
}


// IReturn_stmtContext is an interface to support dynamic dispatch.
type IReturn_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturn_stmtContext differentiates from other interfaces.
	IsReturn_stmtContext()
}

type Return_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_stmtContext() *Return_stmtContext {
	var p = new(Return_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_return_stmt
	return p
}

func (*Return_stmtContext) IsReturn_stmtContext() {}

func NewReturn_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_stmtContext {
	var p = new(Return_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_return_stmt

	return p
}

func (s *Return_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_stmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserRETURN, 0)
}

func (s *Return_stmtContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Return_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Return_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterReturn_stmt(s)
	}
}

func (s *Return_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitReturn_stmt(s)
	}
}

func (s *Return_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitReturn_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Return_stmt() (localctx IReturn_stmtContext) {
	localctx = NewReturn_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, AltPython3ParserRULE_return_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(517)
		p.Match(AltPython3ParserRETURN)
	}
	p.SetState(519)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 21)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 21))) & ((1 << (AltPython3ParserLAMBDA - 21)) | (1 << (AltPython3ParserNOT - 21)) | (1 << (AltPython3ParserNONE - 21)) | (1 << (AltPython3ParserTRUE - 21)) | (1 << (AltPython3ParserFALSE - 21)) | (1 << (AltPython3ParserNAME - 21)) | (1 << (AltPython3ParserSTRING_LITERAL - 21)) | (1 << (AltPython3ParserBYTES_LITERAL - 21)) | (1 << (AltPython3ParserDECIMAL_INTEGER - 21)) | (1 << (AltPython3ParserOCT_INTEGER - 21)) | (1 << (AltPython3ParserHEX_INTEGER - 21)) | (1 << (AltPython3ParserBIN_INTEGER - 21)) | (1 << (AltPython3ParserFLOAT_NUMBER - 21)) | (1 << (AltPython3ParserIMAG_NUMBER - 21)) | (1 << (AltPython3ParserELLIPSIS - 21)) | (1 << (AltPython3ParserSTAR - 21)) | (1 << (AltPython3ParserOPEN_PAREN - 21)))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (AltPython3ParserOPEN_BRACK - 55)) | (1 << (AltPython3ParserADD - 55)) | (1 << (AltPython3ParserMINUS - 55)) | (1 << (AltPython3ParserNOT_OP - 55)) | (1 << (AltPython3ParserOPEN_BRACE - 55)))) != 0) {
		{
			p.SetState(518)
			p.Testlist()
		}

	}



	return localctx
}


// IYield_stmtContext is an interface to support dynamic dispatch.
type IYield_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYield_stmtContext differentiates from other interfaces.
	IsYield_stmtContext()
}

type Yield_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_stmtContext() *Yield_stmtContext {
	var p = new(Yield_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_yield_stmt
	return p
}

func (*Yield_stmtContext) IsYield_stmtContext() {}

func NewYield_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_stmtContext {
	var p = new(Yield_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_yield_stmt

	return p
}

func (s *Yield_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_stmtContext) Yield_expr() IYield_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *Yield_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Yield_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterYield_stmt(s)
	}
}

func (s *Yield_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitYield_stmt(s)
	}
}

func (s *Yield_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitYield_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Yield_stmt() (localctx IYield_stmtContext) {
	localctx = NewYield_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, AltPython3ParserRULE_yield_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(521)
		p.Yield_expr()
	}



	return localctx
}


// IRaise_stmtContext is an interface to support dynamic dispatch.
type IRaise_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRaise_stmtContext differentiates from other interfaces.
	IsRaise_stmtContext()
}

type Raise_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaise_stmtContext() *Raise_stmtContext {
	var p = new(Raise_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_raise_stmt
	return p
}

func (*Raise_stmtContext) IsRaise_stmtContext() {}

func NewRaise_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Raise_stmtContext {
	var p = new(Raise_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_raise_stmt

	return p
}

func (s *Raise_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Raise_stmtContext) RAISE() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserRAISE, 0)
}

func (s *Raise_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Raise_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Raise_stmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserFROM, 0)
}

func (s *Raise_stmtContext) NAME() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNAME, 0)
}

func (s *Raise_stmtContext) Str() IStrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *Raise_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raise_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Raise_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterRaise_stmt(s)
	}
}

func (s *Raise_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitRaise_stmt(s)
	}
}

func (s *Raise_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitRaise_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Raise_stmt() (localctx IRaise_stmtContext) {
	localctx = NewRaise_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, AltPython3ParserRULE_raise_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(523)
			p.Match(AltPython3ParserRAISE)
		}
		p.SetState(529)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 21)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 21))) & ((1 << (AltPython3ParserLAMBDA - 21)) | (1 << (AltPython3ParserNOT - 21)) | (1 << (AltPython3ParserNONE - 21)) | (1 << (AltPython3ParserTRUE - 21)) | (1 << (AltPython3ParserFALSE - 21)) | (1 << (AltPython3ParserNAME - 21)) | (1 << (AltPython3ParserSTRING_LITERAL - 21)) | (1 << (AltPython3ParserBYTES_LITERAL - 21)) | (1 << (AltPython3ParserDECIMAL_INTEGER - 21)) | (1 << (AltPython3ParserOCT_INTEGER - 21)) | (1 << (AltPython3ParserHEX_INTEGER - 21)) | (1 << (AltPython3ParserBIN_INTEGER - 21)) | (1 << (AltPython3ParserFLOAT_NUMBER - 21)) | (1 << (AltPython3ParserIMAG_NUMBER - 21)) | (1 << (AltPython3ParserELLIPSIS - 21)) | (1 << (AltPython3ParserSTAR - 21)) | (1 << (AltPython3ParserOPEN_PAREN - 21)))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (AltPython3ParserOPEN_BRACK - 55)) | (1 << (AltPython3ParserADD - 55)) | (1 << (AltPython3ParserMINUS - 55)) | (1 << (AltPython3ParserNOT_OP - 55)) | (1 << (AltPython3ParserOPEN_BRACE - 55)))) != 0) {
			{
				p.SetState(524)
				p.Test()
			}
			p.SetState(527)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == AltPython3ParserFROM {
				{
					p.SetState(525)
					p.Match(AltPython3ParserFROM)
				}
				{
					p.SetState(526)
					p.Test()
				}

			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(531)
			p.Match(AltPython3ParserRAISE)
		}
		{
			p.SetState(532)
			p.Match(AltPython3ParserNAME)
		}
		{
			p.SetState(533)
			p.Match(AltPython3ParserCOMMA)
		}
		{
			p.SetState(534)
			p.Str()
		}

		 	if (this.getStrictPython3Parsing()) {
				Token raiseToken = ((org.antlr.v4.runtime.tree.TerminalNodeImpl)this._ctx.children.get(0)).getSymbol();
				Token startingOffender = ((org.antlr.v4.runtime.tree.TerminalNodeImpl)this._ctx.children.get(1)).getSymbol();

				throw new NoViableAltException(this, this.getInputStream(), raiseToken, startingOffender, null,
											   this._ctx);
		 	}
		 	else {
		 		this.likelyIsPython2 = true;
		 	}
		 

	}


	return localctx
}


// IImport_stmtContext is an interface to support dynamic dispatch.
type IImport_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_stmtContext differentiates from other interfaces.
	IsImport_stmtContext()
}

type Import_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_stmtContext() *Import_stmtContext {
	var p = new(Import_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_import_stmt
	return p
}

func (*Import_stmtContext) IsImport_stmtContext() {}

func NewImport_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_stmtContext {
	var p = new(Import_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_import_stmt

	return p
}

func (s *Import_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_stmtContext) Import_name() IImport_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_nameContext)
}

func (s *Import_stmtContext) Import_from() IImport_fromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_fromContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_fromContext)
}

func (s *Import_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Import_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterImport_stmt(s)
	}
}

func (s *Import_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitImport_stmt(s)
	}
}

func (s *Import_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitImport_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Import_stmt() (localctx IImport_stmtContext) {
	localctx = NewImport_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, AltPython3ParserRULE_import_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(541)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserIMPORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(539)
			p.Import_name()
		}


	case AltPython3ParserFROM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(540)
			p.Import_from()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IImport_nameContext is an interface to support dynamic dispatch.
type IImport_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_nameContext differentiates from other interfaces.
	IsImport_nameContext()
}

type Import_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_nameContext() *Import_nameContext {
	var p = new(Import_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_import_name
	return p
}

func (*Import_nameContext) IsImport_nameContext() {}

func NewImport_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_nameContext {
	var p = new(Import_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_import_name

	return p
}

func (s *Import_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_nameContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserIMPORT, 0)
}

func (s *Import_nameContext) Dotted_as_names() IDotted_as_namesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_as_namesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_as_namesContext)
}

func (s *Import_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Import_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterImport_name(s)
	}
}

func (s *Import_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitImport_name(s)
	}
}

func (s *Import_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitImport_name(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Import_name() (localctx IImport_nameContext) {
	localctx = NewImport_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, AltPython3ParserRULE_import_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(543)
		p.Match(AltPython3ParserIMPORT)
	}
	{
		p.SetState(544)
		p.Dotted_as_names()
	}



	return localctx
}


// IImport_fromContext is an interface to support dynamic dispatch.
type IImport_fromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_fromContext differentiates from other interfaces.
	IsImport_fromContext()
}

type Import_fromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_fromContext() *Import_fromContext {
	var p = new(Import_fromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_import_from
	return p
}

func (*Import_fromContext) IsImport_fromContext() {}

func NewImport_fromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_fromContext {
	var p = new(Import_fromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_import_from

	return p
}

func (s *Import_fromContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_fromContext) FROM() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserFROM, 0)
}

func (s *Import_fromContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserIMPORT, 0)
}

func (s *Import_fromContext) Dotted_name() IDotted_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *Import_fromContext) Import_as_names() IImport_as_namesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_as_namesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_as_namesContext)
}

func (s *Import_fromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_fromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Import_fromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterImport_from(s)
	}
}

func (s *Import_fromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitImport_from(s)
	}
}

func (s *Import_fromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitImport_from(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Import_from() (localctx IImport_fromContext) {
	localctx = NewImport_fromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, AltPython3ParserRULE_import_from)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(546)
		p.Match(AltPython3ParserFROM)
	}
	p.SetState(559)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.SetState(550)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == AltPython3ParserDOT || _la == AltPython3ParserELLIPSIS {
			p.SetState(547)
			_la = p.GetTokenStream().LA(1)

			if !(_la == AltPython3ParserDOT || _la == AltPython3ParserELLIPSIS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
			    p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}


			p.SetState(552)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(553)
			p.Dotted_name()
		}


	case 2:
		p.SetState(555)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == AltPython3ParserDOT || _la == AltPython3ParserELLIPSIS {
			p.SetState(554)
			_la = p.GetTokenStream().LA(1)

			if !(_la == AltPython3ParserDOT || _la == AltPython3ParserELLIPSIS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
			    p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}


			p.SetState(557)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(561)
		p.Match(AltPython3ParserIMPORT)
	}
	p.SetState(568)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserSTAR:
		{
			p.SetState(562)
			p.Match(AltPython3ParserSTAR)
		}


	case AltPython3ParserOPEN_PAREN:
		{
			p.SetState(563)
			p.Match(AltPython3ParserOPEN_PAREN)
		}
		{
			p.SetState(564)
			p.Import_as_names()
		}
		{
			p.SetState(565)
			p.Match(AltPython3ParserCLOSE_PAREN)
		}


	case AltPython3ParserNAME:
		{
			p.SetState(567)
			p.Import_as_names()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IImport_as_nameContext is an interface to support dynamic dispatch.
type IImport_as_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_as_nameContext differentiates from other interfaces.
	IsImport_as_nameContext()
}

type Import_as_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_as_nameContext() *Import_as_nameContext {
	var p = new(Import_as_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_import_as_name
	return p
}

func (*Import_as_nameContext) IsImport_as_nameContext() {}

func NewImport_as_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_as_nameContext {
	var p = new(Import_as_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_import_as_name

	return p
}

func (s *Import_as_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_as_nameContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(AltPython3ParserNAME)
}

func (s *Import_as_nameContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNAME, i)
}

func (s *Import_as_nameContext) AS() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserAS, 0)
}

func (s *Import_as_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_as_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Import_as_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterImport_as_name(s)
	}
}

func (s *Import_as_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitImport_as_name(s)
	}
}

func (s *Import_as_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitImport_as_name(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Import_as_name() (localctx IImport_as_nameContext) {
	localctx = NewImport_as_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, AltPython3ParserRULE_import_as_name)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(570)
		p.Match(AltPython3ParserNAME)
	}
	p.SetState(573)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserAS {
		{
			p.SetState(571)
			p.Match(AltPython3ParserAS)
		}
		{
			p.SetState(572)
			p.Match(AltPython3ParserNAME)
		}

	}



	return localctx
}


// IDotted_as_nameContext is an interface to support dynamic dispatch.
type IDotted_as_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotted_as_nameContext differentiates from other interfaces.
	IsDotted_as_nameContext()
}

type Dotted_as_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_as_nameContext() *Dotted_as_nameContext {
	var p = new(Dotted_as_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_dotted_as_name
	return p
}

func (*Dotted_as_nameContext) IsDotted_as_nameContext() {}

func NewDotted_as_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_as_nameContext {
	var p = new(Dotted_as_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_dotted_as_name

	return p
}

func (s *Dotted_as_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_as_nameContext) Dotted_name() IDotted_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *Dotted_as_nameContext) AS() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserAS, 0)
}

func (s *Dotted_as_nameContext) NAME() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNAME, 0)
}

func (s *Dotted_as_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_as_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dotted_as_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterDotted_as_name(s)
	}
}

func (s *Dotted_as_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitDotted_as_name(s)
	}
}

func (s *Dotted_as_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitDotted_as_name(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Dotted_as_name() (localctx IDotted_as_nameContext) {
	localctx = NewDotted_as_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, AltPython3ParserRULE_dotted_as_name)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(575)
		p.Dotted_name()
	}
	p.SetState(578)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserAS {
		{
			p.SetState(576)
			p.Match(AltPython3ParserAS)
		}
		{
			p.SetState(577)
			p.Match(AltPython3ParserNAME)
		}

	}



	return localctx
}


// IImport_as_namesContext is an interface to support dynamic dispatch.
type IImport_as_namesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_as_namesContext differentiates from other interfaces.
	IsImport_as_namesContext()
}

type Import_as_namesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_as_namesContext() *Import_as_namesContext {
	var p = new(Import_as_namesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_import_as_names
	return p
}

func (*Import_as_namesContext) IsImport_as_namesContext() {}

func NewImport_as_namesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_as_namesContext {
	var p = new(Import_as_namesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_import_as_names

	return p
}

func (s *Import_as_namesContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_as_namesContext) AllImport_as_name() []IImport_as_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImport_as_nameContext)(nil)).Elem())
	var tst = make([]IImport_as_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImport_as_nameContext)
		}
	}

	return tst
}

func (s *Import_as_namesContext) Import_as_name(i int) IImport_as_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_as_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImport_as_nameContext)
}

func (s *Import_as_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_as_namesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Import_as_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterImport_as_names(s)
	}
}

func (s *Import_as_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitImport_as_names(s)
	}
}

func (s *Import_as_namesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitImport_as_names(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Import_as_names() (localctx IImport_as_namesContext) {
	localctx = NewImport_as_namesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, AltPython3ParserRULE_import_as_names)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(580)
		p.Import_as_name()
	}
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(581)
				p.Match(AltPython3ParserCOMMA)
			}
			{
				p.SetState(582)
				p.Import_as_name()
			}


		}
		p.SetState(587)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())
	}
	p.SetState(589)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserCOMMA {
		{
			p.SetState(588)
			p.Match(AltPython3ParserCOMMA)
		}

	}



	return localctx
}


// IDotted_as_namesContext is an interface to support dynamic dispatch.
type IDotted_as_namesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotted_as_namesContext differentiates from other interfaces.
	IsDotted_as_namesContext()
}

type Dotted_as_namesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_as_namesContext() *Dotted_as_namesContext {
	var p = new(Dotted_as_namesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_dotted_as_names
	return p
}

func (*Dotted_as_namesContext) IsDotted_as_namesContext() {}

func NewDotted_as_namesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_as_namesContext {
	var p = new(Dotted_as_namesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_dotted_as_names

	return p
}

func (s *Dotted_as_namesContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_as_namesContext) AllDotted_as_name() []IDotted_as_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDotted_as_nameContext)(nil)).Elem())
	var tst = make([]IDotted_as_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDotted_as_nameContext)
		}
	}

	return tst
}

func (s *Dotted_as_namesContext) Dotted_as_name(i int) IDotted_as_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_as_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDotted_as_nameContext)
}

func (s *Dotted_as_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_as_namesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dotted_as_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterDotted_as_names(s)
	}
}

func (s *Dotted_as_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitDotted_as_names(s)
	}
}

func (s *Dotted_as_namesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitDotted_as_names(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Dotted_as_names() (localctx IDotted_as_namesContext) {
	localctx = NewDotted_as_namesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, AltPython3ParserRULE_dotted_as_names)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(591)
		p.Dotted_as_name()
	}
	p.SetState(596)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == AltPython3ParserCOMMA {
		{
			p.SetState(592)
			p.Match(AltPython3ParserCOMMA)
		}
		{
			p.SetState(593)
			p.Dotted_as_name()
		}


		p.SetState(598)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IDotted_nameContext is an interface to support dynamic dispatch.
type IDotted_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotted_nameContext differentiates from other interfaces.
	IsDotted_nameContext()
}

type Dotted_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_nameContext() *Dotted_nameContext {
	var p = new(Dotted_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_dotted_name
	return p
}

func (*Dotted_nameContext) IsDotted_nameContext() {}

func NewDotted_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_nameContext {
	var p = new(Dotted_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_dotted_name

	return p
}

func (s *Dotted_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_nameContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(AltPython3ParserNAME)
}

func (s *Dotted_nameContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNAME, i)
}

func (s *Dotted_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dotted_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterDotted_name(s)
	}
}

func (s *Dotted_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitDotted_name(s)
	}
}

func (s *Dotted_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitDotted_name(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Dotted_name() (localctx IDotted_nameContext) {
	localctx = NewDotted_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, AltPython3ParserRULE_dotted_name)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(599)
		p.Match(AltPython3ParserNAME)
	}
	p.SetState(604)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == AltPython3ParserDOT {
		{
			p.SetState(600)
			p.Match(AltPython3ParserDOT)
		}
		{
			p.SetState(601)
			p.Match(AltPython3ParserNAME)
		}


		p.SetState(606)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IGlobal_stmtContext is an interface to support dynamic dispatch.
type IGlobal_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobal_stmtContext differentiates from other interfaces.
	IsGlobal_stmtContext()
}

type Global_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobal_stmtContext() *Global_stmtContext {
	var p = new(Global_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_global_stmt
	return p
}

func (*Global_stmtContext) IsGlobal_stmtContext() {}

func NewGlobal_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_stmtContext {
	var p = new(Global_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_global_stmt

	return p
}

func (s *Global_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_stmtContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserGLOBAL, 0)
}

func (s *Global_stmtContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(AltPython3ParserNAME)
}

func (s *Global_stmtContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNAME, i)
}

func (s *Global_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Global_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterGlobal_stmt(s)
	}
}

func (s *Global_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitGlobal_stmt(s)
	}
}

func (s *Global_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitGlobal_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Global_stmt() (localctx IGlobal_stmtContext) {
	localctx = NewGlobal_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, AltPython3ParserRULE_global_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		p.Match(AltPython3ParserGLOBAL)
	}
	{
		p.SetState(608)
		p.Match(AltPython3ParserNAME)
	}
	p.SetState(613)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == AltPython3ParserCOMMA {
		{
			p.SetState(609)
			p.Match(AltPython3ParserCOMMA)
		}
		{
			p.SetState(610)
			p.Match(AltPython3ParserNAME)
		}


		p.SetState(615)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// INonlocal_stmtContext is an interface to support dynamic dispatch.
type INonlocal_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonlocal_stmtContext differentiates from other interfaces.
	IsNonlocal_stmtContext()
}

type Nonlocal_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonlocal_stmtContext() *Nonlocal_stmtContext {
	var p = new(Nonlocal_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_nonlocal_stmt
	return p
}

func (*Nonlocal_stmtContext) IsNonlocal_stmtContext() {}

func NewNonlocal_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nonlocal_stmtContext {
	var p = new(Nonlocal_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_nonlocal_stmt

	return p
}

func (s *Nonlocal_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Nonlocal_stmtContext) NONLOCAL() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNONLOCAL, 0)
}

func (s *Nonlocal_stmtContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(AltPython3ParserNAME)
}

func (s *Nonlocal_stmtContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNAME, i)
}

func (s *Nonlocal_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nonlocal_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Nonlocal_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterNonlocal_stmt(s)
	}
}

func (s *Nonlocal_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitNonlocal_stmt(s)
	}
}

func (s *Nonlocal_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitNonlocal_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Nonlocal_stmt() (localctx INonlocal_stmtContext) {
	localctx = NewNonlocal_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, AltPython3ParserRULE_nonlocal_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(616)
		p.Match(AltPython3ParserNONLOCAL)
	}
	{
		p.SetState(617)
		p.Match(AltPython3ParserNAME)
	}
	p.SetState(622)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == AltPython3ParserCOMMA {
		{
			p.SetState(618)
			p.Match(AltPython3ParserCOMMA)
		}
		{
			p.SetState(619)
			p.Match(AltPython3ParserNAME)
		}


		p.SetState(624)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAssert_stmtContext is an interface to support dynamic dispatch.
type IAssert_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssert_stmtContext differentiates from other interfaces.
	IsAssert_stmtContext()
}

type Assert_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssert_stmtContext() *Assert_stmtContext {
	var p = new(Assert_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_assert_stmt
	return p
}

func (*Assert_stmtContext) IsAssert_stmtContext() {}

func NewAssert_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assert_stmtContext {
	var p = new(Assert_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_assert_stmt

	return p
}

func (s *Assert_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Assert_stmtContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserASSERT, 0)
}

func (s *Assert_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Assert_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Assert_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assert_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Assert_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterAssert_stmt(s)
	}
}

func (s *Assert_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitAssert_stmt(s)
	}
}

func (s *Assert_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitAssert_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Assert_stmt() (localctx IAssert_stmtContext) {
	localctx = NewAssert_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, AltPython3ParserRULE_assert_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(625)
		p.Match(AltPython3ParserASSERT)
	}
	{
		p.SetState(626)
		p.Test()
	}
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserCOMMA {
		{
			p.SetState(627)
			p.Match(AltPython3ParserCOMMA)
		}
		{
			p.SetState(628)
			p.Test()
		}

	}



	return localctx
}


// ICompound_stmtContext is an interface to support dynamic dispatch.
type ICompound_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompound_stmtContext differentiates from other interfaces.
	IsCompound_stmtContext()
}

type Compound_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_stmtContext() *Compound_stmtContext {
	var p = new(Compound_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_compound_stmt
	return p
}

func (*Compound_stmtContext) IsCompound_stmtContext() {}

func NewCompound_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_stmtContext {
	var p = new(Compound_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_compound_stmt

	return p
}

func (s *Compound_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_stmtContext) If_stmt() IIf_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_stmtContext)
}

func (s *Compound_stmtContext) While_stmt() IWhile_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhile_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhile_stmtContext)
}

func (s *Compound_stmtContext) For_stmt() IFor_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_stmtContext)
}

func (s *Compound_stmtContext) Try_stmt() ITry_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITry_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITry_stmtContext)
}

func (s *Compound_stmtContext) With_stmt() IWith_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWith_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWith_stmtContext)
}

func (s *Compound_stmtContext) Funcdef() IFuncdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *Compound_stmtContext) Classdef() IClassdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassdefContext)
}

func (s *Compound_stmtContext) Decorated() IDecoratedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecoratedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecoratedContext)
}

func (s *Compound_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Compound_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterCompound_stmt(s)
	}
}

func (s *Compound_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitCompound_stmt(s)
	}
}

func (s *Compound_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitCompound_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Compound_stmt() (localctx ICompound_stmtContext) {
	localctx = NewCompound_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, AltPython3ParserRULE_compound_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(639)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(631)
			p.If_stmt()
		}


	case AltPython3ParserWHILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(632)
			p.While_stmt()
		}


	case AltPython3ParserFOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(633)
			p.For_stmt()
		}


	case AltPython3ParserTRY:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(634)
			p.Try_stmt()
		}


	case AltPython3ParserWITH:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(635)
			p.With_stmt()
		}


	case AltPython3ParserDEF:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(636)
			p.Funcdef()
		}


	case AltPython3ParserCLASS:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(637)
			p.Classdef()
		}


	case AltPython3ParserAT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(638)
			p.Decorated()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IIf_stmtContext is an interface to support dynamic dispatch.
type IIf_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_stmtContext differentiates from other interfaces.
	IsIf_stmtContext()
}

type If_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_stmtContext() *If_stmtContext {
	var p = new(If_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_if_stmt
	return p
}

func (*If_stmtContext) IsIf_stmtContext() {}

func NewIf_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_stmtContext {
	var p = new(If_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_if_stmt

	return p
}

func (s *If_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserIF, 0)
}

func (s *If_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *If_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *If_stmtContext) AllSuite() []ISuiteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuiteContext)(nil)).Elem())
	var tst = make([]ISuiteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuiteContext)
		}
	}

	return tst
}

func (s *If_stmtContext) Suite(i int) ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *If_stmtContext) AllELIF() []antlr.TerminalNode {
	return s.GetTokens(AltPython3ParserELIF)
}

func (s *If_stmtContext) ELIF(i int) antlr.TerminalNode {
	return s.GetToken(AltPython3ParserELIF, i)
}

func (s *If_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserELSE, 0)
}

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitIf_stmt(s)
	}
}

func (s *If_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitIf_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) If_stmt() (localctx IIf_stmtContext) {
	localctx = NewIf_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, AltPython3ParserRULE_if_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(641)
		p.Match(AltPython3ParserIF)
	}
	{
		p.SetState(642)
		p.Test()
	}
	{
		p.SetState(643)
		p.Match(AltPython3ParserCOLON)
	}
	{
		p.SetState(644)
		p.Suite()
	}
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == AltPython3ParserELIF {
		{
			p.SetState(645)
			p.Match(AltPython3ParserELIF)
		}
		{
			p.SetState(646)
			p.Test()
		}
		{
			p.SetState(647)
			p.Match(AltPython3ParserCOLON)
		}
		{
			p.SetState(648)
			p.Suite()
		}


		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(658)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserELSE {
		{
			p.SetState(655)
			p.Match(AltPython3ParserELSE)
		}
		{
			p.SetState(656)
			p.Match(AltPython3ParserCOLON)
		}
		{
			p.SetState(657)
			p.Suite()
		}

	}



	return localctx
}


// IWhile_stmtContext is an interface to support dynamic dispatch.
type IWhile_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhile_stmtContext differentiates from other interfaces.
	IsWhile_stmtContext()
}

type While_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhile_stmtContext() *While_stmtContext {
	var p = new(While_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_while_stmt
	return p
}

func (*While_stmtContext) IsWhile_stmtContext() {}

func NewWhile_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *While_stmtContext {
	var p = new(While_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_while_stmt

	return p
}

func (s *While_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *While_stmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserWHILE, 0)
}

func (s *While_stmtContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *While_stmtContext) AllSuite() []ISuiteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuiteContext)(nil)).Elem())
	var tst = make([]ISuiteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuiteContext)
		}
	}

	return tst
}

func (s *While_stmtContext) Suite(i int) ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *While_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserELSE, 0)
}

func (s *While_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *While_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterWhile_stmt(s)
	}
}

func (s *While_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitWhile_stmt(s)
	}
}

func (s *While_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitWhile_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) While_stmt() (localctx IWhile_stmtContext) {
	localctx = NewWhile_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, AltPython3ParserRULE_while_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(660)
		p.Match(AltPython3ParserWHILE)
	}
	{
		p.SetState(661)
		p.Test()
	}
	{
		p.SetState(662)
		p.Match(AltPython3ParserCOLON)
	}
	{
		p.SetState(663)
		p.Suite()
	}
	p.SetState(667)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserELSE {
		{
			p.SetState(664)
			p.Match(AltPython3ParserELSE)
		}
		{
			p.SetState(665)
			p.Match(AltPython3ParserCOLON)
		}
		{
			p.SetState(666)
			p.Suite()
		}

	}



	return localctx
}


// IFor_stmtContext is an interface to support dynamic dispatch.
type IFor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_stmtContext differentiates from other interfaces.
	IsFor_stmtContext()
}

type For_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_stmtContext() *For_stmtContext {
	var p = new(For_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_for_stmt
	return p
}

func (*For_stmtContext) IsFor_stmtContext() {}

func NewFor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_stmtContext {
	var p = new(For_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_for_stmt

	return p
}

func (s *For_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserFOR, 0)
}

func (s *For_stmtContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *For_stmtContext) IN() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserIN, 0)
}

func (s *For_stmtContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *For_stmtContext) AllSuite() []ISuiteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuiteContext)(nil)).Elem())
	var tst = make([]ISuiteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuiteContext)
		}
	}

	return tst
}

func (s *For_stmtContext) Suite(i int) ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *For_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserELSE, 0)
}

func (s *For_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *For_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterFor_stmt(s)
	}
}

func (s *For_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitFor_stmt(s)
	}
}

func (s *For_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitFor_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) For_stmt() (localctx IFor_stmtContext) {
	localctx = NewFor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, AltPython3ParserRULE_for_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(669)
		p.Match(AltPython3ParserFOR)
	}
	{
		p.SetState(670)
		p.Exprlist()
	}
	{
		p.SetState(671)
		p.Match(AltPython3ParserIN)
	}
	{
		p.SetState(672)
		p.Testlist()
	}
	{
		p.SetState(673)
		p.Match(AltPython3ParserCOLON)
	}
	{
		p.SetState(674)
		p.Suite()
	}
	p.SetState(678)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserELSE {
		{
			p.SetState(675)
			p.Match(AltPython3ParserELSE)
		}
		{
			p.SetState(676)
			p.Match(AltPython3ParserCOLON)
		}
		{
			p.SetState(677)
			p.Suite()
		}

	}



	return localctx
}


// ITry_stmtContext is an interface to support dynamic dispatch.
type ITry_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTry_stmtContext differentiates from other interfaces.
	IsTry_stmtContext()
}

type Try_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTry_stmtContext() *Try_stmtContext {
	var p = new(Try_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_try_stmt
	return p
}

func (*Try_stmtContext) IsTry_stmtContext() {}

func NewTry_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Try_stmtContext {
	var p = new(Try_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_try_stmt

	return p
}

func (s *Try_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Try_stmtContext) TRY() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserTRY, 0)
}

func (s *Try_stmtContext) AllSuite() []ISuiteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuiteContext)(nil)).Elem())
	var tst = make([]ISuiteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuiteContext)
		}
	}

	return tst
}

func (s *Try_stmtContext) Suite(i int) ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *Try_stmtContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserFINALLY, 0)
}

func (s *Try_stmtContext) AllExcept_clause() []IExcept_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExcept_clauseContext)(nil)).Elem())
	var tst = make([]IExcept_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExcept_clauseContext)
		}
	}

	return tst
}

func (s *Try_stmtContext) Except_clause(i int) IExcept_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExcept_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExcept_clauseContext)
}

func (s *Try_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserELSE, 0)
}

func (s *Try_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Try_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Try_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterTry_stmt(s)
	}
}

func (s *Try_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitTry_stmt(s)
	}
}

func (s *Try_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitTry_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Try_stmt() (localctx ITry_stmtContext) {
	localctx = NewTry_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, AltPython3ParserRULE_try_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(680)
		p.Match(AltPython3ParserTRY)
	}
	{
		p.SetState(681)
		p.Match(AltPython3ParserCOLON)
	}
	{
		p.SetState(682)
		p.Suite()
	}
	p.SetState(704)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserEXCEPT:
		p.SetState(687)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == AltPython3ParserEXCEPT {
			{
				p.SetState(683)
				p.Except_clause()
			}
			{
				p.SetState(684)
				p.Match(AltPython3ParserCOLON)
			}
			{
				p.SetState(685)
				p.Suite()
			}


			p.SetState(689)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(694)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == AltPython3ParserELSE {
			{
				p.SetState(691)
				p.Match(AltPython3ParserELSE)
			}
			{
				p.SetState(692)
				p.Match(AltPython3ParserCOLON)
			}
			{
				p.SetState(693)
				p.Suite()
			}

		}
		p.SetState(699)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == AltPython3ParserFINALLY {
			{
				p.SetState(696)
				p.Match(AltPython3ParserFINALLY)
			}
			{
				p.SetState(697)
				p.Match(AltPython3ParserCOLON)
			}
			{
				p.SetState(698)
				p.Suite()
			}

		}


	case AltPython3ParserFINALLY:
		{
			p.SetState(701)
			p.Match(AltPython3ParserFINALLY)
		}
		{
			p.SetState(702)
			p.Match(AltPython3ParserCOLON)
		}
		{
			p.SetState(703)
			p.Suite()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// IWith_stmtContext is an interface to support dynamic dispatch.
type IWith_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWith_stmtContext differentiates from other interfaces.
	IsWith_stmtContext()
}

type With_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_stmtContext() *With_stmtContext {
	var p = new(With_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_with_stmt
	return p
}

func (*With_stmtContext) IsWith_stmtContext() {}

func NewWith_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_stmtContext {
	var p = new(With_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_with_stmt

	return p
}

func (s *With_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *With_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserWITH, 0)
}

func (s *With_stmtContext) AllWith_item() []IWith_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWith_itemContext)(nil)).Elem())
	var tst = make([]IWith_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWith_itemContext)
		}
	}

	return tst
}

func (s *With_stmtContext) With_item(i int) IWith_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWith_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWith_itemContext)
}

func (s *With_stmtContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *With_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterWith_stmt(s)
	}
}

func (s *With_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitWith_stmt(s)
	}
}

func (s *With_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitWith_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) With_stmt() (localctx IWith_stmtContext) {
	localctx = NewWith_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, AltPython3ParserRULE_with_stmt)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(706)
		p.Match(AltPython3ParserWITH)
	}
	{
		p.SetState(707)
		p.With_item()
	}
	p.SetState(712)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == AltPython3ParserCOMMA {
		{
			p.SetState(708)
			p.Match(AltPython3ParserCOMMA)
		}
		{
			p.SetState(709)
			p.With_item()
		}


		p.SetState(714)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(715)
		p.Match(AltPython3ParserCOLON)
	}
	{
		p.SetState(716)
		p.Suite()
	}



	return localctx
}


// IWith_itemContext is an interface to support dynamic dispatch.
type IWith_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWith_itemContext differentiates from other interfaces.
	IsWith_itemContext()
}

type With_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_itemContext() *With_itemContext {
	var p = new(With_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_with_item
	return p
}

func (*With_itemContext) IsWith_itemContext() {}

func NewWith_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_itemContext {
	var p = new(With_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_with_item

	return p
}

func (s *With_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *With_itemContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *With_itemContext) AS() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserAS, 0)
}

func (s *With_itemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *With_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *With_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterWith_item(s)
	}
}

func (s *With_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitWith_item(s)
	}
}

func (s *With_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitWith_item(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) With_item() (localctx IWith_itemContext) {
	localctx = NewWith_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, AltPython3ParserRULE_with_item)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(718)
		p.Test()
	}
	p.SetState(721)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserAS {
		{
			p.SetState(719)
			p.Match(AltPython3ParserAS)
		}
		{
			p.SetState(720)
			p.Expr()
		}

	}



	return localctx
}


// IExcept_clauseContext is an interface to support dynamic dispatch.
type IExcept_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExcept_clauseContext differentiates from other interfaces.
	IsExcept_clauseContext()
}

type Except_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExcept_clauseContext() *Except_clauseContext {
	var p = new(Except_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_except_clause
	return p
}

func (*Except_clauseContext) IsExcept_clauseContext() {}

func NewExcept_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Except_clauseContext {
	var p = new(Except_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_except_clause

	return p
}

func (s *Except_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Except_clauseContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserEXCEPT, 0)
}

func (s *Except_clauseContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Except_clauseContext) AS() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserAS, 0)
}

func (s *Except_clauseContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(AltPython3ParserNAME)
}

func (s *Except_clauseContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNAME, i)
}

func (s *Except_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Except_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Except_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterExcept_clause(s)
	}
}

func (s *Except_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitExcept_clause(s)
	}
}

func (s *Except_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitExcept_clause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Except_clause() (localctx IExcept_clauseContext) {
	localctx = NewExcept_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, AltPython3ParserRULE_except_clause)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(723)
			p.Match(AltPython3ParserEXCEPT)
		}
		p.SetState(729)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 21)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 21))) & ((1 << (AltPython3ParserLAMBDA - 21)) | (1 << (AltPython3ParserNOT - 21)) | (1 << (AltPython3ParserNONE - 21)) | (1 << (AltPython3ParserTRUE - 21)) | (1 << (AltPython3ParserFALSE - 21)) | (1 << (AltPython3ParserNAME - 21)) | (1 << (AltPython3ParserSTRING_LITERAL - 21)) | (1 << (AltPython3ParserBYTES_LITERAL - 21)) | (1 << (AltPython3ParserDECIMAL_INTEGER - 21)) | (1 << (AltPython3ParserOCT_INTEGER - 21)) | (1 << (AltPython3ParserHEX_INTEGER - 21)) | (1 << (AltPython3ParserBIN_INTEGER - 21)) | (1 << (AltPython3ParserFLOAT_NUMBER - 21)) | (1 << (AltPython3ParserIMAG_NUMBER - 21)) | (1 << (AltPython3ParserELLIPSIS - 21)) | (1 << (AltPython3ParserSTAR - 21)) | (1 << (AltPython3ParserOPEN_PAREN - 21)))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (AltPython3ParserOPEN_BRACK - 55)) | (1 << (AltPython3ParserADD - 55)) | (1 << (AltPython3ParserMINUS - 55)) | (1 << (AltPython3ParserNOT_OP - 55)) | (1 << (AltPython3ParserOPEN_BRACE - 55)))) != 0) {
			{
				p.SetState(724)
				p.Test()
			}
			p.SetState(727)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == AltPython3ParserAS {
				{
					p.SetState(725)
					p.Match(AltPython3ParserAS)
				}
				{
					p.SetState(726)
					p.Match(AltPython3ParserNAME)
				}

			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(731)
			p.Match(AltPython3ParserEXCEPT)
		}
		{
			p.SetState(732)
			p.Match(AltPython3ParserNAME)
		}
		{
			p.SetState(733)
			p.Match(AltPython3ParserCOMMA)
		}
		{
			p.SetState(734)
			p.Match(AltPython3ParserNAME)
		}

		 	if (this.getStrictPython3Parsing()) {
				Token exceptToken = ((org.antlr.v4.runtime.tree.TerminalNodeImpl)this._ctx.children.get(0)).getSymbol();
				Token startingOffender = ((org.antlr.v4.runtime.tree.TerminalNodeImpl)this._ctx.children.get(1)).getSymbol();

				throw new NoViableAltException(this, this.getInputStream(), exceptToken, startingOffender, null,
											   this._ctx);
		 	}
		 	else {
		 		this.likelyIsPython2 = true;
		 	}
		 

	}


	return localctx
}


// ISuiteContext is an interface to support dynamic dispatch.
type ISuiteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuiteContext differentiates from other interfaces.
	IsSuiteContext()
}

type SuiteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuiteContext() *SuiteContext {
	var p = new(SuiteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_suite
	return p
}

func (*SuiteContext) IsSuiteContext() {}

func NewSuiteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuiteContext {
	var p = new(SuiteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_suite

	return p
}

func (s *SuiteContext) GetParser() antlr.Parser { return s.parser }

func (s *SuiteContext) Simple_stmt() ISimple_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *SuiteContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNEWLINE, 0)
}

func (s *SuiteContext) INDENT() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserINDENT, 0)
}

func (s *SuiteContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserDEDENT, 0)
}

func (s *SuiteContext) AllStmt() []IStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStmtContext)(nil)).Elem())
	var tst = make([]IStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStmtContext)
		}
	}

	return tst
}

func (s *SuiteContext) Stmt(i int) IStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *SuiteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuiteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SuiteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterSuite(s)
	}
}

func (s *SuiteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitSuite(s)
	}
}

func (s *SuiteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitSuite(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Suite() (localctx ISuiteContext) {
	localctx = NewSuiteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, AltPython3ParserRULE_suite)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(748)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserPRINT, AltPython3ParserRETURN, AltPython3ParserRAISE, AltPython3ParserFROM, AltPython3ParserIMPORT, AltPython3ParserGLOBAL, AltPython3ParserNONLOCAL, AltPython3ParserASSERT, AltPython3ParserLAMBDA, AltPython3ParserNOT, AltPython3ParserNONE, AltPython3ParserTRUE, AltPython3ParserFALSE, AltPython3ParserYIELD, AltPython3ParserDEL, AltPython3ParserPASS, AltPython3ParserCONTINUE, AltPython3ParserBREAK, AltPython3ParserNAME, AltPython3ParserSTRING_LITERAL, AltPython3ParserBYTES_LITERAL, AltPython3ParserDECIMAL_INTEGER, AltPython3ParserOCT_INTEGER, AltPython3ParserHEX_INTEGER, AltPython3ParserBIN_INTEGER, AltPython3ParserFLOAT_NUMBER, AltPython3ParserIMAG_NUMBER, AltPython3ParserELLIPSIS, AltPython3ParserSTAR, AltPython3ParserOPEN_PAREN, AltPython3ParserOPEN_BRACK, AltPython3ParserADD, AltPython3ParserMINUS, AltPython3ParserNOT_OP, AltPython3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(738)
			p.Simple_stmt()
		}


	case AltPython3ParserNEWLINE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(739)
			p.Match(AltPython3ParserNEWLINE)
		}
		{
			p.SetState(740)
			p.Match(AltPython3ParserINDENT)
		}
		p.SetState(742)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << AltPython3ParserPRINT) | (1 << AltPython3ParserDEF) | (1 << AltPython3ParserRETURN) | (1 << AltPython3ParserRAISE) | (1 << AltPython3ParserFROM) | (1 << AltPython3ParserIMPORT) | (1 << AltPython3ParserGLOBAL) | (1 << AltPython3ParserNONLOCAL) | (1 << AltPython3ParserASSERT) | (1 << AltPython3ParserIF) | (1 << AltPython3ParserWHILE) | (1 << AltPython3ParserFOR) | (1 << AltPython3ParserTRY) | (1 << AltPython3ParserWITH) | (1 << AltPython3ParserLAMBDA) | (1 << AltPython3ParserNOT) | (1 << AltPython3ParserNONE) | (1 << AltPython3ParserTRUE) | (1 << AltPython3ParserFALSE) | (1 << AltPython3ParserCLASS) | (1 << AltPython3ParserYIELD) | (1 << AltPython3ParserDEL))) != 0) || ((((_la - 32)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 32))) & ((1 << (AltPython3ParserPASS - 32)) | (1 << (AltPython3ParserCONTINUE - 32)) | (1 << (AltPython3ParserBREAK - 32)) | (1 << (AltPython3ParserNAME - 32)) | (1 << (AltPython3ParserSTRING_LITERAL - 32)) | (1 << (AltPython3ParserBYTES_LITERAL - 32)) | (1 << (AltPython3ParserDECIMAL_INTEGER - 32)) | (1 << (AltPython3ParserOCT_INTEGER - 32)) | (1 << (AltPython3ParserHEX_INTEGER - 32)) | (1 << (AltPython3ParserBIN_INTEGER - 32)) | (1 << (AltPython3ParserFLOAT_NUMBER - 32)) | (1 << (AltPython3ParserIMAG_NUMBER - 32)) | (1 << (AltPython3ParserELLIPSIS - 32)) | (1 << (AltPython3ParserSTAR - 32)) | (1 << (AltPython3ParserOPEN_PAREN - 32)) | (1 << (AltPython3ParserOPEN_BRACK - 32)) | (1 << (AltPython3ParserADD - 32)) | (1 << (AltPython3ParserMINUS - 32)))) != 0) || ((((_la - 67)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 67))) & ((1 << (AltPython3ParserNOT_OP - 67)) | (1 << (AltPython3ParserOPEN_BRACE - 67)) | (1 << (AltPython3ParserAT - 67)))) != 0) {
			{
				p.SetState(741)
				p.Stmt()
			}


			p.SetState(744)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(746)
			p.Match(AltPython3ParserDEDENT)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ITestContext is an interface to support dynamic dispatch.
type ITestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestContext differentiates from other interfaces.
	IsTestContext()
}

type TestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestContext() *TestContext {
	var p = new(TestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_test
	return p
}

func (*TestContext) IsTestContext() {}

func NewTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestContext {
	var p = new(TestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_test

	return p
}

func (s *TestContext) GetParser() antlr.Parser { return s.parser }

func (s *TestContext) AllOr_test() []IOr_testContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOr_testContext)(nil)).Elem())
	var tst = make([]IOr_testContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOr_testContext)
		}
	}

	return tst
}

func (s *TestContext) Or_test(i int) IOr_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_testContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *TestContext) IF() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserIF, 0)
}

func (s *TestContext) ELSE() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserELSE, 0)
}

func (s *TestContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TestContext) Lambdef() ILambdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdefContext)
}

func (s *TestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterTest(s)
	}
}

func (s *TestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitTest(s)
	}
}

func (s *TestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitTest(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Test() (localctx ITestContext) {
	localctx = NewTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, AltPython3ParserRULE_test)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(759)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserNOT, AltPython3ParserNONE, AltPython3ParserTRUE, AltPython3ParserFALSE, AltPython3ParserNAME, AltPython3ParserSTRING_LITERAL, AltPython3ParserBYTES_LITERAL, AltPython3ParserDECIMAL_INTEGER, AltPython3ParserOCT_INTEGER, AltPython3ParserHEX_INTEGER, AltPython3ParserBIN_INTEGER, AltPython3ParserFLOAT_NUMBER, AltPython3ParserIMAG_NUMBER, AltPython3ParserELLIPSIS, AltPython3ParserSTAR, AltPython3ParserOPEN_PAREN, AltPython3ParserOPEN_BRACK, AltPython3ParserADD, AltPython3ParserMINUS, AltPython3ParserNOT_OP, AltPython3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(750)
			p.Or_test()
		}
		p.SetState(756)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == AltPython3ParserIF {
			{
				p.SetState(751)
				p.Match(AltPython3ParserIF)
			}
			{
				p.SetState(752)
				p.Or_test()
			}
			{
				p.SetState(753)
				p.Match(AltPython3ParserELSE)
			}
			{
				p.SetState(754)
				p.Test()
			}

		}


	case AltPython3ParserLAMBDA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(758)
			p.Lambdef()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ITest_nocondContext is an interface to support dynamic dispatch.
type ITest_nocondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTest_nocondContext differentiates from other interfaces.
	IsTest_nocondContext()
}

type Test_nocondContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTest_nocondContext() *Test_nocondContext {
	var p = new(Test_nocondContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_test_nocond
	return p
}

func (*Test_nocondContext) IsTest_nocondContext() {}

func NewTest_nocondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Test_nocondContext {
	var p = new(Test_nocondContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_test_nocond

	return p
}

func (s *Test_nocondContext) GetParser() antlr.Parser { return s.parser }

func (s *Test_nocondContext) Or_test() IOr_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_testContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *Test_nocondContext) Lambdef_nocond() ILambdef_nocondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdef_nocondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdef_nocondContext)
}

func (s *Test_nocondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Test_nocondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Test_nocondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterTest_nocond(s)
	}
}

func (s *Test_nocondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitTest_nocond(s)
	}
}

func (s *Test_nocondContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitTest_nocond(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Test_nocond() (localctx ITest_nocondContext) {
	localctx = NewTest_nocondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, AltPython3ParserRULE_test_nocond)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(763)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserNOT, AltPython3ParserNONE, AltPython3ParserTRUE, AltPython3ParserFALSE, AltPython3ParserNAME, AltPython3ParserSTRING_LITERAL, AltPython3ParserBYTES_LITERAL, AltPython3ParserDECIMAL_INTEGER, AltPython3ParserOCT_INTEGER, AltPython3ParserHEX_INTEGER, AltPython3ParserBIN_INTEGER, AltPython3ParserFLOAT_NUMBER, AltPython3ParserIMAG_NUMBER, AltPython3ParserELLIPSIS, AltPython3ParserSTAR, AltPython3ParserOPEN_PAREN, AltPython3ParserOPEN_BRACK, AltPython3ParserADD, AltPython3ParserMINUS, AltPython3ParserNOT_OP, AltPython3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(761)
			p.Or_test()
		}


	case AltPython3ParserLAMBDA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(762)
			p.Lambdef_nocond()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ILambdefContext is an interface to support dynamic dispatch.
type ILambdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdefContext differentiates from other interfaces.
	IsLambdefContext()
}

type LambdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdefContext() *LambdefContext {
	var p = new(LambdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_lambdef
	return p
}

func (*LambdefContext) IsLambdefContext() {}

func NewLambdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdefContext {
	var p = new(LambdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_lambdef

	return p
}

func (s *LambdefContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdefContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserLAMBDA, 0)
}

func (s *LambdefContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *LambdefContext) Varargslist() IVarargslistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarargslistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarargslistContext)
}

func (s *LambdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LambdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterLambdef(s)
	}
}

func (s *LambdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitLambdef(s)
	}
}

func (s *LambdefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitLambdef(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Lambdef() (localctx ILambdefContext) {
	localctx = NewLambdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, AltPython3ParserRULE_lambdef)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(765)
		p.Match(AltPython3ParserLAMBDA)
	}
	p.SetState(767)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 36)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 36))) & ((1 << (AltPython3ParserNAME - 36)) | (1 << (AltPython3ParserSTAR - 36)) | (1 << (AltPython3ParserPOWER - 36)))) != 0) {
		{
			p.SetState(766)
			p.Varargslist()
		}

	}
	{
		p.SetState(769)
		p.Match(AltPython3ParserCOLON)
	}
	{
		p.SetState(770)
		p.Test()
	}



	return localctx
}


// ILambdef_nocondContext is an interface to support dynamic dispatch.
type ILambdef_nocondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdef_nocondContext differentiates from other interfaces.
	IsLambdef_nocondContext()
}

type Lambdef_nocondContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdef_nocondContext() *Lambdef_nocondContext {
	var p = new(Lambdef_nocondContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_lambdef_nocond
	return p
}

func (*Lambdef_nocondContext) IsLambdef_nocondContext() {}

func NewLambdef_nocondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lambdef_nocondContext {
	var p = new(Lambdef_nocondContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_lambdef_nocond

	return p
}

func (s *Lambdef_nocondContext) GetParser() antlr.Parser { return s.parser }

func (s *Lambdef_nocondContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserLAMBDA, 0)
}

func (s *Lambdef_nocondContext) Test_nocond() ITest_nocondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITest_nocondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITest_nocondContext)
}

func (s *Lambdef_nocondContext) Varargslist() IVarargslistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarargslistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarargslistContext)
}

func (s *Lambdef_nocondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lambdef_nocondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Lambdef_nocondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterLambdef_nocond(s)
	}
}

func (s *Lambdef_nocondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitLambdef_nocond(s)
	}
}

func (s *Lambdef_nocondContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitLambdef_nocond(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Lambdef_nocond() (localctx ILambdef_nocondContext) {
	localctx = NewLambdef_nocondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, AltPython3ParserRULE_lambdef_nocond)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(772)
		p.Match(AltPython3ParserLAMBDA)
	}
	p.SetState(774)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 36)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 36))) & ((1 << (AltPython3ParserNAME - 36)) | (1 << (AltPython3ParserSTAR - 36)) | (1 << (AltPython3ParserPOWER - 36)))) != 0) {
		{
			p.SetState(773)
			p.Varargslist()
		}

	}
	{
		p.SetState(776)
		p.Match(AltPython3ParserCOLON)
	}
	{
		p.SetState(777)
		p.Test_nocond()
	}



	return localctx
}


// IOr_testContext is an interface to support dynamic dispatch.
type IOr_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOr_testContext differentiates from other interfaces.
	IsOr_testContext()
}

type Or_testContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOr_testContext() *Or_testContext {
	var p = new(Or_testContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_or_test
	return p
}

func (*Or_testContext) IsOr_testContext() {}

func NewOr_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Or_testContext {
	var p = new(Or_testContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_or_test

	return p
}

func (s *Or_testContext) GetParser() antlr.Parser { return s.parser }

func (s *Or_testContext) AllAnd_test() []IAnd_testContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnd_testContext)(nil)).Elem())
	var tst = make([]IAnd_testContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnd_testContext)
		}
	}

	return tst
}

func (s *Or_testContext) And_test(i int) IAnd_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_testContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnd_testContext)
}

func (s *Or_testContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(AltPython3ParserOR)
}

func (s *Or_testContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(AltPython3ParserOR, i)
}

func (s *Or_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Or_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Or_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterOr_test(s)
	}
}

func (s *Or_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitOr_test(s)
	}
}

func (s *Or_testContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitOr_test(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Or_test() (localctx IOr_testContext) {
	localctx = NewOr_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, AltPython3ParserRULE_or_test)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(779)
		p.And_test()
	}
	p.SetState(784)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == AltPython3ParserOR {
		{
			p.SetState(780)
			p.Match(AltPython3ParserOR)
		}
		{
			p.SetState(781)
			p.And_test()
		}


		p.SetState(786)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAnd_testContext is an interface to support dynamic dispatch.
type IAnd_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnd_testContext differentiates from other interfaces.
	IsAnd_testContext()
}

type And_testContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_testContext() *And_testContext {
	var p = new(And_testContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_and_test
	return p
}

func (*And_testContext) IsAnd_testContext() {}

func NewAnd_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_testContext {
	var p = new(And_testContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_and_test

	return p
}

func (s *And_testContext) GetParser() antlr.Parser { return s.parser }

func (s *And_testContext) AllNot_test() []INot_testContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INot_testContext)(nil)).Elem())
	var tst = make([]INot_testContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INot_testContext)
		}
	}

	return tst
}

func (s *And_testContext) Not_test(i int) INot_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INot_testContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INot_testContext)
}

func (s *And_testContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(AltPython3ParserAND)
}

func (s *And_testContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(AltPython3ParserAND, i)
}

func (s *And_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *And_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterAnd_test(s)
	}
}

func (s *And_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitAnd_test(s)
	}
}

func (s *And_testContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitAnd_test(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) And_test() (localctx IAnd_testContext) {
	localctx = NewAnd_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, AltPython3ParserRULE_and_test)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(787)
		p.Not_test()
	}
	p.SetState(792)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == AltPython3ParserAND {
		{
			p.SetState(788)
			p.Match(AltPython3ParserAND)
		}
		{
			p.SetState(789)
			p.Not_test()
		}


		p.SetState(794)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// INot_testContext is an interface to support dynamic dispatch.
type INot_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNot_testContext differentiates from other interfaces.
	IsNot_testContext()
}

type Not_testContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNot_testContext() *Not_testContext {
	var p = new(Not_testContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_not_test
	return p
}

func (*Not_testContext) IsNot_testContext() {}

func NewNot_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Not_testContext {
	var p = new(Not_testContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_not_test

	return p
}

func (s *Not_testContext) GetParser() antlr.Parser { return s.parser }

func (s *Not_testContext) NOT() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNOT, 0)
}

func (s *Not_testContext) Not_test() INot_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INot_testContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INot_testContext)
}

func (s *Not_testContext) Comparison() IComparisonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *Not_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Not_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Not_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterNot_test(s)
	}
}

func (s *Not_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitNot_test(s)
	}
}

func (s *Not_testContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitNot_test(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Not_test() (localctx INot_testContext) {
	localctx = NewNot_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, AltPython3ParserRULE_not_test)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(798)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserNOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(795)
			p.Match(AltPython3ParserNOT)
		}
		{
			p.SetState(796)
			p.Not_test()
		}


	case AltPython3ParserNONE, AltPython3ParserTRUE, AltPython3ParserFALSE, AltPython3ParserNAME, AltPython3ParserSTRING_LITERAL, AltPython3ParserBYTES_LITERAL, AltPython3ParserDECIMAL_INTEGER, AltPython3ParserOCT_INTEGER, AltPython3ParserHEX_INTEGER, AltPython3ParserBIN_INTEGER, AltPython3ParserFLOAT_NUMBER, AltPython3ParserIMAG_NUMBER, AltPython3ParserELLIPSIS, AltPython3ParserSTAR, AltPython3ParserOPEN_PAREN, AltPython3ParserOPEN_BRACK, AltPython3ParserADD, AltPython3ParserMINUS, AltPython3ParserNOT_OP, AltPython3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(797)
			p.Comparison()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IComparisonContext is an interface to support dynamic dispatch.
type IComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonContext differentiates from other interfaces.
	IsComparisonContext()
}

type ComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonContext() *ComparisonContext {
	var p = new(ComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_comparison
	return p
}

func (*ComparisonContext) IsComparisonContext() {}

func NewComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonContext {
	var p = new(ComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_comparison

	return p
}

func (s *ComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonContext) AllStar_expr() []IStar_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStar_exprContext)(nil)).Elem())
	var tst = make([]IStar_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStar_exprContext)
		}
	}

	return tst
}

func (s *ComparisonContext) Star_expr(i int) IStar_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStar_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *ComparisonContext) AllComp_op() []IComp_opContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComp_opContext)(nil)).Elem())
	var tst = make([]IComp_opContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComp_opContext)
		}
	}

	return tst
}

func (s *ComparisonContext) Comp_op(i int) IComp_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_opContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComp_opContext)
}

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitComparison(s)
	}
}

func (s *ComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitComparison(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Comparison() (localctx IComparisonContext) {
	localctx = NewComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, AltPython3ParserRULE_comparison)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(800)
		p.Star_expr()
	}
	p.SetState(806)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << AltPython3ParserIN) | (1 << AltPython3ParserNOT) | (1 << AltPython3ParserIS))) != 0) || ((((_la - 70)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 70))) & ((1 << (AltPython3ParserLESS_THAN - 70)) | (1 << (AltPython3ParserGREATER_THAN - 70)) | (1 << (AltPython3ParserEQUALS - 70)) | (1 << (AltPython3ParserGT_EQ - 70)) | (1 << (AltPython3ParserLT_EQ - 70)) | (1 << (AltPython3ParserNOT_EQ_1 - 70)) | (1 << (AltPython3ParserNOT_EQ_2 - 70)))) != 0) {
		{
			p.SetState(801)
			p.Comp_op()
		}
		{
			p.SetState(802)
			p.Star_expr()
		}


		p.SetState(808)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IComp_opContext is an interface to support dynamic dispatch.
type IComp_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_opContext differentiates from other interfaces.
	IsComp_opContext()
}

type Comp_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_opContext() *Comp_opContext {
	var p = new(Comp_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_comp_op
	return p
}

func (*Comp_opContext) IsComp_opContext() {}

func NewComp_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_opContext {
	var p = new(Comp_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_comp_op

	return p
}

func (s *Comp_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_opContext) IN() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserIN, 0)
}

func (s *Comp_opContext) NOT() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNOT, 0)
}

func (s *Comp_opContext) IS() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserIS, 0)
}

func (s *Comp_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Comp_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterComp_op(s)
	}
}

func (s *Comp_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitComp_op(s)
	}
}

func (s *Comp_opContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitComp_op(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Comp_op() (localctx IComp_opContext) {
	localctx = NewComp_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, AltPython3ParserRULE_comp_op)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(822)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(809)
			p.Match(AltPython3ParserLESS_THAN)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(810)
			p.Match(AltPython3ParserGREATER_THAN)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(811)
			p.Match(AltPython3ParserEQUALS)
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(812)
			p.Match(AltPython3ParserGT_EQ)
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(813)
			p.Match(AltPython3ParserLT_EQ)
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(814)
			p.Match(AltPython3ParserNOT_EQ_1)
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(815)
			p.Match(AltPython3ParserNOT_EQ_2)
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(816)
			p.Match(AltPython3ParserIN)
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(817)
			p.Match(AltPython3ParserNOT)
		}
		{
			p.SetState(818)
			p.Match(AltPython3ParserIN)
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(819)
			p.Match(AltPython3ParserIS)
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(820)
			p.Match(AltPython3ParserIS)
		}
		{
			p.SetState(821)
			p.Match(AltPython3ParserNOT)
		}

	}


	return localctx
}


// IStar_exprContext is an interface to support dynamic dispatch.
type IStar_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStar_exprContext differentiates from other interfaces.
	IsStar_exprContext()
}

type Star_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStar_exprContext() *Star_exprContext {
	var p = new(Star_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_star_expr
	return p
}

func (*Star_exprContext) IsStar_exprContext() {}

func NewStar_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Star_exprContext {
	var p = new(Star_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_star_expr

	return p
}

func (s *Star_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Star_exprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Star_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Star_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Star_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterStar_expr(s)
	}
}

func (s *Star_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitStar_expr(s)
	}
}

func (s *Star_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitStar_expr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Star_expr() (localctx IStar_exprContext) {
	localctx = NewStar_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, AltPython3ParserRULE_star_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(825)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserSTAR {
		{
			p.SetState(824)
			p.Match(AltPython3ParserSTAR)
		}

	}
	{
		p.SetState(827)
		p.Expr()
	}



	return localctx
}


// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AllXor_expr() []IXor_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IXor_exprContext)(nil)).Elem())
	var tst = make([]IXor_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IXor_exprContext)
		}
	}

	return tst
}

func (s *ExprContext) Xor_expr(i int) IXor_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXor_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IXor_exprContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitExpr(s)
	}
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, AltPython3ParserRULE_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(829)
		p.Xor_expr()
	}
	p.SetState(834)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == AltPython3ParserOR_OP {
		{
			p.SetState(830)
			p.Match(AltPython3ParserOR_OP)
		}
		{
			p.SetState(831)
			p.Xor_expr()
		}


		p.SetState(836)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IXor_exprContext is an interface to support dynamic dispatch.
type IXor_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXor_exprContext differentiates from other interfaces.
	IsXor_exprContext()
}

type Xor_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXor_exprContext() *Xor_exprContext {
	var p = new(Xor_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_xor_expr
	return p
}

func (*Xor_exprContext) IsXor_exprContext() {}

func NewXor_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xor_exprContext {
	var p = new(Xor_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_xor_expr

	return p
}

func (s *Xor_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Xor_exprContext) AllAnd_expr() []IAnd_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnd_exprContext)(nil)).Elem())
	var tst = make([]IAnd_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnd_exprContext)
		}
	}

	return tst
}

func (s *Xor_exprContext) And_expr(i int) IAnd_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnd_exprContext)
}

func (s *Xor_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xor_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Xor_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterXor_expr(s)
	}
}

func (s *Xor_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitXor_expr(s)
	}
}

func (s *Xor_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitXor_expr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Xor_expr() (localctx IXor_exprContext) {
	localctx = NewXor_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, AltPython3ParserRULE_xor_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(837)
		p.And_expr()
	}
	p.SetState(842)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == AltPython3ParserXOR {
		{
			p.SetState(838)
			p.Match(AltPython3ParserXOR)
		}
		{
			p.SetState(839)
			p.And_expr()
		}


		p.SetState(844)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAnd_exprContext is an interface to support dynamic dispatch.
type IAnd_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnd_exprContext differentiates from other interfaces.
	IsAnd_exprContext()
}

type And_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_exprContext() *And_exprContext {
	var p = new(And_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_and_expr
	return p
}

func (*And_exprContext) IsAnd_exprContext() {}

func NewAnd_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_exprContext {
	var p = new(And_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_and_expr

	return p
}

func (s *And_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *And_exprContext) AllShift_expr() []IShift_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IShift_exprContext)(nil)).Elem())
	var tst = make([]IShift_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IShift_exprContext)
		}
	}

	return tst
}

func (s *And_exprContext) Shift_expr(i int) IShift_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IShift_exprContext)
}

func (s *And_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *And_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterAnd_expr(s)
	}
}

func (s *And_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitAnd_expr(s)
	}
}

func (s *And_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitAnd_expr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) And_expr() (localctx IAnd_exprContext) {
	localctx = NewAnd_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, AltPython3ParserRULE_and_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(845)
		p.Shift_expr()
	}
	p.SetState(850)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == AltPython3ParserAND_OP {
		{
			p.SetState(846)
			p.Match(AltPython3ParserAND_OP)
		}
		{
			p.SetState(847)
			p.Shift_expr()
		}


		p.SetState(852)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IShift_exprContext is an interface to support dynamic dispatch.
type IShift_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShift_exprContext differentiates from other interfaces.
	IsShift_exprContext()
}

type Shift_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_exprContext() *Shift_exprContext {
	var p = new(Shift_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_shift_expr
	return p
}

func (*Shift_exprContext) IsShift_exprContext() {}

func NewShift_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_exprContext {
	var p = new(Shift_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_shift_expr

	return p
}

func (s *Shift_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_exprContext) AllArith_expr() []IArith_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArith_exprContext)(nil)).Elem())
	var tst = make([]IArith_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArith_exprContext)
		}
	}

	return tst
}

func (s *Shift_exprContext) Arith_expr(i int) IArith_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArith_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArith_exprContext)
}

func (s *Shift_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Shift_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterShift_expr(s)
	}
}

func (s *Shift_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitShift_expr(s)
	}
}

func (s *Shift_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitShift_expr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Shift_expr() (localctx IShift_exprContext) {
	localctx = NewShift_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, AltPython3ParserRULE_shift_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(853)
		p.Arith_expr()
	}
	p.SetState(860)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == AltPython3ParserLEFT_SHIFT || _la == AltPython3ParserRIGHT_SHIFT {
		p.SetState(858)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case AltPython3ParserLEFT_SHIFT:
			{
				p.SetState(854)
				p.Match(AltPython3ParserLEFT_SHIFT)
			}
			{
				p.SetState(855)
				p.Arith_expr()
			}


		case AltPython3ParserRIGHT_SHIFT:
			{
				p.SetState(856)
				p.Match(AltPython3ParserRIGHT_SHIFT)
			}
			{
				p.SetState(857)
				p.Arith_expr()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(862)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IArith_exprContext is an interface to support dynamic dispatch.
type IArith_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArith_exprContext differentiates from other interfaces.
	IsArith_exprContext()
}

type Arith_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArith_exprContext() *Arith_exprContext {
	var p = new(Arith_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_arith_expr
	return p
}

func (*Arith_exprContext) IsArith_exprContext() {}

func NewArith_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arith_exprContext {
	var p = new(Arith_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_arith_expr

	return p
}

func (s *Arith_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Arith_exprContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *Arith_exprContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Arith_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arith_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Arith_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterArith_expr(s)
	}
}

func (s *Arith_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitArith_expr(s)
	}
}

func (s *Arith_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitArith_expr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Arith_expr() (localctx IArith_exprContext) {
	localctx = NewArith_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, AltPython3ParserRULE_arith_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(863)
		p.Term()
	}
	p.SetState(870)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == AltPython3ParserADD || _la == AltPython3ParserMINUS {
		p.SetState(868)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case AltPython3ParserADD:
			{
				p.SetState(864)
				p.Match(AltPython3ParserADD)
			}
			{
				p.SetState(865)
				p.Term()
			}


		case AltPython3ParserMINUS:
			{
				p.SetState(866)
				p.Match(AltPython3ParserMINUS)
			}
			{
				p.SetState(867)
				p.Term()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(872)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) AllFactor() []IFactorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFactorContext)(nil)).Elem())
	var tst = make([]IFactorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFactorContext)
		}
	}

	return tst
}

func (s *TermContext) Factor(i int) IFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitTerm(s)
	}
}

func (s *TermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitTerm(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, AltPython3ParserRULE_term)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(873)
		p.Factor()
	}
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ((((_la - 47)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 47))) & ((1 << (AltPython3ParserSTAR - 47)) | (1 << (AltPython3ParserDIV - 47)) | (1 << (AltPython3ParserMOD - 47)) | (1 << (AltPython3ParserIDIV - 47)) | (1 << (AltPython3ParserAT - 47)))) != 0) {
		p.SetState(884)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case AltPython3ParserSTAR:
			{
				p.SetState(874)
				p.Match(AltPython3ParserSTAR)
			}
			{
				p.SetState(875)
				p.Factor()
			}


		case AltPython3ParserDIV:
			{
				p.SetState(876)
				p.Match(AltPython3ParserDIV)
			}
			{
				p.SetState(877)
				p.Factor()
			}


		case AltPython3ParserMOD:
			{
				p.SetState(878)
				p.Match(AltPython3ParserMOD)
			}
			{
				p.SetState(879)
				p.Factor()
			}


		case AltPython3ParserIDIV:
			{
				p.SetState(880)
				p.Match(AltPython3ParserIDIV)
			}
			{
				p.SetState(881)
				p.Factor()
			}


		case AltPython3ParserAT:
			{
				p.SetState(882)
				p.Match(AltPython3ParserAT)
			}
			{
				p.SetState(883)
				p.Factor()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(888)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IFactorContext is an interface to support dynamic dispatch.
type IFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFactorContext differentiates from other interfaces.
	IsFactorContext()
}

type FactorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactorContext() *FactorContext {
	var p = new(FactorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_factor
	return p
}

func (*FactorContext) IsFactorContext() {}

func NewFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FactorContext {
	var p = new(FactorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_factor

	return p
}

func (s *FactorContext) GetParser() antlr.Parser { return s.parser }

func (s *FactorContext) Factor() IFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *FactorContext) Power() IPowerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowerContext)
}

func (s *FactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterFactor(s)
	}
}

func (s *FactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitFactor(s)
	}
}

func (s *FactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitFactor(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Factor() (localctx IFactorContext) {
	localctx = NewFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, AltPython3ParserRULE_factor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(896)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserADD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(889)
			p.Match(AltPython3ParserADD)
		}
		{
			p.SetState(890)
			p.Factor()
		}


	case AltPython3ParserMINUS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(891)
			p.Match(AltPython3ParserMINUS)
		}
		{
			p.SetState(892)
			p.Factor()
		}


	case AltPython3ParserNOT_OP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(893)
			p.Match(AltPython3ParserNOT_OP)
		}
		{
			p.SetState(894)
			p.Factor()
		}


	case AltPython3ParserNONE, AltPython3ParserTRUE, AltPython3ParserFALSE, AltPython3ParserNAME, AltPython3ParserSTRING_LITERAL, AltPython3ParserBYTES_LITERAL, AltPython3ParserDECIMAL_INTEGER, AltPython3ParserOCT_INTEGER, AltPython3ParserHEX_INTEGER, AltPython3ParserBIN_INTEGER, AltPython3ParserFLOAT_NUMBER, AltPython3ParserIMAG_NUMBER, AltPython3ParserELLIPSIS, AltPython3ParserOPEN_PAREN, AltPython3ParserOPEN_BRACK, AltPython3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(895)
			p.Power()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IPowerContext is an interface to support dynamic dispatch.
type IPowerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerContext differentiates from other interfaces.
	IsPowerContext()
}

type PowerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerContext() *PowerContext {
	var p = new(PowerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_power
	return p
}

func (*PowerContext) IsPowerContext() {}

func NewPowerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerContext {
	var p = new(PowerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_power

	return p
}

func (s *PowerContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *PowerContext) AllTrailer() []ITrailerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITrailerContext)(nil)).Elem())
	var tst = make([]ITrailerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITrailerContext)
		}
	}

	return tst
}

func (s *PowerContext) Trailer(i int) ITrailerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrailerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITrailerContext)
}

func (s *PowerContext) Factor() IFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *PowerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PowerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterPower(s)
	}
}

func (s *PowerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitPower(s)
	}
}

func (s *PowerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitPower(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Power() (localctx IPowerContext) {
	localctx = NewPowerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, AltPython3ParserRULE_power)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(898)
		p.Atom()
	}
	p.SetState(902)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ((((_la - 45)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 45))) & ((1 << (AltPython3ParserDOT - 45)) | (1 << (AltPython3ParserOPEN_PAREN - 45)) | (1 << (AltPython3ParserOPEN_BRACK - 45)))) != 0) {
		{
			p.SetState(899)
			p.Trailer()
		}


		p.SetState(904)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(907)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserPOWER {
		{
			p.SetState(905)
			p.Match(AltPython3ParserPOWER)
		}
		{
			p.SetState(906)
			p.Factor()
		}

	}



	return localctx
}


// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) Yield_expr() IYield_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *AtomContext) Testlist_comp() ITestlist_compContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlist_compContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlist_compContext)
}

func (s *AtomContext) Dictorsetmaker() IDictorsetmakerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictorsetmakerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictorsetmakerContext)
}

func (s *AtomContext) NAME() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNAME, 0)
}

func (s *AtomContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *AtomContext) AllStr() []IStrContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStrContext)(nil)).Elem())
	var tst = make([]IStrContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStrContext)
		}
	}

	return tst
}

func (s *AtomContext) Str(i int) IStrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *AtomContext) NONE() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNONE, 0)
}

func (s *AtomContext) TRUE() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserTRUE, 0)
}

func (s *AtomContext) FALSE() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserFALSE, 0)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitAtom(s)
	}
}

func (s *AtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitAtom(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, AltPython3ParserRULE_atom)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(937)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserOPEN_PAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(909)
			p.Match(AltPython3ParserOPEN_PAREN)
		}
		p.SetState(912)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case AltPython3ParserYIELD:
			{
				p.SetState(910)
				p.Yield_expr()
			}


		case AltPython3ParserLAMBDA, AltPython3ParserNOT, AltPython3ParserNONE, AltPython3ParserTRUE, AltPython3ParserFALSE, AltPython3ParserNAME, AltPython3ParserSTRING_LITERAL, AltPython3ParserBYTES_LITERAL, AltPython3ParserDECIMAL_INTEGER, AltPython3ParserOCT_INTEGER, AltPython3ParserHEX_INTEGER, AltPython3ParserBIN_INTEGER, AltPython3ParserFLOAT_NUMBER, AltPython3ParserIMAG_NUMBER, AltPython3ParserELLIPSIS, AltPython3ParserSTAR, AltPython3ParserOPEN_PAREN, AltPython3ParserOPEN_BRACK, AltPython3ParserADD, AltPython3ParserMINUS, AltPython3ParserNOT_OP, AltPython3ParserOPEN_BRACE:
			{
				p.SetState(911)
				p.Testlist_comp()
			}


		case AltPython3ParserCLOSE_PAREN:



		default:
		}
		{
			p.SetState(914)
			p.Match(AltPython3ParserCLOSE_PAREN)
		}


	case AltPython3ParserOPEN_BRACK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(915)
			p.Match(AltPython3ParserOPEN_BRACK)
		}
		p.SetState(917)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 21)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 21))) & ((1 << (AltPython3ParserLAMBDA - 21)) | (1 << (AltPython3ParserNOT - 21)) | (1 << (AltPython3ParserNONE - 21)) | (1 << (AltPython3ParserTRUE - 21)) | (1 << (AltPython3ParserFALSE - 21)) | (1 << (AltPython3ParserNAME - 21)) | (1 << (AltPython3ParserSTRING_LITERAL - 21)) | (1 << (AltPython3ParserBYTES_LITERAL - 21)) | (1 << (AltPython3ParserDECIMAL_INTEGER - 21)) | (1 << (AltPython3ParserOCT_INTEGER - 21)) | (1 << (AltPython3ParserHEX_INTEGER - 21)) | (1 << (AltPython3ParserBIN_INTEGER - 21)) | (1 << (AltPython3ParserFLOAT_NUMBER - 21)) | (1 << (AltPython3ParserIMAG_NUMBER - 21)) | (1 << (AltPython3ParserELLIPSIS - 21)) | (1 << (AltPython3ParserSTAR - 21)) | (1 << (AltPython3ParserOPEN_PAREN - 21)))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (AltPython3ParserOPEN_BRACK - 55)) | (1 << (AltPython3ParserADD - 55)) | (1 << (AltPython3ParserMINUS - 55)) | (1 << (AltPython3ParserNOT_OP - 55)) | (1 << (AltPython3ParserOPEN_BRACE - 55)))) != 0) {
			{
				p.SetState(916)
				p.Testlist_comp()
			}

		}
		{
			p.SetState(919)
			p.Match(AltPython3ParserCLOSE_BRACK)
		}


	case AltPython3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(920)
			p.Match(AltPython3ParserOPEN_BRACE)
		}
		p.SetState(922)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 21)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 21))) & ((1 << (AltPython3ParserLAMBDA - 21)) | (1 << (AltPython3ParserNOT - 21)) | (1 << (AltPython3ParserNONE - 21)) | (1 << (AltPython3ParserTRUE - 21)) | (1 << (AltPython3ParserFALSE - 21)) | (1 << (AltPython3ParserNAME - 21)) | (1 << (AltPython3ParserSTRING_LITERAL - 21)) | (1 << (AltPython3ParserBYTES_LITERAL - 21)) | (1 << (AltPython3ParserDECIMAL_INTEGER - 21)) | (1 << (AltPython3ParserOCT_INTEGER - 21)) | (1 << (AltPython3ParserHEX_INTEGER - 21)) | (1 << (AltPython3ParserBIN_INTEGER - 21)) | (1 << (AltPython3ParserFLOAT_NUMBER - 21)) | (1 << (AltPython3ParserIMAG_NUMBER - 21)) | (1 << (AltPython3ParserELLIPSIS - 21)) | (1 << (AltPython3ParserSTAR - 21)) | (1 << (AltPython3ParserOPEN_PAREN - 21)))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (AltPython3ParserOPEN_BRACK - 55)) | (1 << (AltPython3ParserADD - 55)) | (1 << (AltPython3ParserMINUS - 55)) | (1 << (AltPython3ParserNOT_OP - 55)) | (1 << (AltPython3ParserOPEN_BRACE - 55)))) != 0) {
			{
				p.SetState(921)
				p.Dictorsetmaker()
			}

		}
		{
			p.SetState(924)
			p.Match(AltPython3ParserCLOSE_BRACE)
		}


	case AltPython3ParserNAME:
		p.EnterOuterAlt(localctx, 4)

			org.antlr.v4.runtime.CommonToken token = null;
			String tokenName = null;

			if (this._ctx.start instanceof org.antlr.v4.runtime.CommonToken) {
				token = (org.antlr.v4.runtime.CommonToken)this._ctx.start;

				if (token.getType() != AltPython3Parser.ALREADY_THROWN_TOKEN_TYPE) {
					tokenName = token.getText();
				}
			}

			if ("xrange".equals(tokenName) || "raw_input".equals(tokenName)) {
				if (this.getStrictPython3Parsing()) {
					// This throws twice - the second time on parenthesis close.
					token.setType(AltPython3Parser.ALREADY_THROWN_TOKEN_TYPE);

					throw new NoViableAltException(this);
				}
				else {
					this.likelyIsPython2 = true;
				}
			}
		 
		{
			p.SetState(926)
			p.Match(AltPython3ParserNAME)
		}


	case AltPython3ParserDECIMAL_INTEGER, AltPython3ParserOCT_INTEGER, AltPython3ParserHEX_INTEGER, AltPython3ParserBIN_INTEGER, AltPython3ParserFLOAT_NUMBER, AltPython3ParserIMAG_NUMBER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(927)
			p.Number()
		}


	case AltPython3ParserSTRING_LITERAL, AltPython3ParserBYTES_LITERAL:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(929)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == AltPython3ParserSTRING_LITERAL || _la == AltPython3ParserBYTES_LITERAL {
			{
				p.SetState(928)
				p.Str()
			}


			p.SetState(931)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}


	case AltPython3ParserELLIPSIS:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(933)
			p.Match(AltPython3ParserELLIPSIS)
		}


	case AltPython3ParserNONE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(934)
			p.Match(AltPython3ParserNONE)
		}


	case AltPython3ParserTRUE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(935)
			p.Match(AltPython3ParserTRUE)
		}


	case AltPython3ParserFALSE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(936)
			p.Match(AltPython3ParserFALSE)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ITestlist_compContext is an interface to support dynamic dispatch.
type ITestlist_compContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestlist_compContext differentiates from other interfaces.
	IsTestlist_compContext()
}

type Testlist_compContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlist_compContext() *Testlist_compContext {
	var p = new(Testlist_compContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_testlist_comp
	return p
}

func (*Testlist_compContext) IsTestlist_compContext() {}

func NewTestlist_compContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Testlist_compContext {
	var p = new(Testlist_compContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_testlist_comp

	return p
}

func (s *Testlist_compContext) GetParser() antlr.Parser { return s.parser }

func (s *Testlist_compContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Testlist_compContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Testlist_compContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *Testlist_compContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Testlist_compContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Testlist_compContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterTestlist_comp(s)
	}
}

func (s *Testlist_compContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitTestlist_comp(s)
	}
}

func (s *Testlist_compContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitTestlist_comp(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Testlist_comp() (localctx ITestlist_compContext) {
	localctx = NewTestlist_compContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, AltPython3ParserRULE_testlist_comp)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(939)
		p.Test()
	}
	p.SetState(951)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserFOR:
		{
			p.SetState(940)
			p.Comp_for()
		}


	case AltPython3ParserCLOSE_PAREN, AltPython3ParserCOMMA, AltPython3ParserCLOSE_BRACK:
		p.SetState(945)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(941)
					p.Match(AltPython3ParserCOMMA)
				}
				{
					p.SetState(942)
					p.Test()
				}


			}
			p.SetState(947)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext())
		}
		p.SetState(949)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == AltPython3ParserCOMMA {
			{
				p.SetState(948)
				p.Match(AltPython3ParserCOMMA)
			}

		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}



	return localctx
}


// ITrailerContext is an interface to support dynamic dispatch.
type ITrailerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrailerContext differentiates from other interfaces.
	IsTrailerContext()
}

type TrailerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrailerContext() *TrailerContext {
	var p = new(TrailerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_trailer
	return p
}

func (*TrailerContext) IsTrailerContext() {}

func NewTrailerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrailerContext {
	var p = new(TrailerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_trailer

	return p
}

func (s *TrailerContext) GetParser() antlr.Parser { return s.parser }

func (s *TrailerContext) Arglist() IArglistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArglistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *TrailerContext) Subscriptlist() ISubscriptlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubscriptlistContext)
}

func (s *TrailerContext) NAME() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNAME, 0)
}

func (s *TrailerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrailerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TrailerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterTrailer(s)
	}
}

func (s *TrailerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitTrailer(s)
	}
}

func (s *TrailerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitTrailer(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Trailer() (localctx ITrailerContext) {
	localctx = NewTrailerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, AltPython3ParserRULE_trailer)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(965)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserOPEN_PAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(953)
			p.Match(AltPython3ParserOPEN_PAREN)
		}
		p.SetState(955)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 21)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 21))) & ((1 << (AltPython3ParserLAMBDA - 21)) | (1 << (AltPython3ParserNOT - 21)) | (1 << (AltPython3ParserNONE - 21)) | (1 << (AltPython3ParserTRUE - 21)) | (1 << (AltPython3ParserFALSE - 21)) | (1 << (AltPython3ParserNAME - 21)) | (1 << (AltPython3ParserSTRING_LITERAL - 21)) | (1 << (AltPython3ParserBYTES_LITERAL - 21)) | (1 << (AltPython3ParserDECIMAL_INTEGER - 21)) | (1 << (AltPython3ParserOCT_INTEGER - 21)) | (1 << (AltPython3ParserHEX_INTEGER - 21)) | (1 << (AltPython3ParserBIN_INTEGER - 21)) | (1 << (AltPython3ParserFLOAT_NUMBER - 21)) | (1 << (AltPython3ParserIMAG_NUMBER - 21)) | (1 << (AltPython3ParserELLIPSIS - 21)) | (1 << (AltPython3ParserSTAR - 21)) | (1 << (AltPython3ParserOPEN_PAREN - 21)))) != 0) || ((((_la - 53)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 53))) & ((1 << (AltPython3ParserPOWER - 53)) | (1 << (AltPython3ParserOPEN_BRACK - 53)) | (1 << (AltPython3ParserADD - 53)) | (1 << (AltPython3ParserMINUS - 53)) | (1 << (AltPython3ParserNOT_OP - 53)) | (1 << (AltPython3ParserOPEN_BRACE - 53)))) != 0) {
			{
				p.SetState(954)
				p.Arglist()
			}

		}
		{
			p.SetState(957)
			p.Match(AltPython3ParserCLOSE_PAREN)
		}


	case AltPython3ParserOPEN_BRACK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(958)
			p.Match(AltPython3ParserOPEN_BRACK)
		}
		{
			p.SetState(959)
			p.Subscriptlist()
		}
		{
			p.SetState(960)
			p.Match(AltPython3ParserCLOSE_BRACK)
		}


	case AltPython3ParserDOT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(962)
			p.Match(AltPython3ParserDOT)
		}
		{
			p.SetState(963)
			p.Match(AltPython3ParserNAME)
		}

			if ("next".equals(this._ctx.children.get(1).getText())) {
				if (this.getStrictPython3Parsing()) {
					TerminalNode tn = ((org.antlr.v4.runtime.tree.TerminalNodeImpl)this._ctx.children.get(0));
					Token parentObject = ((PowerContext)tn.getParent().getParent()).start;
					Token offendingToken = ((org.antlr.v4.runtime.tree.TerminalNodeImpl)this._ctx.children.get(1)).getSymbol();

					throw new NoViableAltException(this, this.getInputStream(), parentObject, offendingToken, null,
												   this._ctx);
				}
				else {
					this.likelyIsPython2 = true;
				}
			}
		 



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ISubscriptlistContext is an interface to support dynamic dispatch.
type ISubscriptlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscriptlistContext differentiates from other interfaces.
	IsSubscriptlistContext()
}

type SubscriptlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptlistContext() *SubscriptlistContext {
	var p = new(SubscriptlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_subscriptlist
	return p
}

func (*SubscriptlistContext) IsSubscriptlistContext() {}

func NewSubscriptlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptlistContext {
	var p = new(SubscriptlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_subscriptlist

	return p
}

func (s *SubscriptlistContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptlistContext) AllSubscript() []ISubscriptContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscriptContext)(nil)).Elem())
	var tst = make([]ISubscriptContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscriptContext)
		}
	}

	return tst
}

func (s *SubscriptlistContext) Subscript(i int) ISubscriptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscriptContext)
}

func (s *SubscriptlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SubscriptlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterSubscriptlist(s)
	}
}

func (s *SubscriptlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitSubscriptlist(s)
	}
}

func (s *SubscriptlistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitSubscriptlist(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Subscriptlist() (localctx ISubscriptlistContext) {
	localctx = NewSubscriptlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, AltPython3ParserRULE_subscriptlist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(967)
		p.Subscript()
	}
	p.SetState(972)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(968)
				p.Match(AltPython3ParserCOMMA)
			}
			{
				p.SetState(969)
				p.Subscript()
			}


		}
		p.SetState(974)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext())
	}
	p.SetState(976)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserCOMMA {
		{
			p.SetState(975)
			p.Match(AltPython3ParserCOMMA)
		}

	}



	return localctx
}


// ISubscriptContext is an interface to support dynamic dispatch.
type ISubscriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscriptContext differentiates from other interfaces.
	IsSubscriptContext()
}

type SubscriptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptContext() *SubscriptContext {
	var p = new(SubscriptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_subscript
	return p
}

func (*SubscriptContext) IsSubscriptContext() {}

func NewSubscriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptContext {
	var p = new(SubscriptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_subscript

	return p
}

func (s *SubscriptContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *SubscriptContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *SubscriptContext) Sliceop() ISliceopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISliceopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISliceopContext)
}

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitSubscript(s)
	}
}

func (s *SubscriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitSubscript(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Subscript() (localctx ISubscriptContext) {
	localctx = NewSubscriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, AltPython3ParserRULE_subscript)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(989)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(978)
			p.Test()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(980)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 21)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 21))) & ((1 << (AltPython3ParserLAMBDA - 21)) | (1 << (AltPython3ParserNOT - 21)) | (1 << (AltPython3ParserNONE - 21)) | (1 << (AltPython3ParserTRUE - 21)) | (1 << (AltPython3ParserFALSE - 21)) | (1 << (AltPython3ParserNAME - 21)) | (1 << (AltPython3ParserSTRING_LITERAL - 21)) | (1 << (AltPython3ParserBYTES_LITERAL - 21)) | (1 << (AltPython3ParserDECIMAL_INTEGER - 21)) | (1 << (AltPython3ParserOCT_INTEGER - 21)) | (1 << (AltPython3ParserHEX_INTEGER - 21)) | (1 << (AltPython3ParserBIN_INTEGER - 21)) | (1 << (AltPython3ParserFLOAT_NUMBER - 21)) | (1 << (AltPython3ParserIMAG_NUMBER - 21)) | (1 << (AltPython3ParserELLIPSIS - 21)) | (1 << (AltPython3ParserSTAR - 21)) | (1 << (AltPython3ParserOPEN_PAREN - 21)))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (AltPython3ParserOPEN_BRACK - 55)) | (1 << (AltPython3ParserADD - 55)) | (1 << (AltPython3ParserMINUS - 55)) | (1 << (AltPython3ParserNOT_OP - 55)) | (1 << (AltPython3ParserOPEN_BRACE - 55)))) != 0) {
			{
				p.SetState(979)
				p.Test()
			}

		}
		{
			p.SetState(982)
			p.Match(AltPython3ParserCOLON)
		}
		p.SetState(984)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 21)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 21))) & ((1 << (AltPython3ParserLAMBDA - 21)) | (1 << (AltPython3ParserNOT - 21)) | (1 << (AltPython3ParserNONE - 21)) | (1 << (AltPython3ParserTRUE - 21)) | (1 << (AltPython3ParserFALSE - 21)) | (1 << (AltPython3ParserNAME - 21)) | (1 << (AltPython3ParserSTRING_LITERAL - 21)) | (1 << (AltPython3ParserBYTES_LITERAL - 21)) | (1 << (AltPython3ParserDECIMAL_INTEGER - 21)) | (1 << (AltPython3ParserOCT_INTEGER - 21)) | (1 << (AltPython3ParserHEX_INTEGER - 21)) | (1 << (AltPython3ParserBIN_INTEGER - 21)) | (1 << (AltPython3ParserFLOAT_NUMBER - 21)) | (1 << (AltPython3ParserIMAG_NUMBER - 21)) | (1 << (AltPython3ParserELLIPSIS - 21)) | (1 << (AltPython3ParserSTAR - 21)) | (1 << (AltPython3ParserOPEN_PAREN - 21)))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (AltPython3ParserOPEN_BRACK - 55)) | (1 << (AltPython3ParserADD - 55)) | (1 << (AltPython3ParserMINUS - 55)) | (1 << (AltPython3ParserNOT_OP - 55)) | (1 << (AltPython3ParserOPEN_BRACE - 55)))) != 0) {
			{
				p.SetState(983)
				p.Test()
			}

		}
		p.SetState(987)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == AltPython3ParserCOLON {
			{
				p.SetState(986)
				p.Sliceop()
			}

		}

	}


	return localctx
}


// ISliceopContext is an interface to support dynamic dispatch.
type ISliceopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSliceopContext differentiates from other interfaces.
	IsSliceopContext()
}

type SliceopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySliceopContext() *SliceopContext {
	var p = new(SliceopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_sliceop
	return p
}

func (*SliceopContext) IsSliceopContext() {}

func NewSliceopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SliceopContext {
	var p = new(SliceopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_sliceop

	return p
}

func (s *SliceopContext) GetParser() antlr.Parser { return s.parser }

func (s *SliceopContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *SliceopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SliceopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SliceopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterSliceop(s)
	}
}

func (s *SliceopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitSliceop(s)
	}
}

func (s *SliceopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitSliceop(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Sliceop() (localctx ISliceopContext) {
	localctx = NewSliceopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, AltPython3ParserRULE_sliceop)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(991)
		p.Match(AltPython3ParserCOLON)
	}
	p.SetState(993)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 21)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 21))) & ((1 << (AltPython3ParserLAMBDA - 21)) | (1 << (AltPython3ParserNOT - 21)) | (1 << (AltPython3ParserNONE - 21)) | (1 << (AltPython3ParserTRUE - 21)) | (1 << (AltPython3ParserFALSE - 21)) | (1 << (AltPython3ParserNAME - 21)) | (1 << (AltPython3ParserSTRING_LITERAL - 21)) | (1 << (AltPython3ParserBYTES_LITERAL - 21)) | (1 << (AltPython3ParserDECIMAL_INTEGER - 21)) | (1 << (AltPython3ParserOCT_INTEGER - 21)) | (1 << (AltPython3ParserHEX_INTEGER - 21)) | (1 << (AltPython3ParserBIN_INTEGER - 21)) | (1 << (AltPython3ParserFLOAT_NUMBER - 21)) | (1 << (AltPython3ParserIMAG_NUMBER - 21)) | (1 << (AltPython3ParserELLIPSIS - 21)) | (1 << (AltPython3ParserSTAR - 21)) | (1 << (AltPython3ParserOPEN_PAREN - 21)))) != 0) || ((((_la - 55)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 55))) & ((1 << (AltPython3ParserOPEN_BRACK - 55)) | (1 << (AltPython3ParserADD - 55)) | (1 << (AltPython3ParserMINUS - 55)) | (1 << (AltPython3ParserNOT_OP - 55)) | (1 << (AltPython3ParserOPEN_BRACE - 55)))) != 0) {
		{
			p.SetState(992)
			p.Test()
		}

	}



	return localctx
}


// IExprlistContext is an interface to support dynamic dispatch.
type IExprlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprlistContext differentiates from other interfaces.
	IsExprlistContext()
}

type ExprlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprlistContext() *ExprlistContext {
	var p = new(ExprlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_exprlist
	return p
}

func (*ExprlistContext) IsExprlistContext() {}

func NewExprlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprlistContext {
	var p = new(ExprlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_exprlist

	return p
}

func (s *ExprlistContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprlistContext) AllStar_expr() []IStar_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStar_exprContext)(nil)).Elem())
	var tst = make([]IStar_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStar_exprContext)
		}
	}

	return tst
}

func (s *ExprlistContext) Star_expr(i int) IStar_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStar_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *ExprlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExprlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterExprlist(s)
	}
}

func (s *ExprlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitExprlist(s)
	}
}

func (s *ExprlistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitExprlist(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Exprlist() (localctx IExprlistContext) {
	localctx = NewExprlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, AltPython3ParserRULE_exprlist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(995)
		p.Star_expr()
	}
	p.SetState(1000)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(996)
				p.Match(AltPython3ParserCOMMA)
			}
			{
				p.SetState(997)
				p.Star_expr()
			}


		}
		p.SetState(1002)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext())
	}
	p.SetState(1004)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserCOMMA {
		{
			p.SetState(1003)
			p.Match(AltPython3ParserCOMMA)
		}

	}



	return localctx
}


// ITestlistContext is an interface to support dynamic dispatch.
type ITestlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestlistContext differentiates from other interfaces.
	IsTestlistContext()
}

type TestlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlistContext() *TestlistContext {
	var p = new(TestlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_testlist
	return p
}

func (*TestlistContext) IsTestlistContext() {}

func NewTestlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestlistContext {
	var p = new(TestlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_testlist

	return p
}

func (s *TestlistContext) GetParser() antlr.Parser { return s.parser }

func (s *TestlistContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *TestlistContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TestlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TestlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterTestlist(s)
	}
}

func (s *TestlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitTestlist(s)
	}
}

func (s *TestlistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitTestlist(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Testlist() (localctx ITestlistContext) {
	localctx = NewTestlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, AltPython3ParserRULE_testlist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1006)
		p.Test()
	}
	p.SetState(1011)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1007)
				p.Match(AltPython3ParserCOMMA)
			}
			{
				p.SetState(1008)
				p.Test()
			}


		}
		p.SetState(1013)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext())
	}
	p.SetState(1015)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserCOMMA {
		{
			p.SetState(1014)
			p.Match(AltPython3ParserCOMMA)
		}

	}



	return localctx
}


// IDictorsetmakerContext is an interface to support dynamic dispatch.
type IDictorsetmakerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictorsetmakerContext differentiates from other interfaces.
	IsDictorsetmakerContext()
}

type DictorsetmakerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictorsetmakerContext() *DictorsetmakerContext {
	var p = new(DictorsetmakerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_dictorsetmaker
	return p
}

func (*DictorsetmakerContext) IsDictorsetmakerContext() {}

func NewDictorsetmakerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictorsetmakerContext {
	var p = new(DictorsetmakerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_dictorsetmaker

	return p
}

func (s *DictorsetmakerContext) GetParser() antlr.Parser { return s.parser }

func (s *DictorsetmakerContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *DictorsetmakerContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *DictorsetmakerContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *DictorsetmakerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictorsetmakerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DictorsetmakerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterDictorsetmaker(s)
	}
}

func (s *DictorsetmakerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitDictorsetmaker(s)
	}
}

func (s *DictorsetmakerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitDictorsetmaker(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Dictorsetmaker() (localctx IDictorsetmakerContext) {
	localctx = NewDictorsetmakerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, AltPython3ParserRULE_dictorsetmaker)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1050)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1017)
			p.Test()
		}
		{
			p.SetState(1018)
			p.Match(AltPython3ParserCOLON)
		}
		{
			p.SetState(1019)
			p.Test()
		}
		p.SetState(1034)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case AltPython3ParserFOR:
			{
				p.SetState(1020)
				p.Comp_for()
			}


		case AltPython3ParserCOMMA, AltPython3ParserCLOSE_BRACE:
			p.SetState(1028)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1021)
						p.Match(AltPython3ParserCOMMA)
					}
					{
						p.SetState(1022)
						p.Test()
					}
					{
						p.SetState(1023)
						p.Match(AltPython3ParserCOLON)
					}
					{
						p.SetState(1024)
						p.Test()
					}


				}
				p.SetState(1030)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext())
			}
			p.SetState(1032)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == AltPython3ParserCOMMA {
				{
					p.SetState(1031)
					p.Match(AltPython3ParserCOMMA)
				}

			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1036)
			p.Test()
		}
		p.SetState(1048)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case AltPython3ParserFOR:
			{
				p.SetState(1037)
				p.Comp_for()
			}


		case AltPython3ParserCOMMA, AltPython3ParserCLOSE_BRACE:
			p.SetState(1042)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1038)
						p.Match(AltPython3ParserCOMMA)
					}
					{
						p.SetState(1039)
						p.Test()
					}


				}
				p.SetState(1044)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext())
			}
			p.SetState(1046)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == AltPython3ParserCOMMA {
				{
					p.SetState(1045)
					p.Match(AltPython3ParserCOMMA)
				}

			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}


	return localctx
}


// IClassdefContext is an interface to support dynamic dispatch.
type IClassdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassdefContext differentiates from other interfaces.
	IsClassdefContext()
}

type ClassdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassdefContext() *ClassdefContext {
	var p = new(ClassdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_classdef
	return p
}

func (*ClassdefContext) IsClassdefContext() {}

func NewClassdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassdefContext {
	var p = new(ClassdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_classdef

	return p
}

func (s *ClassdefContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassdefContext) CLASS() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserCLASS, 0)
}

func (s *ClassdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserNAME, 0)
}

func (s *ClassdefContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *ClassdefContext) Arglist() IArglistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArglistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *ClassdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ClassdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterClassdef(s)
	}
}

func (s *ClassdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitClassdef(s)
	}
}

func (s *ClassdefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitClassdef(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Classdef() (localctx IClassdefContext) {
	localctx = NewClassdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, AltPython3ParserRULE_classdef)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1052)
		p.Match(AltPython3ParserCLASS)
	}
	{
		p.SetState(1053)
		p.Match(AltPython3ParserNAME)
	}
	p.SetState(1059)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserOPEN_PAREN {
		{
			p.SetState(1054)
			p.Match(AltPython3ParserOPEN_PAREN)
		}
		p.SetState(1056)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if ((((_la - 21)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 21))) & ((1 << (AltPython3ParserLAMBDA - 21)) | (1 << (AltPython3ParserNOT - 21)) | (1 << (AltPython3ParserNONE - 21)) | (1 << (AltPython3ParserTRUE - 21)) | (1 << (AltPython3ParserFALSE - 21)) | (1 << (AltPython3ParserNAME - 21)) | (1 << (AltPython3ParserSTRING_LITERAL - 21)) | (1 << (AltPython3ParserBYTES_LITERAL - 21)) | (1 << (AltPython3ParserDECIMAL_INTEGER - 21)) | (1 << (AltPython3ParserOCT_INTEGER - 21)) | (1 << (AltPython3ParserHEX_INTEGER - 21)) | (1 << (AltPython3ParserBIN_INTEGER - 21)) | (1 << (AltPython3ParserFLOAT_NUMBER - 21)) | (1 << (AltPython3ParserIMAG_NUMBER - 21)) | (1 << (AltPython3ParserELLIPSIS - 21)) | (1 << (AltPython3ParserSTAR - 21)) | (1 << (AltPython3ParserOPEN_PAREN - 21)))) != 0) || ((((_la - 53)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 53))) & ((1 << (AltPython3ParserPOWER - 53)) | (1 << (AltPython3ParserOPEN_BRACK - 53)) | (1 << (AltPython3ParserADD - 53)) | (1 << (AltPython3ParserMINUS - 53)) | (1 << (AltPython3ParserNOT_OP - 53)) | (1 << (AltPython3ParserOPEN_BRACE - 53)))) != 0) {
			{
				p.SetState(1055)
				p.Arglist()
			}

		}
		{
			p.SetState(1058)
			p.Match(AltPython3ParserCLOSE_PAREN)
		}

	}
	{
		p.SetState(1061)
		p.Match(AltPython3ParserCOLON)
	}
	{
		p.SetState(1062)
		p.Suite()
	}



	return localctx
}


// IArglistContext is an interface to support dynamic dispatch.
type IArglistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArglistContext differentiates from other interfaces.
	IsArglistContext()
}

type ArglistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArglistContext() *ArglistContext {
	var p = new(ArglistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_arglist
	return p
}

func (*ArglistContext) IsArglistContext() {}

func NewArglistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArglistContext {
	var p = new(ArglistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_arglist

	return p
}

func (s *ArglistContext) GetParser() antlr.Parser { return s.parser }

func (s *ArglistContext) AllArgument() []IArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentContext)(nil)).Elem())
	var tst = make([]IArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentContext)
		}
	}

	return tst
}

func (s *ArglistContext) Argument(i int) IArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArglistContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *ArglistContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *ArglistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArglistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArglistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterArglist(s)
	}
}

func (s *ArglistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitArglist(s)
	}
}

func (s *ArglistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitArglist(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Arglist() (localctx IArglistContext) {
	localctx = NewArglistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, AltPython3ParserRULE_arglist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1069)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1064)
				p.Argument()
			}
			{
				p.SetState(1065)
				p.Match(AltPython3ParserCOMMA)
			}


		}
		p.SetState(1071)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext())
	}
	p.SetState(1092)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1072)
			p.Argument()
		}
		p.SetState(1074)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == AltPython3ParserCOMMA {
			{
				p.SetState(1073)
				p.Match(AltPython3ParserCOMMA)
			}

		}


	case 2:
		{
			p.SetState(1076)
			p.Match(AltPython3ParserSTAR)
		}
		{
			p.SetState(1077)
			p.Test()
		}
		p.SetState(1082)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1078)
					p.Match(AltPython3ParserCOMMA)
				}
				{
					p.SetState(1079)
					p.Argument()
				}


			}
			p.SetState(1084)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext())
		}
		p.SetState(1088)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == AltPython3ParserCOMMA {
			{
				p.SetState(1085)
				p.Match(AltPython3ParserCOMMA)
			}
			{
				p.SetState(1086)
				p.Match(AltPython3ParserPOWER)
			}
			{
				p.SetState(1087)
				p.Test()
			}

		}


	case 3:
		{
			p.SetState(1090)
			p.Match(AltPython3ParserPOWER)
		}
		{
			p.SetState(1091)
			p.Test()
		}

	}



	return localctx
}


// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_argument
	return p
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *ArgumentContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *ArgumentContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitArgument(s)
	}
}

func (s *ArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitArgument(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, AltPython3ParserRULE_argument)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1102)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 160, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1094)
			p.Test()
		}
		p.SetState(1096)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == AltPython3ParserFOR {
			{
				p.SetState(1095)
				p.Comp_for()
			}

		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1098)
			p.Test()
		}
		{
			p.SetState(1099)
			p.Match(AltPython3ParserASSIGN)
		}
		{
			p.SetState(1100)
			p.Test()
		}

	}


	return localctx
}


// IComp_iterContext is an interface to support dynamic dispatch.
type IComp_iterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_iterContext differentiates from other interfaces.
	IsComp_iterContext()
}

type Comp_iterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_iterContext() *Comp_iterContext {
	var p = new(Comp_iterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_comp_iter
	return p
}

func (*Comp_iterContext) IsComp_iterContext() {}

func NewComp_iterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_iterContext {
	var p = new(Comp_iterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_comp_iter

	return p
}

func (s *Comp_iterContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_iterContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *Comp_iterContext) Comp_if() IComp_ifContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_ifContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_ifContext)
}

func (s *Comp_iterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_iterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Comp_iterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterComp_iter(s)
	}
}

func (s *Comp_iterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitComp_iter(s)
	}
}

func (s *Comp_iterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitComp_iter(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Comp_iter() (localctx IComp_iterContext) {
	localctx = NewComp_iterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, AltPython3ParserRULE_comp_iter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1106)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1104)
			p.Comp_for()
		}


	case AltPython3ParserIF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1105)
			p.Comp_if()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IComp_forContext is an interface to support dynamic dispatch.
type IComp_forContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_forContext differentiates from other interfaces.
	IsComp_forContext()
}

type Comp_forContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_forContext() *Comp_forContext {
	var p = new(Comp_forContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_comp_for
	return p
}

func (*Comp_forContext) IsComp_forContext() {}

func NewComp_forContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_forContext {
	var p = new(Comp_forContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_comp_for

	return p
}

func (s *Comp_forContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_forContext) FOR() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserFOR, 0)
}

func (s *Comp_forContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *Comp_forContext) IN() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserIN, 0)
}

func (s *Comp_forContext) Or_test() IOr_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_testContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *Comp_forContext) Comp_iter() IComp_iterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_iterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_iterContext)
}

func (s *Comp_forContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_forContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Comp_forContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterComp_for(s)
	}
}

func (s *Comp_forContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitComp_for(s)
	}
}

func (s *Comp_forContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitComp_for(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Comp_for() (localctx IComp_forContext) {
	localctx = NewComp_forContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, AltPython3ParserRULE_comp_for)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1108)
		p.Match(AltPython3ParserFOR)
	}
	{
		p.SetState(1109)
		p.Exprlist()
	}
	{
		p.SetState(1110)
		p.Match(AltPython3ParserIN)
	}
	{
		p.SetState(1111)
		p.Or_test()
	}
	p.SetState(1113)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserIF || _la == AltPython3ParserFOR {
		{
			p.SetState(1112)
			p.Comp_iter()
		}

	}



	return localctx
}


// IComp_ifContext is an interface to support dynamic dispatch.
type IComp_ifContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_ifContext differentiates from other interfaces.
	IsComp_ifContext()
}

type Comp_ifContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_ifContext() *Comp_ifContext {
	var p = new(Comp_ifContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_comp_if
	return p
}

func (*Comp_ifContext) IsComp_ifContext() {}

func NewComp_ifContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_ifContext {
	var p = new(Comp_ifContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_comp_if

	return p
}

func (s *Comp_ifContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_ifContext) IF() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserIF, 0)
}

func (s *Comp_ifContext) Test_nocond() ITest_nocondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITest_nocondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITest_nocondContext)
}

func (s *Comp_ifContext) Comp_iter() IComp_iterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_iterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_iterContext)
}

func (s *Comp_ifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_ifContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Comp_ifContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterComp_if(s)
	}
}

func (s *Comp_ifContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitComp_if(s)
	}
}

func (s *Comp_ifContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitComp_if(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Comp_if() (localctx IComp_ifContext) {
	localctx = NewComp_ifContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, AltPython3ParserRULE_comp_if)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1115)
		p.Match(AltPython3ParserIF)
	}
	{
		p.SetState(1116)
		p.Test_nocond()
	}
	p.SetState(1118)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == AltPython3ParserIF || _la == AltPython3ParserFOR {
		{
			p.SetState(1117)
			p.Comp_iter()
		}

	}



	return localctx
}


// IYield_exprContext is an interface to support dynamic dispatch.
type IYield_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYield_exprContext differentiates from other interfaces.
	IsYield_exprContext()
}

type Yield_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_exprContext() *Yield_exprContext {
	var p = new(Yield_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_yield_expr
	return p
}

func (*Yield_exprContext) IsYield_exprContext() {}

func NewYield_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_exprContext {
	var p = new(Yield_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_yield_expr

	return p
}

func (s *Yield_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_exprContext) YIELD() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserYIELD, 0)
}

func (s *Yield_exprContext) Yield_arg() IYield_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_argContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_argContext)
}

func (s *Yield_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Yield_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterYield_expr(s)
	}
}

func (s *Yield_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitYield_expr(s)
	}
}

func (s *Yield_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitYield_expr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Yield_expr() (localctx IYield_exprContext) {
	localctx = NewYield_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, AltPython3ParserRULE_yield_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1120)
		p.Match(AltPython3ParserYIELD)
	}
	p.SetState(1122)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 5)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 5))) & ((1 << (AltPython3ParserFROM - 5)) | (1 << (AltPython3ParserLAMBDA - 5)) | (1 << (AltPython3ParserNOT - 5)) | (1 << (AltPython3ParserNONE - 5)) | (1 << (AltPython3ParserTRUE - 5)) | (1 << (AltPython3ParserFALSE - 5)) | (1 << (AltPython3ParserNAME - 5)))) != 0) || ((((_la - 37)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 37))) & ((1 << (AltPython3ParserSTRING_LITERAL - 37)) | (1 << (AltPython3ParserBYTES_LITERAL - 37)) | (1 << (AltPython3ParserDECIMAL_INTEGER - 37)) | (1 << (AltPython3ParserOCT_INTEGER - 37)) | (1 << (AltPython3ParserHEX_INTEGER - 37)) | (1 << (AltPython3ParserBIN_INTEGER - 37)) | (1 << (AltPython3ParserFLOAT_NUMBER - 37)) | (1 << (AltPython3ParserIMAG_NUMBER - 37)) | (1 << (AltPython3ParserELLIPSIS - 37)) | (1 << (AltPython3ParserSTAR - 37)) | (1 << (AltPython3ParserOPEN_PAREN - 37)) | (1 << (AltPython3ParserOPEN_BRACK - 37)) | (1 << (AltPython3ParserADD - 37)) | (1 << (AltPython3ParserMINUS - 37)) | (1 << (AltPython3ParserNOT_OP - 37)) | (1 << (AltPython3ParserOPEN_BRACE - 37)))) != 0) {
		{
			p.SetState(1121)
			p.Yield_arg()
		}

	}



	return localctx
}


// IYield_argContext is an interface to support dynamic dispatch.
type IYield_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYield_argContext differentiates from other interfaces.
	IsYield_argContext()
}

type Yield_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_argContext() *Yield_argContext {
	var p = new(Yield_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_yield_arg
	return p
}

func (*Yield_argContext) IsYield_argContext() {}

func NewYield_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_argContext {
	var p = new(Yield_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_yield_arg

	return p
}

func (s *Yield_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_argContext) FROM() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserFROM, 0)
}

func (s *Yield_argContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Yield_argContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Yield_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Yield_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterYield_arg(s)
	}
}

func (s *Yield_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitYield_arg(s)
	}
}

func (s *Yield_argContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitYield_arg(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Yield_arg() (localctx IYield_argContext) {
	localctx = NewYield_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, AltPython3ParserRULE_yield_arg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1127)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserFROM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1124)
			p.Match(AltPython3ParserFROM)
		}
		{
			p.SetState(1125)
			p.Test()
		}


	case AltPython3ParserLAMBDA, AltPython3ParserNOT, AltPython3ParserNONE, AltPython3ParserTRUE, AltPython3ParserFALSE, AltPython3ParserNAME, AltPython3ParserSTRING_LITERAL, AltPython3ParserBYTES_LITERAL, AltPython3ParserDECIMAL_INTEGER, AltPython3ParserOCT_INTEGER, AltPython3ParserHEX_INTEGER, AltPython3ParserBIN_INTEGER, AltPython3ParserFLOAT_NUMBER, AltPython3ParserIMAG_NUMBER, AltPython3ParserELLIPSIS, AltPython3ParserSTAR, AltPython3ParserOPEN_PAREN, AltPython3ParserOPEN_BRACK, AltPython3ParserADD, AltPython3ParserMINUS, AltPython3ParserNOT_OP, AltPython3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1126)
			p.Testlist()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IStrContext is an interface to support dynamic dispatch.
type IStrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrContext differentiates from other interfaces.
	IsStrContext()
}

type StrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrContext() *StrContext {
	var p = new(StrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_str
	return p
}

func (*StrContext) IsStrContext() {}

func NewStrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrContext {
	var p = new(StrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_str

	return p
}

func (s *StrContext) GetParser() antlr.Parser { return s.parser }

func (s *StrContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserSTRING_LITERAL, 0)
}

func (s *StrContext) BYTES_LITERAL() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserBYTES_LITERAL, 0)
}

func (s *StrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterStr(s)
	}
}

func (s *StrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitStr(s)
	}
}

func (s *StrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitStr(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Str() (localctx IStrContext) {
	localctx = NewStrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, AltPython3ParserRULE_str)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1129)
	_la = p.GetTokenStream().LA(1)

	if !(_la == AltPython3ParserSTRING_LITERAL || _la == AltPython3ParserBYTES_LITERAL) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}



	return localctx
}


// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) Integer() IIntegerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *NumberContext) FLOAT_NUMBER() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserFLOAT_NUMBER, 0)
}

func (s *NumberContext) IMAG_NUMBER() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserIMAG_NUMBER, 0)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitNumber(s)
	}
}

func (s *NumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitNumber(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, AltPython3ParserRULE_number)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1134)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case AltPython3ParserDECIMAL_INTEGER, AltPython3ParserOCT_INTEGER, AltPython3ParserHEX_INTEGER, AltPython3ParserBIN_INTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1131)
			p.Integer()
		}


	case AltPython3ParserFLOAT_NUMBER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1132)
			p.Match(AltPython3ParserFLOAT_NUMBER)
		}


	case AltPython3ParserIMAG_NUMBER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1133)
			p.Match(AltPython3ParserIMAG_NUMBER)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IIntegerContext is an interface to support dynamic dispatch.
type IIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerContext differentiates from other interfaces.
	IsIntegerContext()
}

type IntegerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerContext() *IntegerContext {
	var p = new(IntegerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = AltPython3ParserRULE_integer
	return p
}

func (*IntegerContext) IsIntegerContext() {}

func NewIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerContext {
	var p = new(IntegerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = AltPython3ParserRULE_integer

	return p
}

func (s *IntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerContext) DECIMAL_INTEGER() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserDECIMAL_INTEGER, 0)
}

func (s *IntegerContext) OCT_INTEGER() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserOCT_INTEGER, 0)
}

func (s *IntegerContext) HEX_INTEGER() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserHEX_INTEGER, 0)
}

func (s *IntegerContext) BIN_INTEGER() antlr.TerminalNode {
	return s.GetToken(AltPython3ParserBIN_INTEGER, 0)
}

func (s *IntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IntegerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.EnterInteger(s)
	}
}

func (s *IntegerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(AltPython3Listener); ok {
		listenerT.ExitInteger(s)
	}
}

func (s *IntegerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case AltPython3Visitor:
		return t.VisitInteger(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *AltPython3Parser) Integer() (localctx IIntegerContext) {
	localctx = NewIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, AltPython3ParserRULE_integer)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1136)
	_la = p.GetTokenStream().LA(1)

	if !(((((_la - 39)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 39))) & ((1 << (AltPython3ParserDECIMAL_INTEGER - 39)) | (1 << (AltPython3ParserOCT_INTEGER - 39)) | (1 << (AltPython3ParserHEX_INTEGER - 39)) | (1 << (AltPython3ParserBIN_INTEGER - 39)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
	    p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}



	return localctx
}


