// Generated from vhdl.g4 by ANTLR 4.7.

package vhdl // vhdl
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 164, 2605,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 4, 176, 9, 176, 4, 177, 9, 177, 4, 178, 9, 178,
	4, 179, 9, 179, 4, 180, 9, 180, 4, 181, 9, 181, 4, 182, 9, 182, 4, 183,
	9, 183, 4, 184, 9, 184, 4, 185, 9, 185, 4, 186, 9, 186, 4, 187, 9, 187,
	4, 188, 9, 188, 4, 189, 9, 189, 4, 190, 9, 190, 4, 191, 9, 191, 4, 192,
	9, 192, 4, 193, 9, 193, 4, 194, 9, 194, 4, 195, 9, 195, 4, 196, 9, 196,
	4, 197, 9, 197, 4, 198, 9, 198, 4, 199, 9, 199, 4, 200, 9, 200, 4, 201,
	9, 201, 4, 202, 9, 202, 4, 203, 9, 203, 4, 204, 9, 204, 4, 205, 9, 205,
	4, 206, 9, 206, 4, 207, 9, 207, 4, 208, 9, 208, 4, 209, 9, 209, 4, 210,
	9, 210, 4, 211, 9, 211, 4, 212, 9, 212, 4, 213, 9, 213, 4, 214, 9, 214,
	4, 215, 9, 215, 4, 216, 9, 216, 4, 217, 9, 217, 4, 218, 9, 218, 4, 219,
	9, 219, 4, 220, 9, 220, 4, 221, 9, 221, 4, 222, 9, 222, 4, 223, 9, 223,
	4, 224, 9, 224, 4, 225, 9, 225, 4, 226, 9, 226, 4, 227, 9, 227, 4, 228,
	9, 228, 4, 229, 9, 229, 4, 230, 9, 230, 4, 231, 9, 231, 4, 232, 9, 232,
	4, 233, 9, 233, 4, 234, 9, 234, 4, 235, 9, 235, 4, 236, 9, 236, 4, 237,
	9, 237, 4, 238, 9, 238, 4, 239, 9, 239, 4, 240, 9, 240, 4, 241, 9, 241,
	4, 242, 9, 242, 4, 243, 9, 243, 4, 244, 9, 244, 4, 245, 9, 245, 4, 246,
	9, 246, 4, 247, 9, 247, 4, 248, 9, 248, 4, 249, 9, 249, 4, 250, 9, 250,
	4, 251, 9, 251, 4, 252, 9, 252, 4, 253, 9, 253, 4, 254, 9, 254, 4, 255,
	9, 255, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 4, 3, 4, 5, 4, 518, 10, 4, 3,
	4, 3, 4, 5, 4, 522, 10, 4, 3, 4, 3, 4, 3, 5, 3, 5, 5, 5, 528, 10, 5, 3,
	6, 3, 6, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 538, 10, 7, 3, 8, 3,
	8, 3, 9, 3, 9, 3, 9, 3, 9, 7, 9, 546, 10, 9, 12, 9, 14, 9, 549, 11, 9,
	3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 557, 10, 10, 3, 10, 3, 10,
	3, 10, 5, 10, 562, 10, 10, 3, 10, 3, 10, 3, 11, 3, 11, 3, 11, 5, 11, 569,
	10, 11, 3, 12, 3, 12, 5, 12, 573, 10, 12, 3, 13, 3, 13, 3, 13, 5, 13, 578,
	10, 13, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14,
	3, 14, 5, 14, 590, 10, 14, 3, 14, 5, 14, 593, 10, 14, 3, 14, 3, 14, 3,
	15, 7, 15, 598, 10, 15, 12, 15, 14, 15, 601, 11, 15, 3, 16, 3, 16, 3, 16,
	5, 16, 606, 10, 16, 3, 16, 3, 16, 5, 16, 610, 10, 16, 3, 16, 3, 16, 5,
	16, 614, 10, 16, 3, 16, 5, 16, 617, 10, 16, 3, 16, 3, 16, 3, 16, 3, 16,
	3, 16, 5, 16, 624, 10, 16, 3, 17, 7, 17, 627, 10, 17, 12, 17, 14, 17, 630,
	11, 17, 3, 18, 3, 18, 5, 18, 634, 10, 18, 3, 19, 3, 19, 5, 19, 638, 10,
	19, 3, 20, 3, 20, 3, 20, 3, 20, 5, 20, 644, 10, 20, 3, 20, 3, 20, 5, 20,
	648, 10, 20, 3, 21, 5, 21, 651, 10, 21, 3, 21, 3, 21, 3, 21, 3, 22, 3,
	22, 3, 22, 5, 22, 659, 10, 22, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 7, 23,
	666, 10, 23, 12, 23, 14, 23, 669, 11, 23, 3, 24, 3, 24, 3, 24, 3, 24, 3,
	24, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 5, 25, 683, 10, 25,
	3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 27, 3, 27, 3,
	27, 3, 28, 3, 28, 5, 28, 698, 10, 28, 3, 28, 5, 28, 701, 10, 28, 3, 28,
	5, 28, 704, 10, 28, 3, 29, 3, 29, 3, 29, 7, 29, 709, 10, 29, 12, 29, 14,
	29, 712, 11, 29, 3, 29, 7, 29, 715, 10, 29, 12, 29, 14, 29, 718, 11, 29,
	3, 29, 3, 29, 3, 29, 3, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3,
	30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 746, 10, 30, 3, 31, 7, 31, 749,
	10, 31, 12, 31, 14, 31, 752, 11, 31, 3, 32, 3, 32, 3, 32, 3, 32, 5, 32,
	758, 10, 32, 5, 32, 760, 10, 32, 3, 32, 3, 32, 3, 32, 3, 32, 5, 32, 766,
	10, 32, 5, 32, 768, 10, 32, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 775,
	10, 33, 3, 33, 5, 33, 778, 10, 33, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3,
	34, 5, 34, 786, 10, 34, 3, 34, 5, 34, 789, 10, 34, 3, 34, 3, 34, 3, 34,
	3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 798, 10, 34, 3, 34, 3, 34, 3, 35, 7,
	35, 803, 10, 35, 12, 35, 14, 35, 806, 11, 35, 3, 36, 3, 36, 5, 36, 810,
	10, 36, 3, 36, 5, 36, 813, 10, 36, 3, 36, 3, 36, 3, 36, 3, 37, 5, 37, 819,
	10, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 38, 3, 38, 3, 38, 7, 38, 828, 10,
	38, 12, 38, 14, 38, 831, 11, 38, 3, 39, 3, 39, 3, 39, 3, 39, 3, 40, 5,
	40, 838, 10, 40, 3, 40, 3, 40, 5, 40, 842, 10, 40, 3, 40, 3, 40, 5, 40,
	846, 10, 40, 3, 40, 3, 40, 3, 41, 5, 41, 851, 10, 41, 3, 41, 3, 41, 3,
	41, 3, 41, 6, 41, 857, 10, 41, 13, 41, 14, 41, 858, 3, 41, 3, 41, 3, 41,
	5, 41, 864, 10, 41, 3, 41, 3, 41, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3,
	43, 3, 43, 3, 43, 3, 43, 5, 43, 877, 10, 43, 3, 44, 3, 44, 3, 44, 7, 44,
	882, 10, 44, 12, 44, 14, 44, 885, 11, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3,
	45, 5, 45, 892, 10, 45, 3, 45, 5, 45, 895, 10, 45, 3, 45, 3, 45, 3, 45,
	3, 45, 3, 46, 3, 46, 3, 46, 5, 46, 904, 10, 46, 3, 46, 5, 46, 907, 10,
	46, 3, 46, 5, 46, 910, 10, 46, 3, 46, 3, 46, 3, 46, 5, 46, 915, 10, 46,
	3, 46, 3, 46, 3, 47, 3, 47, 3, 47, 5, 47, 922, 10, 47, 3, 47, 5, 47, 925,
	10, 47, 3, 47, 3, 47, 3, 48, 3, 48, 3, 48, 3, 48, 3, 49, 3, 49, 5, 49,
	935, 10, 49, 3, 50, 3, 50, 5, 50, 939, 10, 50, 3, 51, 5, 51, 942, 10, 51,
	3, 51, 5, 51, 945, 10, 51, 3, 51, 3, 51, 3, 51, 3, 52, 5, 52, 951, 10,
	52, 3, 52, 3, 52, 5, 52, 955, 10, 52, 3, 52, 5, 52, 958, 10, 52, 3, 52,
	3, 52, 5, 52, 962, 10, 52, 3, 52, 3, 52, 3, 53, 5, 53, 967, 10, 53, 3,
	53, 5, 53, 970, 10, 53, 3, 53, 3, 53, 3, 53, 3, 54, 5, 54, 976, 10, 54,
	3, 54, 5, 54, 979, 10, 54, 3, 54, 3, 54, 5, 54, 983, 10, 54, 3, 55, 3,
	55, 3, 56, 3, 56, 3, 56, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 58,
	3, 58, 3, 58, 3, 58, 3, 58, 5, 58, 1001, 10, 58, 5, 58, 1003, 10, 58, 3,
	59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 5, 59, 1014,
	10, 59, 3, 59, 5, 59, 1017, 10, 59, 3, 59, 3, 59, 3, 60, 3, 60, 3, 60,
	5, 60, 1024, 10, 60, 3, 61, 7, 61, 1027, 10, 61, 12, 61, 14, 61, 1030,
	11, 61, 3, 62, 3, 62, 5, 62, 1034, 10, 62, 3, 63, 3, 63, 3, 63, 3, 63,
	3, 63, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 5, 64, 1047, 10, 64, 3,
	64, 3, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 66, 3, 66, 3, 66, 3, 66,
	3, 66, 3, 67, 3, 67, 5, 67, 1063, 10, 67, 3, 68, 7, 68, 1066, 10, 68, 12,
	68, 14, 68, 1069, 11, 68, 3, 69, 3, 69, 5, 69, 1073, 10, 69, 3, 70, 3,
	70, 3, 70, 5, 70, 1078, 10, 70, 3, 70, 5, 70, 1081, 10, 70, 3, 71, 7, 71,
	1084, 10, 71, 12, 71, 14, 71, 1087, 11, 71, 3, 71, 3, 71, 3, 72, 3, 72,
	3, 72, 3, 73, 3, 73, 5, 73, 1096, 10, 73, 3, 74, 3, 74, 3, 75, 3, 75, 3,
	75, 3, 75, 3, 75, 3, 75, 3, 76, 3, 76, 5, 76, 1108, 10, 76, 3, 77, 3, 77,
	3, 77, 5, 77, 1113, 10, 77, 3, 77, 3, 77, 3, 78, 3, 78, 3, 78, 3, 78, 3,
	78, 3, 79, 3, 79, 3, 80, 3, 80, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81,
	5, 81, 1132, 10, 81, 3, 81, 3, 81, 3, 81, 5, 81, 1137, 10, 81, 3, 82, 3,
	82, 3, 83, 3, 83, 5, 83, 1143, 10, 83, 3, 84, 3, 84, 3, 84, 7, 84, 1148,
	10, 84, 12, 84, 14, 84, 1151, 11, 84, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85,
	3, 85, 3, 85, 5, 85, 1160, 10, 85, 3, 85, 3, 85, 5, 85, 1164, 10, 85, 3,
	85, 5, 85, 1167, 10, 85, 3, 85, 3, 85, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86,
	3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3,
	86, 3, 86, 3, 86, 3, 86, 3, 86, 5, 86, 1191, 10, 86, 3, 87, 7, 87, 1194,
	10, 87, 12, 87, 14, 87, 1197, 11, 87, 3, 88, 3, 88, 5, 88, 1201, 10, 88,
	3, 89, 5, 89, 1204, 10, 89, 3, 89, 5, 89, 1207, 10, 89, 3, 90, 3, 90, 3,
	90, 7, 90, 1212, 10, 90, 12, 90, 14, 90, 1215, 11, 90, 3, 90, 3, 90, 5,
	90, 1219, 10, 90, 3, 91, 3, 91, 3, 91, 3, 91, 3, 92, 3, 92, 3, 92, 5, 92,
	1228, 10, 92, 3, 93, 7, 93, 1231, 10, 93, 12, 93, 14, 93, 1234, 11, 93,
	3, 94, 3, 94, 3, 94, 5, 94, 1239, 10, 94, 3, 95, 3, 95, 5, 95, 1243, 10,
	95, 3, 96, 3, 96, 3, 96, 3, 96, 7, 96, 1249, 10, 96, 12, 96, 14, 96, 1252,
	11, 96, 3, 96, 3, 96, 3, 97, 5, 97, 1257, 10, 97, 3, 97, 3, 97, 5, 97,
	1261, 10, 97, 3, 97, 3, 97, 5, 97, 1265, 10, 97, 3, 97, 3, 97, 3, 98, 3,
	98, 3, 98, 3, 98, 7, 98, 1273, 10, 98, 12, 98, 14, 98, 1276, 11, 98, 3,
	99, 3, 99, 3, 99, 5, 99, 1281, 10, 99, 3, 99, 3, 99, 3, 99, 3, 99, 5, 99,
	1287, 10, 99, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 5, 100, 1294, 10,
	100, 3, 100, 3, 100, 3, 101, 3, 101, 3, 102, 3, 102, 5, 102, 1302, 10,
	102, 3, 102, 3, 102, 3, 102, 3, 103, 3, 103, 3, 103, 3, 103, 3, 104, 3,
	104, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 5, 105, 1319, 10,
	105, 3, 106, 3, 106, 3, 106, 3, 106, 3, 106, 3, 106, 5, 106, 1327, 10,
	106, 3, 106, 3, 106, 3, 107, 3, 107, 3, 107, 3, 107, 7, 107, 1335, 10,
	107, 12, 107, 14, 107, 1338, 11, 107, 3, 107, 5, 107, 1341, 10, 107, 3,
	107, 7, 107, 1344, 10, 107, 12, 107, 14, 107, 1347, 11, 107, 3, 107, 3,
	107, 3, 107, 5, 107, 1352, 10, 107, 3, 107, 3, 107, 3, 108, 3, 108, 3,
	108, 3, 108, 5, 108, 1360, 10, 108, 3, 109, 3, 109, 3, 109, 3, 109, 3,
	109, 3, 109, 3, 110, 3, 110, 3, 110, 7, 110, 1371, 10, 110, 12, 110, 14,
	110, 1374, 11, 110, 3, 111, 3, 111, 3, 111, 3, 111, 3, 111, 3, 111, 3,
	112, 3, 112, 5, 112, 1384, 10, 112, 3, 113, 3, 113, 3, 113, 7, 113, 1389,
	10, 113, 12, 113, 14, 113, 1392, 11, 113, 3, 114, 3, 114, 3, 114, 3, 114,
	3, 114, 3, 114, 3, 114, 3, 114, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115,
	3, 115, 3, 115, 3, 115, 3, 116, 3, 116, 3, 116, 3, 116, 3, 117, 3, 117,
	3, 118, 3, 118, 3, 118, 7, 118, 1419, 10, 118, 12, 118, 14, 118, 1422,
	11, 118, 3, 119, 5, 119, 1425, 10, 119, 3, 119, 3, 119, 3, 119, 3, 119,
	3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 7, 119, 1436, 10, 119, 12, 119,
	14, 119, 1439, 11, 119, 3, 119, 3, 119, 5, 119, 1443, 10, 119, 3, 119,
	3, 119, 3, 119, 5, 119, 1448, 10, 119, 3, 119, 3, 119, 3, 120, 3, 120,
	3, 120, 3, 120, 7, 120, 1456, 10, 120, 12, 120, 14, 120, 1459, 11, 120,
	3, 120, 3, 120, 3, 121, 3, 121, 5, 121, 1465, 10, 121, 3, 122, 3, 122,
	3, 122, 3, 122, 3, 123, 5, 123, 1472, 10, 123, 3, 123, 3, 123, 3, 123,
	3, 123, 3, 123, 3, 123, 3, 123, 5, 123, 1481, 10, 123, 3, 123, 3, 123,
	5, 123, 1485, 10, 123, 3, 124, 3, 124, 3, 124, 7, 124, 1490, 10, 124, 12,
	124, 14, 124, 1493, 11, 124, 3, 124, 3, 124, 5, 124, 1497, 10, 124, 3,
	125, 5, 125, 1500, 10, 125, 3, 125, 3, 125, 3, 125, 5, 125, 1505, 10, 125,
	3, 125, 3, 125, 3, 125, 5, 125, 1510, 10, 125, 3, 126, 3, 126, 3, 126,
	3, 126, 3, 126, 3, 126, 5, 126, 1518, 10, 126, 3, 127, 3, 127, 3, 128,
	3, 128, 3, 128, 3, 128, 3, 128, 3, 129, 3, 129, 3, 129, 7, 129, 1530, 10,
	129, 12, 129, 14, 129, 1533, 11, 129, 3, 130, 3, 130, 3, 130, 7, 130, 1538,
	10, 130, 12, 130, 14, 130, 1541, 11, 130, 3, 131, 3, 131, 3, 131, 7, 131,
	1546, 10, 131, 12, 131, 14, 131, 1549, 11, 131, 3, 132, 3, 132, 3, 132,
	3, 132, 5, 132, 1555, 10, 132, 3, 132, 3, 132, 3, 132, 5, 132, 1560, 10,
	132, 3, 133, 3, 133, 3, 133, 3, 133, 3, 133, 5, 133, 1567, 10, 133, 3,
	133, 3, 133, 5, 133, 1571, 10, 133, 3, 134, 3, 134, 3, 134, 3, 134, 5,
	134, 1577, 10, 134, 3, 134, 3, 134, 5, 134, 1581, 10, 134, 3, 134, 3, 134,
	5, 134, 1585, 10, 134, 3, 135, 3, 135, 3, 135, 3, 135, 3, 135, 3, 136,
	5, 136, 1593, 10, 136, 3, 136, 3, 136, 3, 136, 5, 136, 1598, 10, 136, 3,
	136, 3, 136, 3, 136, 5, 136, 1603, 10, 136, 3, 137, 3, 137, 3, 137, 3,
	137, 5, 137, 1609, 10, 137, 3, 138, 3, 138, 3, 138, 3, 139, 3, 139, 3,
	139, 3, 139, 3, 140, 3, 140, 5, 140, 1620, 10, 140, 3, 141, 3, 141, 3,
	141, 3, 141, 3, 141, 5, 141, 1627, 10, 141, 3, 142, 3, 142, 3, 143, 3,
	143, 3, 143, 7, 143, 1634, 10, 143, 12, 143, 14, 143, 1637, 11, 143, 3,
	144, 3, 144, 3, 145, 5, 145, 1642, 10, 145, 3, 145, 5, 145, 1645, 10, 145,
	3, 145, 3, 145, 3, 145, 3, 145, 3, 145, 5, 145, 1652, 10, 145, 3, 145,
	3, 145, 3, 146, 3, 146, 3, 147, 3, 147, 3, 148, 3, 148, 3, 148, 3, 148,
	7, 148, 1664, 10, 148, 12, 148, 14, 148, 1667, 11, 148, 5, 148, 1669, 10,
	148, 3, 149, 3, 149, 3, 149, 3, 149, 5, 149, 1675, 10, 149, 3, 150, 3,
	150, 3, 150, 3, 150, 3, 150, 7, 150, 1682, 10, 150, 12, 150, 14, 150, 1685,
	11, 150, 5, 150, 1687, 10, 150, 3, 151, 3, 151, 5, 151, 1691, 10, 151,
	3, 151, 3, 151, 3, 152, 3, 152, 3, 152, 3, 152, 7, 152, 1699, 10, 152,
	12, 152, 14, 152, 1702, 11, 152, 3, 152, 3, 152, 6, 152, 1706, 10, 152,
	13, 152, 14, 152, 1707, 3, 153, 3, 153, 3, 153, 7, 153, 1713, 10, 153,
	12, 153, 14, 153, 1716, 11, 153, 3, 154, 3, 154, 3, 154, 3, 154, 3, 154,
	3, 154, 3, 155, 3, 155, 5, 155, 1726, 10, 155, 3, 156, 3, 156, 3, 156,
	3, 156, 3, 157, 5, 157, 1733, 10, 157, 3, 157, 3, 157, 5, 157, 1737, 10,
	157, 3, 157, 3, 157, 5, 157, 1741, 10, 157, 3, 157, 3, 157, 3, 158, 3,
	158, 5, 158, 1747, 10, 158, 3, 159, 3, 159, 3, 159, 3, 159, 3, 159, 3,
	159, 5, 159, 1755, 10, 159, 3, 160, 5, 160, 1758, 10, 160, 3, 160, 5, 160,
	1761, 10, 160, 3, 161, 3, 161, 3, 161, 3, 161, 3, 161, 3, 161, 3, 161,
	3, 161, 5, 161, 1771, 10, 161, 3, 161, 5, 161, 1774, 10, 161, 3, 161, 3,
	161, 3, 162, 3, 162, 3, 162, 3, 162, 3, 162, 3, 162, 3, 162, 3, 162, 3,
	162, 3, 162, 3, 162, 5, 162, 1789, 10, 162, 3, 163, 7, 163, 1792, 10, 163,
	12, 163, 14, 163, 1795, 11, 163, 3, 164, 3, 164, 3, 164, 3, 164, 3, 164,
	3, 164, 5, 164, 1803, 10, 164, 3, 164, 5, 164, 1806, 10, 164, 3, 164, 3,
	164, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3,
	165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 3,
	165, 5, 165, 1828, 10, 165, 3, 166, 7, 166, 1831, 10, 166, 12, 166, 14,
	166, 1834, 11, 166, 3, 167, 3, 167, 3, 167, 3, 167, 3, 168, 3, 168, 3,
	168, 3, 169, 3, 169, 3, 169, 3, 169, 7, 169, 1847, 10, 169, 12, 169, 14,
	169, 1850, 11, 169, 3, 169, 3, 169, 3, 169, 5, 169, 1855, 10, 169, 3, 170,
	3, 170, 3, 170, 3, 170, 3, 170, 3, 170, 3, 171, 3, 171, 3, 172, 3, 172,
	3, 172, 3, 172, 3, 172, 3, 172, 3, 173, 3, 173, 3, 173, 3, 173, 3, 173,
	3, 173, 3, 173, 3, 173, 3, 173, 5, 173, 1880, 10, 173, 3, 174, 3, 174,
	3, 174, 5, 174, 1885, 10, 174, 3, 175, 3, 175, 3, 175, 3, 175, 3, 175,
	3, 175, 3, 175, 3, 175, 3, 175, 3, 175, 3, 175, 3, 175, 5, 175, 1899, 10,
	175, 3, 176, 7, 176, 1902, 10, 176, 12, 176, 14, 176, 1905, 11, 176, 3,
	177, 7, 177, 1908, 10, 177, 12, 177, 14, 177, 1911, 11, 177, 3, 178, 3,
	178, 3, 178, 3, 178, 3, 178, 5, 178, 1918, 10, 178, 3, 179, 5, 179, 1921,
	10, 179, 3, 179, 3, 179, 3, 179, 3, 180, 3, 180, 3, 180, 3, 180, 3, 180,
	3, 180, 3, 180, 3, 180, 3, 180, 3, 180, 3, 180, 3, 180, 3, 180, 5, 180,
	1939, 10, 180, 3, 181, 7, 181, 1942, 10, 181, 12, 181, 14, 181, 1945, 11,
	181, 3, 182, 5, 182, 1948, 10, 182, 3, 182, 5, 182, 1951, 10, 182, 3, 182,
	3, 182, 3, 182, 3, 182, 3, 182, 5, 182, 1958, 10, 182, 3, 182, 5, 182,
	1961, 10, 182, 3, 182, 3, 182, 3, 182, 3, 182, 3, 182, 5, 182, 1968, 10,
	182, 3, 182, 3, 182, 5, 182, 1972, 10, 182, 3, 182, 3, 182, 3, 183, 7,
	183, 1977, 10, 183, 12, 183, 14, 183, 1980, 11, 183, 3, 184, 3, 184, 3,
	184, 3, 184, 3, 184, 3, 184, 3, 184, 5, 184, 1989, 10, 184, 3, 185, 3,
	185, 3, 185, 5, 185, 1994, 10, 185, 3, 186, 3, 186, 3, 186, 7, 186, 1999,
	10, 186, 12, 186, 14, 186, 2002, 11, 186, 3, 186, 3, 186, 5, 186, 2006,
	10, 186, 3, 187, 3, 187, 3, 187, 3, 187, 3, 188, 3, 188, 5, 188, 2014,
	10, 188, 3, 189, 3, 189, 3, 189, 3, 189, 5, 189, 2020, 10, 189, 3, 190,
	3, 190, 3, 190, 3, 191, 3, 191, 6, 191, 2027, 10, 191, 13, 191, 14, 191,
	2028, 3, 191, 3, 191, 3, 191, 5, 191, 2034, 10, 191, 3, 192, 3, 192, 6,
	192, 2038, 10, 192, 13, 192, 14, 192, 2039, 3, 192, 3, 192, 3, 192, 5,
	192, 2045, 10, 192, 3, 193, 3, 193, 3, 193, 3, 193, 5, 193, 2051, 10, 193,
	3, 194, 3, 194, 3, 195, 5, 195, 2056, 10, 195, 3, 195, 3, 195, 3, 195,
	3, 195, 5, 195, 2062, 10, 195, 3, 195, 3, 195, 3, 196, 5, 196, 2067, 10,
	196, 3, 196, 3, 196, 5, 196, 2071, 10, 196, 3, 196, 3, 196, 3, 197, 3,
	197, 3, 197, 3, 197, 3, 197, 3, 197, 3, 197, 3, 198, 3, 198, 3, 198, 5,
	198, 2085, 10, 198, 3, 199, 3, 199, 5, 199, 2089, 10, 199, 3, 200, 3, 200,
	3, 200, 3, 200, 3, 200, 3, 201, 3, 201, 3, 201, 3, 201, 3, 201, 3, 201,
	3, 201, 3, 201, 3, 201, 3, 202, 3, 202, 3, 202, 3, 202, 3, 202, 3, 202,
	3, 202, 3, 202, 7, 202, 2113, 10, 202, 12, 202, 14, 202, 2116, 11, 202,
	3, 203, 3, 203, 3, 203, 3, 204, 3, 204, 3, 204, 7, 204, 2124, 10, 204,
	12, 204, 14, 204, 2127, 11, 204, 3, 205, 7, 205, 2130, 10, 205, 12, 205,
	14, 205, 2133, 11, 205, 3, 206, 3, 206, 3, 206, 3, 206, 3, 206, 3, 206,
	3, 206, 3, 206, 3, 206, 3, 206, 3, 206, 3, 206, 5, 206, 2147, 10, 206,
	3, 206, 3, 206, 3, 206, 3, 206, 5, 206, 2153, 10, 206, 3, 207, 3, 207,
	3, 207, 3, 207, 5, 207, 2159, 10, 207, 3, 208, 3, 208, 3, 209, 5, 209,
	2164, 10, 209, 3, 209, 3, 209, 3, 209, 5, 209, 2169, 10, 209, 3, 209, 3,
	209, 3, 209, 3, 210, 3, 210, 3, 210, 3, 210, 3, 210, 5, 210, 2179, 10,
	210, 3, 210, 3, 210, 5, 210, 2183, 10, 210, 3, 210, 3, 210, 3, 211, 3,
	211, 3, 212, 3, 212, 3, 212, 7, 212, 2192, 10, 212, 12, 212, 14, 212, 2195,
	11, 212, 3, 212, 3, 212, 5, 212, 2199, 10, 212, 3, 213, 3, 213, 3, 213,
	3, 213, 7, 213, 2205, 10, 213, 12, 213, 14, 213, 2208, 11, 213, 5, 213,
	2210, 10, 213, 3, 213, 3, 213, 5, 213, 2214, 10, 213, 3, 213, 3, 213, 3,
	214, 5, 214, 2219, 10, 214, 3, 214, 3, 214, 3, 214, 3, 214, 7, 214, 2225,
	10, 214, 12, 214, 14, 214, 2228, 11, 214, 3, 215, 5, 215, 2231, 10, 215,
	3, 215, 3, 215, 3, 215, 3, 215, 5, 215, 2237, 10, 215, 3, 215, 3, 215,
	3, 216, 3, 216, 3, 216, 3, 216, 3, 216, 3, 217, 5, 217, 2247, 10, 217,
	3, 217, 3, 217, 3, 217, 3, 217, 6, 217, 2253, 10, 217, 13, 217, 14, 217,
	2254, 3, 217, 3, 217, 3, 217, 5, 217, 2260, 10, 217, 3, 217, 3, 217, 3,
	218, 5, 218, 2265, 10, 218, 3, 218, 3, 218, 3, 218, 3, 218, 3, 218, 3,
	218, 3, 218, 3, 218, 3, 218, 7, 218, 2276, 10, 218, 12, 218, 14, 218, 2279,
	11, 218, 3, 218, 3, 218, 5, 218, 2283, 10, 218, 3, 218, 3, 218, 3, 218,
	5, 218, 2288, 10, 218, 3, 218, 3, 218, 3, 219, 5, 219, 2293, 10, 219, 3,
	219, 3, 219, 5, 219, 2297, 10, 219, 3, 219, 3, 219, 3, 219, 3, 219, 3,
	219, 3, 219, 5, 219, 2305, 10, 219, 3, 219, 3, 219, 3, 220, 3, 220, 3,
	220, 3, 220, 3, 220, 5, 220, 2314, 10, 220, 3, 220, 3, 220, 5, 220, 2318,
	10, 220, 3, 221, 7, 221, 2321, 10, 221, 12, 221, 14, 221, 2324, 11, 221,
	3, 222, 3, 222, 3, 222, 3, 222, 3, 222, 3, 222, 3, 222, 5, 222, 2333, 10,
	222, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223, 3, 224, 3,
	224, 3, 224, 3, 224, 3, 224, 3, 224, 3, 225, 3, 225, 3, 225, 3, 225, 3,
	225, 3, 225, 3, 226, 3, 226, 5, 226, 2356, 10, 226, 3, 226, 3, 226, 3,
	226, 3, 226, 3, 226, 3, 226, 5, 226, 2364, 10, 226, 3, 227, 3, 227, 3,
	227, 3, 227, 3, 227, 3, 227, 3, 227, 5, 227, 2373, 10, 227, 3, 227, 5,
	227, 2376, 10, 227, 3, 227, 3, 227, 3, 228, 3, 228, 3, 228, 3, 229, 3,
	229, 3, 229, 3, 229, 3, 229, 3, 229, 3, 229, 3, 229, 3, 229, 3, 229, 3,
	229, 3, 229, 3, 229, 5, 229, 2396, 10, 229, 3, 230, 7, 230, 2399, 10, 230,
	12, 230, 14, 230, 2402, 11, 230, 3, 231, 3, 231, 3, 232, 3, 232, 5, 232,
	2408, 10, 232, 3, 233, 3, 233, 3, 233, 3, 233, 3, 233, 3, 233, 5, 233,
	2416, 10, 233, 3, 234, 5, 234, 2419, 10, 234, 3, 234, 3, 234, 3, 234, 3,
	234, 3, 234, 3, 234, 5, 234, 2427, 10, 234, 3, 234, 3, 234, 3, 234, 3,
	235, 7, 235, 2433, 10, 235, 12, 235, 14, 235, 2436, 11, 235, 3, 236, 3,
	236, 3, 236, 3, 236, 3, 236, 3, 236, 3, 237, 3, 237, 5, 237, 2446, 10,
	237, 3, 237, 5, 237, 2449, 10, 237, 3, 237, 5, 237, 2452, 10, 237, 3, 238,
	3, 238, 3, 238, 3, 238, 5, 238, 2458, 10, 238, 3, 239, 3, 239, 5, 239,
	2462, 10, 239, 3, 240, 3, 240, 3, 240, 3, 240, 7, 240, 2468, 10, 240, 12,
	240, 14, 240, 2471, 11, 240, 3, 241, 3, 241, 3, 241, 5, 241, 2476, 10,
	241, 3, 242, 3, 242, 3, 242, 3, 242, 3, 242, 3, 242, 3, 243, 3, 243, 5,
	243, 2486, 10, 243, 3, 243, 3, 243, 5, 243, 2490, 10, 243, 3, 243, 3, 243,
	3, 244, 3, 244, 3, 244, 3, 245, 3, 245, 3, 245, 3, 246, 3, 246, 3, 246,
	3, 246, 5, 246, 2504, 10, 246, 3, 246, 3, 246, 3, 247, 3, 247, 3, 247,
	3, 247, 5, 247, 2512, 10, 247, 3, 248, 3, 248, 3, 248, 3, 248, 3, 248,
	7, 248, 2519, 10, 248, 12, 248, 14, 248, 2522, 11, 248, 3, 248, 3, 248,
	3, 248, 3, 248, 3, 249, 3, 249, 3, 249, 3, 249, 3, 249, 7, 249, 2533, 10,
	249, 12, 249, 14, 249, 2536, 11, 249, 3, 249, 3, 249, 3, 249, 3, 249, 3,
	250, 3, 250, 3, 250, 3, 250, 7, 250, 2546, 10, 250, 12, 250, 14, 250, 2549,
	11, 250, 3, 250, 3, 250, 3, 251, 5, 251, 2554, 10, 251, 3, 251, 3, 251,
	3, 251, 3, 251, 3, 251, 3, 252, 5, 252, 2562, 10, 252, 3, 252, 3, 252,
	3, 252, 3, 252, 3, 252, 3, 252, 5, 252, 2570, 10, 252, 3, 252, 3, 252,
	3, 253, 5, 253, 2575, 10, 253, 3, 253, 3, 253, 5, 253, 2579, 10, 253, 3,
	253, 5, 253, 2582, 10, 253, 3, 253, 5, 253, 2585, 10, 253, 3, 253, 3, 253,
	3, 254, 3, 254, 3, 254, 7, 254, 2592, 10, 254, 12, 254, 14, 254, 2595,
	11, 254, 3, 254, 5, 254, 2598, 10, 254, 3, 255, 3, 255, 3, 255, 5, 255,
	2603, 10, 255, 3, 255, 2, 2, 256, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22,
	24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,
	60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94,
	96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124,
	126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154,
	156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184,
	186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214,
	216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244,
	246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274,
	276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304,
	306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334,
	336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364,
	366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392, 394,
	396, 398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422, 424,
	426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452, 454,
	456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 482, 484,
	486, 488, 490, 492, 494, 496, 498, 500, 502, 504, 506, 508, 2, 17, 5, 2,
	114, 114, 119, 119, 160, 160, 4, 2, 142, 142, 150, 151, 4, 2, 25, 25, 99,
	99, 19, 2, 10, 10, 21, 23, 27, 27, 31, 31, 33, 33, 36, 36, 44, 44, 48,
	48, 53, 53, 66, 66, 70, 70, 73, 73, 88, 88, 94, 96, 102, 102, 104, 104,
	107, 107, 3, 2, 120, 121, 4, 2, 40, 40, 65, 65, 7, 2, 9, 9, 52, 52, 57,
	57, 63, 63, 112, 113, 7, 2, 18, 18, 40, 40, 42, 42, 47, 47, 65, 65, 5,
	2, 51, 51, 77, 77, 148, 149, 5, 2, 133, 134, 136, 136, 152, 154, 5, 2,
	83, 84, 89, 90, 92, 93, 4, 2, 19, 19, 80, 80, 3, 2, 150, 151, 4, 2, 33,
	33, 70, 70, 4, 2, 39, 39, 72, 72, 2, 2804, 2, 510, 3, 2, 2, 2, 4, 512,
	3, 2, 2, 2, 6, 515, 3, 2, 2, 2, 8, 527, 3, 2, 2, 2, 10, 529, 3, 2, 2, 2,
	12, 537, 3, 2, 2, 2, 14, 539, 3, 2, 2, 2, 16, 541, 3, 2, 2, 2, 18, 552,
	3, 2, 2, 2, 20, 568, 3, 2, 2, 2, 22, 572, 3, 2, 2, 2, 24, 574, 3, 2, 2,
	2, 26, 579, 3, 2, 2, 2, 28, 599, 3, 2, 2, 2, 30, 623, 3, 2, 2, 2, 32, 628,
	3, 2, 2, 2, 34, 633, 3, 2, 2, 2, 36, 637, 3, 2, 2, 2, 38, 639, 3, 2, 2,
	2, 40, 650, 3, 2, 2, 2, 42, 658, 3, 2, 2, 2, 44, 662, 3, 2, 2, 2, 46, 670,
	3, 2, 2, 2, 48, 682, 3, 2, 2, 2, 50, 684, 3, 2, 2, 2, 52, 692, 3, 2, 2,
	2, 54, 697, 3, 2, 2, 2, 56, 705, 3, 2, 2, 2, 58, 745, 3, 2, 2, 2, 60, 750,
	3, 2, 2, 2, 62, 759, 3, 2, 2, 2, 64, 777, 3, 2, 2, 2, 66, 779, 3, 2, 2,
	2, 68, 804, 3, 2, 2, 2, 70, 807, 3, 2, 2, 2, 72, 818, 3, 2, 2, 2, 74, 824,
	3, 2, 2, 2, 76, 832, 3, 2, 2, 2, 78, 837, 3, 2, 2, 2, 80, 850, 3, 2, 2,
	2, 82, 867, 3, 2, 2, 2, 84, 876, 3, 2, 2, 2, 86, 878, 3, 2, 2, 2, 88, 886,
	3, 2, 2, 2, 90, 900, 3, 2, 2, 2, 92, 918, 3, 2, 2, 2, 94, 928, 3, 2, 2,
	2, 96, 934, 3, 2, 2, 2, 98, 938, 3, 2, 2, 2, 100, 941, 3, 2, 2, 2, 102,
	950, 3, 2, 2, 2, 104, 966, 3, 2, 2, 2, 106, 975, 3, 2, 2, 2, 108, 984,
	3, 2, 2, 2, 110, 986, 3, 2, 2, 2, 112, 989, 3, 2, 2, 2, 114, 995, 3, 2,
	2, 2, 116, 1004, 3, 2, 2, 2, 118, 1023, 3, 2, 2, 2, 120, 1028, 3, 2, 2,
	2, 122, 1033, 3, 2, 2, 2, 124, 1035, 3, 2, 2, 2, 126, 1040, 3, 2, 2, 2,
	128, 1050, 3, 2, 2, 2, 130, 1055, 3, 2, 2, 2, 132, 1062, 3, 2, 2, 2, 134,
	1067, 3, 2, 2, 2, 136, 1072, 3, 2, 2, 2, 138, 1080, 3, 2, 2, 2, 140, 1085,
	3, 2, 2, 2, 142, 1090, 3, 2, 2, 2, 144, 1095, 3, 2, 2, 2, 146, 1097, 3,
	2, 2, 2, 148, 1099, 3, 2, 2, 2, 150, 1107, 3, 2, 2, 2, 152, 1112, 3, 2,
	2, 2, 154, 1116, 3, 2, 2, 2, 156, 1121, 3, 2, 2, 2, 158, 1123, 3, 2, 2,
	2, 160, 1136, 3, 2, 2, 2, 162, 1138, 3, 2, 2, 2, 164, 1140, 3, 2, 2, 2,
	166, 1144, 3, 2, 2, 2, 168, 1152, 3, 2, 2, 2, 170, 1190, 3, 2, 2, 2, 172,
	1195, 3, 2, 2, 2, 174, 1198, 3, 2, 2, 2, 176, 1203, 3, 2, 2, 2, 178, 1218,
	3, 2, 2, 2, 180, 1220, 3, 2, 2, 2, 182, 1227, 3, 2, 2, 2, 184, 1232, 3,
	2, 2, 2, 186, 1238, 3, 2, 2, 2, 188, 1242, 3, 2, 2, 2, 190, 1244, 3, 2,
	2, 2, 192, 1256, 3, 2, 2, 2, 194, 1268, 3, 2, 2, 2, 196, 1286, 3, 2, 2,
	2, 198, 1288, 3, 2, 2, 2, 200, 1297, 3, 2, 2, 2, 202, 1301, 3, 2, 2, 2,
	204, 1306, 3, 2, 2, 2, 206, 1310, 3, 2, 2, 2, 208, 1318, 3, 2, 2, 2, 210,
	1320, 3, 2, 2, 2, 212, 1330, 3, 2, 2, 2, 214, 1359, 3, 2, 2, 2, 216, 1361,
	3, 2, 2, 2, 218, 1367, 3, 2, 2, 2, 220, 1375, 3, 2, 2, 2, 222, 1383, 3,
	2, 2, 2, 224, 1385, 3, 2, 2, 2, 226, 1393, 3, 2, 2, 2, 228, 1401, 3, 2,
	2, 2, 230, 1409, 3, 2, 2, 2, 232, 1413, 3, 2, 2, 2, 234, 1415, 3, 2, 2,
	2, 236, 1424, 3, 2, 2, 2, 238, 1451, 3, 2, 2, 2, 240, 1464, 3, 2, 2, 2,
	242, 1466, 3, 2, 2, 2, 244, 1484, 3, 2, 2, 2, 246, 1496, 3, 2, 2, 2, 248,
	1499, 3, 2, 2, 2, 250, 1517, 3, 2, 2, 2, 252, 1519, 3, 2, 2, 2, 254, 1521,
	3, 2, 2, 2, 256, 1526, 3, 2, 2, 2, 258, 1534, 3, 2, 2, 2, 260, 1542, 3,
	2, 2, 2, 262, 1550, 3, 2, 2, 2, 264, 1561, 3, 2, 2, 2, 266, 1572, 3, 2,
	2, 2, 268, 1586, 3, 2, 2, 2, 270, 1592, 3, 2, 2, 2, 272, 1608, 3, 2, 2,
	2, 274, 1610, 3, 2, 2, 2, 276, 1613, 3, 2, 2, 2, 278, 1619, 3, 2, 2, 2,
	280, 1626, 3, 2, 2, 2, 282, 1628, 3, 2, 2, 2, 284, 1630, 3, 2, 2, 2, 286,
	1638, 3, 2, 2, 2, 288, 1641, 3, 2, 2, 2, 290, 1655, 3, 2, 2, 2, 292, 1657,
	3, 2, 2, 2, 294, 1668, 3, 2, 2, 2, 296, 1670, 3, 2, 2, 2, 298, 1676, 3,
	2, 2, 2, 300, 1688, 3, 2, 2, 2, 302, 1705, 3, 2, 2, 2, 304, 1709, 3, 2,
	2, 2, 306, 1717, 3, 2, 2, 2, 308, 1725, 3, 2, 2, 2, 310, 1727, 3, 2, 2,
	2, 312, 1732, 3, 2, 2, 2, 314, 1746, 3, 2, 2, 2, 316, 1754, 3, 2, 2, 2,
	318, 1757, 3, 2, 2, 2, 320, 1762, 3, 2, 2, 2, 322, 1788, 3, 2, 2, 2, 324,
	1793, 3, 2, 2, 2, 326, 1796, 3, 2, 2, 2, 328, 1827, 3, 2, 2, 2, 330, 1832,
	3, 2, 2, 2, 332, 1835, 3, 2, 2, 2, 334, 1839, 3, 2, 2, 2, 336, 1842, 3,
	2, 2, 2, 338, 1856, 3, 2, 2, 2, 340, 1862, 3, 2, 2, 2, 342, 1864, 3, 2,
	2, 2, 344, 1879, 3, 2, 2, 2, 346, 1884, 3, 2, 2, 2, 348, 1898, 3, 2, 2,
	2, 350, 1903, 3, 2, 2, 2, 352, 1909, 3, 2, 2, 2, 354, 1912, 3, 2, 2, 2,
	356, 1920, 3, 2, 2, 2, 358, 1938, 3, 2, 2, 2, 360, 1943, 3, 2, 2, 2, 362,
	1947, 3, 2, 2, 2, 364, 1978, 3, 2, 2, 2, 366, 1981, 3, 2, 2, 2, 368, 1993,
	3, 2, 2, 2, 370, 2005, 3, 2, 2, 2, 372, 2007, 3, 2, 2, 2, 374, 2013, 3,
	2, 2, 2, 376, 2015, 3, 2, 2, 2, 378, 2021, 3, 2, 2, 2, 380, 2024, 3, 2,
	2, 2, 382, 2035, 3, 2, 2, 2, 384, 2046, 3, 2, 2, 2, 386, 2052, 3, 2, 2,
	2, 388, 2055, 3, 2, 2, 2, 390, 2066, 3, 2, 2, 2, 392, 2074, 3, 2, 2, 2,
	394, 2084, 3, 2, 2, 2, 396, 2088, 3, 2, 2, 2, 398, 2090, 3, 2, 2, 2, 400,
	2095, 3, 2, 2, 2, 402, 2104, 3, 2, 2, 2, 404, 2117, 3, 2, 2, 2, 406, 2120,
	3, 2, 2, 2, 408, 2131, 3, 2, 2, 2, 410, 2152, 3, 2, 2, 2, 412, 2154, 3,
	2, 2, 2, 414, 2160, 3, 2, 2, 2, 416, 2163, 3, 2, 2, 2, 418, 2173, 3, 2,
	2, 2, 420, 2186, 3, 2, 2, 2, 422, 2198, 3, 2, 2, 2, 424, 2200, 3, 2, 2,
	2, 426, 2218, 3, 2, 2, 2, 428, 2230, 3, 2, 2, 2, 430, 2240, 3, 2, 2, 2,
	432, 2246, 3, 2, 2, 2, 434, 2264, 3, 2, 2, 2, 436, 2292, 3, 2, 2, 2, 438,
	2317, 3, 2, 2, 2, 440, 2322, 3, 2, 2, 2, 442, 2332, 3, 2, 2, 2, 444, 2334,
	3, 2, 2, 2, 446, 2341, 3, 2, 2, 2, 448, 2347, 3, 2, 2, 2, 450, 2353, 3,
	2, 2, 2, 452, 2365, 3, 2, 2, 2, 454, 2379, 3, 2, 2, 2, 456, 2395, 3, 2,
	2, 2, 458, 2400, 3, 2, 2, 2, 460, 2403, 3, 2, 2, 2, 462, 2407, 3, 2, 2,
	2, 464, 2409, 3, 2, 2, 2, 466, 2418, 3, 2, 2, 2, 468, 2434, 3, 2, 2, 2,
	470, 2437, 3, 2, 2, 2, 472, 2443, 3, 2, 2, 2, 474, 2457, 3, 2, 2, 2, 476,
	2461, 3, 2, 2, 2, 478, 2463, 3, 2, 2, 2, 480, 2472, 3, 2, 2, 2, 482, 2477,
	3, 2, 2, 2, 484, 2483, 3, 2, 2, 2, 486, 2493, 3, 2, 2, 2, 488, 2496, 3,
	2, 2, 2, 490, 2499, 3, 2, 2, 2, 492, 2511, 3, 2, 2, 2, 494, 2513, 3, 2,
	2, 2, 496, 2527, 3, 2, 2, 2, 498, 2541, 3, 2, 2, 2, 500, 2553, 3, 2, 2,
	2, 502, 2561, 3, 2, 2, 2, 504, 2574, 3, 2, 2, 2, 506, 2597, 3, 2, 2, 2,
	508, 2599, 3, 2, 2, 2, 510, 511, 9, 2, 2, 2, 511, 3, 3, 2, 2, 2, 512, 513,
	7, 4, 2, 2, 513, 514, 5, 472, 237, 2, 514, 5, 3, 2, 2, 2, 515, 517, 5,
	234, 118, 2, 516, 518, 5, 488, 245, 2, 517, 516, 3, 2, 2, 2, 517, 518,
	3, 2, 2, 2, 518, 521, 3, 2, 2, 2, 519, 520, 7, 137, 2, 2, 520, 522, 5,
	194, 98, 2, 521, 519, 3, 2, 2, 2, 521, 522, 3, 2, 2, 2, 522, 523, 3, 2,
	2, 2, 523, 524, 7, 5, 2, 2, 524, 7, 3, 2, 2, 2, 525, 528, 5, 194, 98, 2,
	526, 528, 7, 62, 2, 2, 527, 525, 3, 2, 2, 2, 527, 526, 3, 2, 2, 2, 528,
	9, 3, 2, 2, 2, 529, 530, 5, 44, 23, 2, 530, 11, 3, 2, 2, 2, 531, 532, 5,
	294, 148, 2, 532, 533, 7, 143, 2, 2, 533, 534, 5, 8, 5, 2, 534, 535, 7,
	144, 2, 2, 535, 538, 3, 2, 2, 2, 536, 538, 5, 8, 5, 2, 537, 531, 3, 2,
	2, 2, 537, 536, 3, 2, 2, 2, 538, 13, 3, 2, 2, 2, 539, 540, 9, 3, 2, 2,
	540, 15, 3, 2, 2, 2, 541, 542, 7, 143, 2, 2, 542, 547, 5, 152, 77, 2, 543,
	544, 7, 141, 2, 2, 544, 546, 5, 152, 77, 2, 545, 543, 3, 2, 2, 2, 546,
	549, 3, 2, 2, 2, 547, 545, 3, 2, 2, 2, 547, 548, 3, 2, 2, 2, 548, 550,
	3, 2, 2, 2, 549, 547, 3, 2, 2, 2, 550, 551, 7, 144, 2, 2, 551, 17, 3, 2,
	2, 2, 552, 553, 7, 7, 2, 2, 553, 556, 5, 20, 11, 2, 554, 555, 7, 147, 2,
	2, 555, 557, 5, 22, 12, 2, 556, 554, 3, 2, 2, 2, 556, 557, 3, 2, 2, 2,
	557, 558, 3, 2, 2, 2, 558, 559, 7, 43, 2, 2, 559, 561, 5, 294, 148, 2,
	560, 562, 5, 424, 213, 2, 561, 560, 3, 2, 2, 2, 561, 562, 3, 2, 2, 2, 562,
	563, 3, 2, 2, 2, 563, 564, 7, 140, 2, 2, 564, 19, 3, 2, 2, 2, 565, 569,
	5, 232, 117, 2, 566, 569, 7, 128, 2, 2, 567, 569, 7, 129, 2, 2, 568, 565,
	3, 2, 2, 2, 568, 566, 3, 2, 2, 2, 568, 567, 3, 2, 2, 2, 569, 21, 3, 2,
	2, 2, 570, 573, 5, 450, 226, 2, 571, 573, 5, 472, 237, 2, 572, 570, 3,
	2, 2, 2, 572, 571, 3, 2, 2, 2, 573, 23, 3, 2, 2, 2, 574, 577, 7, 54, 2,
	2, 575, 578, 5, 366, 184, 2, 576, 578, 5, 472, 237, 2, 577, 575, 3, 2,
	2, 2, 577, 576, 3, 2, 2, 2, 578, 25, 3, 2, 2, 2, 579, 580, 7, 10, 2, 2,
	580, 581, 5, 232, 117, 2, 581, 582, 7, 60, 2, 2, 582, 583, 5, 232, 117,
	2, 583, 584, 7, 43, 2, 2, 584, 585, 5, 28, 15, 2, 585, 586, 7, 14, 2, 2,
	586, 587, 5, 32, 17, 2, 587, 589, 7, 26, 2, 2, 588, 590, 7, 10, 2, 2, 589,
	588, 3, 2, 2, 2, 589, 590, 3, 2, 2, 2, 590, 592, 3, 2, 2, 2, 591, 593,
	5, 232, 117, 2, 592, 591, 3, 2, 2, 2, 592, 593, 3, 2, 2, 2, 593, 594, 3,
	2, 2, 2, 594, 595, 7, 140, 2, 2, 595, 27, 3, 2, 2, 2, 596, 598, 5, 58,
	30, 2, 597, 596, 3, 2, 2, 2, 598, 601, 3, 2, 2, 2, 599, 597, 3, 2, 2, 2,
	599, 600, 3, 2, 2, 2, 600, 29, 3, 2, 2, 2, 601, 599, 3, 2, 2, 2, 602, 624,
	5, 66, 34, 2, 603, 624, 5, 362, 182, 2, 604, 606, 5, 274, 138, 2, 605,
	604, 3, 2, 2, 2, 605, 606, 3, 2, 2, 2, 606, 607, 3, 2, 2, 2, 607, 624,
	5, 104, 53, 2, 608, 610, 5, 274, 138, 2, 609, 608, 3, 2, 2, 2, 609, 610,
	3, 2, 2, 2, 610, 611, 3, 2, 2, 2, 611, 624, 5, 100, 51, 2, 612, 614, 5,
	274, 138, 2, 613, 612, 3, 2, 2, 2, 613, 614, 3, 2, 2, 2, 614, 616, 3, 2,
	2, 2, 615, 617, 7, 68, 2, 2, 616, 615, 3, 2, 2, 2, 616, 617, 3, 2, 2, 2,
	617, 618, 3, 2, 2, 2, 618, 624, 5, 106, 54, 2, 619, 624, 5, 92, 47, 2,
	620, 624, 5, 212, 107, 2, 621, 624, 5, 102, 52, 2, 622, 624, 5, 438, 220,
	2, 623, 602, 3, 2, 2, 2, 623, 603, 3, 2, 2, 2, 623, 605, 3, 2, 2, 2, 623,
	609, 3, 2, 2, 2, 623, 613, 3, 2, 2, 2, 623, 619, 3, 2, 2, 2, 623, 620,
	3, 2, 2, 2, 623, 621, 3, 2, 2, 2, 623, 622, 3, 2, 2, 2, 624, 31, 3, 2,
	2, 2, 625, 627, 5, 30, 16, 2, 626, 625, 3, 2, 2, 2, 627, 630, 3, 2, 2,
	2, 628, 626, 3, 2, 2, 2, 628, 629, 3, 2, 2, 2, 629, 33, 3, 2, 2, 2, 630,
	628, 3, 2, 2, 2, 631, 634, 5, 496, 249, 2, 632, 634, 5, 130, 66, 2, 633,
	631, 3, 2, 2, 2, 633, 632, 3, 2, 2, 2, 634, 35, 3, 2, 2, 2, 635, 638, 5,
	494, 248, 2, 636, 638, 5, 128, 65, 2, 637, 635, 3, 2, 2, 2, 637, 636, 3,
	2, 2, 2, 638, 37, 3, 2, 2, 2, 639, 640, 7, 12, 2, 2, 640, 643, 5, 108,
	55, 2, 641, 642, 7, 81, 2, 2, 642, 644, 5, 194, 98, 2, 643, 641, 3, 2,
	2, 2, 643, 644, 3, 2, 2, 2, 644, 647, 3, 2, 2, 2, 645, 646, 7, 86, 2, 2,
	646, 648, 5, 194, 98, 2, 647, 645, 3, 2, 2, 2, 647, 648, 3, 2, 2, 2, 648,
	39, 3, 2, 2, 2, 649, 651, 5, 274, 138, 2, 650, 649, 3, 2, 2, 2, 650, 651,
	3, 2, 2, 2, 651, 652, 3, 2, 2, 2, 652, 653, 5, 38, 20, 2, 653, 654, 7,
	140, 2, 2, 654, 41, 3, 2, 2, 2, 655, 656, 5, 208, 105, 2, 656, 657, 7,
	135, 2, 2, 657, 659, 3, 2, 2, 2, 658, 655, 3, 2, 2, 2, 658, 659, 3, 2,
	2, 2, 659, 660, 3, 2, 2, 2, 660, 661, 5, 12, 7, 2, 661, 43, 3, 2, 2, 2,
	662, 667, 5, 42, 22, 2, 663, 664, 7, 141, 2, 2, 664, 666, 5, 42, 22, 2,
	665, 663, 3, 2, 2, 2, 666, 669, 3, 2, 2, 2, 667, 665, 3, 2, 2, 2, 667,
	668, 3, 2, 2, 2, 668, 45, 3, 2, 2, 2, 669, 667, 3, 2, 2, 2, 670, 671, 7,
	13, 2, 2, 671, 672, 5, 274, 138, 2, 672, 673, 5, 294, 148, 2, 673, 674,
	7, 140, 2, 2, 674, 47, 3, 2, 2, 2, 675, 683, 5, 232, 117, 2, 676, 683,
	7, 74, 2, 2, 677, 683, 7, 75, 2, 2, 678, 683, 7, 5, 2, 2, 679, 683, 7,
	98, 2, 2, 680, 683, 7, 79, 2, 2, 681, 683, 7, 100, 2, 2, 682, 675, 3, 2,
	2, 2, 682, 676, 3, 2, 2, 2, 682, 677, 3, 2, 2, 2, 682, 678, 3, 2, 2, 2,
	682, 679, 3, 2, 2, 2, 682, 680, 3, 2, 2, 2, 682, 681, 3, 2, 2, 2, 683,
	49, 3, 2, 2, 2, 684, 685, 7, 13, 2, 2, 685, 686, 5, 48, 25, 2, 686, 687,
	7, 60, 2, 2, 687, 688, 5, 180, 91, 2, 688, 689, 7, 43, 2, 2, 689, 690,
	5, 194, 98, 2, 690, 691, 7, 140, 2, 2, 691, 51, 3, 2, 2, 2, 692, 693, 5,
	232, 117, 2, 693, 694, 7, 140, 2, 2, 694, 53, 3, 2, 2, 2, 695, 696, 7,
	106, 2, 2, 696, 698, 5, 160, 81, 2, 697, 695, 3, 2, 2, 2, 697, 698, 3,
	2, 2, 2, 698, 700, 3, 2, 2, 2, 699, 701, 5, 220, 111, 2, 700, 699, 3, 2,
	2, 2, 700, 701, 3, 2, 2, 2, 701, 703, 3, 2, 2, 2, 702, 704, 5, 342, 172,
	2, 703, 702, 3, 2, 2, 2, 703, 704, 3, 2, 2, 2, 704, 55, 3, 2, 2, 2, 705,
	706, 7, 32, 2, 2, 706, 710, 5, 64, 33, 2, 707, 709, 5, 498, 250, 2, 708,
	707, 3, 2, 2, 2, 709, 712, 3, 2, 2, 2, 710, 708, 3, 2, 2, 2, 710, 711,
	3, 2, 2, 2, 711, 716, 3, 2, 2, 2, 712, 710, 3, 2, 2, 2, 713, 715, 5, 122,
	62, 2, 714, 713, 3, 2, 2, 2, 715, 718, 3, 2, 2, 2, 716, 714, 3, 2, 2, 2,
	716, 717, 3, 2, 2, 2, 717, 719, 3, 2, 2, 2, 718, 716, 3, 2, 2, 2, 719,
	720, 7, 26, 2, 2, 720, 721, 7, 32, 2, 2, 721, 722, 7, 140, 2, 2, 722, 57,
	3, 2, 2, 2, 723, 746, 5, 454, 228, 2, 724, 746, 5, 452, 227, 2, 725, 746,
	5, 490, 246, 2, 726, 746, 5, 470, 236, 2, 727, 746, 5, 126, 64, 2, 728,
	746, 5, 418, 210, 2, 729, 746, 5, 502, 252, 2, 730, 746, 5, 198, 100, 2,
	731, 746, 5, 18, 10, 2, 732, 746, 5, 90, 46, 2, 733, 746, 5, 46, 24, 2,
	734, 746, 5, 50, 26, 2, 735, 746, 5, 124, 63, 2, 736, 746, 5, 148, 75,
	2, 737, 746, 5, 446, 224, 2, 738, 746, 5, 498, 250, 2, 739, 746, 5, 228,
	115, 2, 740, 746, 5, 226, 114, 2, 741, 746, 5, 306, 154, 2, 742, 746, 5,
	448, 225, 2, 743, 746, 5, 368, 185, 2, 744, 746, 5, 482, 242, 2, 745, 723,
	3, 2, 2, 2, 745, 724, 3, 2, 2, 2, 745, 725, 3, 2, 2, 2, 745, 726, 3, 2,
	2, 2, 745, 727, 3, 2, 2, 2, 745, 728, 3, 2, 2, 2, 745, 729, 3, 2, 2, 2,
	745, 730, 3, 2, 2, 2, 745, 731, 3, 2, 2, 2, 745, 732, 3, 2, 2, 2, 745,
	733, 3, 2, 2, 2, 745, 734, 3, 2, 2, 2, 745, 735, 3, 2, 2, 2, 745, 736,
	3, 2, 2, 2, 745, 737, 3, 2, 2, 2, 745, 738, 3, 2, 2, 2, 745, 739, 3, 2,
	2, 2, 745, 740, 3, 2, 2, 2, 745, 741, 3, 2, 2, 2, 745, 742, 3, 2, 2, 2,
	745, 743, 3, 2, 2, 2, 745, 744, 3, 2, 2, 2, 746, 59, 3, 2, 2, 2, 747, 749,
	5, 58, 30, 2, 748, 747, 3, 2, 2, 2, 749, 752, 3, 2, 2, 2, 750, 748, 3,
	2, 2, 2, 750, 751, 3, 2, 2, 2, 751, 61, 3, 2, 2, 2, 752, 750, 3, 2, 2,
	2, 753, 757, 5, 216, 109, 2, 754, 755, 5, 220, 111, 2, 755, 756, 7, 140,
	2, 2, 756, 758, 3, 2, 2, 2, 757, 754, 3, 2, 2, 2, 757, 758, 3, 2, 2, 2,
	758, 760, 3, 2, 2, 2, 759, 753, 3, 2, 2, 2, 759, 760, 3, 2, 2, 2, 760,
	767, 3, 2, 2, 2, 761, 765, 5, 338, 170, 2, 762, 763, 5, 342, 172, 2, 763,
	764, 7, 140, 2, 2, 764, 766, 3, 2, 2, 2, 765, 762, 3, 2, 2, 2, 765, 766,
	3, 2, 2, 2, 766, 768, 3, 2, 2, 2, 767, 761, 3, 2, 2, 2, 767, 768, 3, 2,
	2, 2, 768, 63, 3, 2, 2, 2, 769, 774, 5, 232, 117, 2, 770, 771, 7, 143,
	2, 2, 771, 772, 5, 240, 121, 2, 772, 773, 7, 144, 2, 2, 773, 775, 3, 2,
	2, 2, 774, 770, 3, 2, 2, 2, 774, 775, 3, 2, 2, 2, 775, 778, 3, 2, 2, 2,
	776, 778, 5, 294, 148, 2, 777, 769, 3, 2, 2, 2, 777, 776, 3, 2, 2, 2, 778,
	65, 3, 2, 2, 2, 779, 780, 5, 274, 138, 2, 780, 785, 7, 15, 2, 2, 781, 782,
	7, 143, 2, 2, 782, 783, 5, 194, 98, 2, 783, 784, 7, 144, 2, 2, 784, 786,
	3, 2, 2, 2, 785, 781, 3, 2, 2, 2, 785, 786, 3, 2, 2, 2, 786, 788, 3, 2,
	2, 2, 787, 789, 7, 43, 2, 2, 788, 787, 3, 2, 2, 2, 788, 789, 3, 2, 2, 2,
	789, 790, 3, 2, 2, 2, 790, 791, 5, 62, 32, 2, 791, 792, 5, 60, 31, 2, 792,
	793, 7, 14, 2, 2, 793, 794, 5, 68, 35, 2, 794, 795, 7, 26, 2, 2, 795, 797,
	7, 15, 2, 2, 796, 798, 5, 232, 117, 2, 797, 796, 3, 2, 2, 2, 797, 798,
	3, 2, 2, 2, 798, 799, 3, 2, 2, 2, 799, 800, 7, 140, 2, 2, 800, 67, 3, 2,
	2, 2, 801, 803, 5, 30, 16, 2, 802, 801, 3, 2, 2, 2, 803, 806, 3, 2, 2,
	2, 804, 802, 3, 2, 2, 2, 804, 805, 3, 2, 2, 2, 805, 69, 3, 2, 2, 2, 806,
	804, 3, 2, 2, 2, 807, 809, 7, 73, 2, 2, 808, 810, 5, 6, 4, 2, 809, 808,
	3, 2, 2, 2, 809, 810, 3, 2, 2, 2, 810, 812, 3, 2, 2, 2, 811, 813, 5, 484,
	243, 2, 812, 811, 3, 2, 2, 2, 812, 813, 3, 2, 2, 2, 813, 814, 3, 2, 2,
	2, 814, 815, 5, 480, 241, 2, 815, 816, 7, 140, 2, 2, 816, 71, 3, 2, 2,
	2, 817, 819, 5, 76, 39, 2, 818, 817, 3, 2, 2, 2, 818, 819, 3, 2, 2, 2,
	819, 820, 3, 2, 2, 2, 820, 821, 5, 294, 148, 2, 821, 822, 7, 135, 2, 2,
	822, 823, 5, 194, 98, 2, 823, 73, 3, 2, 2, 2, 824, 829, 5, 72, 37, 2, 825,
	826, 7, 141, 2, 2, 826, 828, 5, 72, 37, 2, 827, 825, 3, 2, 2, 2, 828, 831,
	3, 2, 2, 2, 829, 827, 3, 2, 2, 2, 829, 830, 3, 2, 2, 2, 830, 75, 3, 2,
	2, 2, 831, 829, 3, 2, 2, 2, 832, 833, 7, 32, 2, 2, 833, 834, 5, 294, 148,
	2, 834, 835, 7, 106, 2, 2, 835, 77, 3, 2, 2, 2, 836, 838, 5, 274, 138,
	2, 837, 836, 3, 2, 2, 2, 837, 838, 3, 2, 2, 2, 838, 839, 3, 2, 2, 2, 839,
	841, 7, 17, 2, 2, 840, 842, 5, 74, 38, 2, 841, 840, 3, 2, 2, 2, 841, 842,
	3, 2, 2, 2, 842, 845, 3, 2, 2, 2, 843, 844, 7, 110, 2, 2, 844, 846, 5,
	108, 55, 2, 845, 843, 3, 2, 2, 2, 845, 846, 3, 2, 2, 2, 846, 847, 3, 2,
	2, 2, 847, 848, 7, 140, 2, 2, 848, 79, 3, 2, 2, 2, 849, 851, 5, 274, 138,
	2, 850, 849, 3, 2, 2, 2, 850, 851, 3, 2, 2, 2, 851, 852, 3, 2, 2, 2, 852,
	853, 7, 20, 2, 2, 853, 854, 5, 194, 98, 2, 854, 856, 7, 43, 2, 2, 855,
	857, 5, 82, 42, 2, 856, 855, 3, 2, 2, 2, 857, 858, 3, 2, 2, 2, 858, 856,
	3, 2, 2, 2, 858, 859, 3, 2, 2, 2, 859, 860, 3, 2, 2, 2, 860, 861, 7, 26,
	2, 2, 861, 863, 7, 20, 2, 2, 862, 864, 5, 232, 117, 2, 863, 862, 3, 2,
	2, 2, 863, 864, 3, 2, 2, 2, 864, 865, 3, 2, 2, 2, 865, 866, 7, 140, 2,
	2, 866, 81, 3, 2, 2, 2, 867, 868, 7, 110, 2, 2, 868, 869, 5, 86, 44, 2,
	869, 870, 7, 135, 2, 2, 870, 871, 5, 408, 205, 2, 871, 83, 3, 2, 2, 2,
	872, 877, 5, 232, 117, 2, 873, 877, 5, 150, 76, 2, 874, 877, 5, 426, 214,
	2, 875, 877, 7, 64, 2, 2, 876, 872, 3, 2, 2, 2, 876, 873, 3, 2, 2, 2, 876,
	874, 3, 2, 2, 2, 876, 875, 3, 2, 2, 2, 877, 85, 3, 2, 2, 2, 878, 883, 5,
	84, 43, 2, 879, 880, 7, 155, 2, 2, 880, 882, 5, 84, 43, 2, 881, 879, 3,
	2, 2, 2, 882, 885, 3, 2, 2, 2, 883, 881, 3, 2, 2, 2, 883, 884, 3, 2, 2,
	2, 884, 87, 3, 2, 2, 2, 885, 883, 3, 2, 2, 2, 886, 887, 7, 32, 2, 2, 887,
	891, 5, 94, 48, 2, 888, 889, 5, 54, 28, 2, 889, 890, 7, 140, 2, 2, 890,
	892, 3, 2, 2, 2, 891, 888, 3, 2, 2, 2, 891, 892, 3, 2, 2, 2, 892, 894,
	3, 2, 2, 2, 893, 895, 5, 56, 29, 2, 894, 893, 3, 2, 2, 2, 894, 895, 3,
	2, 2, 2, 895, 896, 3, 2, 2, 2, 896, 897, 7, 26, 2, 2, 897, 898, 7, 32,
	2, 2, 898, 899, 7, 140, 2, 2, 899, 89, 3, 2, 2, 2, 900, 901, 7, 21, 2,
	2, 901, 903, 5, 232, 117, 2, 902, 904, 7, 43, 2, 2, 903, 902, 3, 2, 2,
	2, 903, 904, 3, 2, 2, 2, 904, 906, 3, 2, 2, 2, 905, 907, 5, 216, 109, 2,
	906, 905, 3, 2, 2, 2, 906, 907, 3, 2, 2, 2, 907, 909, 3, 2, 2, 2, 908,
	910, 5, 338, 170, 2, 909, 908, 3, 2, 2, 2, 909, 910, 3, 2, 2, 2, 910, 911,
	3, 2, 2, 2, 911, 912, 7, 26, 2, 2, 912, 914, 7, 21, 2, 2, 913, 915, 5,
	232, 117, 2, 914, 913, 3, 2, 2, 2, 914, 915, 3, 2, 2, 2, 915, 916, 3, 2,
	2, 2, 916, 917, 7, 140, 2, 2, 917, 91, 3, 2, 2, 2, 918, 919, 5, 274, 138,
	2, 919, 921, 5, 244, 123, 2, 920, 922, 5, 220, 111, 2, 921, 920, 3, 2,
	2, 2, 921, 922, 3, 2, 2, 2, 922, 924, 3, 2, 2, 2, 923, 925, 5, 342, 172,
	2, 924, 923, 3, 2, 2, 2, 924, 925, 3, 2, 2, 2, 925, 926, 3, 2, 2, 2, 926,
	927, 7, 140, 2, 2, 927, 93, 3, 2, 2, 2, 928, 929, 5, 246, 124, 2, 929,
	930, 7, 147, 2, 2, 930, 931, 5, 294, 148, 2, 931, 95, 3, 2, 2, 2, 932,
	935, 5, 34, 18, 2, 933, 935, 5, 380, 191, 2, 934, 932, 3, 2, 2, 2, 934,
	933, 3, 2, 2, 2, 935, 97, 3, 2, 2, 2, 936, 939, 5, 36, 19, 2, 937, 939,
	5, 382, 192, 2, 938, 936, 3, 2, 2, 2, 938, 937, 3, 2, 2, 2, 939, 99, 3,
	2, 2, 2, 940, 942, 5, 274, 138, 2, 941, 940, 3, 2, 2, 2, 941, 942, 3, 2,
	2, 2, 942, 944, 3, 2, 2, 2, 943, 945, 7, 68, 2, 2, 944, 943, 3, 2, 2, 2,
	944, 945, 3, 2, 2, 2, 945, 946, 3, 2, 2, 2, 946, 947, 5, 38, 20, 2, 947,
	948, 7, 140, 2, 2, 948, 101, 3, 2, 2, 2, 949, 951, 5, 274, 138, 2, 950,
	949, 3, 2, 2, 2, 950, 951, 3, 2, 2, 2, 951, 952, 3, 2, 2, 2, 952, 954,
	7, 17, 2, 2, 953, 955, 5, 74, 38, 2, 954, 953, 3, 2, 2, 2, 954, 955, 3,
	2, 2, 2, 955, 957, 3, 2, 2, 2, 956, 958, 5, 404, 203, 2, 957, 956, 3, 2,
	2, 2, 957, 958, 3, 2, 2, 2, 958, 961, 3, 2, 2, 2, 959, 960, 7, 110, 2,
	2, 960, 962, 5, 108, 55, 2, 961, 959, 3, 2, 2, 2, 961, 962, 3, 2, 2, 2,
	962, 963, 3, 2, 2, 2, 963, 964, 7, 140, 2, 2, 964, 103, 3, 2, 2, 2, 965,
	967, 5, 274, 138, 2, 966, 965, 3, 2, 2, 2, 966, 967, 3, 2, 2, 2, 967, 969,
	3, 2, 2, 2, 968, 970, 7, 68, 2, 2, 969, 968, 3, 2, 2, 2, 969, 970, 3, 2,
	2, 2, 970, 971, 3, 2, 2, 2, 971, 972, 5, 354, 178, 2, 972, 973, 7, 140,
	2, 2, 973, 105, 3, 2, 2, 2, 974, 976, 5, 274, 138, 2, 975, 974, 3, 2, 2,
	2, 975, 976, 3, 2, 2, 2, 976, 978, 3, 2, 2, 2, 977, 979, 7, 68, 2, 2, 978,
	977, 3, 2, 2, 2, 978, 979, 3, 2, 2, 2, 979, 982, 3, 2, 2, 2, 980, 983,
	5, 112, 57, 2, 981, 983, 5, 400, 201, 2, 982, 980, 3, 2, 2, 2, 982, 981,
	3, 2, 2, 2, 983, 107, 3, 2, 2, 2, 984, 985, 5, 194, 98, 2, 985, 109, 3,
	2, 2, 2, 986, 987, 7, 105, 2, 2, 987, 988, 5, 108, 55, 2, 988, 111, 3,
	2, 2, 2, 989, 990, 5, 476, 239, 2, 990, 991, 7, 133, 2, 2, 991, 992, 5,
	318, 160, 2, 992, 993, 5, 114, 58, 2, 993, 994, 7, 140, 2, 2, 994, 113,
	3, 2, 2, 2, 995, 1002, 5, 506, 254, 2, 996, 997, 7, 110, 2, 2, 997, 1000,
	5, 108, 55, 2, 998, 999, 7, 28, 2, 2, 999, 1001, 5, 114, 58, 2, 1000, 998,
	3, 2, 2, 2, 1000, 1001, 3, 2, 2, 2, 1001, 1003, 3, 2, 2, 2, 1002, 996,
	3, 2, 2, 2, 1002, 1003, 3, 2, 2, 2, 1003, 115, 3, 2, 2, 2, 1004, 1005,
	7, 22, 2, 2, 1005, 1006, 5, 232, 117, 2, 1006, 1007, 7, 60, 2, 2, 1007,
	1008, 5, 294, 148, 2, 1008, 1009, 7, 43, 2, 2, 1009, 1010, 5, 120, 61,
	2, 1010, 1011, 5, 56, 29, 2, 1011, 1013, 7, 26, 2, 2, 1012, 1014, 7, 22,
	2, 2, 1013, 1012, 3, 2, 2, 2, 1013, 1014, 3, 2, 2, 2, 1014, 1016, 3, 2,
	2, 2, 1015, 1017, 5, 232, 117, 2, 1016, 1015, 3, 2, 2, 2, 1016, 1017, 3,
	2, 2, 2, 1017, 1018, 3, 2, 2, 2, 1018, 1019, 7, 140, 2, 2, 1019, 117, 3,
	2, 2, 2, 1020, 1024, 5, 498, 250, 2, 1021, 1024, 5, 50, 26, 2, 1022, 1024,
	5, 226, 114, 2, 1023, 1020, 3, 2, 2, 2, 1023, 1021, 3, 2, 2, 2, 1023, 1022,
	3, 2, 2, 2, 1024, 119, 3, 2, 2, 2, 1025, 1027, 5, 118, 60, 2, 1026, 1025,
	3, 2, 2, 2, 1027, 1030, 3, 2, 2, 2, 1028, 1026, 3, 2, 2, 2, 1028, 1029,
	3, 2, 2, 2, 1029, 121, 3, 2, 2, 2, 1030, 1028, 3, 2, 2, 2, 1031, 1034,
	5, 56, 29, 2, 1032, 1034, 5, 88, 45, 2, 1033, 1031, 3, 2, 2, 2, 1033, 1032,
	3, 2, 2, 2, 1034, 123, 3, 2, 2, 2, 1035, 1036, 7, 32, 2, 2, 1036, 1037,
	5, 94, 48, 2, 1037, 1038, 5, 54, 28, 2, 1038, 1039, 7, 140, 2, 2, 1039,
	125, 3, 2, 2, 2, 1040, 1041, 7, 23, 2, 2, 1041, 1042, 5, 234, 118, 2, 1042,
	1043, 7, 147, 2, 2, 1043, 1046, 5, 472, 237, 2, 1044, 1045, 7, 137, 2,
	2, 1045, 1047, 5, 194, 98, 2, 1046, 1044, 3, 2, 2, 2, 1046, 1047, 3, 2,
	2, 2, 1047, 1048, 3, 2, 2, 2, 1048, 1049, 7, 140, 2, 2, 1049, 127, 3, 2,
	2, 2, 1050, 1051, 7, 11, 2, 2, 1051, 1052, 5, 238, 120, 2, 1052, 1053,
	7, 60, 2, 2, 1053, 1054, 5, 472, 237, 2, 1054, 129, 3, 2, 2, 2, 1055, 1056,
	7, 11, 2, 2, 1056, 1057, 5, 238, 120, 2, 1057, 1058, 7, 60, 2, 2, 1058,
	1059, 5, 450, 226, 2, 1059, 131, 3, 2, 2, 2, 1060, 1063, 5, 378, 190, 2,
	1061, 1063, 5, 238, 120, 2, 1062, 1060, 3, 2, 2, 2, 1062, 1061, 3, 2, 2,
	2, 1063, 133, 3, 2, 2, 2, 1064, 1066, 5, 136, 69, 2, 1065, 1064, 3, 2,
	2, 2, 1066, 1069, 3, 2, 2, 2, 1067, 1065, 3, 2, 2, 2, 1067, 1068, 3, 2,
	2, 2, 1068, 135, 3, 2, 2, 2, 1069, 1067, 3, 2, 2, 2, 1070, 1073, 5, 276,
	139, 2, 1071, 1073, 5, 498, 250, 2, 1072, 1070, 3, 2, 2, 2, 1072, 1071,
	3, 2, 2, 2, 1073, 137, 3, 2, 2, 2, 1074, 1081, 7, 101, 2, 2, 1075, 1076,
	7, 76, 2, 2, 1076, 1078, 5, 194, 98, 2, 1077, 1075, 3, 2, 2, 2, 1077, 1078,
	3, 2, 2, 2, 1078, 1079, 3, 2, 2, 2, 1079, 1081, 7, 41, 2, 2, 1080, 1074,
	3, 2, 2, 2, 1080, 1077, 3, 2, 2, 2, 1081, 139, 3, 2, 2, 2, 1082, 1084,
	5, 142, 72, 2, 1083, 1082, 3, 2, 2, 2, 1084, 1087, 3, 2, 2, 2, 1085, 1083,
	3, 2, 2, 2, 1085, 1086, 3, 2, 2, 2, 1086, 1088, 3, 2, 2, 2, 1087, 1085,
	3, 2, 2, 2, 1088, 1089, 7, 2, 2, 3, 1089, 141, 3, 2, 2, 2, 1090, 1091,
	5, 134, 68, 2, 1091, 1092, 5, 278, 140, 2, 1092, 143, 3, 2, 2, 2, 1093,
	1096, 5, 232, 117, 2, 1094, 1096, 7, 129, 2, 2, 1095, 1093, 3, 2, 2, 2,
	1095, 1094, 3, 2, 2, 2, 1096, 145, 3, 2, 2, 2, 1097, 1098, 9, 4, 2, 2,
	1098, 147, 3, 2, 2, 2, 1099, 1100, 7, 24, 2, 2, 1100, 1101, 5, 230, 116,
	2, 1101, 1102, 7, 6, 2, 2, 1102, 1103, 5, 194, 98, 2, 1103, 1104, 7, 140,
	2, 2, 1104, 149, 3, 2, 2, 2, 1105, 1108, 5, 374, 188, 2, 1106, 1108, 5,
	472, 237, 2, 1107, 1105, 3, 2, 2, 2, 1107, 1106, 3, 2, 2, 2, 1108, 151,
	3, 2, 2, 2, 1109, 1110, 5, 86, 44, 2, 1110, 1111, 7, 135, 2, 2, 1111, 1113,
	3, 2, 2, 2, 1112, 1109, 3, 2, 2, 2, 1112, 1113, 3, 2, 2, 2, 1113, 1114,
	3, 2, 2, 2, 1114, 1115, 5, 194, 98, 2, 1115, 153, 3, 2, 2, 2, 1116, 1117,
	5, 234, 118, 2, 1117, 1118, 7, 147, 2, 2, 1118, 1119, 5, 158, 80, 2, 1119,
	1120, 7, 140, 2, 2, 1120, 155, 3, 2, 2, 2, 1121, 1122, 5, 450, 226, 2,
	1122, 157, 3, 2, 2, 2, 1123, 1124, 5, 472, 237, 2, 1124, 159, 3, 2, 2,
	2, 1125, 1126, 7, 27, 2, 2, 1126, 1131, 5, 294, 148, 2, 1127, 1128, 7,
	143, 2, 2, 1128, 1129, 5, 232, 117, 2, 1129, 1130, 7, 144, 2, 2, 1130,
	1132, 3, 2, 2, 2, 1131, 1127, 3, 2, 2, 2, 1131, 1132, 3, 2, 2, 2, 1132,
	1137, 3, 2, 2, 2, 1133, 1134, 7, 22, 2, 2, 1134, 1137, 5, 294, 148, 2,
	1135, 1137, 7, 62, 2, 2, 1136, 1125, 3, 2, 2, 2, 1136, 1133, 3, 2, 2, 2,
	1136, 1135, 3, 2, 2, 2, 1137, 161, 3, 2, 2, 2, 1138, 1139, 9, 5, 2, 2,
	1139, 163, 3, 2, 2, 2, 1140, 1142, 5, 162, 82, 2, 1141, 1143, 7, 138, 2,
	2, 1142, 1141, 3, 2, 2, 2, 1142, 1143, 3, 2, 2, 2, 1143, 165, 3, 2, 2,
	2, 1144, 1149, 5, 164, 83, 2, 1145, 1146, 7, 141, 2, 2, 1146, 1148, 5,
	164, 83, 2, 1147, 1145, 3, 2, 2, 2, 1148, 1151, 3, 2, 2, 2, 1149, 1147,
	3, 2, 2, 2, 1149, 1150, 3, 2, 2, 2, 1150, 167, 3, 2, 2, 2, 1151, 1149,
	3, 2, 2, 2, 1152, 1153, 7, 27, 2, 2, 1153, 1154, 5, 232, 117, 2, 1154,
	1155, 7, 43, 2, 2, 1155, 1156, 5, 176, 89, 2, 1156, 1159, 5, 172, 87, 2,
	1157, 1158, 7, 14, 2, 2, 1158, 1160, 5, 184, 93, 2, 1159, 1157, 3, 2, 2,
	2, 1159, 1160, 3, 2, 2, 2, 1160, 1161, 3, 2, 2, 2, 1161, 1163, 7, 26, 2,
	2, 1162, 1164, 7, 27, 2, 2, 1163, 1162, 3, 2, 2, 2, 1163, 1164, 3, 2, 2,
	2, 1164, 1166, 3, 2, 2, 2, 1165, 1167, 5, 232, 117, 2, 1166, 1165, 3, 2,
	2, 2, 1166, 1167, 3, 2, 2, 2, 1167, 1168, 3, 2, 2, 2, 1168, 1169, 7, 140,
	2, 2, 1169, 169, 3, 2, 2, 2, 1170, 1191, 5, 454, 228, 2, 1171, 1191, 5,
	452, 227, 2, 1172, 1191, 5, 490, 246, 2, 1173, 1191, 5, 470, 236, 2, 1174,
	1191, 5, 126, 64, 2, 1175, 1191, 5, 418, 210, 2, 1176, 1191, 5, 502, 252,
	2, 1177, 1191, 5, 198, 100, 2, 1178, 1191, 5, 18, 10, 2, 1179, 1191, 5,
	46, 24, 2, 1180, 1191, 5, 50, 26, 2, 1181, 1191, 5, 148, 75, 2, 1182, 1191,
	5, 446, 224, 2, 1183, 1191, 5, 498, 250, 2, 1184, 1191, 5, 228, 115, 2,
	1185, 1191, 5, 226, 114, 2, 1186, 1191, 5, 306, 154, 2, 1187, 1191, 5,
	448, 225, 2, 1188, 1191, 5, 368, 185, 2, 1189, 1191, 5, 482, 242, 2, 1190,
	1170, 3, 2, 2, 2, 1190, 1171, 3, 2, 2, 2, 1190, 1172, 3, 2, 2, 2, 1190,
	1173, 3, 2, 2, 2, 1190, 1174, 3, 2, 2, 2, 1190, 1175, 3, 2, 2, 2, 1190,
	1176, 3, 2, 2, 2, 1190, 1177, 3, 2, 2, 2, 1190, 1178, 3, 2, 2, 2, 1190,
	1179, 3, 2, 2, 2, 1190, 1180, 3, 2, 2, 2, 1190, 1181, 3, 2, 2, 2, 1190,
	1182, 3, 2, 2, 2, 1190, 1183, 3, 2, 2, 2, 1190, 1184, 3, 2, 2, 2, 1190,
	1185, 3, 2, 2, 2, 1190, 1186, 3, 2, 2, 2, 1190, 1187, 3, 2, 2, 2, 1190,
	1188, 3, 2, 2, 2, 1190, 1189, 3, 2, 2, 2, 1191, 171, 3, 2, 2, 2, 1192,
	1194, 5, 170, 86, 2, 1193, 1192, 3, 2, 2, 2, 1194, 1197, 3, 2, 2, 2, 1195,
	1193, 3, 2, 2, 2, 1195, 1196, 3, 2, 2, 2, 1196, 173, 3, 2, 2, 2, 1197,
	1195, 3, 2, 2, 2, 1198, 1200, 5, 186, 94, 2, 1199, 1201, 5, 424, 213, 2,
	1200, 1199, 3, 2, 2, 2, 1200, 1201, 3, 2, 2, 2, 1201, 175, 3, 2, 2, 2,
	1202, 1204, 5, 216, 109, 2, 1203, 1202, 3, 2, 2, 2, 1203, 1204, 3, 2, 2,
	2, 1204, 1206, 3, 2, 2, 2, 1205, 1207, 5, 338, 170, 2, 1206, 1205, 3, 2,
	2, 2, 1206, 1207, 3, 2, 2, 2, 1207, 177, 3, 2, 2, 2, 1208, 1213, 5, 174,
	88, 2, 1209, 1210, 7, 141, 2, 2, 1210, 1212, 5, 174, 88, 2, 1211, 1209,
	3, 2, 2, 2, 1212, 1215, 3, 2, 2, 2, 1213, 1211, 3, 2, 2, 2, 1213, 1214,
	3, 2, 2, 2, 1214, 1219, 3, 2, 2, 2, 1215, 1213, 3, 2, 2, 2, 1216, 1219,
	7, 64, 2, 2, 1217, 1219, 7, 8, 2, 2, 1218, 1208, 3, 2, 2, 2, 1218, 1216,
	3, 2, 2, 2, 1218, 1217, 3, 2, 2, 2, 1219, 179, 3, 2, 2, 2, 1220, 1221,
	5, 178, 90, 2, 1221, 1222, 7, 147, 2, 2, 1222, 1223, 5, 162, 82, 2, 1223,
	181, 3, 2, 2, 2, 1224, 1228, 5, 100, 51, 2, 1225, 1228, 5, 362, 182, 2,
	1226, 1228, 5, 104, 53, 2, 1227, 1224, 3, 2, 2, 2, 1227, 1225, 3, 2, 2,
	2, 1227, 1226, 3, 2, 2, 2, 1228, 183, 3, 2, 2, 2, 1229, 1231, 5, 182, 92,
	2, 1230, 1229, 3, 2, 2, 2, 1231, 1234, 3, 2, 2, 2, 1232, 1230, 3, 2, 2,
	2, 1232, 1233, 3, 2, 2, 2, 1233, 185, 3, 2, 2, 2, 1234, 1232, 3, 2, 2,
	2, 1235, 1239, 5, 232, 117, 2, 1236, 1239, 7, 128, 2, 2, 1237, 1239, 7,
	129, 2, 2, 1238, 1235, 3, 2, 2, 2, 1238, 1236, 3, 2, 2, 2, 1238, 1237,
	3, 2, 2, 2, 1239, 187, 3, 2, 2, 2, 1240, 1243, 5, 232, 117, 2, 1241, 1243,
	7, 128, 2, 2, 1242, 1240, 3, 2, 2, 2, 1242, 1241, 3, 2, 2, 2, 1243, 189,
	3, 2, 2, 2, 1244, 1245, 7, 143, 2, 2, 1245, 1250, 5, 188, 95, 2, 1246,
	1247, 7, 141, 2, 2, 1247, 1249, 5, 188, 95, 2, 1248, 1246, 3, 2, 2, 2,
	1249, 1252, 3, 2, 2, 2, 1250, 1248, 3, 2, 2, 2, 1250, 1251, 3, 2, 2, 2,
	1251, 1253, 3, 2, 2, 2, 1252, 1250, 3, 2, 2, 2, 1253, 1254, 7, 144, 2,
	2, 1254, 191, 3, 2, 2, 2, 1255, 1257, 5, 274, 138, 2, 1256, 1255, 3, 2,
	2, 2, 1256, 1257, 3, 2, 2, 2, 1257, 1258, 3, 2, 2, 2, 1258, 1260, 7, 30,
	2, 2, 1259, 1261, 5, 232, 117, 2, 1260, 1259, 3, 2, 2, 2, 1260, 1261, 3,
	2, 2, 2, 1261, 1264, 3, 2, 2, 2, 1262, 1263, 7, 110, 2, 2, 1263, 1265,
	5, 108, 55, 2, 1264, 1262, 3, 2, 2, 2, 1264, 1265, 3, 2, 2, 2, 1265, 1266,
	3, 2, 2, 2, 1266, 1267, 7, 140, 2, 2, 1267, 193, 3, 2, 2, 2, 1268, 1274,
	5, 384, 193, 2, 1269, 1270, 5, 286, 144, 2, 1270, 1271, 5, 384, 193, 2,
	1271, 1273, 3, 2, 2, 2, 1272, 1269, 3, 2, 2, 2, 1273, 1276, 3, 2, 2, 2,
	1274, 1272, 3, 2, 2, 2, 1274, 1275, 3, 2, 2, 2, 1275, 195, 3, 2, 2, 2,
	1276, 1274, 3, 2, 2, 2, 1277, 1280, 5, 344, 173, 2, 1278, 1279, 7, 131,
	2, 2, 1279, 1281, 5, 344, 173, 2, 1280, 1278, 3, 2, 2, 2, 1280, 1281, 3,
	2, 2, 2, 1281, 1287, 3, 2, 2, 2, 1282, 1283, 7, 3, 2, 2, 1283, 1287, 5,
	344, 173, 2, 1284, 1285, 7, 58, 2, 2, 1285, 1287, 5, 344, 173, 2, 1286,
	1277, 3, 2, 2, 2, 1286, 1282, 3, 2, 2, 2, 1286, 1284, 3, 2, 2, 2, 1287,
	197, 3, 2, 2, 2, 1288, 1289, 7, 31, 2, 2, 1289, 1290, 5, 234, 118, 2, 1290,
	1291, 7, 147, 2, 2, 1291, 1293, 5, 472, 237, 2, 1292, 1294, 5, 202, 102,
	2, 1293, 1292, 3, 2, 2, 2, 1293, 1294, 3, 2, 2, 2, 1294, 1295, 3, 2, 2,
	2, 1295, 1296, 7, 140, 2, 2, 1296, 199, 3, 2, 2, 2, 1297, 1298, 5, 194,
	98, 2, 1298, 201, 3, 2, 2, 2, 1299, 1300, 7, 62, 2, 2, 1300, 1302, 5, 194,
	98, 2, 1301, 1299, 3, 2, 2, 2, 1301, 1302, 3, 2, 2, 2, 1302, 1303, 3, 2,
	2, 2, 1303, 1304, 7, 43, 2, 2, 1304, 1305, 5, 200, 101, 2, 1305, 203, 3,
	2, 2, 2, 1306, 1307, 7, 31, 2, 2, 1307, 1308, 7, 60, 2, 2, 1308, 1309,
	5, 472, 237, 2, 1309, 205, 3, 2, 2, 2, 1310, 1311, 5, 260, 131, 2, 1311,
	207, 3, 2, 2, 2, 1312, 1319, 5, 232, 117, 2, 1313, 1314, 5, 232, 117, 2,
	1314, 1315, 7, 143, 2, 2, 1315, 1316, 5, 376, 189, 2, 1316, 1317, 7, 144,
	2, 2, 1317, 1319, 3, 2, 2, 2, 1318, 1312, 3, 2, 2, 2, 1318, 1313, 3, 2,
	2, 2, 1319, 209, 3, 2, 2, 2, 1320, 1321, 7, 73, 2, 2, 1321, 1322, 5, 234,
	118, 2, 1322, 1323, 7, 147, 2, 2, 1323, 1326, 5, 472, 237, 2, 1324, 1325,
	7, 137, 2, 2, 1325, 1327, 5, 194, 98, 2, 1326, 1324, 3, 2, 2, 2, 1326,
	1327, 3, 2, 2, 2, 1327, 1328, 3, 2, 2, 2, 1328, 1329, 7, 140, 2, 2, 1329,
	211, 3, 2, 2, 2, 1330, 1331, 5, 274, 138, 2, 1331, 1332, 5, 214, 108, 2,
	1332, 1340, 7, 34, 2, 2, 1333, 1335, 5, 58, 30, 2, 1334, 1333, 3, 2, 2,
	2, 1335, 1338, 3, 2, 2, 2, 1336, 1334, 3, 2, 2, 2, 1336, 1337, 3, 2, 2,
	2, 1337, 1339, 3, 2, 2, 2, 1338, 1336, 3, 2, 2, 2, 1339, 1341, 7, 14, 2,
	2, 1340, 1336, 3, 2, 2, 2, 1340, 1341, 3, 2, 2, 2, 1341, 1345, 3, 2, 2,
	2, 1342, 1344, 5, 30, 16, 2, 1343, 1342, 3, 2, 2, 2, 1344, 1347, 3, 2,
	2, 2, 1345, 1343, 3, 2, 2, 2, 1345, 1346, 3, 2, 2, 2, 1346, 1348, 3, 2,
	2, 2, 1347, 1345, 3, 2, 2, 2, 1348, 1349, 7, 26, 2, 2, 1349, 1351, 7, 34,
	2, 2, 1350, 1352, 5, 232, 117, 2, 1351, 1350, 3, 2, 2, 2, 1351, 1352, 3,
	2, 2, 2, 1352, 1353, 3, 2, 2, 2, 1353, 1354, 7, 140, 2, 2, 1354, 213, 3,
	2, 2, 2, 1355, 1356, 7, 32, 2, 2, 1356, 1360, 5, 332, 167, 2, 1357, 1358,
	7, 38, 2, 2, 1358, 1360, 5, 108, 55, 2, 1359, 1355, 3, 2, 2, 2, 1359, 1357,
	3, 2, 2, 2, 1360, 215, 3, 2, 2, 2, 1361, 1362, 7, 35, 2, 2, 1362, 1363,
	7, 143, 2, 2, 1363, 1364, 5, 218, 110, 2, 1364, 1365, 7, 144, 2, 2, 1365,
	1366, 7, 140, 2, 2, 1366, 217, 3, 2, 2, 2, 1367, 1372, 5, 248, 125, 2,
	1368, 1369, 7, 140, 2, 2, 1369, 1371, 5, 248, 125, 2, 1370, 1368, 3, 2,
	2, 2, 1371, 1374, 3, 2, 2, 2, 1372, 1370, 3, 2, 2, 2, 1372, 1373, 3, 2,
	2, 2, 1373, 219, 3, 2, 2, 2, 1374, 1372, 3, 2, 2, 2, 1375, 1376, 7, 35,
	2, 2, 1376, 1377, 7, 50, 2, 2, 1377, 1378, 7, 143, 2, 2, 1378, 1379, 5,
	44, 23, 2, 1379, 1380, 7, 144, 2, 2, 1380, 221, 3, 2, 2, 2, 1381, 1384,
	5, 294, 148, 2, 1382, 1384, 7, 128, 2, 2, 1383, 1381, 3, 2, 2, 2, 1383,
	1382, 3, 2, 2, 2, 1384, 223, 3, 2, 2, 2, 1385, 1390, 5, 222, 112, 2, 1386,
	1387, 7, 141, 2, 2, 1387, 1389, 5, 222, 112, 2, 1388, 1386, 3, 2, 2, 2,
	1389, 1392, 3, 2, 2, 2, 1390, 1388, 3, 2, 2, 2, 1390, 1391, 3, 2, 2, 2,
	1391, 225, 3, 2, 2, 2, 1392, 1390, 3, 2, 2, 2, 1393, 1394, 7, 36, 2, 2,
	1394, 1395, 5, 274, 138, 2, 1395, 1396, 5, 294, 148, 2, 1396, 1397, 7,
	143, 2, 2, 1397, 1398, 5, 224, 113, 2, 1398, 1399, 7, 144, 2, 2, 1399,
	1400, 7, 140, 2, 2, 1400, 227, 3, 2, 2, 2, 1401, 1402, 7, 36, 2, 2, 1402,
	1403, 5, 232, 117, 2, 1403, 1404, 7, 43, 2, 2, 1404, 1405, 7, 143, 2, 2,
	1405, 1406, 5, 166, 84, 2, 1406, 1407, 7, 144, 2, 2, 1407, 1408, 7, 140,
	2, 2, 1408, 229, 3, 2, 2, 2, 1409, 1410, 5, 422, 212, 2, 1410, 1411, 7,
	147, 2, 2, 1411, 1412, 5, 294, 148, 2, 1412, 231, 3, 2, 2, 2, 1413, 1414,
	9, 6, 2, 2, 1414, 233, 3, 2, 2, 2, 1415, 1420, 5, 232, 117, 2, 1416, 1417,
	7, 141, 2, 2, 1417, 1419, 5, 232, 117, 2, 1418, 1416, 3, 2, 2, 2, 1419,
	1422, 3, 2, 2, 2, 1420, 1418, 3, 2, 2, 2, 1420, 1421, 3, 2, 2, 2, 1421,
	235, 3, 2, 2, 2, 1422, 1420, 3, 2, 2, 2, 1423, 1425, 5, 274, 138, 2, 1424,
	1423, 3, 2, 2, 2, 1424, 1425, 3, 2, 2, 2, 1425, 1426, 3, 2, 2, 2, 1426,
	1427, 7, 38, 2, 2, 1427, 1428, 5, 108, 55, 2, 1428, 1429, 7, 97, 2, 2,
	1429, 1437, 5, 408, 205, 2, 1430, 1431, 7, 29, 2, 2, 1431, 1432, 5, 108,
	55, 2, 1432, 1433, 7, 97, 2, 2, 1433, 1434, 5, 408, 205, 2, 1434, 1436,
	3, 2, 2, 2, 1435, 1430, 3, 2, 2, 2, 1436, 1439, 3, 2, 2, 2, 1437, 1435,
	3, 2, 2, 2, 1437, 1438, 3, 2, 2, 2, 1438, 1442, 3, 2, 2, 2, 1439, 1437,
	3, 2, 2, 2, 1440, 1441, 7, 28, 2, 2, 1441, 1443, 5, 408, 205, 2, 1442,
	1440, 3, 2, 2, 2, 1442, 1443, 3, 2, 2, 2, 1443, 1444, 3, 2, 2, 2, 1444,
	1445, 7, 26, 2, 2, 1445, 1447, 7, 38, 2, 2, 1446, 1448, 5, 232, 117, 2,
	1447, 1446, 3, 2, 2, 2, 1447, 1448, 3, 2, 2, 2, 1448, 1449, 3, 2, 2, 2,
	1449, 1450, 7, 140, 2, 2, 1450, 237, 3, 2, 2, 2, 1451, 1452, 7, 143, 2,
	2, 1452, 1457, 5, 150, 76, 2, 1453, 1454, 7, 141, 2, 2, 1454, 1456, 5,
	150, 76, 2, 1455, 1453, 3, 2, 2, 2, 1456, 1459, 3, 2, 2, 2, 1457, 1455,
	3, 2, 2, 2, 1457, 1458, 3, 2, 2, 2, 1458, 1460, 3, 2, 2, 2, 1459, 1457,
	3, 2, 2, 2, 1460, 1461, 7, 144, 2, 2, 1461, 239, 3, 2, 2, 2, 1462, 1465,
	5, 150, 76, 2, 1463, 1465, 5, 194, 98, 2, 1464, 1462, 3, 2, 2, 2, 1464,
	1463, 3, 2, 2, 2, 1465, 241, 3, 2, 2, 2, 1466, 1467, 5, 294, 148, 2, 1467,
	1468, 7, 74, 2, 2, 1468, 1469, 7, 138, 2, 2, 1469, 243, 3, 2, 2, 2, 1470,
	1472, 7, 21, 2, 2, 1471, 1470, 3, 2, 2, 2, 1471, 1472, 3, 2, 2, 2, 1472,
	1473, 3, 2, 2, 2, 1473, 1485, 5, 294, 148, 2, 1474, 1475, 7, 27, 2, 2,
	1475, 1480, 5, 294, 148, 2, 1476, 1477, 7, 143, 2, 2, 1477, 1478, 5, 232,
	117, 2, 1478, 1479, 7, 144, 2, 2, 1479, 1481, 3, 2, 2, 2, 1480, 1476, 3,
	2, 2, 2, 1480, 1481, 3, 2, 2, 2, 1481, 1485, 3, 2, 2, 2, 1482, 1483, 7,
	22, 2, 2, 1483, 1485, 5, 294, 148, 2, 1484, 1471, 3, 2, 2, 2, 1484, 1474,
	3, 2, 2, 2, 1484, 1482, 3, 2, 2, 2, 1485, 245, 3, 2, 2, 2, 1486, 1491,
	5, 232, 117, 2, 1487, 1488, 7, 141, 2, 2, 1488, 1490, 5, 232, 117, 2, 1489,
	1487, 3, 2, 2, 2, 1490, 1493, 3, 2, 2, 2, 1491, 1489, 3, 2, 2, 2, 1491,
	1492, 3, 2, 2, 2, 1492, 1497, 3, 2, 2, 2, 1493, 1491, 3, 2, 2, 2, 1494,
	1497, 7, 64, 2, 2, 1495, 1497, 7, 8, 2, 2, 1496, 1486, 3, 2, 2, 2, 1496,
	1494, 3, 2, 2, 2, 1496, 1495, 3, 2, 2, 2, 1497, 247, 3, 2, 2, 2, 1498,
	1500, 7, 23, 2, 2, 1499, 1498, 3, 2, 2, 2, 1499, 1500, 3, 2, 2, 2, 1500,
	1501, 3, 2, 2, 2, 1501, 1502, 5, 234, 118, 2, 1502, 1504, 7, 147, 2, 2,
	1503, 1505, 7, 40, 2, 2, 1504, 1503, 3, 2, 2, 2, 1504, 1505, 3, 2, 2, 2,
	1505, 1506, 3, 2, 2, 2, 1506, 1509, 5, 472, 237, 2, 1507, 1508, 7, 137,
	2, 2, 1508, 1510, 5, 194, 98, 2, 1509, 1507, 3, 2, 2, 2, 1509, 1510, 3,
	2, 2, 2, 1510, 249, 3, 2, 2, 2, 1511, 1518, 5, 248, 125, 2, 1512, 1518,
	5, 266, 134, 2, 1513, 1518, 5, 270, 136, 2, 1514, 1518, 5, 254, 128, 2,
	1515, 1518, 5, 268, 135, 2, 1516, 1518, 5, 262, 132, 2, 1517, 1511, 3,
	2, 2, 2, 1517, 1512, 3, 2, 2, 2, 1517, 1513, 3, 2, 2, 2, 1517, 1514, 3,
	2, 2, 2, 1517, 1515, 3, 2, 2, 2, 1517, 1516, 3, 2, 2, 2, 1518, 251, 3,
	2, 2, 2, 1519, 1520, 5, 250, 126, 2, 1520, 253, 3, 2, 2, 2, 1521, 1522,
	7, 31, 2, 2, 1522, 1523, 5, 234, 118, 2, 1523, 1524, 7, 147, 2, 2, 1524,
	1525, 5, 472, 237, 2, 1525, 255, 3, 2, 2, 2, 1526, 1531, 5, 266, 134, 2,
	1527, 1528, 7, 140, 2, 2, 1528, 1530, 5, 266, 134, 2, 1529, 1527, 3, 2,
	2, 2, 1530, 1533, 3, 2, 2, 2, 1531, 1529, 3, 2, 2, 2, 1531, 1532, 3, 2,
	2, 2, 1532, 257, 3, 2, 2, 2, 1533, 1531, 3, 2, 2, 2, 1534, 1539, 5, 264,
	133, 2, 1535, 1536, 7, 140, 2, 2, 1536, 1538, 5, 264, 133, 2, 1537, 1535,
	3, 2, 2, 2, 1538, 1541, 3, 2, 2, 2, 1539, 1537, 3, 2, 2, 2, 1539, 1540,
	3, 2, 2, 2, 1540, 259, 3, 2, 2, 2, 1541, 1539, 3, 2, 2, 2, 1542, 1547,
	5, 252, 127, 2, 1543, 1544, 7, 140, 2, 2, 1544, 1546, 5, 252, 127, 2, 1545,
	1543, 3, 2, 2, 2, 1546, 1549, 3, 2, 2, 2, 1547, 1545, 3, 2, 2, 2, 1547,
	1548, 3, 2, 2, 2, 1548, 261, 3, 2, 2, 2, 1549, 1547, 3, 2, 2, 2, 1550,
	1551, 7, 73, 2, 2, 1551, 1552, 5, 234, 118, 2, 1552, 1554, 7, 147, 2, 2,
	1553, 1555, 9, 7, 2, 2, 1554, 1553, 3, 2, 2, 2, 1554, 1555, 3, 2, 2, 2,
	1555, 1556, 3, 2, 2, 2, 1556, 1559, 5, 472, 237, 2, 1557, 1558, 7, 137,
	2, 2, 1558, 1560, 5, 194, 98, 2, 1559, 1557, 3, 2, 2, 2, 1559, 1560, 3,
	2, 2, 2, 1560, 263, 3, 2, 2, 2, 1561, 1562, 5, 234, 118, 2, 1562, 1563,
	7, 147, 2, 2, 1563, 1564, 5, 290, 146, 2, 1564, 1566, 5, 472, 237, 2, 1565,
	1567, 7, 19, 2, 2, 1566, 1565, 3, 2, 2, 2, 1566, 1567, 3, 2, 2, 2, 1567,
	1570, 3, 2, 2, 2, 1568, 1569, 7, 137, 2, 2, 1569, 1571, 5, 194, 98, 2,
	1570, 1568, 3, 2, 2, 2, 1570, 1571, 3, 2, 2, 2, 1571, 265, 3, 2, 2, 2,
	1572, 1573, 7, 88, 2, 2, 1573, 1574, 5, 234, 118, 2, 1574, 1576, 7, 147,
	2, 2, 1575, 1577, 5, 290, 146, 2, 1576, 1575, 3, 2, 2, 2, 1576, 1577, 3,
	2, 2, 2, 1577, 1578, 3, 2, 2, 2, 1578, 1580, 5, 472, 237, 2, 1579, 1581,
	7, 19, 2, 2, 1580, 1579, 3, 2, 2, 2, 1580, 1581, 3, 2, 2, 2, 1581, 1584,
	3, 2, 2, 2, 1582, 1583, 7, 137, 2, 2, 1583, 1585, 5, 194, 98, 2, 1584,
	1582, 3, 2, 2, 2, 1584, 1585, 3, 2, 2, 2, 1585, 267, 3, 2, 2, 2, 1586,
	1587, 7, 96, 2, 2, 1587, 1588, 5, 234, 118, 2, 1588, 1589, 7, 147, 2, 2,
	1589, 1590, 5, 450, 226, 2, 1590, 269, 3, 2, 2, 2, 1591, 1593, 7, 107,
	2, 2, 1592, 1591, 3, 2, 2, 2, 1592, 1593, 3, 2, 2, 2, 1593, 1594, 3, 2,
	2, 2, 1594, 1595, 5, 234, 118, 2, 1595, 1597, 7, 147, 2, 2, 1596, 1598,
	5, 290, 146, 2, 1597, 1596, 3, 2, 2, 2, 1597, 1598, 3, 2, 2, 2, 1598, 1599,
	3, 2, 2, 2, 1599, 1602, 5, 472, 237, 2, 1600, 1601, 7, 137, 2, 2, 1601,
	1603, 5, 194, 98, 2, 1602, 1600, 3, 2, 2, 2, 1602, 1603, 3, 2, 2, 2, 1603,
	271, 3, 2, 2, 2, 1604, 1605, 7, 111, 2, 2, 1605, 1609, 5, 108, 55, 2, 1606,
	1607, 7, 32, 2, 2, 1607, 1609, 5, 332, 167, 2, 1608, 1604, 3, 2, 2, 2,
	1608, 1606, 3, 2, 2, 2, 1609, 273, 3, 2, 2, 2, 1610, 1611, 5, 232, 117,
	2, 1611, 1612, 7, 147, 2, 2, 1612, 275, 3, 2, 2, 2, 1613, 1614, 7, 45,
	2, 2, 1614, 1615, 5, 284, 143, 2, 1615, 1616, 7, 140, 2, 2, 1616, 277,
	3, 2, 2, 2, 1617, 1620, 5, 396, 199, 2, 1618, 1620, 5, 346, 174, 2, 1619,
	1617, 3, 2, 2, 2, 1619, 1618, 3, 2, 2, 2, 1620, 279, 3, 2, 2, 2, 1621,
	1627, 7, 59, 2, 2, 1622, 1627, 7, 115, 2, 2, 1623, 1627, 7, 129, 2, 2,
	1624, 1627, 5, 188, 95, 2, 1625, 1627, 5, 314, 158, 2, 1626, 1621, 3, 2,
	2, 2, 1626, 1622, 3, 2, 2, 2, 1626, 1623, 3, 2, 2, 2, 1626, 1624, 3, 2,
	2, 2, 1626, 1625, 3, 2, 2, 2, 1627, 281, 3, 2, 2, 2, 1628, 1629, 5, 232,
	117, 2, 1629, 283, 3, 2, 2, 2, 1630, 1635, 5, 282, 142, 2, 1631, 1632,
	7, 141, 2, 2, 1632, 1634, 5, 282, 142, 2, 1633, 1631, 3, 2, 2, 2, 1634,
	1637, 3, 2, 2, 2, 1635, 1633, 3, 2, 2, 2, 1635, 1636, 3, 2, 2, 2, 1636,
	285, 3, 2, 2, 2, 1637, 1635, 3, 2, 2, 2, 1638, 1639, 9, 8, 2, 2, 1639,
	287, 3, 2, 2, 2, 1640, 1642, 5, 274, 138, 2, 1641, 1640, 3, 2, 2, 2, 1641,
	1642, 3, 2, 2, 2, 1642, 1644, 3, 2, 2, 2, 1643, 1645, 5, 272, 137, 2, 1644,
	1643, 3, 2, 2, 2, 1644, 1645, 3, 2, 2, 2, 1645, 1646, 3, 2, 2, 2, 1646,
	1647, 7, 49, 2, 2, 1647, 1648, 5, 408, 205, 2, 1648, 1649, 7, 26, 2, 2,
	1649, 1651, 7, 49, 2, 2, 1650, 1652, 5, 232, 117, 2, 1651, 1650, 3, 2,
	2, 2, 1651, 1652, 3, 2, 2, 2, 1652, 1653, 3, 2, 2, 2, 1653, 1654, 7, 140,
	2, 2, 1654, 289, 3, 2, 2, 2, 1655, 1656, 9, 9, 2, 2, 1656, 291, 3, 2, 2,
	2, 1657, 1658, 9, 10, 2, 2, 1658, 293, 3, 2, 2, 2, 1659, 1669, 5, 304,
	153, 2, 1660, 1665, 5, 296, 149, 2, 1661, 1662, 7, 156, 2, 2, 1662, 1664,
	5, 296, 149, 2, 1663, 1661, 3, 2, 2, 2, 1664, 1667, 3, 2, 2, 2, 1665, 1663,
	3, 2, 2, 2, 1665, 1666, 3, 2, 2, 2, 1666, 1669, 3, 2, 2, 2, 1667, 1665,
	3, 2, 2, 2, 1668, 1659, 3, 2, 2, 2, 1668, 1660, 3, 2, 2, 2, 1669, 295,
	3, 2, 2, 2, 1670, 1674, 5, 304, 153, 2, 1671, 1675, 5, 298, 150, 2, 1672,
	1675, 5, 300, 151, 2, 1673, 1675, 5, 302, 152, 2, 1674, 1671, 3, 2, 2,
	2, 1674, 1672, 3, 2, 2, 2, 1674, 1673, 3, 2, 2, 2, 1674, 1675, 3, 2, 2,
	2, 1675, 297, 3, 2, 2, 2, 1676, 1677, 7, 164, 2, 2, 1677, 1686, 5, 48,
	25, 2, 1678, 1683, 5, 194, 98, 2, 1679, 1680, 7, 141, 2, 2, 1680, 1682,
	5, 194, 98, 2, 1681, 1679, 3, 2, 2, 2, 1682, 1685, 3, 2, 2, 2, 1683, 1681,
	3, 2, 2, 2, 1683, 1684, 3, 2, 2, 2, 1684, 1687, 3, 2, 2, 2, 1685, 1683,
	3, 2, 2, 2, 1686, 1678, 3, 2, 2, 2, 1686, 1687, 3, 2, 2, 2, 1687, 299,
	3, 2, 2, 2, 1688, 1690, 7, 143, 2, 2, 1689, 1691, 5, 10, 6, 2, 1690, 1689,
	3, 2, 2, 2, 1690, 1691, 3, 2, 2, 2, 1691, 1692, 3, 2, 2, 2, 1692, 1693,
	7, 144, 2, 2, 1693, 301, 3, 2, 2, 2, 1694, 1695, 7, 143, 2, 2, 1695, 1700,
	5, 376, 189, 2, 1696, 1697, 7, 141, 2, 2, 1697, 1699, 5, 376, 189, 2, 1698,
	1696, 3, 2, 2, 2, 1699, 1702, 3, 2, 2, 2, 1700, 1698, 3, 2, 2, 2, 1700,
	1701, 3, 2, 2, 2, 1701, 1703, 3, 2, 2, 2, 1702, 1700, 3, 2, 2, 2, 1703,
	1704, 7, 144, 2, 2, 1704, 1706, 3, 2, 2, 2, 1705, 1694, 3, 2, 2, 2, 1706,
	1707, 3, 2, 2, 2, 1707, 1705, 3, 2, 2, 2, 1707, 1708, 3, 2, 2, 2, 1708,
	303, 3, 2, 2, 2, 1709, 1714, 5, 232, 117, 2, 1710, 1711, 7, 156, 2, 2,
	1711, 1713, 5, 474, 238, 2, 1712, 1710, 3, 2, 2, 2, 1713, 1716, 3, 2, 2,
	2, 1714, 1712, 3, 2, 2, 2, 1714, 1715, 3, 2, 2, 2, 1715, 305, 3, 2, 2,
	2, 1716, 1714, 3, 2, 2, 2, 1717, 1718, 7, 53, 2, 2, 1718, 1719, 5, 232,
	117, 2, 1719, 1720, 7, 43, 2, 2, 1720, 1721, 5, 308, 155, 2, 1721, 1722,
	7, 140, 2, 2, 1722, 307, 3, 2, 2, 2, 1723, 1726, 5, 392, 197, 2, 1724,
	1726, 5, 96, 49, 2, 1725, 1723, 3, 2, 2, 2, 1725, 1724, 3, 2, 2, 2, 1726,
	309, 3, 2, 2, 2, 1727, 1728, 5, 234, 118, 2, 1728, 1729, 7, 147, 2, 2,
	1729, 1730, 5, 156, 79, 2, 1730, 311, 3, 2, 2, 2, 1731, 1733, 5, 274, 138,
	2, 1732, 1731, 3, 2, 2, 2, 1732, 1733, 3, 2, 2, 2, 1733, 1734, 3, 2, 2,
	2, 1734, 1736, 7, 55, 2, 2, 1735, 1737, 5, 232, 117, 2, 1736, 1735, 3,
	2, 2, 2, 1736, 1737, 3, 2, 2, 2, 1737, 1740, 3, 2, 2, 2, 1738, 1739, 7,
	110, 2, 2, 1739, 1741, 5, 108, 55, 2, 1740, 1738, 3, 2, 2, 2, 1740, 1741,
	3, 2, 2, 2, 1741, 1742, 3, 2, 2, 2, 1742, 1743, 7, 140, 2, 2, 1743, 313,
	3, 2, 2, 2, 1744, 1747, 5, 2, 2, 2, 1745, 1747, 5, 334, 168, 2, 1746, 1744,
	3, 2, 2, 2, 1746, 1745, 3, 2, 2, 2, 1747, 315, 3, 2, 2, 2, 1748, 1755,
	5, 126, 64, 2, 1749, 1755, 5, 418, 210, 2, 1750, 1755, 5, 502, 252, 2,
	1751, 1755, 5, 198, 100, 2, 1752, 1755, 5, 482, 242, 2, 1753, 1755, 5,
	368, 185, 2, 1754, 1748, 3, 2, 2, 2, 1754, 1749, 3, 2, 2, 2, 1754, 1750,
	3, 2, 2, 2, 1754, 1751, 3, 2, 2, 2, 1754, 1752, 3, 2, 2, 2, 1754, 1753,
	3, 2, 2, 2, 1755, 317, 3, 2, 2, 2, 1756, 1758, 7, 37, 2, 2, 1757, 1756,
	3, 2, 2, 2, 1757, 1758, 3, 2, 2, 2, 1758, 1760, 3, 2, 2, 2, 1759, 1761,
	5, 138, 70, 2, 1760, 1759, 3, 2, 2, 2, 1760, 1761, 3, 2, 2, 2, 1761, 319,
	3, 2, 2, 2, 1762, 1763, 7, 66, 2, 2, 1763, 1764, 7, 16, 2, 2, 1764, 1765,
	5, 232, 117, 2, 1765, 1766, 7, 43, 2, 2, 1766, 1767, 5, 324, 163, 2, 1767,
	1770, 7, 26, 2, 2, 1768, 1769, 7, 66, 2, 2, 1769, 1771, 7, 16, 2, 2, 1770,
	1768, 3, 2, 2, 2, 1770, 1771, 3, 2, 2, 2, 1771, 1773, 3, 2, 2, 2, 1772,
	1774, 5, 232, 117, 2, 1773, 1772, 3, 2, 2, 2, 1773, 1774, 3, 2, 2, 2, 1774,
	1775, 3, 2, 2, 2, 1775, 1776, 7, 140, 2, 2, 1776, 321, 3, 2, 2, 2, 1777,
	1789, 5, 454, 228, 2, 1778, 1789, 5, 452, 227, 2, 1779, 1789, 5, 490, 246,
	2, 1780, 1789, 5, 470, 236, 2, 1781, 1789, 5, 126, 64, 2, 1782, 1789, 5,
	502, 252, 2, 1783, 1789, 5, 198, 100, 2, 1784, 1789, 5, 18, 10, 2, 1785,
	1789, 5, 498, 250, 2, 1786, 1789, 5, 228, 115, 2, 1787, 1789, 5, 226, 114,
	2, 1788, 1777, 3, 2, 2, 2, 1788, 1778, 3, 2, 2, 2, 1788, 1779, 3, 2, 2,
	2, 1788, 1780, 3, 2, 2, 2, 1788, 1781, 3, 2, 2, 2, 1788, 1782, 3, 2, 2,
	2, 1788, 1783, 3, 2, 2, 2, 1788, 1784, 3, 2, 2, 2, 1788, 1785, 3, 2, 2,
	2, 1788, 1786, 3, 2, 2, 2, 1788, 1787, 3, 2, 2, 2, 1789, 323, 3, 2, 2,
	2, 1790, 1792, 5, 322, 162, 2, 1791, 1790, 3, 2, 2, 2, 1792, 1795, 3, 2,
	2, 2, 1793, 1791, 3, 2, 2, 2, 1793, 1794, 3, 2, 2, 2, 1794, 325, 3, 2,
	2, 2, 1795, 1793, 3, 2, 2, 2, 1796, 1797, 7, 66, 2, 2, 1797, 1798, 5, 232,
	117, 2, 1798, 1799, 7, 43, 2, 2, 1799, 1800, 5, 330, 166, 2, 1800, 1802,
	7, 26, 2, 2, 1801, 1803, 7, 66, 2, 2, 1802, 1801, 3, 2, 2, 2, 1802, 1803,
	3, 2, 2, 2, 1803, 1805, 3, 2, 2, 2, 1804, 1806, 5, 232, 117, 2, 1805, 1804,
	3, 2, 2, 2, 1805, 1806, 3, 2, 2, 2, 1806, 1807, 3, 2, 2, 2, 1807, 1808,
	7, 140, 2, 2, 1808, 327, 3, 2, 2, 2, 1809, 1828, 5, 454, 228, 2, 1810,
	1828, 5, 490, 246, 2, 1811, 1828, 5, 470, 236, 2, 1812, 1828, 5, 126, 64,
	2, 1813, 1828, 5, 418, 210, 2, 1814, 1828, 5, 502, 252, 2, 1815, 1828,
	5, 198, 100, 2, 1816, 1828, 5, 18, 10, 2, 1817, 1828, 5, 90, 46, 2, 1818,
	1828, 5, 46, 24, 2, 1819, 1828, 5, 50, 26, 2, 1820, 1828, 5, 148, 75, 2,
	1821, 1828, 5, 498, 250, 2, 1822, 1828, 5, 228, 115, 2, 1823, 1828, 5,
	226, 114, 2, 1824, 1828, 5, 306, 154, 2, 1825, 1828, 5, 448, 225, 2, 1826,
	1828, 5, 482, 242, 2, 1827, 1809, 3, 2, 2, 2, 1827, 1810, 3, 2, 2, 2, 1827,
	1811, 3, 2, 2, 2, 1827, 1812, 3, 2, 2, 2, 1827, 1813, 3, 2, 2, 2, 1827,
	1814, 3, 2, 2, 2, 1827, 1815, 3, 2, 2, 2, 1827, 1816, 3, 2, 2, 2, 1827,
	1817, 3, 2, 2, 2, 1827, 1818, 3, 2, 2, 2, 1827, 1819, 3, 2, 2, 2, 1827,
	1820, 3, 2, 2, 2, 1827, 1821, 3, 2, 2, 2, 1827, 1822, 3, 2, 2, 2, 1827,
	1823, 3, 2, 2, 2, 1827, 1824, 3, 2, 2, 2, 1827, 1825, 3, 2, 2, 2, 1827,
	1826, 3, 2, 2, 2, 1828, 329, 3, 2, 2, 2, 1829, 1831, 5, 328, 165, 2, 1830,
	1829, 3, 2, 2, 2, 1831, 1834, 3, 2, 2, 2, 1832, 1830, 3, 2, 2, 2, 1832,
	1833, 3, 2, 2, 2, 1833, 331, 3, 2, 2, 2, 1834, 1832, 3, 2, 2, 2, 1835,
	1836, 5, 232, 117, 2, 1836, 1837, 7, 40, 2, 2, 1837, 1838, 5, 150, 76,
	2, 1838, 333, 3, 2, 2, 2, 1839, 1840, 5, 2, 2, 2, 1840, 1841, 5, 232, 117,
	2, 1841, 335, 3, 2, 2, 2, 1842, 1843, 5, 378, 190, 2, 1843, 1844, 7, 104,
	2, 2, 1844, 1848, 5, 52, 27, 2, 1845, 1847, 5, 398, 200, 2, 1846, 1845,
	3, 2, 2, 2, 1847, 1850, 3, 2, 2, 2, 1848, 1846, 3, 2, 2, 2, 1848, 1849,
	3, 2, 2, 2, 1849, 1851, 3, 2, 2, 2, 1850, 1848, 3, 2, 2, 2, 1851, 1852,
	7, 26, 2, 2, 1852, 1854, 7, 104, 2, 2, 1853, 1855, 5, 232, 117, 2, 1854,
	1853, 3, 2, 2, 2, 1854, 1855, 3, 2, 2, 2, 1855, 337, 3, 2, 2, 2, 1856,
	1857, 7, 67, 2, 2, 1857, 1858, 7, 143, 2, 2, 1858, 1859, 5, 340, 171, 2,
	1859, 1860, 7, 144, 2, 2, 1860, 1861, 7, 140, 2, 2, 1861, 339, 3, 2, 2,
	2, 1862, 1863, 5, 258, 130, 2, 1863, 341, 3, 2, 2, 2, 1864, 1865, 7, 67,
	2, 2, 1865, 1866, 7, 50, 2, 2, 1866, 1867, 7, 143, 2, 2, 1867, 1868, 5,
	44, 23, 2, 1868, 1869, 7, 144, 2, 2, 1869, 343, 3, 2, 2, 2, 1870, 1880,
	5, 280, 141, 2, 1871, 1880, 5, 366, 184, 2, 1872, 1873, 7, 143, 2, 2, 1873,
	1874, 5, 194, 98, 2, 1874, 1875, 7, 144, 2, 2, 1875, 1880, 3, 2, 2, 2,
	1876, 1880, 5, 24, 13, 2, 1877, 1880, 5, 16, 9, 2, 1878, 1880, 5, 294,
	148, 2, 1879, 1870, 3, 2, 2, 2, 1879, 1871, 3, 2, 2, 2, 1879, 1872, 3,
	2, 2, 2, 1879, 1876, 3, 2, 2, 2, 1879, 1877, 3, 2, 2, 2, 1879, 1878, 3,
	2, 2, 2, 1880, 345, 3, 2, 2, 2, 1881, 1885, 5, 168, 85, 2, 1882, 1885,
	5, 116, 59, 2, 1883, 1885, 5, 326, 164, 2, 1884, 1881, 3, 2, 2, 2, 1884,
	1882, 3, 2, 2, 2, 1884, 1883, 3, 2, 2, 2, 1885, 347, 3, 2, 2, 2, 1886,
	1899, 5, 454, 228, 2, 1887, 1899, 5, 452, 227, 2, 1888, 1899, 5, 490, 246,
	2, 1889, 1899, 5, 470, 236, 2, 1890, 1899, 5, 126, 64, 2, 1891, 1899, 5,
	502, 252, 2, 1892, 1899, 5, 18, 10, 2, 1893, 1899, 5, 46, 24, 2, 1894,
	1899, 5, 50, 26, 2, 1895, 1899, 5, 498, 250, 2, 1896, 1899, 5, 228, 115,
	2, 1897, 1899, 5, 226, 114, 2, 1898, 1886, 3, 2, 2, 2, 1898, 1887, 3, 2,
	2, 2, 1898, 1888, 3, 2, 2, 2, 1898, 1889, 3, 2, 2, 2, 1898, 1890, 3, 2,
	2, 2, 1898, 1891, 3, 2, 2, 2, 1898, 1892, 3, 2, 2, 2, 1898, 1893, 3, 2,
	2, 2, 1898, 1894, 3, 2, 2, 2, 1898, 1895, 3, 2, 2, 2, 1898, 1896, 3, 2,
	2, 2, 1898, 1897, 3, 2, 2, 2, 1899, 349, 3, 2, 2, 2, 1900, 1902, 5, 348,
	175, 2, 1901, 1900, 3, 2, 2, 2, 1902, 1905, 3, 2, 2, 2, 1903, 1901, 3,
	2, 2, 2, 1903, 1904, 3, 2, 2, 2, 1904, 351, 3, 2, 2, 2, 1905, 1903, 3,
	2, 2, 2, 1906, 1908, 5, 410, 206, 2, 1907, 1906, 3, 2, 2, 2, 1908, 1911,
	3, 2, 2, 2, 1909, 1907, 3, 2, 2, 2, 1909, 1910, 3, 2, 2, 2, 1910, 353,
	3, 2, 2, 2, 1911, 1909, 3, 2, 2, 2, 1912, 1917, 5, 304, 153, 2, 1913, 1914,
	7, 143, 2, 2, 1914, 1915, 5, 10, 6, 2, 1915, 1916, 7, 144, 2, 2, 1916,
	1918, 3, 2, 2, 2, 1917, 1913, 3, 2, 2, 2, 1917, 1918, 3, 2, 2, 2, 1918,
	355, 3, 2, 2, 2, 1919, 1921, 5, 274, 138, 2, 1920, 1919, 3, 2, 2, 2, 1920,
	1921, 3, 2, 2, 2, 1921, 1922, 3, 2, 2, 2, 1922, 1923, 5, 354, 178, 2, 1923,
	1924, 7, 140, 2, 2, 1924, 357, 3, 2, 2, 2, 1925, 1939, 5, 454, 228, 2,
	1926, 1939, 5, 452, 227, 2, 1927, 1939, 5, 490, 246, 2, 1928, 1939, 5,
	470, 236, 2, 1929, 1939, 5, 126, 64, 2, 1930, 1939, 5, 502, 252, 2, 1931,
	1939, 5, 198, 100, 2, 1932, 1939, 5, 18, 10, 2, 1933, 1939, 5, 46, 24,
	2, 1934, 1939, 5, 50, 26, 2, 1935, 1939, 5, 498, 250, 2, 1936, 1939, 5,
	228, 115, 2, 1937, 1939, 5, 226, 114, 2, 1938, 1925, 3, 2, 2, 2, 1938,
	1926, 3, 2, 2, 2, 1938, 1927, 3, 2, 2, 2, 1938, 1928, 3, 2, 2, 2, 1938,
	1929, 3, 2, 2, 2, 1938, 1930, 3, 2, 2, 2, 1938, 1931, 3, 2, 2, 2, 1938,
	1932, 3, 2, 2, 2, 1938, 1933, 3, 2, 2, 2, 1938, 1934, 3, 2, 2, 2, 1938,
	1935, 3, 2, 2, 2, 1938, 1936, 3, 2, 2, 2, 1938, 1937, 3, 2, 2, 2, 1939,
	359, 3, 2, 2, 2, 1940, 1942, 5, 358, 180, 2, 1941, 1940, 3, 2, 2, 2, 1942,
	1945, 3, 2, 2, 2, 1943, 1941, 3, 2, 2, 2, 1943, 1944, 3, 2, 2, 2, 1944,
	361, 3, 2, 2, 2, 1945, 1943, 3, 2, 2, 2, 1946, 1948, 5, 274, 138, 2, 1947,
	1946, 3, 2, 2, 2, 1947, 1948, 3, 2, 2, 2, 1948, 1950, 3, 2, 2, 2, 1949,
	1951, 7, 68, 2, 2, 1950, 1949, 3, 2, 2, 2, 1950, 1951, 3, 2, 2, 2, 1951,
	1952, 3, 2, 2, 2, 1952, 1957, 7, 69, 2, 2, 1953, 1954, 7, 143, 2, 2, 1954,
	1955, 5, 406, 204, 2, 1955, 1956, 7, 144, 2, 2, 1956, 1958, 3, 2, 2, 2,
	1957, 1953, 3, 2, 2, 2, 1957, 1958, 3, 2, 2, 2, 1958, 1960, 3, 2, 2, 2,
	1959, 1961, 7, 43, 2, 2, 1960, 1959, 3, 2, 2, 2, 1960, 1961, 3, 2, 2, 2,
	1961, 1962, 3, 2, 2, 2, 1962, 1963, 5, 360, 181, 2, 1963, 1964, 7, 14,
	2, 2, 1964, 1965, 5, 364, 183, 2, 1965, 1967, 7, 26, 2, 2, 1966, 1968,
	7, 68, 2, 2, 1967, 1966, 3, 2, 2, 2, 1967, 1968, 3, 2, 2, 2, 1968, 1969,
	3, 2, 2, 2, 1969, 1971, 7, 69, 2, 2, 1970, 1972, 5, 232, 117, 2, 1971,
	1970, 3, 2, 2, 2, 1971, 1972, 3, 2, 2, 2, 1972, 1973, 3, 2, 2, 2, 1973,
	1974, 7, 140, 2, 2, 1974, 363, 3, 2, 2, 2, 1975, 1977, 5, 410, 206, 2,
	1976, 1975, 3, 2, 2, 2, 1977, 1980, 3, 2, 2, 2, 1978, 1976, 3, 2, 2, 2,
	1978, 1979, 3, 2, 2, 2, 1979, 365, 3, 2, 2, 2, 1980, 1978, 3, 2, 2, 2,
	1981, 1982, 5, 472, 237, 2, 1982, 1988, 7, 164, 2, 2, 1983, 1989, 5, 16,
	9, 2, 1984, 1985, 7, 143, 2, 2, 1985, 1986, 5, 194, 98, 2, 1986, 1987,
	7, 144, 2, 2, 1987, 1989, 3, 2, 2, 2, 1988, 1983, 3, 2, 2, 2, 1988, 1984,
	3, 2, 2, 2, 1989, 367, 3, 2, 2, 2, 1990, 1994, 5, 210, 106, 2, 1991, 1994,
	5, 70, 36, 2, 1992, 1994, 5, 444, 223, 2, 1993, 1990, 3, 2, 2, 2, 1993,
	1991, 3, 2, 2, 2, 1993, 1992, 3, 2, 2, 2, 1994, 369, 3, 2, 2, 2, 1995,
	2000, 5, 294, 148, 2, 1996, 1997, 7, 141, 2, 2, 1997, 1999, 5, 294, 148,
	2, 1998, 1996, 3, 2, 2, 2, 1999, 2002, 3, 2, 2, 2, 2000, 1998, 3, 2, 2,
	2, 2000, 2001, 3, 2, 2, 2, 2001, 2006, 3, 2, 2, 2, 2002, 2000, 3, 2, 2,
	2, 2003, 2006, 7, 64, 2, 2, 2004, 2006, 7, 8, 2, 2, 2005, 1995, 3, 2, 2,
	2, 2005, 2003, 3, 2, 2, 2, 2005, 2004, 3, 2, 2, 2, 2006, 371, 3, 2, 2,
	2, 2007, 2008, 5, 370, 186, 2, 2008, 2009, 7, 147, 2, 2, 2009, 2010, 5,
	294, 148, 2, 2010, 373, 3, 2, 2, 2, 2011, 2014, 5, 376, 189, 2, 2012, 2014,
	5, 294, 148, 2, 2013, 2011, 3, 2, 2, 2, 2013, 2012, 3, 2, 2, 2, 2014, 375,
	3, 2, 2, 2, 2015, 2019, 5, 426, 214, 2, 2016, 2017, 5, 146, 74, 2, 2017,
	2018, 5, 426, 214, 2, 2018, 2020, 3, 2, 2, 2, 2019, 2016, 3, 2, 2, 2, 2019,
	2020, 3, 2, 2, 2, 2020, 377, 3, 2, 2, 2, 2021, 2022, 7, 74, 2, 2, 2022,
	2023, 5, 374, 188, 2, 2023, 379, 3, 2, 2, 2, 2024, 2026, 7, 78, 2, 2, 2025,
	2027, 5, 310, 156, 2, 2026, 2025, 3, 2, 2, 2, 2027, 2028, 3, 2, 2, 2, 2028,
	2026, 3, 2, 2, 2, 2028, 2029, 3, 2, 2, 2, 2029, 2030, 3, 2, 2, 2, 2030,
	2031, 7, 26, 2, 2, 2031, 2033, 7, 78, 2, 2, 2032, 2034, 5, 232, 117, 2,
	2033, 2032, 3, 2, 2, 2, 2033, 2034, 3, 2, 2, 2, 2034, 381, 3, 2, 2, 2,
	2035, 2037, 7, 78, 2, 2, 2036, 2038, 5, 154, 78, 2, 2037, 2036, 3, 2, 2,
	2, 2038, 2039, 3, 2, 2, 2, 2039, 2037, 3, 2, 2, 2, 2039, 2040, 3, 2, 2,
	2, 2040, 2041, 3, 2, 2, 2, 2041, 2042, 7, 26, 2, 2, 2042, 2044, 7, 78,
	2, 2, 2043, 2045, 5, 232, 117, 2, 2044, 2043, 3, 2, 2, 2, 2044, 2045, 3,
	2, 2, 2, 2045, 383, 3, 2, 2, 2, 2046, 2050, 5, 412, 207, 2, 2047, 2048,
	5, 386, 194, 2, 2048, 2049, 5, 412, 207, 2, 2049, 2051, 3, 2, 2, 2, 2050,
	2047, 3, 2, 2, 2, 2050, 2051, 3, 2, 2, 2, 2051, 385, 3, 2, 2, 2, 2052,
	2053, 9, 11, 2, 2, 2053, 387, 3, 2, 2, 2, 2054, 2056, 5, 274, 138, 2, 2055,
	2054, 3, 2, 2, 2, 2055, 2056, 3, 2, 2, 2, 2056, 2057, 3, 2, 2, 2, 2057,
	2058, 7, 81, 2, 2, 2058, 2061, 5, 194, 98, 2, 2059, 2060, 7, 86, 2, 2,
	2060, 2062, 5, 194, 98, 2, 2061, 2059, 3, 2, 2, 2, 2061, 2062, 3, 2, 2,
	2, 2062, 2063, 3, 2, 2, 2, 2063, 2064, 7, 140, 2, 2, 2064, 389, 3, 2, 2,
	2, 2065, 2067, 5, 274, 138, 2, 2066, 2065, 3, 2, 2, 2, 2066, 2067, 3, 2,
	2, 2, 2067, 2068, 3, 2, 2, 2, 2068, 2070, 7, 82, 2, 2, 2069, 2071, 5, 194,
	98, 2, 2070, 2069, 3, 2, 2, 2, 2070, 2071, 3, 2, 2, 2, 2071, 2072, 3, 2,
	2, 2, 2072, 2073, 7, 140, 2, 2, 2073, 391, 3, 2, 2, 2, 2074, 2075, 5, 294,
	148, 2, 2075, 2076, 7, 5, 2, 2, 2076, 2077, 5, 294, 148, 2, 2077, 2078,
	7, 98, 2, 2, 2078, 2079, 5, 294, 148, 2, 2079, 2080, 7, 79, 2, 2, 2080,
	393, 3, 2, 2, 2, 2081, 2085, 5, 336, 169, 2, 2082, 2085, 5, 190, 96, 2,
	2083, 2085, 5, 378, 190, 2, 2084, 2081, 3, 2, 2, 2, 2084, 2082, 3, 2, 2,
	2, 2084, 2083, 3, 2, 2, 2, 2085, 395, 3, 2, 2, 2, 2086, 2089, 5, 26, 14,
	2, 2087, 2089, 5, 320, 161, 2, 2088, 2086, 3, 2, 2, 2, 2088, 2087, 3, 2,
	2, 2, 2089, 397, 3, 2, 2, 2, 2090, 2091, 5, 232, 117, 2, 2091, 2092, 7,
	154, 2, 2, 2092, 2093, 5, 334, 168, 2, 2093, 2094, 7, 140, 2, 2, 2094,
	399, 3, 2, 2, 2, 2095, 2096, 7, 109, 2, 2, 2096, 2097, 5, 194, 98, 2, 2097,
	2098, 7, 85, 2, 2, 2098, 2099, 5, 476, 239, 2, 2099, 2100, 7, 133, 2, 2,
	2100, 2101, 5, 318, 160, 2, 2101, 2102, 5, 402, 202, 2, 2102, 2103, 7,
	140, 2, 2, 2103, 401, 3, 2, 2, 2, 2104, 2105, 5, 506, 254, 2, 2105, 2106,
	7, 110, 2, 2, 2106, 2114, 5, 86, 44, 2, 2107, 2108, 7, 141, 2, 2, 2108,
	2109, 5, 506, 254, 2, 2109, 2110, 7, 110, 2, 2, 2110, 2111, 5, 86, 44,
	2, 2111, 2113, 3, 2, 2, 2, 2112, 2107, 3, 2, 2, 2, 2113, 2116, 3, 2, 2,
	2, 2114, 2112, 3, 2, 2, 2, 2114, 2115, 3, 2, 2, 2, 2115, 403, 3, 2, 2,
	2, 2116, 2114, 3, 2, 2, 2, 2117, 2118, 7, 61, 2, 2, 2118, 2119, 5, 406,
	204, 2, 2119, 405, 3, 2, 2, 2, 2120, 2125, 5, 294, 148, 2, 2121, 2122,
	7, 141, 2, 2, 2122, 2124, 5, 294, 148, 2, 2123, 2121, 3, 2, 2, 2, 2124,
	2127, 3, 2, 2, 2, 2125, 2123, 3, 2, 2, 2, 2125, 2126, 3, 2, 2, 2, 2126,
	407, 3, 2, 2, 2, 2127, 2125, 3, 2, 2, 2, 2128, 2130, 5, 410, 206, 2, 2129,
	2128, 3, 2, 2, 2, 2130, 2133, 3, 2, 2, 2, 2131, 2129, 3, 2, 2, 2, 2131,
	2132, 3, 2, 2, 2, 2132, 409, 3, 2, 2, 2, 2133, 2131, 3, 2, 2, 2, 2134,
	2153, 5, 504, 253, 2, 2135, 2153, 5, 40, 21, 2, 2136, 2153, 5, 388, 195,
	2, 2137, 2153, 5, 416, 209, 2, 2138, 2153, 5, 500, 251, 2, 2139, 2153,
	5, 236, 119, 2, 2140, 2153, 5, 80, 41, 2, 2141, 2153, 5, 288, 145, 2, 2142,
	2153, 5, 312, 157, 2, 2143, 2153, 5, 192, 97, 2, 2144, 2153, 5, 390, 196,
	2, 2145, 2147, 5, 274, 138, 2, 2146, 2145, 3, 2, 2, 2, 2146, 2147, 3, 2,
	2, 2, 2147, 2148, 3, 2, 2, 2, 2148, 2149, 7, 59, 2, 2, 2149, 2153, 7, 140,
	2, 2, 2150, 2153, 5, 78, 40, 2, 2151, 2153, 5, 356, 179, 2, 2152, 2134,
	3, 2, 2, 2, 2152, 2135, 3, 2, 2, 2, 2152, 2136, 3, 2, 2, 2, 2152, 2137,
	3, 2, 2, 2, 2152, 2138, 3, 2, 2, 2, 2152, 2139, 3, 2, 2, 2, 2152, 2140,
	3, 2, 2, 2, 2152, 2141, 3, 2, 2, 2, 2152, 2142, 3, 2, 2, 2, 2152, 2143,
	3, 2, 2, 2, 2152, 2144, 3, 2, 2, 2, 2152, 2146, 3, 2, 2, 2, 2152, 2150,
	3, 2, 2, 2, 2152, 2151, 3, 2, 2, 2, 2153, 411, 3, 2, 2, 2, 2154, 2158,
	5, 426, 214, 2, 2155, 2156, 5, 414, 208, 2, 2156, 2157, 5, 426, 214, 2,
	2157, 2159, 3, 2, 2, 2, 2158, 2155, 3, 2, 2, 2, 2158, 2159, 3, 2, 2, 2,
	2159, 413, 3, 2, 2, 2, 2160, 2161, 9, 12, 2, 2, 2161, 415, 3, 2, 2, 2,
	2162, 2164, 5, 274, 138, 2, 2163, 2162, 3, 2, 2, 2, 2163, 2164, 3, 2, 2,
	2, 2164, 2165, 3, 2, 2, 2, 2165, 2166, 5, 476, 239, 2, 2166, 2168, 7, 133,
	2, 2, 2167, 2169, 5, 138, 70, 2, 2168, 2167, 3, 2, 2, 2, 2168, 2169, 3,
	2, 2, 2, 2169, 2170, 3, 2, 2, 2, 2170, 2171, 5, 506, 254, 2, 2171, 2172,
	7, 140, 2, 2, 2172, 417, 3, 2, 2, 2, 2173, 2174, 7, 88, 2, 2, 2174, 2175,
	5, 234, 118, 2, 2175, 2176, 7, 147, 2, 2, 2176, 2178, 5, 472, 237, 2, 2177,
	2179, 5, 420, 211, 2, 2178, 2177, 3, 2, 2, 2, 2178, 2179, 3, 2, 2, 2, 2179,
	2182, 3, 2, 2, 2, 2180, 2181, 7, 137, 2, 2, 2181, 2183, 5, 194, 98, 2,
	2182, 2180, 3, 2, 2, 2, 2182, 2183, 3, 2, 2, 2, 2183, 2184, 3, 2, 2, 2,
	2184, 2185, 7, 140, 2, 2, 2185, 419, 3, 2, 2, 2, 2186, 2187, 9, 13, 2,
	2, 2187, 421, 3, 2, 2, 2, 2188, 2193, 5, 294, 148, 2, 2189, 2190, 7, 141,
	2, 2, 2190, 2192, 5, 294, 148, 2, 2191, 2189, 3, 2, 2, 2, 2192, 2195, 3,
	2, 2, 2, 2193, 2191, 3, 2, 2, 2, 2193, 2194, 3, 2, 2, 2, 2194, 2199, 3,
	2, 2, 2, 2195, 2193, 3, 2, 2, 2, 2196, 2199, 7, 64, 2, 2, 2197, 2199, 7,
	8, 2, 2, 2198, 2188, 3, 2, 2, 2, 2198, 2196, 3, 2, 2, 2, 2198, 2197, 3,
	2, 2, 2, 2199, 423, 3, 2, 2, 2, 2200, 2209, 7, 145, 2, 2, 2201, 2206, 5,
	294, 148, 2, 2202, 2203, 7, 141, 2, 2, 2203, 2205, 5, 294, 148, 2, 2204,
	2202, 3, 2, 2, 2, 2205, 2208, 3, 2, 2, 2, 2206, 2204, 3, 2, 2, 2, 2206,
	2207, 3, 2, 2, 2, 2207, 2210, 3, 2, 2, 2, 2208, 2206, 3, 2, 2, 2, 2209,
	2201, 3, 2, 2, 2, 2209, 2210, 3, 2, 2, 2, 2210, 2213, 3, 2, 2, 2, 2211,
	2212, 7, 82, 2, 2, 2212, 2214, 5, 294, 148, 2, 2213, 2211, 3, 2, 2, 2,
	2213, 2214, 3, 2, 2, 2, 2214, 2215, 3, 2, 2, 2, 2215, 2216, 7, 146, 2,
	2, 2216, 425, 3, 2, 2, 2, 2217, 2219, 9, 14, 2, 2, 2218, 2217, 3, 2, 2,
	2, 2218, 2219, 3, 2, 2, 2, 2219, 2220, 3, 2, 2, 2, 2220, 2226, 5, 478,
	240, 2, 2221, 2222, 5, 14, 8, 2, 2222, 2223, 5, 478, 240, 2, 2223, 2225,
	3, 2, 2, 2, 2224, 2221, 3, 2, 2, 2, 2225, 2228, 3, 2, 2, 2, 2226, 2224,
	3, 2, 2, 2, 2226, 2227, 3, 2, 2, 2, 2227, 427, 3, 2, 2, 2, 2228, 2226,
	3, 2, 2, 2, 2229, 2231, 5, 274, 138, 2, 2230, 2229, 3, 2, 2, 2, 2230, 2231,
	3, 2, 2, 2, 2231, 2232, 3, 2, 2, 2, 2232, 2233, 5, 426, 214, 2, 2233, 2234,
	7, 132, 2, 2, 2234, 2236, 5, 426, 214, 2, 2235, 2237, 5, 488, 245, 2, 2236,
	2235, 3, 2, 2, 2, 2236, 2237, 3, 2, 2, 2, 2237, 2238, 3, 2, 2, 2, 2238,
	2239, 7, 140, 2, 2, 2239, 429, 3, 2, 2, 2, 2240, 2241, 7, 110, 2, 2, 2241,
	2242, 5, 86, 44, 2, 2242, 2243, 7, 135, 2, 2, 2243, 2244, 5, 440, 221,
	2, 2244, 431, 3, 2, 2, 2, 2245, 2247, 5, 274, 138, 2, 2246, 2245, 3, 2,
	2, 2, 2246, 2247, 3, 2, 2, 2, 2247, 2248, 3, 2, 2, 2, 2248, 2249, 7, 20,
	2, 2, 2249, 2250, 5, 194, 98, 2, 2250, 2252, 7, 106, 2, 2, 2251, 2253,
	5, 430, 216, 2, 2252, 2251, 3, 2, 2, 2, 2253, 2254, 3, 2, 2, 2, 2254, 2252,
	3, 2, 2, 2, 2254, 2255, 3, 2, 2, 2, 2255, 2256, 3, 2, 2, 2, 2256, 2257,
	7, 26, 2, 2, 2257, 2259, 7, 20, 2, 2, 2258, 2260, 5, 232, 117, 2, 2259,
	2258, 3, 2, 2, 2, 2259, 2260, 3, 2, 2, 2, 2260, 2261, 3, 2, 2, 2, 2261,
	2262, 7, 140, 2, 2, 2262, 433, 3, 2, 2, 2, 2263, 2265, 5, 274, 138, 2,
	2264, 2263, 3, 2, 2, 2, 2264, 2265, 3, 2, 2, 2, 2265, 2266, 3, 2, 2, 2,
	2266, 2267, 7, 38, 2, 2, 2267, 2268, 5, 108, 55, 2, 2268, 2269, 7, 106,
	2, 2, 2269, 2277, 5, 440, 221, 2, 2270, 2271, 7, 29, 2, 2, 2271, 2272,
	5, 108, 55, 2, 2272, 2273, 7, 106, 2, 2, 2273, 2274, 5, 440, 221, 2, 2274,
	2276, 3, 2, 2, 2, 2275, 2270, 3, 2, 2, 2, 2276, 2279, 3, 2, 2, 2, 2277,
	2275, 3, 2, 2, 2, 2277, 2278, 3, 2, 2, 2, 2278, 2282, 3, 2, 2, 2, 2279,
	2277, 3, 2, 2, 2, 2280, 2281, 7, 28, 2, 2, 2281, 2283, 5, 440, 221, 2,
	2282, 2280, 3, 2, 2, 2, 2282, 2283, 3, 2, 2, 2, 2283, 2284, 3, 2, 2, 2,
	2284, 2285, 7, 26, 2, 2, 2285, 2287, 7, 106, 2, 2, 2286, 2288, 5, 232,
	117, 2, 2287, 2286, 3, 2, 2, 2, 2287, 2288, 3, 2, 2, 2, 2288, 2289, 3,
	2, 2, 2, 2289, 2290, 7, 140, 2, 2, 2290, 435, 3, 2, 2, 2, 2291, 2293, 5,
	274, 138, 2, 2292, 2291, 3, 2, 2, 2, 2292, 2293, 3, 2, 2, 2, 2293, 2294,
	3, 2, 2, 2, 2294, 2296, 7, 71, 2, 2, 2295, 2297, 7, 43, 2, 2, 2296, 2295,
	3, 2, 2, 2, 2296, 2297, 3, 2, 2, 2, 2297, 2298, 3, 2, 2, 2, 2298, 2299,
	5, 350, 176, 2, 2299, 2300, 7, 14, 2, 2, 2300, 2301, 5, 352, 177, 2, 2301,
	2302, 7, 26, 2, 2, 2302, 2304, 7, 71, 2, 2, 2303, 2305, 5, 232, 117, 2,
	2304, 2303, 3, 2, 2, 2, 2304, 2305, 3, 2, 2, 2, 2305, 2306, 3, 2, 2, 2,
	2306, 2307, 7, 140, 2, 2, 2307, 437, 3, 2, 2, 2, 2308, 2318, 5, 428, 215,
	2, 2309, 2318, 5, 434, 218, 2, 2310, 2318, 5, 432, 217, 2, 2311, 2318,
	5, 436, 219, 2, 2312, 2314, 5, 274, 138, 2, 2313, 2312, 3, 2, 2, 2, 2313,
	2314, 3, 2, 2, 2, 2314, 2315, 3, 2, 2, 2, 2315, 2316, 7, 59, 2, 2, 2316,
	2318, 7, 140, 2, 2, 2317, 2308, 3, 2, 2, 2, 2317, 2309, 3, 2, 2, 2, 2317,
	2310, 3, 2, 2, 2, 2317, 2311, 3, 2, 2, 2, 2317, 2313, 3, 2, 2, 2, 2318,
	439, 3, 2, 2, 2, 2319, 2321, 5, 438, 220, 2, 2320, 2319, 3, 2, 2, 2, 2321,
	2324, 3, 2, 2, 2, 2322, 2320, 3, 2, 2, 2, 2322, 2323, 3, 2, 2, 2, 2323,
	441, 3, 2, 2, 2, 2324, 2322, 3, 2, 2, 2, 2325, 2326, 7, 91, 2, 2, 2326,
	2327, 5, 426, 214, 2, 2327, 2328, 7, 141, 2, 2, 2328, 2329, 5, 426, 214,
	2, 2329, 2333, 3, 2, 2, 2, 2330, 2331, 7, 56, 2, 2, 2331, 2333, 5, 426,
	214, 2, 2332, 2325, 3, 2, 2, 2, 2332, 2330, 3, 2, 2, 2, 2333, 443, 3, 2,
	2, 2, 2334, 2335, 7, 73, 2, 2, 2335, 2336, 5, 234, 118, 2, 2336, 2337,
	7, 147, 2, 2, 2337, 2338, 5, 472, 237, 2, 2338, 2339, 5, 442, 222, 2, 2339,
	2340, 7, 140, 2, 2, 2340, 445, 3, 2, 2, 2, 2341, 2342, 7, 46, 2, 2, 2342,
	2343, 5, 372, 187, 2, 2343, 2344, 7, 109, 2, 2, 2344, 2345, 5, 194, 98,
	2, 2345, 2346, 7, 140, 2, 2, 2346, 447, 3, 2, 2, 2, 2347, 2348, 7, 94,
	2, 2, 2348, 2349, 5, 232, 117, 2, 2349, 2350, 7, 43, 2, 2, 2350, 2351,
	5, 450, 226, 2, 2351, 2352, 7, 140, 2, 2, 2352, 449, 3, 2, 2, 2, 2353,
	2355, 5, 294, 148, 2, 2354, 2356, 5, 238, 120, 2, 2355, 2354, 3, 2, 2,
	2, 2355, 2356, 3, 2, 2, 2, 2356, 2363, 3, 2, 2, 2, 2357, 2358, 7, 100,
	2, 2, 2358, 2359, 5, 194, 98, 2, 2359, 2360, 7, 5, 2, 2, 2360, 2361, 5,
	194, 98, 2, 2361, 2362, 7, 98, 2, 2, 2362, 2364, 3, 2, 2, 2, 2363, 2357,
	3, 2, 2, 2, 2363, 2364, 3, 2, 2, 2, 2364, 451, 3, 2, 2, 2, 2365, 2366,
	5, 462, 232, 2, 2366, 2367, 7, 43, 2, 2, 2367, 2368, 5, 458, 230, 2, 2368,
	2369, 7, 14, 2, 2, 2369, 2370, 5, 468, 235, 2, 2370, 2372, 7, 26, 2, 2,
	2371, 2373, 5, 460, 231, 2, 2372, 2371, 3, 2, 2, 2, 2372, 2373, 3, 2, 2,
	2, 2373, 2375, 3, 2, 2, 2, 2374, 2376, 5, 144, 73, 2, 2375, 2374, 3, 2,
	2, 2, 2375, 2376, 3, 2, 2, 2, 2376, 2377, 3, 2, 2, 2, 2377, 2378, 7, 140,
	2, 2, 2378, 453, 3, 2, 2, 2, 2379, 2380, 5, 462, 232, 2, 2380, 2381, 7,
	140, 2, 2, 2381, 455, 3, 2, 2, 2, 2382, 2396, 5, 454, 228, 2, 2383, 2396,
	5, 452, 227, 2, 2384, 2396, 5, 490, 246, 2, 2385, 2396, 5, 470, 236, 2,
	2386, 2396, 5, 126, 64, 2, 2387, 2396, 5, 502, 252, 2, 2388, 2396, 5, 198,
	100, 2, 2389, 2396, 5, 18, 10, 2, 2390, 2396, 5, 46, 24, 2, 2391, 2396,
	5, 50, 26, 2, 2392, 2396, 5, 498, 250, 2, 2393, 2396, 5, 228, 115, 2, 2394,
	2396, 5, 226, 114, 2, 2395, 2382, 3, 2, 2, 2, 2395, 2383, 3, 2, 2, 2, 2395,
	2384, 3, 2, 2, 2, 2395, 2385, 3, 2, 2, 2, 2395, 2386, 3, 2, 2, 2, 2395,
	2387, 3, 2, 2, 2, 2395, 2388, 3, 2, 2, 2, 2395, 2389, 3, 2, 2, 2, 2395,
	2390, 3, 2, 2, 2, 2395, 2391, 3, 2, 2, 2, 2395, 2392, 3, 2, 2, 2, 2395,
	2393, 3, 2, 2, 2, 2395, 2394, 3, 2, 2, 2, 2396, 457, 3, 2, 2, 2, 2397,
	2399, 5, 456, 229, 2, 2398, 2397, 3, 2, 2, 2, 2399, 2402, 3, 2, 2, 2, 2400,
	2398, 3, 2, 2, 2, 2400, 2401, 3, 2, 2, 2, 2401, 459, 3, 2, 2, 2, 2402,
	2400, 3, 2, 2, 2, 2403, 2404, 9, 15, 2, 2, 2404, 461, 3, 2, 2, 2, 2405,
	2408, 5, 464, 233, 2, 2406, 2408, 5, 466, 234, 2, 2407, 2405, 3, 2, 2,
	2, 2407, 2406, 3, 2, 2, 2, 2408, 463, 3, 2, 2, 2, 2409, 2410, 7, 70, 2,
	2, 2410, 2415, 5, 144, 73, 2, 2411, 2412, 7, 143, 2, 2, 2412, 2413, 5,
	206, 104, 2, 2413, 2414, 7, 144, 2, 2, 2414, 2416, 3, 2, 2, 2, 2415, 2411,
	3, 2, 2, 2, 2415, 2416, 3, 2, 2, 2, 2416, 465, 3, 2, 2, 2, 2417, 2419,
	9, 16, 2, 2, 2418, 2417, 3, 2, 2, 2, 2418, 2419, 3, 2, 2, 2, 2419, 2420,
	3, 2, 2, 2, 2420, 2421, 7, 33, 2, 2, 2421, 2426, 5, 144, 73, 2, 2422, 2423,
	7, 143, 2, 2, 2423, 2424, 5, 206, 104, 2, 2424, 2425, 7, 144, 2, 2, 2425,
	2427, 3, 2, 2, 2, 2426, 2422, 3, 2, 2, 2, 2426, 2427, 3, 2, 2, 2, 2427,
	2428, 3, 2, 2, 2, 2428, 2429, 7, 82, 2, 2, 2429, 2430, 5, 472, 237, 2,
	2430, 467, 3, 2, 2, 2, 2431, 2433, 5, 410, 206, 2, 2432, 2431, 3, 2, 2,
	2, 2433, 2436, 3, 2, 2, 2, 2434, 2432, 3, 2, 2, 2, 2434, 2435, 3, 2, 2,
	2, 2435, 469, 3, 2, 2, 2, 2436, 2434, 3, 2, 2, 2, 2437, 2438, 7, 95, 2,
	2, 2438, 2439, 5, 232, 117, 2, 2439, 2440, 7, 43, 2, 2, 2440, 2441, 5,
	472, 237, 2, 2441, 2442, 7, 140, 2, 2, 2442, 471, 3, 2, 2, 2, 2443, 2445,
	5, 304, 153, 2, 2444, 2446, 5, 304, 153, 2, 2445, 2444, 3, 2, 2, 2, 2445,
	2446, 3, 2, 2, 2, 2446, 2448, 3, 2, 2, 2, 2447, 2449, 5, 132, 67, 2, 2448,
	2447, 3, 2, 2, 2, 2448, 2449, 3, 2, 2, 2, 2449, 2451, 3, 2, 2, 2, 2450,
	2452, 5, 488, 245, 2, 2451, 2450, 3, 2, 2, 2, 2451, 2452, 3, 2, 2, 2, 2452,
	473, 3, 2, 2, 2, 2453, 2458, 5, 232, 117, 2, 2454, 2458, 7, 128, 2, 2,
	2455, 2458, 7, 129, 2, 2, 2456, 2458, 7, 8, 2, 2, 2457, 2453, 3, 2, 2,
	2, 2457, 2454, 3, 2, 2, 2, 2457, 2455, 3, 2, 2, 2, 2457, 2456, 3, 2, 2,
	2, 2458, 475, 3, 2, 2, 2, 2459, 2462, 5, 294, 148, 2, 2460, 2462, 5, 16,
	9, 2, 2461, 2459, 3, 2, 2, 2, 2461, 2460, 3, 2, 2, 2, 2462, 477, 3, 2,
	2, 2, 2463, 2469, 5, 196, 99, 2, 2464, 2465, 5, 292, 147, 2, 2465, 2466,
	5, 196, 99, 2, 2466, 2468, 3, 2, 2, 2, 2467, 2464, 3, 2, 2, 2, 2468, 2471,
	3, 2, 2, 2, 2469, 2467, 3, 2, 2, 2, 2469, 2470, 3, 2, 2, 2, 2470, 479,
	3, 2, 2, 2, 2471, 2469, 3, 2, 2, 2, 2472, 2475, 5, 294, 148, 2, 2473, 2474,
	7, 99, 2, 2, 2474, 2476, 5, 294, 148, 2, 2475, 2473, 3, 2, 2, 2, 2475,
	2476, 3, 2, 2, 2, 2476, 481, 3, 2, 2, 2, 2477, 2478, 7, 96, 2, 2, 2478,
	2479, 5, 234, 118, 2, 2479, 2480, 7, 147, 2, 2, 2480, 2481, 5, 450, 226,
	2, 2481, 2482, 7, 140, 2, 2, 2482, 483, 3, 2, 2, 2, 2483, 2485, 5, 234,
	118, 2, 2484, 2486, 5, 488, 245, 2, 2485, 2484, 3, 2, 2, 2, 2485, 2486,
	3, 2, 2, 2, 2486, 2489, 3, 2, 2, 2, 2487, 2488, 7, 137, 2, 2, 2488, 2490,
	5, 194, 98, 2, 2489, 2487, 3, 2, 2, 2, 2489, 2490, 3, 2, 2, 2, 2490, 2491,
	3, 2, 2, 2, 2491, 2492, 7, 98, 2, 2, 2492, 485, 3, 2, 2, 2, 2493, 2494,
	7, 32, 2, 2, 2494, 2495, 5, 194, 98, 2, 2495, 487, 3, 2, 2, 2, 2496, 2497,
	7, 100, 2, 2, 2497, 2498, 5, 194, 98, 2, 2498, 489, 3, 2, 2, 2, 2499, 2500,
	7, 102, 2, 2, 2500, 2503, 5, 232, 117, 2, 2501, 2502, 7, 43, 2, 2, 2502,
	2504, 5, 492, 247, 2, 2503, 2501, 3, 2, 2, 2, 2503, 2504, 3, 2, 2, 2, 2504,
	2505, 3, 2, 2, 2, 2505, 2506, 7, 140, 2, 2, 2506, 491, 3, 2, 2, 2, 2507,
	2512, 5, 394, 198, 2, 2508, 2512, 5, 98, 50, 2, 2509, 2512, 5, 4, 3, 2,
	2510, 2512, 5, 204, 103, 2, 2511, 2507, 3, 2, 2, 2, 2511, 2508, 3, 2, 2,
	2, 2511, 2509, 3, 2, 2, 2, 2511, 2510, 3, 2, 2, 2, 2512, 493, 3, 2, 2,
	2, 2513, 2514, 7, 11, 2, 2, 2514, 2515, 7, 143, 2, 2, 2515, 2520, 5, 242,
	122, 2, 2516, 2517, 7, 141, 2, 2, 2517, 2519, 5, 242, 122, 2, 2518, 2516,
	3, 2, 2, 2, 2519, 2522, 3, 2, 2, 2, 2520, 2518, 3, 2, 2, 2, 2520, 2521,
	3, 2, 2, 2, 2521, 2523, 3, 2, 2, 2, 2522, 2520, 3, 2, 2, 2, 2523, 2524,
	7, 144, 2, 2, 2524, 2525, 7, 60, 2, 2, 2525, 2526, 5, 472, 237, 2, 2526,
	495, 3, 2, 2, 2, 2527, 2528, 7, 11, 2, 2, 2528, 2529, 7, 143, 2, 2, 2529,
	2534, 5, 242, 122, 2, 2530, 2531, 7, 141, 2, 2, 2531, 2533, 5, 242, 122,
	2, 2532, 2530, 3, 2, 2, 2, 2533, 2536, 3, 2, 2, 2, 2534, 2532, 3, 2, 2,
	2, 2534, 2535, 3, 2, 2, 2, 2535, 2537, 3, 2, 2, 2, 2536, 2534, 3, 2, 2,
	2, 2537, 2538, 7, 144, 2, 2, 2538, 2539, 7, 60, 2, 2, 2539, 2540, 5, 450,
	226, 2, 2540, 497, 3, 2, 2, 2, 2541, 2542, 7, 106, 2, 2, 2542, 2547, 5,
	304, 153, 2, 2543, 2544, 7, 141, 2, 2, 2544, 2546, 5, 304, 153, 2, 2545,
	2543, 3, 2, 2, 2, 2546, 2549, 3, 2, 2, 2, 2547, 2545, 3, 2, 2, 2, 2547,
	2548, 3, 2, 2, 2, 2548, 2550, 3, 2, 2, 2, 2549, 2547, 3, 2, 2, 2, 2550,
	2551, 7, 140, 2, 2, 2551, 499, 3, 2, 2, 2, 2552, 2554, 5, 274, 138, 2,
	2553, 2552, 3, 2, 2, 2, 2553, 2554, 3, 2, 2, 2, 2554, 2555, 3, 2, 2, 2,
	2555, 2556, 5, 476, 239, 2, 2556, 2557, 7, 137, 2, 2, 2557, 2558, 5, 194,
	98, 2, 2558, 2559, 7, 140, 2, 2, 2559, 501, 3, 2, 2, 2, 2560, 2562, 7,
	87, 2, 2, 2561, 2560, 3, 2, 2, 2, 2561, 2562, 3, 2, 2, 2, 2562, 2563, 3,
	2, 2, 2, 2563, 2564, 7, 107, 2, 2, 2564, 2565, 5, 234, 118, 2, 2565, 2566,
	7, 147, 2, 2, 2566, 2569, 5, 472, 237, 2, 2567, 2568, 7, 137, 2, 2, 2568,
	2570, 5, 194, 98, 2, 2569, 2567, 3, 2, 2, 2, 2569, 2570, 3, 2, 2, 2, 2570,
	2571, 3, 2, 2, 2, 2571, 2572, 7, 140, 2, 2, 2572, 503, 3, 2, 2, 2, 2573,
	2575, 5, 274, 138, 2, 2574, 2573, 3, 2, 2, 2, 2574, 2575, 3, 2, 2, 2, 2575,
	2576, 3, 2, 2, 2, 2576, 2578, 7, 108, 2, 2, 2577, 2579, 5, 404, 203, 2,
	2578, 2577, 3, 2, 2, 2, 2578, 2579, 3, 2, 2, 2, 2579, 2581, 3, 2, 2, 2,
	2580, 2582, 5, 110, 56, 2, 2581, 2580, 3, 2, 2, 2, 2581, 2582, 3, 2, 2,
	2, 2582, 2584, 3, 2, 2, 2, 2583, 2585, 5, 486, 244, 2, 2584, 2583, 3, 2,
	2, 2, 2584, 2585, 3, 2, 2, 2, 2585, 2586, 3, 2, 2, 2, 2586, 2587, 7, 140,
	2, 2, 2587, 505, 3, 2, 2, 2, 2588, 2593, 5, 508, 255, 2, 2589, 2590, 7,
	141, 2, 2, 2590, 2592, 5, 508, 255, 2, 2591, 2589, 3, 2, 2, 2, 2592, 2595,
	3, 2, 2, 2, 2593, 2591, 3, 2, 2, 2, 2593, 2594, 3, 2, 2, 2, 2594, 2598,
	3, 2, 2, 2, 2595, 2593, 3, 2, 2, 2, 2596, 2598, 7, 103, 2, 2, 2597, 2588,
	3, 2, 2, 2, 2597, 2596, 3, 2, 2, 2, 2598, 507, 3, 2, 2, 2, 2599, 2602,
	5, 194, 98, 2, 2600, 2601, 7, 6, 2, 2, 2601, 2603, 5, 194, 98, 2, 2602,
	2600, 3, 2, 2, 2, 2602, 2603, 3, 2, 2, 2, 2603, 509, 3, 2, 2, 2, 297, 517,
	521, 527, 537, 547, 556, 561, 568, 572, 577, 589, 592, 599, 605, 609, 613,
	616, 623, 628, 633, 637, 643, 647, 650, 658, 667, 682, 697, 700, 703, 710,
	716, 745, 750, 757, 759, 765, 767, 774, 777, 785, 788, 797, 804, 809, 812,
	818, 829, 837, 841, 845, 850, 858, 863, 876, 883, 891, 894, 903, 906, 909,
	914, 921, 924, 934, 938, 941, 944, 950, 954, 957, 961, 966, 969, 975, 978,
	982, 1000, 1002, 1013, 1016, 1023, 1028, 1033, 1046, 1062, 1067, 1072,
	1077, 1080, 1085, 1095, 1107, 1112, 1131, 1136, 1142, 1149, 1159, 1163,
	1166, 1190, 1195, 1200, 1203, 1206, 1213, 1218, 1227, 1232, 1238, 1242,
	1250, 1256, 1260, 1264, 1274, 1280, 1286, 1293, 1301, 1318, 1326, 1336,
	1340, 1345, 1351, 1359, 1372, 1383, 1390, 1420, 1424, 1437, 1442, 1447,
	1457, 1464, 1471, 1480, 1484, 1491, 1496, 1499, 1504, 1509, 1517, 1531,
	1539, 1547, 1554, 1559, 1566, 1570, 1576, 1580, 1584, 1592, 1597, 1602,
	1608, 1619, 1626, 1635, 1641, 1644, 1651, 1665, 1668, 1674, 1683, 1686,
	1690, 1700, 1707, 1714, 1725, 1732, 1736, 1740, 1746, 1754, 1757, 1760,
	1770, 1773, 1788, 1793, 1802, 1805, 1827, 1832, 1848, 1854, 1879, 1884,
	1898, 1903, 1909, 1917, 1920, 1938, 1943, 1947, 1950, 1957, 1960, 1967,
	1971, 1978, 1988, 1993, 2000, 2005, 2013, 2019, 2028, 2033, 2039, 2044,
	2050, 2055, 2061, 2066, 2070, 2084, 2088, 2114, 2125, 2131, 2146, 2152,
	2158, 2163, 2168, 2178, 2182, 2193, 2198, 2206, 2209, 2213, 2218, 2226,
	2230, 2236, 2246, 2254, 2259, 2264, 2277, 2282, 2287, 2292, 2296, 2304,
	2313, 2317, 2322, 2332, 2355, 2363, 2372, 2375, 2395, 2400, 2407, 2415,
	2418, 2426, 2434, 2445, 2448, 2451, 2457, 2461, 2469, 2475, 2485, 2489,
	2503, 2511, 2520, 2534, 2547, 2553, 2561, 2569, 2574, 2578, 2581, 2584,
	2593, 2597, 2602,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'\n'",
	"'\r'", "", "", "", "'**'", "'=='", "'<='", "'>='", "'=>'", "'/='", "':='",
	"'<>'", "'\"'", "';'", "','", "'&'", "'('", "')'", "'['", "']'", "':'",
	"'*'", "'/'", "'+'", "'-'", "'<'", "'>'", "'='", "'|'", "'.'", "'\\'",
	"", "", "", "", "", "", "'''",
}
var symbolicNames = []string{
	"", "ABS", "ACCESS", "ACROSS", "AFTER", "ALIAS", "ALL", "AND", "ARCHITECTURE",
	"ARRAY", "ASSERT", "ATTRIBUTE", "BEGIN", "BLOCK", "BODY", "BREAK", "BUFFER",
	"BUS", "CASE", "COMPONENT", "CONFIGURATION", "CONSTANT", "DISCONNECT",
	"DOWNTO", "END", "ENTITY", "ELSE", "ELSIF", "EXIT", "FILE", "FOR", "FUNCTION",
	"GENERATE", "GENERIC", "GROUP", "GUARDED", "IF", "IMPURE", "IN", "INERTIAL",
	"INOUT", "IS", "LABEL", "LIBRARY", "LIMIT", "LINKAGE", "LITERAL", "LOOP",
	"MAP", "MOD", "NAND", "NATURE", "NEW", "NEXT", "NOISE", "NOR", "NOT", "NULL",
	"OF", "ON", "OPEN", "OR", "OTHERS", "OUT", "PACKAGE", "PORT", "POSTPONED",
	"PROCESS", "PROCEDURE", "PROCEDURAL", "PURE", "QUANTITY", "RANGE", "REVERSE_RANGE",
	"REJECT", "REM", "RECORD", "REFERENCE", "REGISTER", "REPORT", "RETURN",
	"ROL", "ROR", "SELECT", "SEVERITY", "SHARED", "SIGNAL", "SLA", "SLL", "SPECTRUM",
	"SRA", "SRL", "SUBNATURE", "SUBTYPE", "TERMINAL", "THEN", "THROUGH", "TO",
	"TOLERANCE", "TRANSPORT", "TYPE", "UNAFFECTED", "UNITS", "UNTIL", "USE",
	"VARIABLE", "WAIT", "WITH", "WHEN", "WHILE", "XNOR", "XOR", "BASE_LITERAL",
	"BIT_STRING_LITERAL", "BIT_STRING_LITERAL_BINARY", "BIT_STRING_LITERAL_OCTAL",
	"BIT_STRING_LITERAL_HEX", "REAL_LITERAL", "BASIC_IDENTIFIER", "EXTENDED_IDENTIFIER",
	"LETTER", "COMMENT", "TAB", "SPACE", "NEWLINE", "CR", "CHARACTER_LITERAL",
	"STRING_LITERAL", "OTHER_SPECIAL_CHARACTER", "DOUBLESTAR", "ASSIGN", "LE",
	"GE", "ARROW", "NEQ", "VARASGN", "BOX", "DBLQUOTE", "SEMI", "COMMA", "AMPERSAND",
	"LPAREN", "RPAREN", "LBRACKET", "RBRACKET", "COLON", "MUL", "DIV", "PLUS",
	"MINUS", "LOWERTHAN", "GREATERTHAN", "EQ", "BAR", "DOT", "BACKSLASH", "EXPONENT",
	"HEXDIGIT", "INTEGER", "DIGIT", "BASED_INTEGER", "EXTENDED_DIGIT", "APOSTROPHE",
}

var ruleNames = []string{
	"abstract_literal", "access_type_definition", "across_aspect", "actual_designator",
	"actual_parameter_part", "actual_part", "adding_operator", "aggregate",
	"alias_declaration", "alias_designator", "alias_indication", "allocator",
	"architecture_body", "architecture_declarative_part", "architecture_statement",
	"architecture_statement_part", "array_nature_definition", "array_type_definition",
	"assertion", "assertion_statement", "association_element", "association_list",
	"attribute_declaration", "attribute_designator", "attribute_specification",
	"base_unit_declaration", "binding_indication", "block_configuration", "block_declarative_item",
	"block_declarative_part", "block_header", "block_specification", "block_statement",
	"block_statement_part", "branch_quantity_declaration", "break_element",
	"break_list", "break_selector_clause", "break_statement", "case_statement",
	"case_statement_alternative", "choice", "choices", "component_configuration",
	"component_declaration", "component_instantiation_statement", "component_specification",
	"composite_nature_definition", "composite_type_definition", "concurrent_assertion_statement",
	"concurrent_break_statement", "concurrent_procedure_call_statement", "concurrent_signal_assignment_statement",
	"condition", "condition_clause", "conditional_signal_assignment", "conditional_waveforms",
	"configuration_declaration", "configuration_declarative_item", "configuration_declarative_part",
	"configuration_item", "configuration_specification", "constant_declaration",
	"constrained_array_definition", "constrained_nature_definition", "constraint",
	"context_clause", "context_item", "delay_mechanism", "design_file", "design_unit",
	"designator", "direction", "disconnection_specification", "discrete_range",
	"element_association", "element_declaration", "element_subnature_definition",
	"element_subtype_definition", "entity_aspect", "entity_class", "entity_class_entry",
	"entity_class_entry_list", "entity_declaration", "entity_declarative_item",
	"entity_declarative_part", "entity_designator", "entity_header", "entity_name_list",
	"entity_specification", "entity_statement", "entity_statement_part", "entity_tag",
	"enumeration_literal", "enumeration_type_definition", "exit_statement",
	"expression", "factor", "file_declaration", "file_logical_name", "file_open_information",
	"file_type_definition", "formal_parameter_list", "formal_part", "free_quantity_declaration",
	"generate_statement", "generation_scheme", "generic_clause", "generic_list",
	"generic_map_aspect", "group_constituent", "group_constituent_list", "group_declaration",
	"group_template_declaration", "guarded_signal_specification", "identifier",
	"identifier_list", "if_statement", "index_constraint", "index_specification",
	"index_subtype_definition", "instantiated_unit", "instantiation_list",
	"interface_constant_declaration", "interface_declaration", "interface_element",
	"interface_file_declaration", "interface_signal_list", "interface_port_list",
	"interface_list", "interface_quantity_declaration", "interface_port_declaration",
	"interface_signal_declaration", "interface_terminal_declaration", "interface_variable_declaration",
	"iteration_scheme", "label_colon", "library_clause", "library_unit", "literal",
	"logical_name", "logical_name_list", "logical_operator", "loop_statement",
	"signal_mode", "multiplying_operator", "name", "name_part", "name_attribute_part",
	"name_function_call_or_indexed_part", "name_slice_part", "selected_name",
	"nature_declaration", "nature_definition", "nature_element_declaration",
	"next_statement", "numeric_literal", "object_declaration", "opts", "package_body",
	"package_body_declarative_item", "package_body_declarative_part", "package_declaration",
	"package_declarative_item", "package_declarative_part", "parameter_specification",
	"physical_literal", "physical_type_definition", "port_clause", "port_list",
	"port_map_aspect", "primary", "primary_unit", "procedural_declarative_item",
	"procedural_declarative_part", "procedural_statement_part", "procedure_call",
	"procedure_call_statement", "process_declarative_item", "process_declarative_part",
	"process_statement", "process_statement_part", "qualified_expression",
	"quantity_declaration", "quantity_list", "quantity_specification", "range_decl",
	"explicit_range", "range_constraint", "record_nature_definition", "record_type_definition",
	"relation", "relational_operator", "report_statement", "return_statement",
	"scalar_nature_definition", "scalar_type_definition", "secondary_unit",
	"secondary_unit_declaration", "selected_signal_assignment", "selected_waveforms",
	"sensitivity_clause", "sensitivity_list", "sequence_of_statements", "sequential_statement",
	"shift_expression", "shift_operator", "signal_assignment_statement", "signal_declaration",
	"signal_kind", "signal_list", "signature", "simple_expression", "simple_simultaneous_statement",
	"simultaneous_alternative", "simultaneous_case_statement", "simultaneous_if_statement",
	"simultaneous_procedural_statement", "simultaneous_statement", "simultaneous_statement_part",
	"source_aspect", "source_quantity_declaration", "step_limit_specification",
	"subnature_declaration", "subnature_indication", "subprogram_body", "subprogram_declaration",
	"subprogram_declarative_item", "subprogram_declarative_part", "subprogram_kind",
	"subprogram_specification", "procedure_specification", "function_specification",
	"subprogram_statement_part", "subtype_declaration", "subtype_indication",
	"suffix", "target", "term", "terminal_aspect", "terminal_declaration",
	"through_aspect", "timeout_clause", "tolerance_aspect", "type_declaration",
	"type_definition", "unconstrained_array_definition", "unconstrained_nature_definition",
	"use_clause", "variable_assignment_statement", "variable_declaration",
	"wait_statement", "waveform", "waveform_element",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type vhdlParser struct {
	*antlr.BaseParser
}

func NewvhdlParser(input antlr.TokenStream) *vhdlParser {
	this := new(vhdlParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "vhdl.g4"

	return this
}

// vhdlParser tokens.
const (
	vhdlParserEOF                       = antlr.TokenEOF
	vhdlParserABS                       = 1
	vhdlParserACCESS                    = 2
	vhdlParserACROSS                    = 3
	vhdlParserAFTER                     = 4
	vhdlParserALIAS                     = 5
	vhdlParserALL                       = 6
	vhdlParserAND                       = 7
	vhdlParserARCHITECTURE              = 8
	vhdlParserARRAY                     = 9
	vhdlParserASSERT                    = 10
	vhdlParserATTRIBUTE                 = 11
	vhdlParserBEGIN                     = 12
	vhdlParserBLOCK                     = 13
	vhdlParserBODY                      = 14
	vhdlParserBREAK                     = 15
	vhdlParserBUFFER                    = 16
	vhdlParserBUS                       = 17
	vhdlParserCASE                      = 18
	vhdlParserCOMPONENT                 = 19
	vhdlParserCONFIGURATION             = 20
	vhdlParserCONSTANT                  = 21
	vhdlParserDISCONNECT                = 22
	vhdlParserDOWNTO                    = 23
	vhdlParserEND                       = 24
	vhdlParserENTITY                    = 25
	vhdlParserELSE                      = 26
	vhdlParserELSIF                     = 27
	vhdlParserEXIT                      = 28
	vhdlParserFILE                      = 29
	vhdlParserFOR                       = 30
	vhdlParserFUNCTION                  = 31
	vhdlParserGENERATE                  = 32
	vhdlParserGENERIC                   = 33
	vhdlParserGROUP                     = 34
	vhdlParserGUARDED                   = 35
	vhdlParserIF                        = 36
	vhdlParserIMPURE                    = 37
	vhdlParserIN                        = 38
	vhdlParserINERTIAL                  = 39
	vhdlParserINOUT                     = 40
	vhdlParserIS                        = 41
	vhdlParserLABEL                     = 42
	vhdlParserLIBRARY                   = 43
	vhdlParserLIMIT                     = 44
	vhdlParserLINKAGE                   = 45
	vhdlParserLITERAL                   = 46
	vhdlParserLOOP                      = 47
	vhdlParserMAP                       = 48
	vhdlParserMOD                       = 49
	vhdlParserNAND                      = 50
	vhdlParserNATURE                    = 51
	vhdlParserNEW                       = 52
	vhdlParserNEXT                      = 53
	vhdlParserNOISE                     = 54
	vhdlParserNOR                       = 55
	vhdlParserNOT                       = 56
	vhdlParserNULL                      = 57
	vhdlParserOF                        = 58
	vhdlParserON                        = 59
	vhdlParserOPEN                      = 60
	vhdlParserOR                        = 61
	vhdlParserOTHERS                    = 62
	vhdlParserOUT                       = 63
	vhdlParserPACKAGE                   = 64
	vhdlParserPORT                      = 65
	vhdlParserPOSTPONED                 = 66
	vhdlParserPROCESS                   = 67
	vhdlParserPROCEDURE                 = 68
	vhdlParserPROCEDURAL                = 69
	vhdlParserPURE                      = 70
	vhdlParserQUANTITY                  = 71
	vhdlParserRANGE                     = 72
	vhdlParserREVERSE_RANGE             = 73
	vhdlParserREJECT                    = 74
	vhdlParserREM                       = 75
	vhdlParserRECORD                    = 76
	vhdlParserREFERENCE                 = 77
	vhdlParserREGISTER                  = 78
	vhdlParserREPORT                    = 79
	vhdlParserRETURN                    = 80
	vhdlParserROL                       = 81
	vhdlParserROR                       = 82
	vhdlParserSELECT                    = 83
	vhdlParserSEVERITY                  = 84
	vhdlParserSHARED                    = 85
	vhdlParserSIGNAL                    = 86
	vhdlParserSLA                       = 87
	vhdlParserSLL                       = 88
	vhdlParserSPECTRUM                  = 89
	vhdlParserSRA                       = 90
	vhdlParserSRL                       = 91
	vhdlParserSUBNATURE                 = 92
	vhdlParserSUBTYPE                   = 93
	vhdlParserTERMINAL                  = 94
	vhdlParserTHEN                      = 95
	vhdlParserTHROUGH                   = 96
	vhdlParserTO                        = 97
	vhdlParserTOLERANCE                 = 98
	vhdlParserTRANSPORT                 = 99
	vhdlParserTYPE                      = 100
	vhdlParserUNAFFECTED                = 101
	vhdlParserUNITS                     = 102
	vhdlParserUNTIL                     = 103
	vhdlParserUSE                       = 104
	vhdlParserVARIABLE                  = 105
	vhdlParserWAIT                      = 106
	vhdlParserWITH                      = 107
	vhdlParserWHEN                      = 108
	vhdlParserWHILE                     = 109
	vhdlParserXNOR                      = 110
	vhdlParserXOR                       = 111
	vhdlParserBASE_LITERAL              = 112
	vhdlParserBIT_STRING_LITERAL        = 113
	vhdlParserBIT_STRING_LITERAL_BINARY = 114
	vhdlParserBIT_STRING_LITERAL_OCTAL  = 115
	vhdlParserBIT_STRING_LITERAL_HEX    = 116
	vhdlParserREAL_LITERAL              = 117
	vhdlParserBASIC_IDENTIFIER          = 118
	vhdlParserEXTENDED_IDENTIFIER       = 119
	vhdlParserLETTER                    = 120
	vhdlParserCOMMENT                   = 121
	vhdlParserTAB                       = 122
	vhdlParserSPACE                     = 123
	vhdlParserNEWLINE                   = 124
	vhdlParserCR                        = 125
	vhdlParserCHARACTER_LITERAL         = 126
	vhdlParserSTRING_LITERAL            = 127
	vhdlParserOTHER_SPECIAL_CHARACTER   = 128
	vhdlParserDOUBLESTAR                = 129
	vhdlParserASSIGN                    = 130
	vhdlParserLE                        = 131
	vhdlParserGE                        = 132
	vhdlParserARROW                     = 133
	vhdlParserNEQ                       = 134
	vhdlParserVARASGN                   = 135
	vhdlParserBOX                       = 136
	vhdlParserDBLQUOTE                  = 137
	vhdlParserSEMI                      = 138
	vhdlParserCOMMA                     = 139
	vhdlParserAMPERSAND                 = 140
	vhdlParserLPAREN                    = 141
	vhdlParserRPAREN                    = 142
	vhdlParserLBRACKET                  = 143
	vhdlParserRBRACKET                  = 144
	vhdlParserCOLON                     = 145
	vhdlParserMUL                       = 146
	vhdlParserDIV                       = 147
	vhdlParserPLUS                      = 148
	vhdlParserMINUS                     = 149
	vhdlParserLOWERTHAN                 = 150
	vhdlParserGREATERTHAN               = 151
	vhdlParserEQ                        = 152
	vhdlParserBAR                       = 153
	vhdlParserDOT                       = 154
	vhdlParserBACKSLASH                 = 155
	vhdlParserEXPONENT                  = 156
	vhdlParserHEXDIGIT                  = 157
	vhdlParserINTEGER                   = 158
	vhdlParserDIGIT                     = 159
	vhdlParserBASED_INTEGER             = 160
	vhdlParserEXTENDED_DIGIT            = 161
	vhdlParserAPOSTROPHE                = 162
)

// vhdlParser rules.
const (
	vhdlParserRULE_abstract_literal                       = 0
	vhdlParserRULE_access_type_definition                 = 1
	vhdlParserRULE_across_aspect                          = 2
	vhdlParserRULE_actual_designator                      = 3
	vhdlParserRULE_actual_parameter_part                  = 4
	vhdlParserRULE_actual_part                            = 5
	vhdlParserRULE_adding_operator                        = 6
	vhdlParserRULE_aggregate                              = 7
	vhdlParserRULE_alias_declaration                      = 8
	vhdlParserRULE_alias_designator                       = 9
	vhdlParserRULE_alias_indication                       = 10
	vhdlParserRULE_allocator                              = 11
	vhdlParserRULE_architecture_body                      = 12
	vhdlParserRULE_architecture_declarative_part          = 13
	vhdlParserRULE_architecture_statement                 = 14
	vhdlParserRULE_architecture_statement_part            = 15
	vhdlParserRULE_array_nature_definition                = 16
	vhdlParserRULE_array_type_definition                  = 17
	vhdlParserRULE_assertion                              = 18
	vhdlParserRULE_assertion_statement                    = 19
	vhdlParserRULE_association_element                    = 20
	vhdlParserRULE_association_list                       = 21
	vhdlParserRULE_attribute_declaration                  = 22
	vhdlParserRULE_attribute_designator                   = 23
	vhdlParserRULE_attribute_specification                = 24
	vhdlParserRULE_base_unit_declaration                  = 25
	vhdlParserRULE_binding_indication                     = 26
	vhdlParserRULE_block_configuration                    = 27
	vhdlParserRULE_block_declarative_item                 = 28
	vhdlParserRULE_block_declarative_part                 = 29
	vhdlParserRULE_block_header                           = 30
	vhdlParserRULE_block_specification                    = 31
	vhdlParserRULE_block_statement                        = 32
	vhdlParserRULE_block_statement_part                   = 33
	vhdlParserRULE_branch_quantity_declaration            = 34
	vhdlParserRULE_break_element                          = 35
	vhdlParserRULE_break_list                             = 36
	vhdlParserRULE_break_selector_clause                  = 37
	vhdlParserRULE_break_statement                        = 38
	vhdlParserRULE_case_statement                         = 39
	vhdlParserRULE_case_statement_alternative             = 40
	vhdlParserRULE_choice                                 = 41
	vhdlParserRULE_choices                                = 42
	vhdlParserRULE_component_configuration                = 43
	vhdlParserRULE_component_declaration                  = 44
	vhdlParserRULE_component_instantiation_statement      = 45
	vhdlParserRULE_component_specification                = 46
	vhdlParserRULE_composite_nature_definition            = 47
	vhdlParserRULE_composite_type_definition              = 48
	vhdlParserRULE_concurrent_assertion_statement         = 49
	vhdlParserRULE_concurrent_break_statement             = 50
	vhdlParserRULE_concurrent_procedure_call_statement    = 51
	vhdlParserRULE_concurrent_signal_assignment_statement = 52
	vhdlParserRULE_condition                              = 53
	vhdlParserRULE_condition_clause                       = 54
	vhdlParserRULE_conditional_signal_assignment          = 55
	vhdlParserRULE_conditional_waveforms                  = 56
	vhdlParserRULE_configuration_declaration              = 57
	vhdlParserRULE_configuration_declarative_item         = 58
	vhdlParserRULE_configuration_declarative_part         = 59
	vhdlParserRULE_configuration_item                     = 60
	vhdlParserRULE_configuration_specification            = 61
	vhdlParserRULE_constant_declaration                   = 62
	vhdlParserRULE_constrained_array_definition           = 63
	vhdlParserRULE_constrained_nature_definition          = 64
	vhdlParserRULE_constraint                             = 65
	vhdlParserRULE_context_clause                         = 66
	vhdlParserRULE_context_item                           = 67
	vhdlParserRULE_delay_mechanism                        = 68
	vhdlParserRULE_design_file                            = 69
	vhdlParserRULE_design_unit                            = 70
	vhdlParserRULE_designator                             = 71
	vhdlParserRULE_direction                              = 72
	vhdlParserRULE_disconnection_specification            = 73
	vhdlParserRULE_discrete_range                         = 74
	vhdlParserRULE_element_association                    = 75
	vhdlParserRULE_element_declaration                    = 76
	vhdlParserRULE_element_subnature_definition           = 77
	vhdlParserRULE_element_subtype_definition             = 78
	vhdlParserRULE_entity_aspect                          = 79
	vhdlParserRULE_entity_class                           = 80
	vhdlParserRULE_entity_class_entry                     = 81
	vhdlParserRULE_entity_class_entry_list                = 82
	vhdlParserRULE_entity_declaration                     = 83
	vhdlParserRULE_entity_declarative_item                = 84
	vhdlParserRULE_entity_declarative_part                = 85
	vhdlParserRULE_entity_designator                      = 86
	vhdlParserRULE_entity_header                          = 87
	vhdlParserRULE_entity_name_list                       = 88
	vhdlParserRULE_entity_specification                   = 89
	vhdlParserRULE_entity_statement                       = 90
	vhdlParserRULE_entity_statement_part                  = 91
	vhdlParserRULE_entity_tag                             = 92
	vhdlParserRULE_enumeration_literal                    = 93
	vhdlParserRULE_enumeration_type_definition            = 94
	vhdlParserRULE_exit_statement                         = 95
	vhdlParserRULE_expression                             = 96
	vhdlParserRULE_factor                                 = 97
	vhdlParserRULE_file_declaration                       = 98
	vhdlParserRULE_file_logical_name                      = 99
	vhdlParserRULE_file_open_information                  = 100
	vhdlParserRULE_file_type_definition                   = 101
	vhdlParserRULE_formal_parameter_list                  = 102
	vhdlParserRULE_formal_part                            = 103
	vhdlParserRULE_free_quantity_declaration              = 104
	vhdlParserRULE_generate_statement                     = 105
	vhdlParserRULE_generation_scheme                      = 106
	vhdlParserRULE_generic_clause                         = 107
	vhdlParserRULE_generic_list                           = 108
	vhdlParserRULE_generic_map_aspect                     = 109
	vhdlParserRULE_group_constituent                      = 110
	vhdlParserRULE_group_constituent_list                 = 111
	vhdlParserRULE_group_declaration                      = 112
	vhdlParserRULE_group_template_declaration             = 113
	vhdlParserRULE_guarded_signal_specification           = 114
	vhdlParserRULE_identifier                             = 115
	vhdlParserRULE_identifier_list                        = 116
	vhdlParserRULE_if_statement                           = 117
	vhdlParserRULE_index_constraint                       = 118
	vhdlParserRULE_index_specification                    = 119
	vhdlParserRULE_index_subtype_definition               = 120
	vhdlParserRULE_instantiated_unit                      = 121
	vhdlParserRULE_instantiation_list                     = 122
	vhdlParserRULE_interface_constant_declaration         = 123
	vhdlParserRULE_interface_declaration                  = 124
	vhdlParserRULE_interface_element                      = 125
	vhdlParserRULE_interface_file_declaration             = 126
	vhdlParserRULE_interface_signal_list                  = 127
	vhdlParserRULE_interface_port_list                    = 128
	vhdlParserRULE_interface_list                         = 129
	vhdlParserRULE_interface_quantity_declaration         = 130
	vhdlParserRULE_interface_port_declaration             = 131
	vhdlParserRULE_interface_signal_declaration           = 132
	vhdlParserRULE_interface_terminal_declaration         = 133
	vhdlParserRULE_interface_variable_declaration         = 134
	vhdlParserRULE_iteration_scheme                       = 135
	vhdlParserRULE_label_colon                            = 136
	vhdlParserRULE_library_clause                         = 137
	vhdlParserRULE_library_unit                           = 138
	vhdlParserRULE_literal                                = 139
	vhdlParserRULE_logical_name                           = 140
	vhdlParserRULE_logical_name_list                      = 141
	vhdlParserRULE_logical_operator                       = 142
	vhdlParserRULE_loop_statement                         = 143
	vhdlParserRULE_signal_mode                            = 144
	vhdlParserRULE_multiplying_operator                   = 145
	vhdlParserRULE_name                                   = 146
	vhdlParserRULE_name_part                              = 147
	vhdlParserRULE_name_attribute_part                    = 148
	vhdlParserRULE_name_function_call_or_indexed_part     = 149
	vhdlParserRULE_name_slice_part                        = 150
	vhdlParserRULE_selected_name                          = 151
	vhdlParserRULE_nature_declaration                     = 152
	vhdlParserRULE_nature_definition                      = 153
	vhdlParserRULE_nature_element_declaration             = 154
	vhdlParserRULE_next_statement                         = 155
	vhdlParserRULE_numeric_literal                        = 156
	vhdlParserRULE_object_declaration                     = 157
	vhdlParserRULE_opts                                   = 158
	vhdlParserRULE_package_body                           = 159
	vhdlParserRULE_package_body_declarative_item          = 160
	vhdlParserRULE_package_body_declarative_part          = 161
	vhdlParserRULE_package_declaration                    = 162
	vhdlParserRULE_package_declarative_item               = 163
	vhdlParserRULE_package_declarative_part               = 164
	vhdlParserRULE_parameter_specification                = 165
	vhdlParserRULE_physical_literal                       = 166
	vhdlParserRULE_physical_type_definition               = 167
	vhdlParserRULE_port_clause                            = 168
	vhdlParserRULE_port_list                              = 169
	vhdlParserRULE_port_map_aspect                        = 170
	vhdlParserRULE_primary                                = 171
	vhdlParserRULE_primary_unit                           = 172
	vhdlParserRULE_procedural_declarative_item            = 173
	vhdlParserRULE_procedural_declarative_part            = 174
	vhdlParserRULE_procedural_statement_part              = 175
	vhdlParserRULE_procedure_call                         = 176
	vhdlParserRULE_procedure_call_statement               = 177
	vhdlParserRULE_process_declarative_item               = 178
	vhdlParserRULE_process_declarative_part               = 179
	vhdlParserRULE_process_statement                      = 180
	vhdlParserRULE_process_statement_part                 = 181
	vhdlParserRULE_qualified_expression                   = 182
	vhdlParserRULE_quantity_declaration                   = 183
	vhdlParserRULE_quantity_list                          = 184
	vhdlParserRULE_quantity_specification                 = 185
	vhdlParserRULE_range_decl                             = 186
	vhdlParserRULE_explicit_range                         = 187
	vhdlParserRULE_range_constraint                       = 188
	vhdlParserRULE_record_nature_definition               = 189
	vhdlParserRULE_record_type_definition                 = 190
	vhdlParserRULE_relation                               = 191
	vhdlParserRULE_relational_operator                    = 192
	vhdlParserRULE_report_statement                       = 193
	vhdlParserRULE_return_statement                       = 194
	vhdlParserRULE_scalar_nature_definition               = 195
	vhdlParserRULE_scalar_type_definition                 = 196
	vhdlParserRULE_secondary_unit                         = 197
	vhdlParserRULE_secondary_unit_declaration             = 198
	vhdlParserRULE_selected_signal_assignment             = 199
	vhdlParserRULE_selected_waveforms                     = 200
	vhdlParserRULE_sensitivity_clause                     = 201
	vhdlParserRULE_sensitivity_list                       = 202
	vhdlParserRULE_sequence_of_statements                 = 203
	vhdlParserRULE_sequential_statement                   = 204
	vhdlParserRULE_shift_expression                       = 205
	vhdlParserRULE_shift_operator                         = 206
	vhdlParserRULE_signal_assignment_statement            = 207
	vhdlParserRULE_signal_declaration                     = 208
	vhdlParserRULE_signal_kind                            = 209
	vhdlParserRULE_signal_list                            = 210
	vhdlParserRULE_signature                              = 211
	vhdlParserRULE_simple_expression                      = 212
	vhdlParserRULE_simple_simultaneous_statement          = 213
	vhdlParserRULE_simultaneous_alternative               = 214
	vhdlParserRULE_simultaneous_case_statement            = 215
	vhdlParserRULE_simultaneous_if_statement              = 216
	vhdlParserRULE_simultaneous_procedural_statement      = 217
	vhdlParserRULE_simultaneous_statement                 = 218
	vhdlParserRULE_simultaneous_statement_part            = 219
	vhdlParserRULE_source_aspect                          = 220
	vhdlParserRULE_source_quantity_declaration            = 221
	vhdlParserRULE_step_limit_specification               = 222
	vhdlParserRULE_subnature_declaration                  = 223
	vhdlParserRULE_subnature_indication                   = 224
	vhdlParserRULE_subprogram_body                        = 225
	vhdlParserRULE_subprogram_declaration                 = 226
	vhdlParserRULE_subprogram_declarative_item            = 227
	vhdlParserRULE_subprogram_declarative_part            = 228
	vhdlParserRULE_subprogram_kind                        = 229
	vhdlParserRULE_subprogram_specification               = 230
	vhdlParserRULE_procedure_specification                = 231
	vhdlParserRULE_function_specification                 = 232
	vhdlParserRULE_subprogram_statement_part              = 233
	vhdlParserRULE_subtype_declaration                    = 234
	vhdlParserRULE_subtype_indication                     = 235
	vhdlParserRULE_suffix                                 = 236
	vhdlParserRULE_target                                 = 237
	vhdlParserRULE_term                                   = 238
	vhdlParserRULE_terminal_aspect                        = 239
	vhdlParserRULE_terminal_declaration                   = 240
	vhdlParserRULE_through_aspect                         = 241
	vhdlParserRULE_timeout_clause                         = 242
	vhdlParserRULE_tolerance_aspect                       = 243
	vhdlParserRULE_type_declaration                       = 244
	vhdlParserRULE_type_definition                        = 245
	vhdlParserRULE_unconstrained_array_definition         = 246
	vhdlParserRULE_unconstrained_nature_definition        = 247
	vhdlParserRULE_use_clause                             = 248
	vhdlParserRULE_variable_assignment_statement          = 249
	vhdlParserRULE_variable_declaration                   = 250
	vhdlParserRULE_wait_statement                         = 251
	vhdlParserRULE_waveform                               = 252
	vhdlParserRULE_waveform_element                       = 253
)

// IAbstract_literalContext is an interface to support dynamic dispatch.
type IAbstract_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstract_literalContext differentiates from other interfaces.
	IsAbstract_literalContext()
}

type Abstract_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstract_literalContext() *Abstract_literalContext {
	var p = new(Abstract_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_abstract_literal
	return p
}

func (*Abstract_literalContext) IsAbstract_literalContext() {}

func NewAbstract_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Abstract_literalContext {
	var p = new(Abstract_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_abstract_literal

	return p
}

func (s *Abstract_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Abstract_literalContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(vhdlParserINTEGER, 0)
}

func (s *Abstract_literalContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserREAL_LITERAL, 0)
}

func (s *Abstract_literalContext) BASE_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserBASE_LITERAL, 0)
}

func (s *Abstract_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Abstract_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Abstract_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAbstract_literal(s)
	}
}

func (s *Abstract_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAbstract_literal(s)
	}
}

func (s *Abstract_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitAbstract_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Abstract_literal() (localctx IAbstract_literalContext) {
	localctx = NewAbstract_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, vhdlParserRULE_abstract_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(508)
	_la = p.GetTokenStream().LA(1)

	if !(_la == vhdlParserBASE_LITERAL || _la == vhdlParserREAL_LITERAL || _la == vhdlParserINTEGER) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IAccess_type_definitionContext is an interface to support dynamic dispatch.
type IAccess_type_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAccess_type_definitionContext differentiates from other interfaces.
	IsAccess_type_definitionContext()
}

type Access_type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccess_type_definitionContext() *Access_type_definitionContext {
	var p = new(Access_type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_access_type_definition
	return p
}

func (*Access_type_definitionContext) IsAccess_type_definitionContext() {}

func NewAccess_type_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Access_type_definitionContext {
	var p = new(Access_type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_access_type_definition

	return p
}

func (s *Access_type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Access_type_definitionContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(vhdlParserACCESS, 0)
}

func (s *Access_type_definitionContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Access_type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Access_type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Access_type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAccess_type_definition(s)
	}
}

func (s *Access_type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAccess_type_definition(s)
	}
}

func (s *Access_type_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitAccess_type_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Access_type_definition() (localctx IAccess_type_definitionContext) {
	localctx = NewAccess_type_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, vhdlParserRULE_access_type_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(510)
		p.Match(vhdlParserACCESS)
	}
	{
		p.SetState(511)
		p.Subtype_indication()
	}

	return localctx
}

// IAcross_aspectContext is an interface to support dynamic dispatch.
type IAcross_aspectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcross_aspectContext differentiates from other interfaces.
	IsAcross_aspectContext()
}

type Across_aspectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcross_aspectContext() *Across_aspectContext {
	var p = new(Across_aspectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_across_aspect
	return p
}

func (*Across_aspectContext) IsAcross_aspectContext() {}

func NewAcross_aspectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Across_aspectContext {
	var p = new(Across_aspectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_across_aspect

	return p
}

func (s *Across_aspectContext) GetParser() antlr.Parser { return s.parser }

func (s *Across_aspectContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Across_aspectContext) ACROSS() antlr.TerminalNode {
	return s.GetToken(vhdlParserACROSS, 0)
}

func (s *Across_aspectContext) Tolerance_aspect() ITolerance_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITolerance_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITolerance_aspectContext)
}

func (s *Across_aspectContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Across_aspectContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Across_aspectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Across_aspectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Across_aspectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAcross_aspect(s)
	}
}

func (s *Across_aspectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAcross_aspect(s)
	}
}

func (s *Across_aspectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitAcross_aspect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Across_aspect() (localctx IAcross_aspectContext) {
	localctx = NewAcross_aspectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, vhdlParserRULE_across_aspect)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(513)
		p.Identifier_list()
	}
	p.SetState(515)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserTOLERANCE {
		{
			p.SetState(514)
			p.Tolerance_aspect()
		}

	}
	p.SetState(519)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(517)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(518)
			p.Expression()
		}

	}
	{
		p.SetState(521)
		p.Match(vhdlParserACROSS)
	}

	return localctx
}

// IActual_designatorContext is an interface to support dynamic dispatch.
type IActual_designatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActual_designatorContext differentiates from other interfaces.
	IsActual_designatorContext()
}

type Actual_designatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActual_designatorContext() *Actual_designatorContext {
	var p = new(Actual_designatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_actual_designator
	return p
}

func (*Actual_designatorContext) IsActual_designatorContext() {}

func NewActual_designatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Actual_designatorContext {
	var p = new(Actual_designatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_actual_designator

	return p
}

func (s *Actual_designatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Actual_designatorContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Actual_designatorContext) OPEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserOPEN, 0)
}

func (s *Actual_designatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Actual_designatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Actual_designatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterActual_designator(s)
	}
}

func (s *Actual_designatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitActual_designator(s)
	}
}

func (s *Actual_designatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitActual_designator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Actual_designator() (localctx IActual_designatorContext) {
	localctx = NewActual_designatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, vhdlParserRULE_actual_designator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(525)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserABS, vhdlParserNEW, vhdlParserNOT, vhdlParserNULL, vhdlParserBASE_LITERAL, vhdlParserBIT_STRING_LITERAL, vhdlParserREAL_LITERAL, vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserCHARACTER_LITERAL, vhdlParserSTRING_LITERAL, vhdlParserLPAREN, vhdlParserPLUS, vhdlParserMINUS, vhdlParserINTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(523)
			p.Expression()
		}

	case vhdlParserOPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(524)
			p.Match(vhdlParserOPEN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IActual_parameter_partContext is an interface to support dynamic dispatch.
type IActual_parameter_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActual_parameter_partContext differentiates from other interfaces.
	IsActual_parameter_partContext()
}

type Actual_parameter_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActual_parameter_partContext() *Actual_parameter_partContext {
	var p = new(Actual_parameter_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_actual_parameter_part
	return p
}

func (*Actual_parameter_partContext) IsActual_parameter_partContext() {}

func NewActual_parameter_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Actual_parameter_partContext {
	var p = new(Actual_parameter_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_actual_parameter_part

	return p
}

func (s *Actual_parameter_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Actual_parameter_partContext) Association_list() IAssociation_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssociation_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssociation_listContext)
}

func (s *Actual_parameter_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Actual_parameter_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Actual_parameter_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterActual_parameter_part(s)
	}
}

func (s *Actual_parameter_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitActual_parameter_part(s)
	}
}

func (s *Actual_parameter_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitActual_parameter_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Actual_parameter_part() (localctx IActual_parameter_partContext) {
	localctx = NewActual_parameter_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, vhdlParserRULE_actual_parameter_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(527)
		p.Association_list()
	}

	return localctx
}

// IActual_partContext is an interface to support dynamic dispatch.
type IActual_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActual_partContext differentiates from other interfaces.
	IsActual_partContext()
}

type Actual_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActual_partContext() *Actual_partContext {
	var p = new(Actual_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_actual_part
	return p
}

func (*Actual_partContext) IsActual_partContext() {}

func NewActual_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Actual_partContext {
	var p = new(Actual_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_actual_part

	return p
}

func (s *Actual_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Actual_partContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Actual_partContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Actual_partContext) Actual_designator() IActual_designatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActual_designatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActual_designatorContext)
}

func (s *Actual_partContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Actual_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Actual_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Actual_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterActual_part(s)
	}
}

func (s *Actual_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitActual_part(s)
	}
}

func (s *Actual_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitActual_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Actual_part() (localctx IActual_partContext) {
	localctx = NewActual_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, vhdlParserRULE_actual_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(535)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(529)
			p.Name()
		}
		{
			p.SetState(530)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(531)
			p.Actual_designator()
		}
		{
			p.SetState(532)
			p.Match(vhdlParserRPAREN)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(534)
			p.Actual_designator()
		}

	}

	return localctx
}

// IAdding_operatorContext is an interface to support dynamic dispatch.
type IAdding_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdding_operatorContext differentiates from other interfaces.
	IsAdding_operatorContext()
}

type Adding_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdding_operatorContext() *Adding_operatorContext {
	var p = new(Adding_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_adding_operator
	return p
}

func (*Adding_operatorContext) IsAdding_operatorContext() {}

func NewAdding_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Adding_operatorContext {
	var p = new(Adding_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_adding_operator

	return p
}

func (s *Adding_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Adding_operatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(vhdlParserPLUS, 0)
}

func (s *Adding_operatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(vhdlParserMINUS, 0)
}

func (s *Adding_operatorContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(vhdlParserAMPERSAND, 0)
}

func (s *Adding_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Adding_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Adding_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAdding_operator(s)
	}
}

func (s *Adding_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAdding_operator(s)
	}
}

func (s *Adding_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitAdding_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Adding_operator() (localctx IAdding_operatorContext) {
	localctx = NewAdding_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, vhdlParserRULE_adding_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(537)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(vhdlParserAMPERSAND-140))|(1<<(vhdlParserPLUS-140))|(1<<(vhdlParserMINUS-140)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IAggregateContext is an interface to support dynamic dispatch.
type IAggregateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAggregateContext differentiates from other interfaces.
	IsAggregateContext()
}

type AggregateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregateContext() *AggregateContext {
	var p = new(AggregateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_aggregate
	return p
}

func (*AggregateContext) IsAggregateContext() {}

func NewAggregateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregateContext {
	var p = new(AggregateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_aggregate

	return p
}

func (s *AggregateContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregateContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *AggregateContext) AllElement_association() []IElement_associationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElement_associationContext)(nil)).Elem())
	var tst = make([]IElement_associationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElement_associationContext)
		}
	}

	return tst
}

func (s *AggregateContext) Element_association(i int) IElement_associationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElement_associationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElement_associationContext)
}

func (s *AggregateContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *AggregateContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *AggregateContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *AggregateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAggregate(s)
	}
}

func (s *AggregateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAggregate(s)
	}
}

func (s *AggregateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitAggregate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Aggregate() (localctx IAggregateContext) {
	localctx = NewAggregateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, vhdlParserRULE_aggregate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(539)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(540)
		p.Element_association()
	}
	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(541)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(542)
			p.Element_association()
		}

		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(548)
		p.Match(vhdlParserRPAREN)
	}

	return localctx
}

// IAlias_declarationContext is an interface to support dynamic dispatch.
type IAlias_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlias_declarationContext differentiates from other interfaces.
	IsAlias_declarationContext()
}

type Alias_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlias_declarationContext() *Alias_declarationContext {
	var p = new(Alias_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_alias_declaration
	return p
}

func (*Alias_declarationContext) IsAlias_declarationContext() {}

func NewAlias_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alias_declarationContext {
	var p = new(Alias_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_alias_declaration

	return p
}

func (s *Alias_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Alias_declarationContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(vhdlParserALIAS, 0)
}

func (s *Alias_declarationContext) Alias_designator() IAlias_designatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_designatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_designatorContext)
}

func (s *Alias_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Alias_declarationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Alias_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Alias_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Alias_declarationContext) Alias_indication() IAlias_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_indicationContext)
}

func (s *Alias_declarationContext) Signature() ISignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignatureContext)
}

func (s *Alias_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alias_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alias_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAlias_declaration(s)
	}
}

func (s *Alias_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAlias_declaration(s)
	}
}

func (s *Alias_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitAlias_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Alias_declaration() (localctx IAlias_declarationContext) {
	localctx = NewAlias_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, vhdlParserRULE_alias_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(550)
		p.Match(vhdlParserALIAS)
	}
	{
		p.SetState(551)
		p.Alias_designator()
	}
	p.SetState(554)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserCOLON {
		{
			p.SetState(552)
			p.Match(vhdlParserCOLON)
		}
		{
			p.SetState(553)
			p.Alias_indication()
		}

	}
	{
		p.SetState(556)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(557)
		p.Name()
	}
	p.SetState(559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserLBRACKET {
		{
			p.SetState(558)
			p.Signature()
		}

	}
	{
		p.SetState(561)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IAlias_designatorContext is an interface to support dynamic dispatch.
type IAlias_designatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlias_designatorContext differentiates from other interfaces.
	IsAlias_designatorContext()
}

type Alias_designatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlias_designatorContext() *Alias_designatorContext {
	var p = new(Alias_designatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_alias_designator
	return p
}

func (*Alias_designatorContext) IsAlias_designatorContext() {}

func NewAlias_designatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alias_designatorContext {
	var p = new(Alias_designatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_alias_designator

	return p
}

func (s *Alias_designatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Alias_designatorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Alias_designatorContext) CHARACTER_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserCHARACTER_LITERAL, 0)
}

func (s *Alias_designatorContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSTRING_LITERAL, 0)
}

func (s *Alias_designatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alias_designatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alias_designatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAlias_designator(s)
	}
}

func (s *Alias_designatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAlias_designator(s)
	}
}

func (s *Alias_designatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitAlias_designator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Alias_designator() (localctx IAlias_designatorContext) {
	localctx = NewAlias_designatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, vhdlParserRULE_alias_designator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(566)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(563)
			p.Identifier()
		}

	case vhdlParserCHARACTER_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(564)
			p.Match(vhdlParserCHARACTER_LITERAL)
		}

	case vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(565)
			p.Match(vhdlParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlias_indicationContext is an interface to support dynamic dispatch.
type IAlias_indicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlias_indicationContext differentiates from other interfaces.
	IsAlias_indicationContext()
}

type Alias_indicationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlias_indicationContext() *Alias_indicationContext {
	var p = new(Alias_indicationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_alias_indication
	return p
}

func (*Alias_indicationContext) IsAlias_indicationContext() {}

func NewAlias_indicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alias_indicationContext {
	var p = new(Alias_indicationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_alias_indication

	return p
}

func (s *Alias_indicationContext) GetParser() antlr.Parser { return s.parser }

func (s *Alias_indicationContext) Subnature_indication() ISubnature_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_indicationContext)
}

func (s *Alias_indicationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Alias_indicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alias_indicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alias_indicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAlias_indication(s)
	}
}

func (s *Alias_indicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAlias_indication(s)
	}
}

func (s *Alias_indicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitAlias_indication(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Alias_indication() (localctx IAlias_indicationContext) {
	localctx = NewAlias_indicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, vhdlParserRULE_alias_indication)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(570)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(568)
			p.Subnature_indication()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(569)
			p.Subtype_indication()
		}

	}

	return localctx
}

// IAllocatorContext is an interface to support dynamic dispatch.
type IAllocatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAllocatorContext differentiates from other interfaces.
	IsAllocatorContext()
}

type AllocatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllocatorContext() *AllocatorContext {
	var p = new(AllocatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_allocator
	return p
}

func (*AllocatorContext) IsAllocatorContext() {}

func NewAllocatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllocatorContext {
	var p = new(AllocatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_allocator

	return p
}

func (s *AllocatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AllocatorContext) NEW() antlr.TerminalNode {
	return s.GetToken(vhdlParserNEW, 0)
}

func (s *AllocatorContext) Qualified_expression() IQualified_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualified_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualified_expressionContext)
}

func (s *AllocatorContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *AllocatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllocatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AllocatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAllocator(s)
	}
}

func (s *AllocatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAllocator(s)
	}
}

func (s *AllocatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitAllocator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Allocator() (localctx IAllocatorContext) {
	localctx = NewAllocatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, vhdlParserRULE_allocator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(572)
		p.Match(vhdlParserNEW)
	}
	p.SetState(575)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(573)
			p.Qualified_expression()
		}

	case 2:
		{
			p.SetState(574)
			p.Subtype_indication()
		}

	}

	return localctx
}

// IArchitecture_bodyContext is an interface to support dynamic dispatch.
type IArchitecture_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArchitecture_bodyContext differentiates from other interfaces.
	IsArchitecture_bodyContext()
}

type Architecture_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArchitecture_bodyContext() *Architecture_bodyContext {
	var p = new(Architecture_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_architecture_body
	return p
}

func (*Architecture_bodyContext) IsArchitecture_bodyContext() {}

func NewArchitecture_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Architecture_bodyContext {
	var p = new(Architecture_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_architecture_body

	return p
}

func (s *Architecture_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Architecture_bodyContext) AllARCHITECTURE() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserARCHITECTURE)
}

func (s *Architecture_bodyContext) ARCHITECTURE(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserARCHITECTURE, i)
}

func (s *Architecture_bodyContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Architecture_bodyContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Architecture_bodyContext) OF() antlr.TerminalNode {
	return s.GetToken(vhdlParserOF, 0)
}

func (s *Architecture_bodyContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Architecture_bodyContext) Architecture_declarative_part() IArchitecture_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArchitecture_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArchitecture_declarative_partContext)
}

func (s *Architecture_bodyContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(vhdlParserBEGIN, 0)
}

func (s *Architecture_bodyContext) Architecture_statement_part() IArchitecture_statement_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArchitecture_statement_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArchitecture_statement_partContext)
}

func (s *Architecture_bodyContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Architecture_bodyContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Architecture_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Architecture_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Architecture_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterArchitecture_body(s)
	}
}

func (s *Architecture_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitArchitecture_body(s)
	}
}

func (s *Architecture_bodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitArchitecture_body(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Architecture_body() (localctx IArchitecture_bodyContext) {
	localctx = NewArchitecture_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, vhdlParserRULE_architecture_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(577)
		p.Match(vhdlParserARCHITECTURE)
	}
	{
		p.SetState(578)
		p.Identifier()
	}
	{
		p.SetState(579)
		p.Match(vhdlParserOF)
	}
	{
		p.SetState(580)
		p.Identifier()
	}
	{
		p.SetState(581)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(582)
		p.Architecture_declarative_part()
	}
	{
		p.SetState(583)
		p.Match(vhdlParserBEGIN)
	}
	{
		p.SetState(584)
		p.Architecture_statement_part()
	}
	{
		p.SetState(585)
		p.Match(vhdlParserEND)
	}
	p.SetState(587)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserARCHITECTURE {
		{
			p.SetState(586)
			p.Match(vhdlParserARCHITECTURE)
		}

	}
	p.SetState(590)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(589)
			p.Identifier()
		}

	}
	{
		p.SetState(592)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IArchitecture_declarative_partContext is an interface to support dynamic dispatch.
type IArchitecture_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArchitecture_declarative_partContext differentiates from other interfaces.
	IsArchitecture_declarative_partContext()
}

type Architecture_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArchitecture_declarative_partContext() *Architecture_declarative_partContext {
	var p = new(Architecture_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_architecture_declarative_part
	return p
}

func (*Architecture_declarative_partContext) IsArchitecture_declarative_partContext() {}

func NewArchitecture_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Architecture_declarative_partContext {
	var p = new(Architecture_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_architecture_declarative_part

	return p
}

func (s *Architecture_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Architecture_declarative_partContext) AllBlock_declarative_item() []IBlock_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_declarative_itemContext)(nil)).Elem())
	var tst = make([]IBlock_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_declarative_itemContext)
		}
	}

	return tst
}

func (s *Architecture_declarative_partContext) Block_declarative_item(i int) IBlock_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_declarative_itemContext)
}

func (s *Architecture_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Architecture_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Architecture_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterArchitecture_declarative_part(s)
	}
}

func (s *Architecture_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitArchitecture_declarative_part(s)
	}
}

func (s *Architecture_declarative_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitArchitecture_declarative_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Architecture_declarative_part() (localctx IArchitecture_declarative_partContext) {
	localctx = NewArchitecture_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, vhdlParserRULE_architecture_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserCOMPONENT)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserDISCONNECT)|(1<<vhdlParserFILE)|(1<<vhdlParserFOR)|(1<<vhdlParserFUNCTION))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(vhdlParserGROUP-34))|(1<<(vhdlParserIMPURE-34))|(1<<(vhdlParserLIMIT-34))|(1<<(vhdlParserNATURE-34)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserQUANTITY-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSIGNAL-68))|(1<<(vhdlParserSUBNATURE-68))|(1<<(vhdlParserSUBTYPE-68))|(1<<(vhdlParserTERMINAL-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		{
			p.SetState(594)
			p.Block_declarative_item()
		}

		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArchitecture_statementContext is an interface to support dynamic dispatch.
type IArchitecture_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArchitecture_statementContext differentiates from other interfaces.
	IsArchitecture_statementContext()
}

type Architecture_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArchitecture_statementContext() *Architecture_statementContext {
	var p = new(Architecture_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_architecture_statement
	return p
}

func (*Architecture_statementContext) IsArchitecture_statementContext() {}

func NewArchitecture_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Architecture_statementContext {
	var p = new(Architecture_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_architecture_statement

	return p
}

func (s *Architecture_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Architecture_statementContext) Block_statement() IBlock_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_statementContext)
}

func (s *Architecture_statementContext) Process_statement() IProcess_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcess_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcess_statementContext)
}

func (s *Architecture_statementContext) Concurrent_procedure_call_statement() IConcurrent_procedure_call_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcurrent_procedure_call_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcurrent_procedure_call_statementContext)
}

func (s *Architecture_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Architecture_statementContext) Concurrent_assertion_statement() IConcurrent_assertion_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcurrent_assertion_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcurrent_assertion_statementContext)
}

func (s *Architecture_statementContext) Concurrent_signal_assignment_statement() IConcurrent_signal_assignment_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcurrent_signal_assignment_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcurrent_signal_assignment_statementContext)
}

func (s *Architecture_statementContext) POSTPONED() antlr.TerminalNode {
	return s.GetToken(vhdlParserPOSTPONED, 0)
}

func (s *Architecture_statementContext) Component_instantiation_statement() IComponent_instantiation_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_instantiation_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_instantiation_statementContext)
}

func (s *Architecture_statementContext) Generate_statement() IGenerate_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_statementContext)
}

func (s *Architecture_statementContext) Concurrent_break_statement() IConcurrent_break_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcurrent_break_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcurrent_break_statementContext)
}

func (s *Architecture_statementContext) Simultaneous_statement() ISimultaneous_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimultaneous_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimultaneous_statementContext)
}

func (s *Architecture_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Architecture_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Architecture_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterArchitecture_statement(s)
	}
}

func (s *Architecture_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitArchitecture_statement(s)
	}
}

func (s *Architecture_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitArchitecture_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Architecture_statement() (localctx IArchitecture_statementContext) {
	localctx = NewArchitecture_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, vhdlParserRULE_architecture_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(621)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(600)
			p.Block_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(601)
			p.Process_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(603)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(602)
				p.Label_colon()
			}

		}
		{
			p.SetState(605)
			p.Concurrent_procedure_call_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(607)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(606)
				p.Label_colon()
			}

		}
		{
			p.SetState(609)
			p.Concurrent_assertion_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(611)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(610)
				p.Label_colon()
			}

		}
		p.SetState(614)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(613)
				p.Match(vhdlParserPOSTPONED)
			}

		}
		{
			p.SetState(616)
			p.Concurrent_signal_assignment_statement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(617)
			p.Component_instantiation_statement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(618)
			p.Generate_statement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(619)
			p.Concurrent_break_statement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(620)
			p.Simultaneous_statement()
		}

	}

	return localctx
}

// IArchitecture_statement_partContext is an interface to support dynamic dispatch.
type IArchitecture_statement_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArchitecture_statement_partContext differentiates from other interfaces.
	IsArchitecture_statement_partContext()
}

type Architecture_statement_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArchitecture_statement_partContext() *Architecture_statement_partContext {
	var p = new(Architecture_statement_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_architecture_statement_part
	return p
}

func (*Architecture_statement_partContext) IsArchitecture_statement_partContext() {}

func NewArchitecture_statement_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Architecture_statement_partContext {
	var p = new(Architecture_statement_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_architecture_statement_part

	return p
}

func (s *Architecture_statement_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Architecture_statement_partContext) AllArchitecture_statement() []IArchitecture_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArchitecture_statementContext)(nil)).Elem())
	var tst = make([]IArchitecture_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArchitecture_statementContext)
		}
	}

	return tst
}

func (s *Architecture_statement_partContext) Architecture_statement(i int) IArchitecture_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArchitecture_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArchitecture_statementContext)
}

func (s *Architecture_statement_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Architecture_statement_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Architecture_statement_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterArchitecture_statement_part(s)
	}
}

func (s *Architecture_statement_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitArchitecture_statement_part(s)
	}
}

func (s *Architecture_statement_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitArchitecture_statement_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Architecture_statement_part() (localctx IArchitecture_statement_partContext) {
	localctx = NewArchitecture_statement_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, vhdlParserRULE_architecture_statement_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserABS)|(1<<vhdlParserASSERT)|(1<<vhdlParserBREAK)|(1<<vhdlParserCASE))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(vhdlParserIF-36))|(1<<(vhdlParserNEW-36))|(1<<(vhdlParserNOT-36))|(1<<(vhdlParserNULL-36))|(1<<(vhdlParserPOSTPONED-36))|(1<<(vhdlParserPROCESS-36)))) != 0) || _la == vhdlParserPROCEDURAL || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(vhdlParserWITH-107))|(1<<(vhdlParserBASE_LITERAL-107))|(1<<(vhdlParserBIT_STRING_LITERAL-107))|(1<<(vhdlParserREAL_LITERAL-107))|(1<<(vhdlParserBASIC_IDENTIFIER-107))|(1<<(vhdlParserEXTENDED_IDENTIFIER-107))|(1<<(vhdlParserCHARACTER_LITERAL-107))|(1<<(vhdlParserSTRING_LITERAL-107)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(vhdlParserLPAREN-141))|(1<<(vhdlParserPLUS-141))|(1<<(vhdlParserMINUS-141))|(1<<(vhdlParserINTEGER-141)))) != 0) {
		{
			p.SetState(623)
			p.Architecture_statement()
		}

		p.SetState(628)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArray_nature_definitionContext is an interface to support dynamic dispatch.
type IArray_nature_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_nature_definitionContext differentiates from other interfaces.
	IsArray_nature_definitionContext()
}

type Array_nature_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_nature_definitionContext() *Array_nature_definitionContext {
	var p = new(Array_nature_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_array_nature_definition
	return p
}

func (*Array_nature_definitionContext) IsArray_nature_definitionContext() {}

func NewArray_nature_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_nature_definitionContext {
	var p = new(Array_nature_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_array_nature_definition

	return p
}

func (s *Array_nature_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_nature_definitionContext) Unconstrained_nature_definition() IUnconstrained_nature_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnconstrained_nature_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnconstrained_nature_definitionContext)
}

func (s *Array_nature_definitionContext) Constrained_nature_definition() IConstrained_nature_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstrained_nature_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstrained_nature_definitionContext)
}

func (s *Array_nature_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_nature_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_nature_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterArray_nature_definition(s)
	}
}

func (s *Array_nature_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitArray_nature_definition(s)
	}
}

func (s *Array_nature_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitArray_nature_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Array_nature_definition() (localctx IArray_nature_definitionContext) {
	localctx = NewArray_nature_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, vhdlParserRULE_array_nature_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(631)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(629)
			p.Unconstrained_nature_definition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(630)
			p.Constrained_nature_definition()
		}

	}

	return localctx
}

// IArray_type_definitionContext is an interface to support dynamic dispatch.
type IArray_type_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_type_definitionContext differentiates from other interfaces.
	IsArray_type_definitionContext()
}

type Array_type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_type_definitionContext() *Array_type_definitionContext {
	var p = new(Array_type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_array_type_definition
	return p
}

func (*Array_type_definitionContext) IsArray_type_definitionContext() {}

func NewArray_type_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_type_definitionContext {
	var p = new(Array_type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_array_type_definition

	return p
}

func (s *Array_type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_type_definitionContext) Unconstrained_array_definition() IUnconstrained_array_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnconstrained_array_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnconstrained_array_definitionContext)
}

func (s *Array_type_definitionContext) Constrained_array_definition() IConstrained_array_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstrained_array_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstrained_array_definitionContext)
}

func (s *Array_type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterArray_type_definition(s)
	}
}

func (s *Array_type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitArray_type_definition(s)
	}
}

func (s *Array_type_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitArray_type_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Array_type_definition() (localctx IArray_type_definitionContext) {
	localctx = NewArray_type_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, vhdlParserRULE_array_type_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(633)
			p.Unconstrained_array_definition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(634)
			p.Constrained_array_definition()
		}

	}

	return localctx
}

// IAssertionContext is an interface to support dynamic dispatch.
type IAssertionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssertionContext differentiates from other interfaces.
	IsAssertionContext()
}

type AssertionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssertionContext() *AssertionContext {
	var p = new(AssertionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_assertion
	return p
}

func (*AssertionContext) IsAssertionContext() {}

func NewAssertionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssertionContext {
	var p = new(AssertionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_assertion

	return p
}

func (s *AssertionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssertionContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(vhdlParserASSERT, 0)
}

func (s *AssertionContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *AssertionContext) REPORT() antlr.TerminalNode {
	return s.GetToken(vhdlParserREPORT, 0)
}

func (s *AssertionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *AssertionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssertionContext) SEVERITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEVERITY, 0)
}

func (s *AssertionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssertionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAssertion(s)
	}
}

func (s *AssertionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAssertion(s)
	}
}

func (s *AssertionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitAssertion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Assertion() (localctx IAssertionContext) {
	localctx = NewAssertionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, vhdlParserRULE_assertion)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(637)
		p.Match(vhdlParserASSERT)
	}
	{
		p.SetState(638)
		p.Condition()
	}
	p.SetState(641)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserREPORT {
		{
			p.SetState(639)
			p.Match(vhdlParserREPORT)
		}
		{
			p.SetState(640)
			p.Expression()
		}

	}
	p.SetState(645)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserSEVERITY {
		{
			p.SetState(643)
			p.Match(vhdlParserSEVERITY)
		}
		{
			p.SetState(644)
			p.Expression()
		}

	}

	return localctx
}

// IAssertion_statementContext is an interface to support dynamic dispatch.
type IAssertion_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssertion_statementContext differentiates from other interfaces.
	IsAssertion_statementContext()
}

type Assertion_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssertion_statementContext() *Assertion_statementContext {
	var p = new(Assertion_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_assertion_statement
	return p
}

func (*Assertion_statementContext) IsAssertion_statementContext() {}

func NewAssertion_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assertion_statementContext {
	var p = new(Assertion_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_assertion_statement

	return p
}

func (s *Assertion_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Assertion_statementContext) Assertion() IAssertionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertionContext)
}

func (s *Assertion_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Assertion_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Assertion_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assertion_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assertion_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAssertion_statement(s)
	}
}

func (s *Assertion_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAssertion_statement(s)
	}
}

func (s *Assertion_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitAssertion_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Assertion_statement() (localctx IAssertion_statementContext) {
	localctx = NewAssertion_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, vhdlParserRULE_assertion_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(647)
			p.Label_colon()
		}

	}
	{
		p.SetState(650)
		p.Assertion()
	}
	{
		p.SetState(651)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IAssociation_elementContext is an interface to support dynamic dispatch.
type IAssociation_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssociation_elementContext differentiates from other interfaces.
	IsAssociation_elementContext()
}

type Association_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssociation_elementContext() *Association_elementContext {
	var p = new(Association_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_association_element
	return p
}

func (*Association_elementContext) IsAssociation_elementContext() {}

func NewAssociation_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Association_elementContext {
	var p = new(Association_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_association_element

	return p
}

func (s *Association_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Association_elementContext) Actual_part() IActual_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActual_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActual_partContext)
}

func (s *Association_elementContext) Formal_part() IFormal_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormal_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormal_partContext)
}

func (s *Association_elementContext) ARROW() antlr.TerminalNode {
	return s.GetToken(vhdlParserARROW, 0)
}

func (s *Association_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Association_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Association_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAssociation_element(s)
	}
}

func (s *Association_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAssociation_element(s)
	}
}

func (s *Association_elementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitAssociation_element(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Association_element() (localctx IAssociation_elementContext) {
	localctx = NewAssociation_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, vhdlParserRULE_association_element)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(656)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(653)
			p.Formal_part()
		}
		{
			p.SetState(654)
			p.Match(vhdlParserARROW)
		}

	}
	{
		p.SetState(658)
		p.Actual_part()
	}

	return localctx
}

// IAssociation_listContext is an interface to support dynamic dispatch.
type IAssociation_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssociation_listContext differentiates from other interfaces.
	IsAssociation_listContext()
}

type Association_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssociation_listContext() *Association_listContext {
	var p = new(Association_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_association_list
	return p
}

func (*Association_listContext) IsAssociation_listContext() {}

func NewAssociation_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Association_listContext {
	var p = new(Association_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_association_list

	return p
}

func (s *Association_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Association_listContext) AllAssociation_element() []IAssociation_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssociation_elementContext)(nil)).Elem())
	var tst = make([]IAssociation_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssociation_elementContext)
		}
	}

	return tst
}

func (s *Association_listContext) Association_element(i int) IAssociation_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssociation_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssociation_elementContext)
}

func (s *Association_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Association_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Association_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Association_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Association_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAssociation_list(s)
	}
}

func (s *Association_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAssociation_list(s)
	}
}

func (s *Association_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitAssociation_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Association_list() (localctx IAssociation_listContext) {
	localctx = NewAssociation_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, vhdlParserRULE_association_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(660)
		p.Association_element()
	}
	p.SetState(665)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(661)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(662)
			p.Association_element()
		}

		p.SetState(667)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAttribute_declarationContext is an interface to support dynamic dispatch.
type IAttribute_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_declarationContext differentiates from other interfaces.
	IsAttribute_declarationContext()
}

type Attribute_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_declarationContext() *Attribute_declarationContext {
	var p = new(Attribute_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_attribute_declaration
	return p
}

func (*Attribute_declarationContext) IsAttribute_declarationContext() {}

func NewAttribute_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_declarationContext {
	var p = new(Attribute_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_attribute_declaration

	return p
}

func (s *Attribute_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_declarationContext) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(vhdlParserATTRIBUTE, 0)
}

func (s *Attribute_declarationContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Attribute_declarationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Attribute_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Attribute_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAttribute_declaration(s)
	}
}

func (s *Attribute_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAttribute_declaration(s)
	}
}

func (s *Attribute_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitAttribute_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Attribute_declaration() (localctx IAttribute_declarationContext) {
	localctx = NewAttribute_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, vhdlParserRULE_attribute_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(668)
		p.Match(vhdlParserATTRIBUTE)
	}
	{
		p.SetState(669)
		p.Label_colon()
	}
	{
		p.SetState(670)
		p.Name()
	}
	{
		p.SetState(671)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IAttribute_designatorContext is an interface to support dynamic dispatch.
type IAttribute_designatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_designatorContext differentiates from other interfaces.
	IsAttribute_designatorContext()
}

type Attribute_designatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_designatorContext() *Attribute_designatorContext {
	var p = new(Attribute_designatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_attribute_designator
	return p
}

func (*Attribute_designatorContext) IsAttribute_designatorContext() {}

func NewAttribute_designatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_designatorContext {
	var p = new(Attribute_designatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_attribute_designator

	return p
}

func (s *Attribute_designatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_designatorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Attribute_designatorContext) RANGE() antlr.TerminalNode {
	return s.GetToken(vhdlParserRANGE, 0)
}

func (s *Attribute_designatorContext) REVERSE_RANGE() antlr.TerminalNode {
	return s.GetToken(vhdlParserREVERSE_RANGE, 0)
}

func (s *Attribute_designatorContext) ACROSS() antlr.TerminalNode {
	return s.GetToken(vhdlParserACROSS, 0)
}

func (s *Attribute_designatorContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(vhdlParserTHROUGH, 0)
}

func (s *Attribute_designatorContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(vhdlParserREFERENCE, 0)
}

func (s *Attribute_designatorContext) TOLERANCE() antlr.TerminalNode {
	return s.GetToken(vhdlParserTOLERANCE, 0)
}

func (s *Attribute_designatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_designatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_designatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAttribute_designator(s)
	}
}

func (s *Attribute_designatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAttribute_designator(s)
	}
}

func (s *Attribute_designatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitAttribute_designator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Attribute_designator() (localctx IAttribute_designatorContext) {
	localctx = NewAttribute_designatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, vhdlParserRULE_attribute_designator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(680)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(673)
			p.Identifier()
		}

	case vhdlParserRANGE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(674)
			p.Match(vhdlParserRANGE)
		}

	case vhdlParserREVERSE_RANGE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(675)
			p.Match(vhdlParserREVERSE_RANGE)
		}

	case vhdlParserACROSS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(676)
			p.Match(vhdlParserACROSS)
		}

	case vhdlParserTHROUGH:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(677)
			p.Match(vhdlParserTHROUGH)
		}

	case vhdlParserREFERENCE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(678)
			p.Match(vhdlParserREFERENCE)
		}

	case vhdlParserTOLERANCE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(679)
			p.Match(vhdlParserTOLERANCE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttribute_specificationContext is an interface to support dynamic dispatch.
type IAttribute_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_specificationContext differentiates from other interfaces.
	IsAttribute_specificationContext()
}

type Attribute_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_specificationContext() *Attribute_specificationContext {
	var p = new(Attribute_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_attribute_specification
	return p
}

func (*Attribute_specificationContext) IsAttribute_specificationContext() {}

func NewAttribute_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_specificationContext {
	var p = new(Attribute_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_attribute_specification

	return p
}

func (s *Attribute_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_specificationContext) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(vhdlParserATTRIBUTE, 0)
}

func (s *Attribute_specificationContext) Attribute_designator() IAttribute_designatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_designatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_designatorContext)
}

func (s *Attribute_specificationContext) OF() antlr.TerminalNode {
	return s.GetToken(vhdlParserOF, 0)
}

func (s *Attribute_specificationContext) Entity_specification() IEntity_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_specificationContext)
}

func (s *Attribute_specificationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Attribute_specificationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Attribute_specificationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Attribute_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterAttribute_specification(s)
	}
}

func (s *Attribute_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitAttribute_specification(s)
	}
}

func (s *Attribute_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitAttribute_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Attribute_specification() (localctx IAttribute_specificationContext) {
	localctx = NewAttribute_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, vhdlParserRULE_attribute_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(682)
		p.Match(vhdlParserATTRIBUTE)
	}
	{
		p.SetState(683)
		p.Attribute_designator()
	}
	{
		p.SetState(684)
		p.Match(vhdlParserOF)
	}
	{
		p.SetState(685)
		p.Entity_specification()
	}
	{
		p.SetState(686)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(687)
		p.Expression()
	}
	{
		p.SetState(688)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IBase_unit_declarationContext is an interface to support dynamic dispatch.
type IBase_unit_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBase_unit_declarationContext differentiates from other interfaces.
	IsBase_unit_declarationContext()
}

type Base_unit_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_unit_declarationContext() *Base_unit_declarationContext {
	var p = new(Base_unit_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_base_unit_declaration
	return p
}

func (*Base_unit_declarationContext) IsBase_unit_declarationContext() {}

func NewBase_unit_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_unit_declarationContext {
	var p = new(Base_unit_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_base_unit_declaration

	return p
}

func (s *Base_unit_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_unit_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Base_unit_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Base_unit_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_unit_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Base_unit_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBase_unit_declaration(s)
	}
}

func (s *Base_unit_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBase_unit_declaration(s)
	}
}

func (s *Base_unit_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitBase_unit_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Base_unit_declaration() (localctx IBase_unit_declarationContext) {
	localctx = NewBase_unit_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, vhdlParserRULE_base_unit_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(690)
		p.Identifier()
	}
	{
		p.SetState(691)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IBinding_indicationContext is an interface to support dynamic dispatch.
type IBinding_indicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinding_indicationContext differentiates from other interfaces.
	IsBinding_indicationContext()
}

type Binding_indicationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinding_indicationContext() *Binding_indicationContext {
	var p = new(Binding_indicationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_binding_indication
	return p
}

func (*Binding_indicationContext) IsBinding_indicationContext() {}

func NewBinding_indicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Binding_indicationContext {
	var p = new(Binding_indicationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_binding_indication

	return p
}

func (s *Binding_indicationContext) GetParser() antlr.Parser { return s.parser }

func (s *Binding_indicationContext) USE() antlr.TerminalNode {
	return s.GetToken(vhdlParserUSE, 0)
}

func (s *Binding_indicationContext) Entity_aspect() IEntity_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_aspectContext)
}

func (s *Binding_indicationContext) Generic_map_aspect() IGeneric_map_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneric_map_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneric_map_aspectContext)
}

func (s *Binding_indicationContext) Port_map_aspect() IPort_map_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_map_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_map_aspectContext)
}

func (s *Binding_indicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Binding_indicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Binding_indicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBinding_indication(s)
	}
}

func (s *Binding_indicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBinding_indication(s)
	}
}

func (s *Binding_indicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitBinding_indication(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Binding_indication() (localctx IBinding_indicationContext) {
	localctx = NewBinding_indicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, vhdlParserRULE_binding_indication)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(695)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserUSE {
		{
			p.SetState(693)
			p.Match(vhdlParserUSE)
		}
		{
			p.SetState(694)
			p.Entity_aspect()
		}

	}
	p.SetState(698)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserGENERIC {
		{
			p.SetState(697)
			p.Generic_map_aspect()
		}

	}
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPORT {
		{
			p.SetState(700)
			p.Port_map_aspect()
		}

	}

	return localctx
}

// IBlock_configurationContext is an interface to support dynamic dispatch.
type IBlock_configurationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_configurationContext differentiates from other interfaces.
	IsBlock_configurationContext()
}

type Block_configurationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_configurationContext() *Block_configurationContext {
	var p = new(Block_configurationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_block_configuration
	return p
}

func (*Block_configurationContext) IsBlock_configurationContext() {}

func NewBlock_configurationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_configurationContext {
	var p = new(Block_configurationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_block_configuration

	return p
}

func (s *Block_configurationContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_configurationContext) AllFOR() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserFOR)
}

func (s *Block_configurationContext) FOR(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserFOR, i)
}

func (s *Block_configurationContext) Block_specification() IBlock_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_specificationContext)
}

func (s *Block_configurationContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Block_configurationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Block_configurationContext) AllUse_clause() []IUse_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem())
	var tst = make([]IUse_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUse_clauseContext)
		}
	}

	return tst
}

func (s *Block_configurationContext) Use_clause(i int) IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Block_configurationContext) AllConfiguration_item() []IConfiguration_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConfiguration_itemContext)(nil)).Elem())
	var tst = make([]IConfiguration_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConfiguration_itemContext)
		}
	}

	return tst
}

func (s *Block_configurationContext) Configuration_item(i int) IConfiguration_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfiguration_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConfiguration_itemContext)
}

func (s *Block_configurationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_configurationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_configurationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBlock_configuration(s)
	}
}

func (s *Block_configurationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBlock_configuration(s)
	}
}

func (s *Block_configurationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitBlock_configuration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Block_configuration() (localctx IBlock_configurationContext) {
	localctx = NewBlock_configurationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, vhdlParserRULE_block_configuration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(703)
		p.Match(vhdlParserFOR)
	}
	{
		p.SetState(704)
		p.Block_specification()
	}
	p.SetState(708)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserUSE {
		{
			p.SetState(705)
			p.Use_clause()
		}

		p.SetState(710)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(714)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserFOR {
		{
			p.SetState(711)
			p.Configuration_item()
		}

		p.SetState(716)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(717)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(718)
		p.Match(vhdlParserFOR)
	}
	{
		p.SetState(719)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IBlock_declarative_itemContext is an interface to support dynamic dispatch.
type IBlock_declarative_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_declarative_itemContext differentiates from other interfaces.
	IsBlock_declarative_itemContext()
}

type Block_declarative_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_declarative_itemContext() *Block_declarative_itemContext {
	var p = new(Block_declarative_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_block_declarative_item
	return p
}

func (*Block_declarative_itemContext) IsBlock_declarative_itemContext() {}

func NewBlock_declarative_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_declarative_itemContext {
	var p = new(Block_declarative_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_block_declarative_item

	return p
}

func (s *Block_declarative_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_declarative_itemContext) Subprogram_declaration() ISubprogram_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarationContext)
}

func (s *Block_declarative_itemContext) Subprogram_body() ISubprogram_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_bodyContext)
}

func (s *Block_declarative_itemContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Block_declarative_itemContext) Subtype_declaration() ISubtype_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_declarationContext)
}

func (s *Block_declarative_itemContext) Constant_declaration() IConstant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declarationContext)
}

func (s *Block_declarative_itemContext) Signal_declaration() ISignal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_declarationContext)
}

func (s *Block_declarative_itemContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Block_declarative_itemContext) File_declaration() IFile_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_declarationContext)
}

func (s *Block_declarative_itemContext) Alias_declaration() IAlias_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_declarationContext)
}

func (s *Block_declarative_itemContext) Component_declaration() IComponent_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_declarationContext)
}

func (s *Block_declarative_itemContext) Attribute_declaration() IAttribute_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_declarationContext)
}

func (s *Block_declarative_itemContext) Attribute_specification() IAttribute_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_specificationContext)
}

func (s *Block_declarative_itemContext) Configuration_specification() IConfiguration_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfiguration_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConfiguration_specificationContext)
}

func (s *Block_declarative_itemContext) Disconnection_specification() IDisconnection_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisconnection_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisconnection_specificationContext)
}

func (s *Block_declarative_itemContext) Step_limit_specification() IStep_limit_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStep_limit_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStep_limit_specificationContext)
}

func (s *Block_declarative_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Block_declarative_itemContext) Group_template_declaration() IGroup_template_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_template_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_template_declarationContext)
}

func (s *Block_declarative_itemContext) Group_declaration() IGroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_declarationContext)
}

func (s *Block_declarative_itemContext) Nature_declaration() INature_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INature_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INature_declarationContext)
}

func (s *Block_declarative_itemContext) Subnature_declaration() ISubnature_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_declarationContext)
}

func (s *Block_declarative_itemContext) Quantity_declaration() IQuantity_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantity_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantity_declarationContext)
}

func (s *Block_declarative_itemContext) Terminal_declaration() ITerminal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminal_declarationContext)
}

func (s *Block_declarative_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_declarative_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_declarative_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBlock_declarative_item(s)
	}
}

func (s *Block_declarative_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBlock_declarative_item(s)
	}
}

func (s *Block_declarative_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitBlock_declarative_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Block_declarative_item() (localctx IBlock_declarative_itemContext) {
	localctx = NewBlock_declarative_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, vhdlParserRULE_block_declarative_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(743)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(721)
			p.Subprogram_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(722)
			p.Subprogram_body()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(723)
			p.Type_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(724)
			p.Subtype_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(725)
			p.Constant_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(726)
			p.Signal_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(727)
			p.Variable_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(728)
			p.File_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(729)
			p.Alias_declaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(730)
			p.Component_declaration()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(731)
			p.Attribute_declaration()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(732)
			p.Attribute_specification()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(733)
			p.Configuration_specification()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(734)
			p.Disconnection_specification()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(735)
			p.Step_limit_specification()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(736)
			p.Use_clause()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(737)
			p.Group_template_declaration()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(738)
			p.Group_declaration()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(739)
			p.Nature_declaration()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(740)
			p.Subnature_declaration()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(741)
			p.Quantity_declaration()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(742)
			p.Terminal_declaration()
		}

	}

	return localctx
}

// IBlock_declarative_partContext is an interface to support dynamic dispatch.
type IBlock_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_declarative_partContext differentiates from other interfaces.
	IsBlock_declarative_partContext()
}

type Block_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_declarative_partContext() *Block_declarative_partContext {
	var p = new(Block_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_block_declarative_part
	return p
}

func (*Block_declarative_partContext) IsBlock_declarative_partContext() {}

func NewBlock_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_declarative_partContext {
	var p = new(Block_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_block_declarative_part

	return p
}

func (s *Block_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_declarative_partContext) AllBlock_declarative_item() []IBlock_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_declarative_itemContext)(nil)).Elem())
	var tst = make([]IBlock_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_declarative_itemContext)
		}
	}

	return tst
}

func (s *Block_declarative_partContext) Block_declarative_item(i int) IBlock_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_declarative_itemContext)
}

func (s *Block_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBlock_declarative_part(s)
	}
}

func (s *Block_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBlock_declarative_part(s)
	}
}

func (s *Block_declarative_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitBlock_declarative_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Block_declarative_part() (localctx IBlock_declarative_partContext) {
	localctx = NewBlock_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, vhdlParserRULE_block_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(748)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserCOMPONENT)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserDISCONNECT)|(1<<vhdlParserFILE)|(1<<vhdlParserFOR)|(1<<vhdlParserFUNCTION))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(vhdlParserGROUP-34))|(1<<(vhdlParserIMPURE-34))|(1<<(vhdlParserLIMIT-34))|(1<<(vhdlParserNATURE-34)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserQUANTITY-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSIGNAL-68))|(1<<(vhdlParserSUBNATURE-68))|(1<<(vhdlParserSUBTYPE-68))|(1<<(vhdlParserTERMINAL-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		{
			p.SetState(745)
			p.Block_declarative_item()
		}

		p.SetState(750)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBlock_headerContext is an interface to support dynamic dispatch.
type IBlock_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_headerContext differentiates from other interfaces.
	IsBlock_headerContext()
}

type Block_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_headerContext() *Block_headerContext {
	var p = new(Block_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_block_header
	return p
}

func (*Block_headerContext) IsBlock_headerContext() {}

func NewBlock_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_headerContext {
	var p = new(Block_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_block_header

	return p
}

func (s *Block_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_headerContext) Generic_clause() IGeneric_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneric_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneric_clauseContext)
}

func (s *Block_headerContext) Port_clause() IPort_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_clauseContext)
}

func (s *Block_headerContext) Generic_map_aspect() IGeneric_map_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneric_map_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneric_map_aspectContext)
}

func (s *Block_headerContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserSEMI)
}

func (s *Block_headerContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, i)
}

func (s *Block_headerContext) Port_map_aspect() IPort_map_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_map_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_map_aspectContext)
}

func (s *Block_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBlock_header(s)
	}
}

func (s *Block_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBlock_header(s)
	}
}

func (s *Block_headerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitBlock_header(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Block_header() (localctx IBlock_headerContext) {
	localctx = NewBlock_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, vhdlParserRULE_block_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserGENERIC {
		{
			p.SetState(751)
			p.Generic_clause()
		}
		p.SetState(755)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserGENERIC {
			{
				p.SetState(752)
				p.Generic_map_aspect()
			}
			{
				p.SetState(753)
				p.Match(vhdlParserSEMI)
			}

		}

	}
	p.SetState(765)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPORT {
		{
			p.SetState(759)
			p.Port_clause()
		}
		p.SetState(763)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserPORT {
			{
				p.SetState(760)
				p.Port_map_aspect()
			}
			{
				p.SetState(761)
				p.Match(vhdlParserSEMI)
			}

		}

	}

	return localctx
}

// IBlock_specificationContext is an interface to support dynamic dispatch.
type IBlock_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_specificationContext differentiates from other interfaces.
	IsBlock_specificationContext()
}

type Block_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_specificationContext() *Block_specificationContext {
	var p = new(Block_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_block_specification
	return p
}

func (*Block_specificationContext) IsBlock_specificationContext() {}

func NewBlock_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_specificationContext {
	var p = new(Block_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_block_specification

	return p
}

func (s *Block_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_specificationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Block_specificationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Block_specificationContext) Index_specification() IIndex_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndex_specificationContext)
}

func (s *Block_specificationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Block_specificationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Block_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBlock_specification(s)
	}
}

func (s *Block_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBlock_specification(s)
	}
}

func (s *Block_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitBlock_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Block_specification() (localctx IBlock_specificationContext) {
	localctx = NewBlock_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, vhdlParserRULE_block_specification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(775)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(767)
			p.Identifier()
		}
		p.SetState(772)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserLPAREN {
			{
				p.SetState(768)
				p.Match(vhdlParserLPAREN)
			}
			{
				p.SetState(769)
				p.Index_specification()
			}
			{
				p.SetState(770)
				p.Match(vhdlParserRPAREN)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(774)
			p.Name()
		}

	}

	return localctx
}

// IBlock_statementContext is an interface to support dynamic dispatch.
type IBlock_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_statementContext differentiates from other interfaces.
	IsBlock_statementContext()
}

type Block_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_statementContext() *Block_statementContext {
	var p = new(Block_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_block_statement
	return p
}

func (*Block_statementContext) IsBlock_statementContext() {}

func NewBlock_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_statementContext {
	var p = new(Block_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_block_statement

	return p
}

func (s *Block_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Block_statementContext) AllBLOCK() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserBLOCK)
}

func (s *Block_statementContext) BLOCK(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserBLOCK, i)
}

func (s *Block_statementContext) Block_header() IBlock_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_headerContext)
}

func (s *Block_statementContext) Block_declarative_part() IBlock_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_declarative_partContext)
}

func (s *Block_statementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(vhdlParserBEGIN, 0)
}

func (s *Block_statementContext) Block_statement_part() IBlock_statement_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_statement_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_statement_partContext)
}

func (s *Block_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Block_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Block_statementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Block_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Block_statementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Block_statementContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Block_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Block_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBlock_statement(s)
	}
}

func (s *Block_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBlock_statement(s)
	}
}

func (s *Block_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitBlock_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Block_statement() (localctx IBlock_statementContext) {
	localctx = NewBlock_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, vhdlParserRULE_block_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(777)
		p.Label_colon()
	}
	{
		p.SetState(778)
		p.Match(vhdlParserBLOCK)
	}
	p.SetState(783)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserLPAREN {
		{
			p.SetState(779)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(780)
			p.Expression()
		}
		{
			p.SetState(781)
			p.Match(vhdlParserRPAREN)
		}

	}
	p.SetState(786)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIS {
		{
			p.SetState(785)
			p.Match(vhdlParserIS)
		}

	}
	{
		p.SetState(788)
		p.Block_header()
	}
	{
		p.SetState(789)
		p.Block_declarative_part()
	}
	{
		p.SetState(790)
		p.Match(vhdlParserBEGIN)
	}
	{
		p.SetState(791)
		p.Block_statement_part()
	}
	{
		p.SetState(792)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(793)
		p.Match(vhdlParserBLOCK)
	}
	p.SetState(795)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(794)
			p.Identifier()
		}

	}
	{
		p.SetState(797)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IBlock_statement_partContext is an interface to support dynamic dispatch.
type IBlock_statement_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_statement_partContext differentiates from other interfaces.
	IsBlock_statement_partContext()
}

type Block_statement_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_statement_partContext() *Block_statement_partContext {
	var p = new(Block_statement_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_block_statement_part
	return p
}

func (*Block_statement_partContext) IsBlock_statement_partContext() {}

func NewBlock_statement_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_statement_partContext {
	var p = new(Block_statement_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_block_statement_part

	return p
}

func (s *Block_statement_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_statement_partContext) AllArchitecture_statement() []IArchitecture_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArchitecture_statementContext)(nil)).Elem())
	var tst = make([]IArchitecture_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArchitecture_statementContext)
		}
	}

	return tst
}

func (s *Block_statement_partContext) Architecture_statement(i int) IArchitecture_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArchitecture_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArchitecture_statementContext)
}

func (s *Block_statement_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_statement_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_statement_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBlock_statement_part(s)
	}
}

func (s *Block_statement_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBlock_statement_part(s)
	}
}

func (s *Block_statement_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitBlock_statement_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Block_statement_part() (localctx IBlock_statement_partContext) {
	localctx = NewBlock_statement_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, vhdlParserRULE_block_statement_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(802)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserABS)|(1<<vhdlParserASSERT)|(1<<vhdlParserBREAK)|(1<<vhdlParserCASE))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(vhdlParserIF-36))|(1<<(vhdlParserNEW-36))|(1<<(vhdlParserNOT-36))|(1<<(vhdlParserNULL-36))|(1<<(vhdlParserPOSTPONED-36))|(1<<(vhdlParserPROCESS-36)))) != 0) || _la == vhdlParserPROCEDURAL || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(vhdlParserWITH-107))|(1<<(vhdlParserBASE_LITERAL-107))|(1<<(vhdlParserBIT_STRING_LITERAL-107))|(1<<(vhdlParserREAL_LITERAL-107))|(1<<(vhdlParserBASIC_IDENTIFIER-107))|(1<<(vhdlParserEXTENDED_IDENTIFIER-107))|(1<<(vhdlParserCHARACTER_LITERAL-107))|(1<<(vhdlParserSTRING_LITERAL-107)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(vhdlParserLPAREN-141))|(1<<(vhdlParserPLUS-141))|(1<<(vhdlParserMINUS-141))|(1<<(vhdlParserINTEGER-141)))) != 0) {
		{
			p.SetState(799)
			p.Architecture_statement()
		}

		p.SetState(804)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBranch_quantity_declarationContext is an interface to support dynamic dispatch.
type IBranch_quantity_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBranch_quantity_declarationContext differentiates from other interfaces.
	IsBranch_quantity_declarationContext()
}

type Branch_quantity_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBranch_quantity_declarationContext() *Branch_quantity_declarationContext {
	var p = new(Branch_quantity_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_branch_quantity_declaration
	return p
}

func (*Branch_quantity_declarationContext) IsBranch_quantity_declarationContext() {}

func NewBranch_quantity_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Branch_quantity_declarationContext {
	var p = new(Branch_quantity_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_branch_quantity_declaration

	return p
}

func (s *Branch_quantity_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Branch_quantity_declarationContext) QUANTITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserQUANTITY, 0)
}

func (s *Branch_quantity_declarationContext) Terminal_aspect() ITerminal_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminal_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminal_aspectContext)
}

func (s *Branch_quantity_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Branch_quantity_declarationContext) Across_aspect() IAcross_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcross_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcross_aspectContext)
}

func (s *Branch_quantity_declarationContext) Through_aspect() IThrough_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThrough_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThrough_aspectContext)
}

func (s *Branch_quantity_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Branch_quantity_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Branch_quantity_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBranch_quantity_declaration(s)
	}
}

func (s *Branch_quantity_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBranch_quantity_declaration(s)
	}
}

func (s *Branch_quantity_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitBranch_quantity_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Branch_quantity_declaration() (localctx IBranch_quantity_declarationContext) {
	localctx = NewBranch_quantity_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, vhdlParserRULE_branch_quantity_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(805)
		p.Match(vhdlParserQUANTITY)
	}
	p.SetState(807)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(806)
			p.Across_aspect()
		}

	}
	p.SetState(810)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(809)
			p.Through_aspect()
		}

	}
	{
		p.SetState(812)
		p.Terminal_aspect()
	}
	{
		p.SetState(813)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IBreak_elementContext is an interface to support dynamic dispatch.
type IBreak_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreak_elementContext differentiates from other interfaces.
	IsBreak_elementContext()
}

type Break_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_elementContext() *Break_elementContext {
	var p = new(Break_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_break_element
	return p
}

func (*Break_elementContext) IsBreak_elementContext() {}

func NewBreak_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_elementContext {
	var p = new(Break_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_break_element

	return p
}

func (s *Break_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_elementContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Break_elementContext) ARROW() antlr.TerminalNode {
	return s.GetToken(vhdlParserARROW, 0)
}

func (s *Break_elementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Break_elementContext) Break_selector_clause() IBreak_selector_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_selector_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreak_selector_clauseContext)
}

func (s *Break_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Break_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBreak_element(s)
	}
}

func (s *Break_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBreak_element(s)
	}
}

func (s *Break_elementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitBreak_element(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Break_element() (localctx IBreak_elementContext) {
	localctx = NewBreak_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, vhdlParserRULE_break_element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(816)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserFOR {
		{
			p.SetState(815)
			p.Break_selector_clause()
		}

	}
	{
		p.SetState(818)
		p.Name()
	}
	{
		p.SetState(819)
		p.Match(vhdlParserARROW)
	}
	{
		p.SetState(820)
		p.Expression()
	}

	return localctx
}

// IBreak_listContext is an interface to support dynamic dispatch.
type IBreak_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreak_listContext differentiates from other interfaces.
	IsBreak_listContext()
}

type Break_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_listContext() *Break_listContext {
	var p = new(Break_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_break_list
	return p
}

func (*Break_listContext) IsBreak_listContext() {}

func NewBreak_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_listContext {
	var p = new(Break_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_break_list

	return p
}

func (s *Break_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_listContext) AllBreak_element() []IBreak_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBreak_elementContext)(nil)).Elem())
	var tst = make([]IBreak_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBreak_elementContext)
		}
	}

	return tst
}

func (s *Break_listContext) Break_element(i int) IBreak_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBreak_elementContext)
}

func (s *Break_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Break_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Break_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Break_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBreak_list(s)
	}
}

func (s *Break_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBreak_list(s)
	}
}

func (s *Break_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitBreak_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Break_list() (localctx IBreak_listContext) {
	localctx = NewBreak_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, vhdlParserRULE_break_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(822)
		p.Break_element()
	}
	p.SetState(827)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(823)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(824)
			p.Break_element()
		}

		p.SetState(829)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBreak_selector_clauseContext is an interface to support dynamic dispatch.
type IBreak_selector_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreak_selector_clauseContext differentiates from other interfaces.
	IsBreak_selector_clauseContext()
}

type Break_selector_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_selector_clauseContext() *Break_selector_clauseContext {
	var p = new(Break_selector_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_break_selector_clause
	return p
}

func (*Break_selector_clauseContext) IsBreak_selector_clauseContext() {}

func NewBreak_selector_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_selector_clauseContext {
	var p = new(Break_selector_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_break_selector_clause

	return p
}

func (s *Break_selector_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_selector_clauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(vhdlParserFOR, 0)
}

func (s *Break_selector_clauseContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Break_selector_clauseContext) USE() antlr.TerminalNode {
	return s.GetToken(vhdlParserUSE, 0)
}

func (s *Break_selector_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_selector_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Break_selector_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBreak_selector_clause(s)
	}
}

func (s *Break_selector_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBreak_selector_clause(s)
	}
}

func (s *Break_selector_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitBreak_selector_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Break_selector_clause() (localctx IBreak_selector_clauseContext) {
	localctx = NewBreak_selector_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, vhdlParserRULE_break_selector_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(830)
		p.Match(vhdlParserFOR)
	}
	{
		p.SetState(831)
		p.Name()
	}
	{
		p.SetState(832)
		p.Match(vhdlParserUSE)
	}

	return localctx
}

// IBreak_statementContext is an interface to support dynamic dispatch.
type IBreak_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreak_statementContext differentiates from other interfaces.
	IsBreak_statementContext()
}

type Break_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_statementContext() *Break_statementContext {
	var p = new(Break_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_break_statement
	return p
}

func (*Break_statementContext) IsBreak_statementContext() {}

func NewBreak_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_statementContext {
	var p = new(Break_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_break_statement

	return p
}

func (s *Break_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_statementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(vhdlParserBREAK, 0)
}

func (s *Break_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Break_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Break_statementContext) Break_list() IBreak_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreak_listContext)
}

func (s *Break_statementContext) WHEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserWHEN, 0)
}

func (s *Break_statementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Break_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Break_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterBreak_statement(s)
	}
}

func (s *Break_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitBreak_statement(s)
	}
}

func (s *Break_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitBreak_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Break_statement() (localctx IBreak_statementContext) {
	localctx = NewBreak_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, vhdlParserRULE_break_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(835)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(834)
			p.Label_colon()
		}

	}
	{
		p.SetState(837)
		p.Match(vhdlParserBREAK)
	}
	p.SetState(839)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserFOR || _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(838)
			p.Break_list()
		}

	}
	p.SetState(843)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserWHEN {
		{
			p.SetState(841)
			p.Match(vhdlParserWHEN)
		}
		{
			p.SetState(842)
			p.Condition()
		}

	}
	{
		p.SetState(845)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ICase_statementContext is an interface to support dynamic dispatch.
type ICase_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_statementContext differentiates from other interfaces.
	IsCase_statementContext()
}

type Case_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_statementContext() *Case_statementContext {
	var p = new(Case_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_case_statement
	return p
}

func (*Case_statementContext) IsCase_statementContext() {}

func NewCase_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_statementContext {
	var p = new(Case_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_case_statement

	return p
}

func (s *Case_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_statementContext) AllCASE() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCASE)
}

func (s *Case_statementContext) CASE(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCASE, i)
}

func (s *Case_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Case_statementContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Case_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Case_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Case_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Case_statementContext) AllCase_statement_alternative() []ICase_statement_alternativeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICase_statement_alternativeContext)(nil)).Elem())
	var tst = make([]ICase_statement_alternativeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICase_statement_alternativeContext)
		}
	}

	return tst
}

func (s *Case_statementContext) Case_statement_alternative(i int) ICase_statement_alternativeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_statement_alternativeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICase_statement_alternativeContext)
}

func (s *Case_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Case_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterCase_statement(s)
	}
}

func (s *Case_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitCase_statement(s)
	}
}

func (s *Case_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitCase_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Case_statement() (localctx ICase_statementContext) {
	localctx = NewCase_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, vhdlParserRULE_case_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(848)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(847)
			p.Label_colon()
		}

	}
	{
		p.SetState(850)
		p.Match(vhdlParserCASE)
	}
	{
		p.SetState(851)
		p.Expression()
	}
	{
		p.SetState(852)
		p.Match(vhdlParserIS)
	}
	p.SetState(854)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == vhdlParserWHEN {
		{
			p.SetState(853)
			p.Case_statement_alternative()
		}

		p.SetState(856)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(858)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(859)
		p.Match(vhdlParserCASE)
	}
	p.SetState(861)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(860)
			p.Identifier()
		}

	}
	{
		p.SetState(863)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ICase_statement_alternativeContext is an interface to support dynamic dispatch.
type ICase_statement_alternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_statement_alternativeContext differentiates from other interfaces.
	IsCase_statement_alternativeContext()
}

type Case_statement_alternativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_statement_alternativeContext() *Case_statement_alternativeContext {
	var p = new(Case_statement_alternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_case_statement_alternative
	return p
}

func (*Case_statement_alternativeContext) IsCase_statement_alternativeContext() {}

func NewCase_statement_alternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_statement_alternativeContext {
	var p = new(Case_statement_alternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_case_statement_alternative

	return p
}

func (s *Case_statement_alternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_statement_alternativeContext) WHEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserWHEN, 0)
}

func (s *Case_statement_alternativeContext) Choices() IChoicesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoicesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChoicesContext)
}

func (s *Case_statement_alternativeContext) ARROW() antlr.TerminalNode {
	return s.GetToken(vhdlParserARROW, 0)
}

func (s *Case_statement_alternativeContext) Sequence_of_statements() ISequence_of_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_of_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_of_statementsContext)
}

func (s *Case_statement_alternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_statement_alternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_statement_alternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterCase_statement_alternative(s)
	}
}

func (s *Case_statement_alternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitCase_statement_alternative(s)
	}
}

func (s *Case_statement_alternativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitCase_statement_alternative(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Case_statement_alternative() (localctx ICase_statement_alternativeContext) {
	localctx = NewCase_statement_alternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, vhdlParserRULE_case_statement_alternative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(865)
		p.Match(vhdlParserWHEN)
	}
	{
		p.SetState(866)
		p.Choices()
	}
	{
		p.SetState(867)
		p.Match(vhdlParserARROW)
	}
	{
		p.SetState(868)
		p.Sequence_of_statements()
	}

	return localctx
}

// IChoiceContext is an interface to support dynamic dispatch.
type IChoiceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChoiceContext differentiates from other interfaces.
	IsChoiceContext()
}

type ChoiceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChoiceContext() *ChoiceContext {
	var p = new(ChoiceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_choice
	return p
}

func (*ChoiceContext) IsChoiceContext() {}

func NewChoiceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChoiceContext {
	var p = new(ChoiceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_choice

	return p
}

func (s *ChoiceContext) GetParser() antlr.Parser { return s.parser }

func (s *ChoiceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ChoiceContext) Discrete_range() IDiscrete_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDiscrete_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDiscrete_rangeContext)
}

func (s *ChoiceContext) Simple_expression() ISimple_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_expressionContext)
}

func (s *ChoiceContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(vhdlParserOTHERS, 0)
}

func (s *ChoiceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChoiceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChoiceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterChoice(s)
	}
}

func (s *ChoiceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitChoice(s)
	}
}

func (s *ChoiceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitChoice(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Choice() (localctx IChoiceContext) {
	localctx = NewChoiceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, vhdlParserRULE_choice)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(874)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(870)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(871)
			p.Discrete_range()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(872)
			p.Simple_expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(873)
			p.Match(vhdlParserOTHERS)
		}

	}

	return localctx
}

// IChoicesContext is an interface to support dynamic dispatch.
type IChoicesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChoicesContext differentiates from other interfaces.
	IsChoicesContext()
}

type ChoicesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChoicesContext() *ChoicesContext {
	var p = new(ChoicesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_choices
	return p
}

func (*ChoicesContext) IsChoicesContext() {}

func NewChoicesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChoicesContext {
	var p = new(ChoicesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_choices

	return p
}

func (s *ChoicesContext) GetParser() antlr.Parser { return s.parser }

func (s *ChoicesContext) AllChoice() []IChoiceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IChoiceContext)(nil)).Elem())
	var tst = make([]IChoiceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IChoiceContext)
		}
	}

	return tst
}

func (s *ChoicesContext) Choice(i int) IChoiceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoiceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IChoiceContext)
}

func (s *ChoicesContext) AllBAR() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserBAR)
}

func (s *ChoicesContext) BAR(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserBAR, i)
}

func (s *ChoicesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChoicesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChoicesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterChoices(s)
	}
}

func (s *ChoicesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitChoices(s)
	}
}

func (s *ChoicesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitChoices(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Choices() (localctx IChoicesContext) {
	localctx = NewChoicesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, vhdlParserRULE_choices)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(876)
		p.Choice()
	}
	p.SetState(881)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserBAR {
		{
			p.SetState(877)
			p.Match(vhdlParserBAR)
		}
		{
			p.SetState(878)
			p.Choice()
		}

		p.SetState(883)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComponent_configurationContext is an interface to support dynamic dispatch.
type IComponent_configurationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_configurationContext differentiates from other interfaces.
	IsComponent_configurationContext()
}

type Component_configurationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_configurationContext() *Component_configurationContext {
	var p = new(Component_configurationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_component_configuration
	return p
}

func (*Component_configurationContext) IsComponent_configurationContext() {}

func NewComponent_configurationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_configurationContext {
	var p = new(Component_configurationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_component_configuration

	return p
}

func (s *Component_configurationContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_configurationContext) AllFOR() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserFOR)
}

func (s *Component_configurationContext) FOR(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserFOR, i)
}

func (s *Component_configurationContext) Component_specification() IComponent_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_specificationContext)
}

func (s *Component_configurationContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Component_configurationContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserSEMI)
}

func (s *Component_configurationContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, i)
}

func (s *Component_configurationContext) Binding_indication() IBinding_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinding_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinding_indicationContext)
}

func (s *Component_configurationContext) Block_configuration() IBlock_configurationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_configurationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_configurationContext)
}

func (s *Component_configurationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_configurationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_configurationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterComponent_configuration(s)
	}
}

func (s *Component_configurationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitComponent_configuration(s)
	}
}

func (s *Component_configurationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitComponent_configuration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Component_configuration() (localctx IComponent_configurationContext) {
	localctx = NewComponent_configurationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, vhdlParserRULE_component_configuration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(884)
		p.Match(vhdlParserFOR)
	}
	{
		p.SetState(885)
		p.Component_specification()
	}
	p.SetState(889)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserGENERIC || _la == vhdlParserPORT || _la == vhdlParserUSE || _la == vhdlParserSEMI {
		{
			p.SetState(886)
			p.Binding_indication()
		}
		{
			p.SetState(887)
			p.Match(vhdlParserSEMI)
		}

	}
	p.SetState(892)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserFOR {
		{
			p.SetState(891)
			p.Block_configuration()
		}

	}
	{
		p.SetState(894)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(895)
		p.Match(vhdlParserFOR)
	}
	{
		p.SetState(896)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IComponent_declarationContext is an interface to support dynamic dispatch.
type IComponent_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_declarationContext differentiates from other interfaces.
	IsComponent_declarationContext()
}

type Component_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_declarationContext() *Component_declarationContext {
	var p = new(Component_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_component_declaration
	return p
}

func (*Component_declarationContext) IsComponent_declarationContext() {}

func NewComponent_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_declarationContext {
	var p = new(Component_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_component_declaration

	return p
}

func (s *Component_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_declarationContext) AllCOMPONENT() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMPONENT)
}

func (s *Component_declarationContext) COMPONENT(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMPONENT, i)
}

func (s *Component_declarationContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Component_declarationContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Component_declarationContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Component_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Component_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Component_declarationContext) Generic_clause() IGeneric_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneric_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneric_clauseContext)
}

func (s *Component_declarationContext) Port_clause() IPort_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_clauseContext)
}

func (s *Component_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterComponent_declaration(s)
	}
}

func (s *Component_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitComponent_declaration(s)
	}
}

func (s *Component_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitComponent_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Component_declaration() (localctx IComponent_declarationContext) {
	localctx = NewComponent_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, vhdlParserRULE_component_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(898)
		p.Match(vhdlParserCOMPONENT)
	}
	{
		p.SetState(899)
		p.Identifier()
	}
	p.SetState(901)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIS {
		{
			p.SetState(900)
			p.Match(vhdlParserIS)
		}

	}
	p.SetState(904)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserGENERIC {
		{
			p.SetState(903)
			p.Generic_clause()
		}

	}
	p.SetState(907)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPORT {
		{
			p.SetState(906)
			p.Port_clause()
		}

	}
	{
		p.SetState(909)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(910)
		p.Match(vhdlParserCOMPONENT)
	}
	p.SetState(912)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(911)
			p.Identifier()
		}

	}
	{
		p.SetState(914)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IComponent_instantiation_statementContext is an interface to support dynamic dispatch.
type IComponent_instantiation_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_instantiation_statementContext differentiates from other interfaces.
	IsComponent_instantiation_statementContext()
}

type Component_instantiation_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_instantiation_statementContext() *Component_instantiation_statementContext {
	var p = new(Component_instantiation_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_component_instantiation_statement
	return p
}

func (*Component_instantiation_statementContext) IsComponent_instantiation_statementContext() {}

func NewComponent_instantiation_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_instantiation_statementContext {
	var p = new(Component_instantiation_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_component_instantiation_statement

	return p
}

func (s *Component_instantiation_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_instantiation_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Component_instantiation_statementContext) Instantiated_unit() IInstantiated_unitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstantiated_unitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstantiated_unitContext)
}

func (s *Component_instantiation_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Component_instantiation_statementContext) Generic_map_aspect() IGeneric_map_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneric_map_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneric_map_aspectContext)
}

func (s *Component_instantiation_statementContext) Port_map_aspect() IPort_map_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_map_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_map_aspectContext)
}

func (s *Component_instantiation_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_instantiation_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_instantiation_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterComponent_instantiation_statement(s)
	}
}

func (s *Component_instantiation_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitComponent_instantiation_statement(s)
	}
}

func (s *Component_instantiation_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitComponent_instantiation_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Component_instantiation_statement() (localctx IComponent_instantiation_statementContext) {
	localctx = NewComponent_instantiation_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, vhdlParserRULE_component_instantiation_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(916)
		p.Label_colon()
	}
	{
		p.SetState(917)
		p.Instantiated_unit()
	}
	p.SetState(919)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserGENERIC {
		{
			p.SetState(918)
			p.Generic_map_aspect()
		}

	}
	p.SetState(922)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPORT {
		{
			p.SetState(921)
			p.Port_map_aspect()
		}

	}
	{
		p.SetState(924)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IComponent_specificationContext is an interface to support dynamic dispatch.
type IComponent_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_specificationContext differentiates from other interfaces.
	IsComponent_specificationContext()
}

type Component_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_specificationContext() *Component_specificationContext {
	var p = new(Component_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_component_specification
	return p
}

func (*Component_specificationContext) IsComponent_specificationContext() {}

func NewComponent_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_specificationContext {
	var p = new(Component_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_component_specification

	return p
}

func (s *Component_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_specificationContext) Instantiation_list() IInstantiation_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstantiation_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstantiation_listContext)
}

func (s *Component_specificationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Component_specificationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Component_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterComponent_specification(s)
	}
}

func (s *Component_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitComponent_specification(s)
	}
}

func (s *Component_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitComponent_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Component_specification() (localctx IComponent_specificationContext) {
	localctx = NewComponent_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, vhdlParserRULE_component_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(926)
		p.Instantiation_list()
	}
	{
		p.SetState(927)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(928)
		p.Name()
	}

	return localctx
}

// IComposite_nature_definitionContext is an interface to support dynamic dispatch.
type IComposite_nature_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComposite_nature_definitionContext differentiates from other interfaces.
	IsComposite_nature_definitionContext()
}

type Composite_nature_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComposite_nature_definitionContext() *Composite_nature_definitionContext {
	var p = new(Composite_nature_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_composite_nature_definition
	return p
}

func (*Composite_nature_definitionContext) IsComposite_nature_definitionContext() {}

func NewComposite_nature_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Composite_nature_definitionContext {
	var p = new(Composite_nature_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_composite_nature_definition

	return p
}

func (s *Composite_nature_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Composite_nature_definitionContext) Array_nature_definition() IArray_nature_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_nature_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_nature_definitionContext)
}

func (s *Composite_nature_definitionContext) Record_nature_definition() IRecord_nature_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecord_nature_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecord_nature_definitionContext)
}

func (s *Composite_nature_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Composite_nature_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Composite_nature_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterComposite_nature_definition(s)
	}
}

func (s *Composite_nature_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitComposite_nature_definition(s)
	}
}

func (s *Composite_nature_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitComposite_nature_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Composite_nature_definition() (localctx IComposite_nature_definitionContext) {
	localctx = NewComposite_nature_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, vhdlParserRULE_composite_nature_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(932)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserARRAY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(930)
			p.Array_nature_definition()
		}

	case vhdlParserRECORD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(931)
			p.Record_nature_definition()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IComposite_type_definitionContext is an interface to support dynamic dispatch.
type IComposite_type_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComposite_type_definitionContext differentiates from other interfaces.
	IsComposite_type_definitionContext()
}

type Composite_type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComposite_type_definitionContext() *Composite_type_definitionContext {
	var p = new(Composite_type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_composite_type_definition
	return p
}

func (*Composite_type_definitionContext) IsComposite_type_definitionContext() {}

func NewComposite_type_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Composite_type_definitionContext {
	var p = new(Composite_type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_composite_type_definition

	return p
}

func (s *Composite_type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Composite_type_definitionContext) Array_type_definition() IArray_type_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_type_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_type_definitionContext)
}

func (s *Composite_type_definitionContext) Record_type_definition() IRecord_type_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecord_type_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecord_type_definitionContext)
}

func (s *Composite_type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Composite_type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Composite_type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterComposite_type_definition(s)
	}
}

func (s *Composite_type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitComposite_type_definition(s)
	}
}

func (s *Composite_type_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitComposite_type_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Composite_type_definition() (localctx IComposite_type_definitionContext) {
	localctx = NewComposite_type_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, vhdlParserRULE_composite_type_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(936)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserARRAY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(934)
			p.Array_type_definition()
		}

	case vhdlParserRECORD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(935)
			p.Record_type_definition()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConcurrent_assertion_statementContext is an interface to support dynamic dispatch.
type IConcurrent_assertion_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConcurrent_assertion_statementContext differentiates from other interfaces.
	IsConcurrent_assertion_statementContext()
}

type Concurrent_assertion_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConcurrent_assertion_statementContext() *Concurrent_assertion_statementContext {
	var p = new(Concurrent_assertion_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_concurrent_assertion_statement
	return p
}

func (*Concurrent_assertion_statementContext) IsConcurrent_assertion_statementContext() {}

func NewConcurrent_assertion_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Concurrent_assertion_statementContext {
	var p = new(Concurrent_assertion_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_concurrent_assertion_statement

	return p
}

func (s *Concurrent_assertion_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Concurrent_assertion_statementContext) Assertion() IAssertionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertionContext)
}

func (s *Concurrent_assertion_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Concurrent_assertion_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Concurrent_assertion_statementContext) POSTPONED() antlr.TerminalNode {
	return s.GetToken(vhdlParserPOSTPONED, 0)
}

func (s *Concurrent_assertion_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Concurrent_assertion_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Concurrent_assertion_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConcurrent_assertion_statement(s)
	}
}

func (s *Concurrent_assertion_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConcurrent_assertion_statement(s)
	}
}

func (s *Concurrent_assertion_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitConcurrent_assertion_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Concurrent_assertion_statement() (localctx IConcurrent_assertion_statementContext) {
	localctx = NewConcurrent_assertion_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, vhdlParserRULE_concurrent_assertion_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(939)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(938)
			p.Label_colon()
		}

	}
	p.SetState(942)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPOSTPONED {
		{
			p.SetState(941)
			p.Match(vhdlParserPOSTPONED)
		}

	}
	{
		p.SetState(944)
		p.Assertion()
	}
	{
		p.SetState(945)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IConcurrent_break_statementContext is an interface to support dynamic dispatch.
type IConcurrent_break_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConcurrent_break_statementContext differentiates from other interfaces.
	IsConcurrent_break_statementContext()
}

type Concurrent_break_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConcurrent_break_statementContext() *Concurrent_break_statementContext {
	var p = new(Concurrent_break_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_concurrent_break_statement
	return p
}

func (*Concurrent_break_statementContext) IsConcurrent_break_statementContext() {}

func NewConcurrent_break_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Concurrent_break_statementContext {
	var p = new(Concurrent_break_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_concurrent_break_statement

	return p
}

func (s *Concurrent_break_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Concurrent_break_statementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(vhdlParserBREAK, 0)
}

func (s *Concurrent_break_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Concurrent_break_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Concurrent_break_statementContext) Break_list() IBreak_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreak_listContext)
}

func (s *Concurrent_break_statementContext) Sensitivity_clause() ISensitivity_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISensitivity_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISensitivity_clauseContext)
}

func (s *Concurrent_break_statementContext) WHEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserWHEN, 0)
}

func (s *Concurrent_break_statementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Concurrent_break_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Concurrent_break_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Concurrent_break_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConcurrent_break_statement(s)
	}
}

func (s *Concurrent_break_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConcurrent_break_statement(s)
	}
}

func (s *Concurrent_break_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitConcurrent_break_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Concurrent_break_statement() (localctx IConcurrent_break_statementContext) {
	localctx = NewConcurrent_break_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, vhdlParserRULE_concurrent_break_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(948)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(947)
			p.Label_colon()
		}

	}
	{
		p.SetState(950)
		p.Match(vhdlParserBREAK)
	}
	p.SetState(952)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserFOR || _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(951)
			p.Break_list()
		}

	}
	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserON {
		{
			p.SetState(954)
			p.Sensitivity_clause()
		}

	}
	p.SetState(959)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserWHEN {
		{
			p.SetState(957)
			p.Match(vhdlParserWHEN)
		}
		{
			p.SetState(958)
			p.Condition()
		}

	}
	{
		p.SetState(961)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IConcurrent_procedure_call_statementContext is an interface to support dynamic dispatch.
type IConcurrent_procedure_call_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConcurrent_procedure_call_statementContext differentiates from other interfaces.
	IsConcurrent_procedure_call_statementContext()
}

type Concurrent_procedure_call_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConcurrent_procedure_call_statementContext() *Concurrent_procedure_call_statementContext {
	var p = new(Concurrent_procedure_call_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_concurrent_procedure_call_statement
	return p
}

func (*Concurrent_procedure_call_statementContext) IsConcurrent_procedure_call_statementContext() {}

func NewConcurrent_procedure_call_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Concurrent_procedure_call_statementContext {
	var p = new(Concurrent_procedure_call_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_concurrent_procedure_call_statement

	return p
}

func (s *Concurrent_procedure_call_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Concurrent_procedure_call_statementContext) Procedure_call() IProcedure_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_callContext)
}

func (s *Concurrent_procedure_call_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Concurrent_procedure_call_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Concurrent_procedure_call_statementContext) POSTPONED() antlr.TerminalNode {
	return s.GetToken(vhdlParserPOSTPONED, 0)
}

func (s *Concurrent_procedure_call_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Concurrent_procedure_call_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Concurrent_procedure_call_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConcurrent_procedure_call_statement(s)
	}
}

func (s *Concurrent_procedure_call_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConcurrent_procedure_call_statement(s)
	}
}

func (s *Concurrent_procedure_call_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitConcurrent_procedure_call_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Concurrent_procedure_call_statement() (localctx IConcurrent_procedure_call_statementContext) {
	localctx = NewConcurrent_procedure_call_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, vhdlParserRULE_concurrent_procedure_call_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(964)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(963)
			p.Label_colon()
		}

	}
	p.SetState(967)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPOSTPONED {
		{
			p.SetState(966)
			p.Match(vhdlParserPOSTPONED)
		}

	}
	{
		p.SetState(969)
		p.Procedure_call()
	}
	{
		p.SetState(970)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IConcurrent_signal_assignment_statementContext is an interface to support dynamic dispatch.
type IConcurrent_signal_assignment_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConcurrent_signal_assignment_statementContext differentiates from other interfaces.
	IsConcurrent_signal_assignment_statementContext()
}

type Concurrent_signal_assignment_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConcurrent_signal_assignment_statementContext() *Concurrent_signal_assignment_statementContext {
	var p = new(Concurrent_signal_assignment_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_concurrent_signal_assignment_statement
	return p
}

func (*Concurrent_signal_assignment_statementContext) IsConcurrent_signal_assignment_statementContext() {
}

func NewConcurrent_signal_assignment_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Concurrent_signal_assignment_statementContext {
	var p = new(Concurrent_signal_assignment_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_concurrent_signal_assignment_statement

	return p
}

func (s *Concurrent_signal_assignment_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Concurrent_signal_assignment_statementContext) Conditional_signal_assignment() IConditional_signal_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_signal_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_signal_assignmentContext)
}

func (s *Concurrent_signal_assignment_statementContext) Selected_signal_assignment() ISelected_signal_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelected_signal_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelected_signal_assignmentContext)
}

func (s *Concurrent_signal_assignment_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Concurrent_signal_assignment_statementContext) POSTPONED() antlr.TerminalNode {
	return s.GetToken(vhdlParserPOSTPONED, 0)
}

func (s *Concurrent_signal_assignment_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Concurrent_signal_assignment_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Concurrent_signal_assignment_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConcurrent_signal_assignment_statement(s)
	}
}

func (s *Concurrent_signal_assignment_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConcurrent_signal_assignment_statement(s)
	}
}

func (s *Concurrent_signal_assignment_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitConcurrent_signal_assignment_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Concurrent_signal_assignment_statement() (localctx IConcurrent_signal_assignment_statementContext) {
	localctx = NewConcurrent_signal_assignment_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, vhdlParserRULE_concurrent_signal_assignment_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(973)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(972)
			p.Label_colon()
		}

	}
	p.SetState(976)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPOSTPONED {
		{
			p.SetState(975)
			p.Match(vhdlParserPOSTPONED)
		}

	}
	p.SetState(980)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserLPAREN:
		{
			p.SetState(978)
			p.Conditional_signal_assignment()
		}

	case vhdlParserWITH:
		{
			p.SetState(979)
			p.Selected_signal_assignment()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConditionContext is an interface to support dynamic dispatch.
type IConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionContext differentiates from other interfaces.
	IsConditionContext()
}

type ConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionContext() *ConditionContext {
	var p = new(ConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_condition
	return p
}

func (*ConditionContext) IsConditionContext() {}

func NewConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionContext {
	var p = new(ConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_condition

	return p
}

func (s *ConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterCondition(s)
	}
}

func (s *ConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitCondition(s)
	}
}

func (s *ConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Condition() (localctx IConditionContext) {
	localctx = NewConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, vhdlParserRULE_condition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(982)
		p.Expression()
	}

	return localctx
}

// ICondition_clauseContext is an interface to support dynamic dispatch.
type ICondition_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCondition_clauseContext differentiates from other interfaces.
	IsCondition_clauseContext()
}

type Condition_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCondition_clauseContext() *Condition_clauseContext {
	var p = new(Condition_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_condition_clause
	return p
}

func (*Condition_clauseContext) IsCondition_clauseContext() {}

func NewCondition_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Condition_clauseContext {
	var p = new(Condition_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_condition_clause

	return p
}

func (s *Condition_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Condition_clauseContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(vhdlParserUNTIL, 0)
}

func (s *Condition_clauseContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Condition_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Condition_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Condition_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterCondition_clause(s)
	}
}

func (s *Condition_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitCondition_clause(s)
	}
}

func (s *Condition_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitCondition_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Condition_clause() (localctx ICondition_clauseContext) {
	localctx = NewCondition_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, vhdlParserRULE_condition_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(984)
		p.Match(vhdlParserUNTIL)
	}
	{
		p.SetState(985)
		p.Condition()
	}

	return localctx
}

// IConditional_signal_assignmentContext is an interface to support dynamic dispatch.
type IConditional_signal_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_signal_assignmentContext differentiates from other interfaces.
	IsConditional_signal_assignmentContext()
}

type Conditional_signal_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_signal_assignmentContext() *Conditional_signal_assignmentContext {
	var p = new(Conditional_signal_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_conditional_signal_assignment
	return p
}

func (*Conditional_signal_assignmentContext) IsConditional_signal_assignmentContext() {}

func NewConditional_signal_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_signal_assignmentContext {
	var p = new(Conditional_signal_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_conditional_signal_assignment

	return p
}

func (s *Conditional_signal_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_signal_assignmentContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Conditional_signal_assignmentContext) LE() antlr.TerminalNode {
	return s.GetToken(vhdlParserLE, 0)
}

func (s *Conditional_signal_assignmentContext) Opts() IOptsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptsContext)
}

func (s *Conditional_signal_assignmentContext) Conditional_waveforms() IConditional_waveformsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_waveformsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_waveformsContext)
}

func (s *Conditional_signal_assignmentContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Conditional_signal_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_signal_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_signal_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConditional_signal_assignment(s)
	}
}

func (s *Conditional_signal_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConditional_signal_assignment(s)
	}
}

func (s *Conditional_signal_assignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitConditional_signal_assignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Conditional_signal_assignment() (localctx IConditional_signal_assignmentContext) {
	localctx = NewConditional_signal_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, vhdlParserRULE_conditional_signal_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(987)
		p.Target()
	}
	{
		p.SetState(988)
		p.Match(vhdlParserLE)
	}
	{
		p.SetState(989)
		p.Opts()
	}
	{
		p.SetState(990)
		p.Conditional_waveforms()
	}
	{
		p.SetState(991)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IConditional_waveformsContext is an interface to support dynamic dispatch.
type IConditional_waveformsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_waveformsContext differentiates from other interfaces.
	IsConditional_waveformsContext()
}

type Conditional_waveformsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_waveformsContext() *Conditional_waveformsContext {
	var p = new(Conditional_waveformsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_conditional_waveforms
	return p
}

func (*Conditional_waveformsContext) IsConditional_waveformsContext() {}

func NewConditional_waveformsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_waveformsContext {
	var p = new(Conditional_waveformsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_conditional_waveforms

	return p
}

func (s *Conditional_waveformsContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_waveformsContext) Waveform() IWaveformContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWaveformContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWaveformContext)
}

func (s *Conditional_waveformsContext) WHEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserWHEN, 0)
}

func (s *Conditional_waveformsContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Conditional_waveformsContext) ELSE() antlr.TerminalNode {
	return s.GetToken(vhdlParserELSE, 0)
}

func (s *Conditional_waveformsContext) Conditional_waveforms() IConditional_waveformsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_waveformsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_waveformsContext)
}

func (s *Conditional_waveformsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_waveformsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_waveformsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConditional_waveforms(s)
	}
}

func (s *Conditional_waveformsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConditional_waveforms(s)
	}
}

func (s *Conditional_waveformsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitConditional_waveforms(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Conditional_waveforms() (localctx IConditional_waveformsContext) {
	localctx = NewConditional_waveformsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, vhdlParserRULE_conditional_waveforms)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(993)
		p.Waveform()
	}
	p.SetState(1000)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserWHEN {
		{
			p.SetState(994)
			p.Match(vhdlParserWHEN)
		}
		{
			p.SetState(995)
			p.Condition()
		}
		p.SetState(998)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserELSE {
			{
				p.SetState(996)
				p.Match(vhdlParserELSE)
			}
			{
				p.SetState(997)
				p.Conditional_waveforms()
			}

		}

	}

	return localctx
}

// IConfiguration_declarationContext is an interface to support dynamic dispatch.
type IConfiguration_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfiguration_declarationContext differentiates from other interfaces.
	IsConfiguration_declarationContext()
}

type Configuration_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfiguration_declarationContext() *Configuration_declarationContext {
	var p = new(Configuration_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_configuration_declaration
	return p
}

func (*Configuration_declarationContext) IsConfiguration_declarationContext() {}

func NewConfiguration_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Configuration_declarationContext {
	var p = new(Configuration_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_configuration_declaration

	return p
}

func (s *Configuration_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Configuration_declarationContext) AllCONFIGURATION() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCONFIGURATION)
}

func (s *Configuration_declarationContext) CONFIGURATION(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCONFIGURATION, i)
}

func (s *Configuration_declarationContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Configuration_declarationContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Configuration_declarationContext) OF() antlr.TerminalNode {
	return s.GetToken(vhdlParserOF, 0)
}

func (s *Configuration_declarationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Configuration_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Configuration_declarationContext) Configuration_declarative_part() IConfiguration_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfiguration_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConfiguration_declarative_partContext)
}

func (s *Configuration_declarationContext) Block_configuration() IBlock_configurationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_configurationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_configurationContext)
}

func (s *Configuration_declarationContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Configuration_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Configuration_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Configuration_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Configuration_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConfiguration_declaration(s)
	}
}

func (s *Configuration_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConfiguration_declaration(s)
	}
}

func (s *Configuration_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitConfiguration_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Configuration_declaration() (localctx IConfiguration_declarationContext) {
	localctx = NewConfiguration_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, vhdlParserRULE_configuration_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1002)
		p.Match(vhdlParserCONFIGURATION)
	}
	{
		p.SetState(1003)
		p.Identifier()
	}
	{
		p.SetState(1004)
		p.Match(vhdlParserOF)
	}
	{
		p.SetState(1005)
		p.Name()
	}
	{
		p.SetState(1006)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(1007)
		p.Configuration_declarative_part()
	}
	{
		p.SetState(1008)
		p.Block_configuration()
	}
	{
		p.SetState(1009)
		p.Match(vhdlParserEND)
	}
	p.SetState(1011)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserCONFIGURATION {
		{
			p.SetState(1010)
			p.Match(vhdlParserCONFIGURATION)
		}

	}
	p.SetState(1014)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1013)
			p.Identifier()
		}

	}
	{
		p.SetState(1016)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IConfiguration_declarative_itemContext is an interface to support dynamic dispatch.
type IConfiguration_declarative_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfiguration_declarative_itemContext differentiates from other interfaces.
	IsConfiguration_declarative_itemContext()
}

type Configuration_declarative_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfiguration_declarative_itemContext() *Configuration_declarative_itemContext {
	var p = new(Configuration_declarative_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_configuration_declarative_item
	return p
}

func (*Configuration_declarative_itemContext) IsConfiguration_declarative_itemContext() {}

func NewConfiguration_declarative_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Configuration_declarative_itemContext {
	var p = new(Configuration_declarative_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_configuration_declarative_item

	return p
}

func (s *Configuration_declarative_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Configuration_declarative_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Configuration_declarative_itemContext) Attribute_specification() IAttribute_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_specificationContext)
}

func (s *Configuration_declarative_itemContext) Group_declaration() IGroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_declarationContext)
}

func (s *Configuration_declarative_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Configuration_declarative_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Configuration_declarative_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConfiguration_declarative_item(s)
	}
}

func (s *Configuration_declarative_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConfiguration_declarative_item(s)
	}
}

func (s *Configuration_declarative_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitConfiguration_declarative_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Configuration_declarative_item() (localctx IConfiguration_declarative_itemContext) {
	localctx = NewConfiguration_declarative_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, vhdlParserRULE_configuration_declarative_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1021)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserUSE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1018)
			p.Use_clause()
		}

	case vhdlParserATTRIBUTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1019)
			p.Attribute_specification()
		}

	case vhdlParserGROUP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1020)
			p.Group_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConfiguration_declarative_partContext is an interface to support dynamic dispatch.
type IConfiguration_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfiguration_declarative_partContext differentiates from other interfaces.
	IsConfiguration_declarative_partContext()
}

type Configuration_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfiguration_declarative_partContext() *Configuration_declarative_partContext {
	var p = new(Configuration_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_configuration_declarative_part
	return p
}

func (*Configuration_declarative_partContext) IsConfiguration_declarative_partContext() {}

func NewConfiguration_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Configuration_declarative_partContext {
	var p = new(Configuration_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_configuration_declarative_part

	return p
}

func (s *Configuration_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Configuration_declarative_partContext) AllConfiguration_declarative_item() []IConfiguration_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConfiguration_declarative_itemContext)(nil)).Elem())
	var tst = make([]IConfiguration_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConfiguration_declarative_itemContext)
		}
	}

	return tst
}

func (s *Configuration_declarative_partContext) Configuration_declarative_item(i int) IConfiguration_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfiguration_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConfiguration_declarative_itemContext)
}

func (s *Configuration_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Configuration_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Configuration_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConfiguration_declarative_part(s)
	}
}

func (s *Configuration_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConfiguration_declarative_part(s)
	}
}

func (s *Configuration_declarative_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitConfiguration_declarative_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Configuration_declarative_part() (localctx IConfiguration_declarative_partContext) {
	localctx = NewConfiguration_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, vhdlParserRULE_configuration_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1026)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserATTRIBUTE || _la == vhdlParserGROUP || _la == vhdlParserUSE {
		{
			p.SetState(1023)
			p.Configuration_declarative_item()
		}

		p.SetState(1028)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IConfiguration_itemContext is an interface to support dynamic dispatch.
type IConfiguration_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfiguration_itemContext differentiates from other interfaces.
	IsConfiguration_itemContext()
}

type Configuration_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfiguration_itemContext() *Configuration_itemContext {
	var p = new(Configuration_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_configuration_item
	return p
}

func (*Configuration_itemContext) IsConfiguration_itemContext() {}

func NewConfiguration_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Configuration_itemContext {
	var p = new(Configuration_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_configuration_item

	return p
}

func (s *Configuration_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Configuration_itemContext) Block_configuration() IBlock_configurationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_configurationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_configurationContext)
}

func (s *Configuration_itemContext) Component_configuration() IComponent_configurationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_configurationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_configurationContext)
}

func (s *Configuration_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Configuration_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Configuration_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConfiguration_item(s)
	}
}

func (s *Configuration_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConfiguration_item(s)
	}
}

func (s *Configuration_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitConfiguration_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Configuration_item() (localctx IConfiguration_itemContext) {
	localctx = NewConfiguration_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, vhdlParserRULE_configuration_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1031)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1029)
			p.Block_configuration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1030)
			p.Component_configuration()
		}

	}

	return localctx
}

// IConfiguration_specificationContext is an interface to support dynamic dispatch.
type IConfiguration_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfiguration_specificationContext differentiates from other interfaces.
	IsConfiguration_specificationContext()
}

type Configuration_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfiguration_specificationContext() *Configuration_specificationContext {
	var p = new(Configuration_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_configuration_specification
	return p
}

func (*Configuration_specificationContext) IsConfiguration_specificationContext() {}

func NewConfiguration_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Configuration_specificationContext {
	var p = new(Configuration_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_configuration_specification

	return p
}

func (s *Configuration_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Configuration_specificationContext) FOR() antlr.TerminalNode {
	return s.GetToken(vhdlParserFOR, 0)
}

func (s *Configuration_specificationContext) Component_specification() IComponent_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_specificationContext)
}

func (s *Configuration_specificationContext) Binding_indication() IBinding_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinding_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinding_indicationContext)
}

func (s *Configuration_specificationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Configuration_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Configuration_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Configuration_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConfiguration_specification(s)
	}
}

func (s *Configuration_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConfiguration_specification(s)
	}
}

func (s *Configuration_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitConfiguration_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Configuration_specification() (localctx IConfiguration_specificationContext) {
	localctx = NewConfiguration_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, vhdlParserRULE_configuration_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1033)
		p.Match(vhdlParserFOR)
	}
	{
		p.SetState(1034)
		p.Component_specification()
	}
	{
		p.SetState(1035)
		p.Binding_indication()
	}
	{
		p.SetState(1036)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IConstant_declarationContext is an interface to support dynamic dispatch.
type IConstant_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_declarationContext differentiates from other interfaces.
	IsConstant_declarationContext()
}

type Constant_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_declarationContext() *Constant_declarationContext {
	var p = new(Constant_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_constant_declaration
	return p
}

func (*Constant_declarationContext) IsConstant_declarationContext() {}

func NewConstant_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_declarationContext {
	var p = new(Constant_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_constant_declaration

	return p
}

func (s *Constant_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_declarationContext) CONSTANT() antlr.TerminalNode {
	return s.GetToken(vhdlParserCONSTANT, 0)
}

func (s *Constant_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Constant_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Constant_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Constant_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Constant_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Constant_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Constant_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConstant_declaration(s)
	}
}

func (s *Constant_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConstant_declaration(s)
	}
}

func (s *Constant_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitConstant_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Constant_declaration() (localctx IConstant_declarationContext) {
	localctx = NewConstant_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, vhdlParserRULE_constant_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1038)
		p.Match(vhdlParserCONSTANT)
	}
	{
		p.SetState(1039)
		p.Identifier_list()
	}
	{
		p.SetState(1040)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1041)
		p.Subtype_indication()
	}
	p.SetState(1044)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(1042)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(1043)
			p.Expression()
		}

	}
	{
		p.SetState(1046)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IConstrained_array_definitionContext is an interface to support dynamic dispatch.
type IConstrained_array_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstrained_array_definitionContext differentiates from other interfaces.
	IsConstrained_array_definitionContext()
}

type Constrained_array_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstrained_array_definitionContext() *Constrained_array_definitionContext {
	var p = new(Constrained_array_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_constrained_array_definition
	return p
}

func (*Constrained_array_definitionContext) IsConstrained_array_definitionContext() {}

func NewConstrained_array_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constrained_array_definitionContext {
	var p = new(Constrained_array_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_constrained_array_definition

	return p
}

func (s *Constrained_array_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constrained_array_definitionContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(vhdlParserARRAY, 0)
}

func (s *Constrained_array_definitionContext) Index_constraint() IIndex_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndex_constraintContext)
}

func (s *Constrained_array_definitionContext) OF() antlr.TerminalNode {
	return s.GetToken(vhdlParserOF, 0)
}

func (s *Constrained_array_definitionContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Constrained_array_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constrained_array_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constrained_array_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConstrained_array_definition(s)
	}
}

func (s *Constrained_array_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConstrained_array_definition(s)
	}
}

func (s *Constrained_array_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitConstrained_array_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Constrained_array_definition() (localctx IConstrained_array_definitionContext) {
	localctx = NewConstrained_array_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, vhdlParserRULE_constrained_array_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1048)
		p.Match(vhdlParserARRAY)
	}
	{
		p.SetState(1049)
		p.Index_constraint()
	}
	{
		p.SetState(1050)
		p.Match(vhdlParserOF)
	}
	{
		p.SetState(1051)
		p.Subtype_indication()
	}

	return localctx
}

// IConstrained_nature_definitionContext is an interface to support dynamic dispatch.
type IConstrained_nature_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstrained_nature_definitionContext differentiates from other interfaces.
	IsConstrained_nature_definitionContext()
}

type Constrained_nature_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstrained_nature_definitionContext() *Constrained_nature_definitionContext {
	var p = new(Constrained_nature_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_constrained_nature_definition
	return p
}

func (*Constrained_nature_definitionContext) IsConstrained_nature_definitionContext() {}

func NewConstrained_nature_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constrained_nature_definitionContext {
	var p = new(Constrained_nature_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_constrained_nature_definition

	return p
}

func (s *Constrained_nature_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constrained_nature_definitionContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(vhdlParserARRAY, 0)
}

func (s *Constrained_nature_definitionContext) Index_constraint() IIndex_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndex_constraintContext)
}

func (s *Constrained_nature_definitionContext) OF() antlr.TerminalNode {
	return s.GetToken(vhdlParserOF, 0)
}

func (s *Constrained_nature_definitionContext) Subnature_indication() ISubnature_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_indicationContext)
}

func (s *Constrained_nature_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constrained_nature_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constrained_nature_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConstrained_nature_definition(s)
	}
}

func (s *Constrained_nature_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConstrained_nature_definition(s)
	}
}

func (s *Constrained_nature_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitConstrained_nature_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Constrained_nature_definition() (localctx IConstrained_nature_definitionContext) {
	localctx = NewConstrained_nature_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, vhdlParserRULE_constrained_nature_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1053)
		p.Match(vhdlParserARRAY)
	}
	{
		p.SetState(1054)
		p.Index_constraint()
	}
	{
		p.SetState(1055)
		p.Match(vhdlParserOF)
	}
	{
		p.SetState(1056)
		p.Subnature_indication()
	}

	return localctx
}

// IConstraintContext is an interface to support dynamic dispatch.
type IConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraintContext differentiates from other interfaces.
	IsConstraintContext()
}

type ConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintContext() *ConstraintContext {
	var p = new(ConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_constraint
	return p
}

func (*ConstraintContext) IsConstraintContext() {}

func NewConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintContext {
	var p = new(ConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_constraint

	return p
}

func (s *ConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintContext) Range_constraint() IRange_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_constraintContext)
}

func (s *ConstraintContext) Index_constraint() IIndex_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndex_constraintContext)
}

func (s *ConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterConstraint(s)
	}
}

func (s *ConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitConstraint(s)
	}
}

func (s *ConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Constraint() (localctx IConstraintContext) {
	localctx = NewConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, vhdlParserRULE_constraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1060)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserRANGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1058)
			p.Range_constraint()
		}

	case vhdlParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1059)
			p.Index_constraint()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IContext_clauseContext is an interface to support dynamic dispatch.
type IContext_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContext_clauseContext differentiates from other interfaces.
	IsContext_clauseContext()
}

type Context_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContext_clauseContext() *Context_clauseContext {
	var p = new(Context_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_context_clause
	return p
}

func (*Context_clauseContext) IsContext_clauseContext() {}

func NewContext_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Context_clauseContext {
	var p = new(Context_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_context_clause

	return p
}

func (s *Context_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Context_clauseContext) AllContext_item() []IContext_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IContext_itemContext)(nil)).Elem())
	var tst = make([]IContext_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IContext_itemContext)
		}
	}

	return tst
}

func (s *Context_clauseContext) Context_item(i int) IContext_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContext_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IContext_itemContext)
}

func (s *Context_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Context_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Context_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterContext_clause(s)
	}
}

func (s *Context_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitContext_clause(s)
	}
}

func (s *Context_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitContext_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Context_clause() (localctx IContext_clauseContext) {
	localctx = NewContext_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, vhdlParserRULE_context_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1065)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserLIBRARY || _la == vhdlParserUSE {
		{
			p.SetState(1062)
			p.Context_item()
		}

		p.SetState(1067)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IContext_itemContext is an interface to support dynamic dispatch.
type IContext_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContext_itemContext differentiates from other interfaces.
	IsContext_itemContext()
}

type Context_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContext_itemContext() *Context_itemContext {
	var p = new(Context_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_context_item
	return p
}

func (*Context_itemContext) IsContext_itemContext() {}

func NewContext_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Context_itemContext {
	var p = new(Context_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_context_item

	return p
}

func (s *Context_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Context_itemContext) Library_clause() ILibrary_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibrary_clauseContext)
}

func (s *Context_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Context_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Context_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Context_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterContext_item(s)
	}
}

func (s *Context_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitContext_item(s)
	}
}

func (s *Context_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitContext_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Context_item() (localctx IContext_itemContext) {
	localctx = NewContext_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, vhdlParserRULE_context_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1070)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserLIBRARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1068)
			p.Library_clause()
		}

	case vhdlParserUSE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1069)
			p.Use_clause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDelay_mechanismContext is an interface to support dynamic dispatch.
type IDelay_mechanismContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay_mechanismContext differentiates from other interfaces.
	IsDelay_mechanismContext()
}

type Delay_mechanismContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay_mechanismContext() *Delay_mechanismContext {
	var p = new(Delay_mechanismContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_delay_mechanism
	return p
}

func (*Delay_mechanismContext) IsDelay_mechanismContext() {}

func NewDelay_mechanismContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay_mechanismContext {
	var p = new(Delay_mechanismContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_delay_mechanism

	return p
}

func (s *Delay_mechanismContext) GetParser() antlr.Parser { return s.parser }

func (s *Delay_mechanismContext) TRANSPORT() antlr.TerminalNode {
	return s.GetToken(vhdlParserTRANSPORT, 0)
}

func (s *Delay_mechanismContext) INERTIAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserINERTIAL, 0)
}

func (s *Delay_mechanismContext) REJECT() antlr.TerminalNode {
	return s.GetToken(vhdlParserREJECT, 0)
}

func (s *Delay_mechanismContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Delay_mechanismContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay_mechanismContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay_mechanismContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterDelay_mechanism(s)
	}
}

func (s *Delay_mechanismContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitDelay_mechanism(s)
	}
}

func (s *Delay_mechanismContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitDelay_mechanism(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Delay_mechanism() (localctx IDelay_mechanismContext) {
	localctx = NewDelay_mechanismContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, vhdlParserRULE_delay_mechanism)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1078)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserTRANSPORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1072)
			p.Match(vhdlParserTRANSPORT)
		}

	case vhdlParserINERTIAL, vhdlParserREJECT:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1075)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserREJECT {
			{
				p.SetState(1073)
				p.Match(vhdlParserREJECT)
			}
			{
				p.SetState(1074)
				p.Expression()
			}

		}
		{
			p.SetState(1077)
			p.Match(vhdlParserINERTIAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDesign_fileContext is an interface to support dynamic dispatch.
type IDesign_fileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesign_fileContext differentiates from other interfaces.
	IsDesign_fileContext()
}

type Design_fileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesign_fileContext() *Design_fileContext {
	var p = new(Design_fileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_design_file
	return p
}

func (*Design_fileContext) IsDesign_fileContext() {}

func NewDesign_fileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Design_fileContext {
	var p = new(Design_fileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_design_file

	return p
}

func (s *Design_fileContext) GetParser() antlr.Parser { return s.parser }

func (s *Design_fileContext) EOF() antlr.TerminalNode {
	return s.GetToken(vhdlParserEOF, 0)
}

func (s *Design_fileContext) AllDesign_unit() []IDesign_unitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDesign_unitContext)(nil)).Elem())
	var tst = make([]IDesign_unitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDesign_unitContext)
		}
	}

	return tst
}

func (s *Design_fileContext) Design_unit(i int) IDesign_unitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesign_unitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDesign_unitContext)
}

func (s *Design_fileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Design_fileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Design_fileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterDesign_file(s)
	}
}

func (s *Design_fileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitDesign_file(s)
	}
}

func (s *Design_fileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitDesign_file(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Design_file() (localctx IDesign_fileContext) {
	localctx = NewDesign_fileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, vhdlParserRULE_design_file)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1083)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserARCHITECTURE)|(1<<vhdlParserCONFIGURATION)|(1<<vhdlParserENTITY))) != 0) || _la == vhdlParserLIBRARY || _la == vhdlParserPACKAGE || _la == vhdlParserUSE {
		{
			p.SetState(1080)
			p.Design_unit()
		}

		p.SetState(1085)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1086)
		p.Match(vhdlParserEOF)
	}

	return localctx
}

// IDesign_unitContext is an interface to support dynamic dispatch.
type IDesign_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesign_unitContext differentiates from other interfaces.
	IsDesign_unitContext()
}

type Design_unitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesign_unitContext() *Design_unitContext {
	var p = new(Design_unitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_design_unit
	return p
}

func (*Design_unitContext) IsDesign_unitContext() {}

func NewDesign_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Design_unitContext {
	var p = new(Design_unitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_design_unit

	return p
}

func (s *Design_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Design_unitContext) Context_clause() IContext_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContext_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContext_clauseContext)
}

func (s *Design_unitContext) Library_unit() ILibrary_unitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_unitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibrary_unitContext)
}

func (s *Design_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Design_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Design_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterDesign_unit(s)
	}
}

func (s *Design_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitDesign_unit(s)
	}
}

func (s *Design_unitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitDesign_unit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Design_unit() (localctx IDesign_unitContext) {
	localctx = NewDesign_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, vhdlParserRULE_design_unit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1088)
		p.Context_clause()
	}
	{
		p.SetState(1089)
		p.Library_unit()
	}

	return localctx
}

// IDesignatorContext is an interface to support dynamic dispatch.
type IDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesignatorContext differentiates from other interfaces.
	IsDesignatorContext()
}

type DesignatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesignatorContext() *DesignatorContext {
	var p = new(DesignatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_designator
	return p
}

func (*DesignatorContext) IsDesignatorContext() {}

func NewDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DesignatorContext {
	var p = new(DesignatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_designator

	return p
}

func (s *DesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *DesignatorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DesignatorContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSTRING_LITERAL, 0)
}

func (s *DesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterDesignator(s)
	}
}

func (s *DesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitDesignator(s)
	}
}

func (s *DesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Designator() (localctx IDesignatorContext) {
	localctx = NewDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, vhdlParserRULE_designator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1093)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1091)
			p.Identifier()
		}

	case vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1092)
			p.Match(vhdlParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDirectionContext is an interface to support dynamic dispatch.
type IDirectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDirectionContext differentiates from other interfaces.
	IsDirectionContext()
}

type DirectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectionContext() *DirectionContext {
	var p = new(DirectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_direction
	return p
}

func (*DirectionContext) IsDirectionContext() {}

func NewDirectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectionContext {
	var p = new(DirectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_direction

	return p
}

func (s *DirectionContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectionContext) TO() antlr.TerminalNode {
	return s.GetToken(vhdlParserTO, 0)
}

func (s *DirectionContext) DOWNTO() antlr.TerminalNode {
	return s.GetToken(vhdlParserDOWNTO, 0)
}

func (s *DirectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterDirection(s)
	}
}

func (s *DirectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitDirection(s)
	}
}

func (s *DirectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitDirection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Direction() (localctx IDirectionContext) {
	localctx = NewDirectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, vhdlParserRULE_direction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1095)
	_la = p.GetTokenStream().LA(1)

	if !(_la == vhdlParserDOWNTO || _la == vhdlParserTO) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IDisconnection_specificationContext is an interface to support dynamic dispatch.
type IDisconnection_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisconnection_specificationContext differentiates from other interfaces.
	IsDisconnection_specificationContext()
}

type Disconnection_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisconnection_specificationContext() *Disconnection_specificationContext {
	var p = new(Disconnection_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_disconnection_specification
	return p
}

func (*Disconnection_specificationContext) IsDisconnection_specificationContext() {}

func NewDisconnection_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Disconnection_specificationContext {
	var p = new(Disconnection_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_disconnection_specification

	return p
}

func (s *Disconnection_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Disconnection_specificationContext) DISCONNECT() antlr.TerminalNode {
	return s.GetToken(vhdlParserDISCONNECT, 0)
}

func (s *Disconnection_specificationContext) Guarded_signal_specification() IGuarded_signal_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGuarded_signal_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGuarded_signal_specificationContext)
}

func (s *Disconnection_specificationContext) AFTER() antlr.TerminalNode {
	return s.GetToken(vhdlParserAFTER, 0)
}

func (s *Disconnection_specificationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Disconnection_specificationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Disconnection_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Disconnection_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Disconnection_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterDisconnection_specification(s)
	}
}

func (s *Disconnection_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitDisconnection_specification(s)
	}
}

func (s *Disconnection_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitDisconnection_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Disconnection_specification() (localctx IDisconnection_specificationContext) {
	localctx = NewDisconnection_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, vhdlParserRULE_disconnection_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1097)
		p.Match(vhdlParserDISCONNECT)
	}
	{
		p.SetState(1098)
		p.Guarded_signal_specification()
	}
	{
		p.SetState(1099)
		p.Match(vhdlParserAFTER)
	}
	{
		p.SetState(1100)
		p.Expression()
	}
	{
		p.SetState(1101)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IDiscrete_rangeContext is an interface to support dynamic dispatch.
type IDiscrete_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDiscrete_rangeContext differentiates from other interfaces.
	IsDiscrete_rangeContext()
}

type Discrete_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDiscrete_rangeContext() *Discrete_rangeContext {
	var p = new(Discrete_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_discrete_range
	return p
}

func (*Discrete_rangeContext) IsDiscrete_rangeContext() {}

func NewDiscrete_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Discrete_rangeContext {
	var p = new(Discrete_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_discrete_range

	return p
}

func (s *Discrete_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Discrete_rangeContext) Range_decl() IRange_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_declContext)
}

func (s *Discrete_rangeContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Discrete_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Discrete_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Discrete_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterDiscrete_range(s)
	}
}

func (s *Discrete_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitDiscrete_range(s)
	}
}

func (s *Discrete_rangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitDiscrete_range(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Discrete_range() (localctx IDiscrete_rangeContext) {
	localctx = NewDiscrete_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, vhdlParserRULE_discrete_range)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1105)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1103)
			p.Range_decl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1104)
			p.Subtype_indication()
		}

	}

	return localctx
}

// IElement_associationContext is an interface to support dynamic dispatch.
type IElement_associationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElement_associationContext differentiates from other interfaces.
	IsElement_associationContext()
}

type Element_associationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElement_associationContext() *Element_associationContext {
	var p = new(Element_associationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_element_association
	return p
}

func (*Element_associationContext) IsElement_associationContext() {}

func NewElement_associationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Element_associationContext {
	var p = new(Element_associationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_element_association

	return p
}

func (s *Element_associationContext) GetParser() antlr.Parser { return s.parser }

func (s *Element_associationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Element_associationContext) Choices() IChoicesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoicesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChoicesContext)
}

func (s *Element_associationContext) ARROW() antlr.TerminalNode {
	return s.GetToken(vhdlParserARROW, 0)
}

func (s *Element_associationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Element_associationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Element_associationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterElement_association(s)
	}
}

func (s *Element_associationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitElement_association(s)
	}
}

func (s *Element_associationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitElement_association(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Element_association() (localctx IElement_associationContext) {
	localctx = NewElement_associationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, vhdlParserRULE_element_association)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1110)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1107)
			p.Choices()
		}
		{
			p.SetState(1108)
			p.Match(vhdlParserARROW)
		}

	}
	{
		p.SetState(1112)
		p.Expression()
	}

	return localctx
}

// IElement_declarationContext is an interface to support dynamic dispatch.
type IElement_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElement_declarationContext differentiates from other interfaces.
	IsElement_declarationContext()
}

type Element_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElement_declarationContext() *Element_declarationContext {
	var p = new(Element_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_element_declaration
	return p
}

func (*Element_declarationContext) IsElement_declarationContext() {}

func NewElement_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Element_declarationContext {
	var p = new(Element_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_element_declaration

	return p
}

func (s *Element_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Element_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Element_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Element_declarationContext) Element_subtype_definition() IElement_subtype_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElement_subtype_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElement_subtype_definitionContext)
}

func (s *Element_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Element_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Element_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Element_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterElement_declaration(s)
	}
}

func (s *Element_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitElement_declaration(s)
	}
}

func (s *Element_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitElement_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Element_declaration() (localctx IElement_declarationContext) {
	localctx = NewElement_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, vhdlParserRULE_element_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1114)
		p.Identifier_list()
	}
	{
		p.SetState(1115)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1116)
		p.Element_subtype_definition()
	}
	{
		p.SetState(1117)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IElement_subnature_definitionContext is an interface to support dynamic dispatch.
type IElement_subnature_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElement_subnature_definitionContext differentiates from other interfaces.
	IsElement_subnature_definitionContext()
}

type Element_subnature_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElement_subnature_definitionContext() *Element_subnature_definitionContext {
	var p = new(Element_subnature_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_element_subnature_definition
	return p
}

func (*Element_subnature_definitionContext) IsElement_subnature_definitionContext() {}

func NewElement_subnature_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Element_subnature_definitionContext {
	var p = new(Element_subnature_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_element_subnature_definition

	return p
}

func (s *Element_subnature_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Element_subnature_definitionContext) Subnature_indication() ISubnature_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_indicationContext)
}

func (s *Element_subnature_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Element_subnature_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Element_subnature_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterElement_subnature_definition(s)
	}
}

func (s *Element_subnature_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitElement_subnature_definition(s)
	}
}

func (s *Element_subnature_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitElement_subnature_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Element_subnature_definition() (localctx IElement_subnature_definitionContext) {
	localctx = NewElement_subnature_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, vhdlParserRULE_element_subnature_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1119)
		p.Subnature_indication()
	}

	return localctx
}

// IElement_subtype_definitionContext is an interface to support dynamic dispatch.
type IElement_subtype_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElement_subtype_definitionContext differentiates from other interfaces.
	IsElement_subtype_definitionContext()
}

type Element_subtype_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElement_subtype_definitionContext() *Element_subtype_definitionContext {
	var p = new(Element_subtype_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_element_subtype_definition
	return p
}

func (*Element_subtype_definitionContext) IsElement_subtype_definitionContext() {}

func NewElement_subtype_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Element_subtype_definitionContext {
	var p = new(Element_subtype_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_element_subtype_definition

	return p
}

func (s *Element_subtype_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Element_subtype_definitionContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Element_subtype_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Element_subtype_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Element_subtype_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterElement_subtype_definition(s)
	}
}

func (s *Element_subtype_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitElement_subtype_definition(s)
	}
}

func (s *Element_subtype_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitElement_subtype_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Element_subtype_definition() (localctx IElement_subtype_definitionContext) {
	localctx = NewElement_subtype_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, vhdlParserRULE_element_subtype_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1121)
		p.Subtype_indication()
	}

	return localctx
}

// IEntity_aspectContext is an interface to support dynamic dispatch.
type IEntity_aspectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_aspectContext differentiates from other interfaces.
	IsEntity_aspectContext()
}

type Entity_aspectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_aspectContext() *Entity_aspectContext {
	var p = new(Entity_aspectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_aspect
	return p
}

func (*Entity_aspectContext) IsEntity_aspectContext() {}

func NewEntity_aspectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_aspectContext {
	var p = new(Entity_aspectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_aspect

	return p
}

func (s *Entity_aspectContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_aspectContext) ENTITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserENTITY, 0)
}

func (s *Entity_aspectContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Entity_aspectContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Entity_aspectContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Entity_aspectContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Entity_aspectContext) CONFIGURATION() antlr.TerminalNode {
	return s.GetToken(vhdlParserCONFIGURATION, 0)
}

func (s *Entity_aspectContext) OPEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserOPEN, 0)
}

func (s *Entity_aspectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_aspectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_aspectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_aspect(s)
	}
}

func (s *Entity_aspectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_aspect(s)
	}
}

func (s *Entity_aspectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitEntity_aspect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Entity_aspect() (localctx IEntity_aspectContext) {
	localctx = NewEntity_aspectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, vhdlParserRULE_entity_aspect)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1134)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserENTITY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1123)
			p.Match(vhdlParserENTITY)
		}
		{
			p.SetState(1124)
			p.Name()
		}
		p.SetState(1129)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserLPAREN {
			{
				p.SetState(1125)
				p.Match(vhdlParserLPAREN)
			}
			{
				p.SetState(1126)
				p.Identifier()
			}
			{
				p.SetState(1127)
				p.Match(vhdlParserRPAREN)
			}

		}

	case vhdlParserCONFIGURATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1131)
			p.Match(vhdlParserCONFIGURATION)
		}
		{
			p.SetState(1132)
			p.Name()
		}

	case vhdlParserOPEN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1133)
			p.Match(vhdlParserOPEN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEntity_classContext is an interface to support dynamic dispatch.
type IEntity_classContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_classContext differentiates from other interfaces.
	IsEntity_classContext()
}

type Entity_classContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_classContext() *Entity_classContext {
	var p = new(Entity_classContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_class
	return p
}

func (*Entity_classContext) IsEntity_classContext() {}

func NewEntity_classContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_classContext {
	var p = new(Entity_classContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_class

	return p
}

func (s *Entity_classContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_classContext) ENTITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserENTITY, 0)
}

func (s *Entity_classContext) ARCHITECTURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserARCHITECTURE, 0)
}

func (s *Entity_classContext) CONFIGURATION() antlr.TerminalNode {
	return s.GetToken(vhdlParserCONFIGURATION, 0)
}

func (s *Entity_classContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserPROCEDURE, 0)
}

func (s *Entity_classContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(vhdlParserFUNCTION, 0)
}

func (s *Entity_classContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(vhdlParserPACKAGE, 0)
}

func (s *Entity_classContext) TYPE() antlr.TerminalNode {
	return s.GetToken(vhdlParserTYPE, 0)
}

func (s *Entity_classContext) SUBTYPE() antlr.TerminalNode {
	return s.GetToken(vhdlParserSUBTYPE, 0)
}

func (s *Entity_classContext) CONSTANT() antlr.TerminalNode {
	return s.GetToken(vhdlParserCONSTANT, 0)
}

func (s *Entity_classContext) SIGNAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSIGNAL, 0)
}

func (s *Entity_classContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARIABLE, 0)
}

func (s *Entity_classContext) COMPONENT() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMPONENT, 0)
}

func (s *Entity_classContext) LABEL() antlr.TerminalNode {
	return s.GetToken(vhdlParserLABEL, 0)
}

func (s *Entity_classContext) LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserLITERAL, 0)
}

func (s *Entity_classContext) UNITS() antlr.TerminalNode {
	return s.GetToken(vhdlParserUNITS, 0)
}

func (s *Entity_classContext) GROUP() antlr.TerminalNode {
	return s.GetToken(vhdlParserGROUP, 0)
}

func (s *Entity_classContext) FILE() antlr.TerminalNode {
	return s.GetToken(vhdlParserFILE, 0)
}

func (s *Entity_classContext) NATURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserNATURE, 0)
}

func (s *Entity_classContext) SUBNATURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserSUBNATURE, 0)
}

func (s *Entity_classContext) QUANTITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserQUANTITY, 0)
}

func (s *Entity_classContext) TERMINAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserTERMINAL, 0)
}

func (s *Entity_classContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_classContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_classContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_class(s)
	}
}

func (s *Entity_classContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_class(s)
	}
}

func (s *Entity_classContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitEntity_class(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Entity_class() (localctx IEntity_classContext) {
	localctx = NewEntity_classContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, vhdlParserRULE_entity_class)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1136)
	_la = p.GetTokenStream().LA(1)

	if !((((_la-8)&-(0x1f+1)) == 0 && ((1<<uint((_la-8)))&((1<<(vhdlParserARCHITECTURE-8))|(1<<(vhdlParserCOMPONENT-8))|(1<<(vhdlParserCONFIGURATION-8))|(1<<(vhdlParserCONSTANT-8))|(1<<(vhdlParserENTITY-8))|(1<<(vhdlParserFILE-8))|(1<<(vhdlParserFUNCTION-8))|(1<<(vhdlParserGROUP-8)))) != 0) || (((_la-42)&-(0x1f+1)) == 0 && ((1<<uint((_la-42)))&((1<<(vhdlParserLABEL-42))|(1<<(vhdlParserLITERAL-42))|(1<<(vhdlParserNATURE-42))|(1<<(vhdlParserPACKAGE-42))|(1<<(vhdlParserPROCEDURE-42))|(1<<(vhdlParserQUANTITY-42)))) != 0) || (((_la-86)&-(0x1f+1)) == 0 && ((1<<uint((_la-86)))&((1<<(vhdlParserSIGNAL-86))|(1<<(vhdlParserSUBNATURE-86))|(1<<(vhdlParserSUBTYPE-86))|(1<<(vhdlParserTERMINAL-86))|(1<<(vhdlParserTYPE-86))|(1<<(vhdlParserUNITS-86))|(1<<(vhdlParserVARIABLE-86)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IEntity_class_entryContext is an interface to support dynamic dispatch.
type IEntity_class_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_class_entryContext differentiates from other interfaces.
	IsEntity_class_entryContext()
}

type Entity_class_entryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_class_entryContext() *Entity_class_entryContext {
	var p = new(Entity_class_entryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_class_entry
	return p
}

func (*Entity_class_entryContext) IsEntity_class_entryContext() {}

func NewEntity_class_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_class_entryContext {
	var p = new(Entity_class_entryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_class_entry

	return p
}

func (s *Entity_class_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_class_entryContext) Entity_class() IEntity_classContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_classContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_classContext)
}

func (s *Entity_class_entryContext) BOX() antlr.TerminalNode {
	return s.GetToken(vhdlParserBOX, 0)
}

func (s *Entity_class_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_class_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_class_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_class_entry(s)
	}
}

func (s *Entity_class_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_class_entry(s)
	}
}

func (s *Entity_class_entryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitEntity_class_entry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Entity_class_entry() (localctx IEntity_class_entryContext) {
	localctx = NewEntity_class_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, vhdlParserRULE_entity_class_entry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1138)
		p.Entity_class()
	}
	p.SetState(1140)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBOX {
		{
			p.SetState(1139)
			p.Match(vhdlParserBOX)
		}

	}

	return localctx
}

// IEntity_class_entry_listContext is an interface to support dynamic dispatch.
type IEntity_class_entry_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_class_entry_listContext differentiates from other interfaces.
	IsEntity_class_entry_listContext()
}

type Entity_class_entry_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_class_entry_listContext() *Entity_class_entry_listContext {
	var p = new(Entity_class_entry_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_class_entry_list
	return p
}

func (*Entity_class_entry_listContext) IsEntity_class_entry_listContext() {}

func NewEntity_class_entry_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_class_entry_listContext {
	var p = new(Entity_class_entry_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_class_entry_list

	return p
}

func (s *Entity_class_entry_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_class_entry_listContext) AllEntity_class_entry() []IEntity_class_entryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEntity_class_entryContext)(nil)).Elem())
	var tst = make([]IEntity_class_entryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEntity_class_entryContext)
		}
	}

	return tst
}

func (s *Entity_class_entry_listContext) Entity_class_entry(i int) IEntity_class_entryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_class_entryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEntity_class_entryContext)
}

func (s *Entity_class_entry_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Entity_class_entry_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Entity_class_entry_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_class_entry_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_class_entry_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_class_entry_list(s)
	}
}

func (s *Entity_class_entry_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_class_entry_list(s)
	}
}

func (s *Entity_class_entry_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitEntity_class_entry_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Entity_class_entry_list() (localctx IEntity_class_entry_listContext) {
	localctx = NewEntity_class_entry_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, vhdlParserRULE_entity_class_entry_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1142)
		p.Entity_class_entry()
	}
	p.SetState(1147)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(1143)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(1144)
			p.Entity_class_entry()
		}

		p.SetState(1149)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEntity_declarationContext is an interface to support dynamic dispatch.
type IEntity_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_declarationContext differentiates from other interfaces.
	IsEntity_declarationContext()
}

type Entity_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_declarationContext() *Entity_declarationContext {
	var p = new(Entity_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_declaration
	return p
}

func (*Entity_declarationContext) IsEntity_declarationContext() {}

func NewEntity_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_declarationContext {
	var p = new(Entity_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_declaration

	return p
}

func (s *Entity_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_declarationContext) AllENTITY() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserENTITY)
}

func (s *Entity_declarationContext) ENTITY(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserENTITY, i)
}

func (s *Entity_declarationContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Entity_declarationContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Entity_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Entity_declarationContext) Entity_header() IEntity_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_headerContext)
}

func (s *Entity_declarationContext) Entity_declarative_part() IEntity_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_declarative_partContext)
}

func (s *Entity_declarationContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Entity_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Entity_declarationContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(vhdlParserBEGIN, 0)
}

func (s *Entity_declarationContext) Entity_statement_part() IEntity_statement_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_statement_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_statement_partContext)
}

func (s *Entity_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_declaration(s)
	}
}

func (s *Entity_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_declaration(s)
	}
}

func (s *Entity_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitEntity_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Entity_declaration() (localctx IEntity_declarationContext) {
	localctx = NewEntity_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, vhdlParserRULE_entity_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1150)
		p.Match(vhdlParserENTITY)
	}
	{
		p.SetState(1151)
		p.Identifier()
	}
	{
		p.SetState(1152)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(1153)
		p.Entity_header()
	}
	{
		p.SetState(1154)
		p.Entity_declarative_part()
	}
	p.SetState(1157)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBEGIN {
		{
			p.SetState(1155)
			p.Match(vhdlParserBEGIN)
		}
		{
			p.SetState(1156)
			p.Entity_statement_part()
		}

	}
	{
		p.SetState(1159)
		p.Match(vhdlParserEND)
	}
	p.SetState(1161)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserENTITY {
		{
			p.SetState(1160)
			p.Match(vhdlParserENTITY)
		}

	}
	p.SetState(1164)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1163)
			p.Identifier()
		}

	}
	{
		p.SetState(1166)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IEntity_declarative_itemContext is an interface to support dynamic dispatch.
type IEntity_declarative_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_declarative_itemContext differentiates from other interfaces.
	IsEntity_declarative_itemContext()
}

type Entity_declarative_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_declarative_itemContext() *Entity_declarative_itemContext {
	var p = new(Entity_declarative_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_declarative_item
	return p
}

func (*Entity_declarative_itemContext) IsEntity_declarative_itemContext() {}

func NewEntity_declarative_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_declarative_itemContext {
	var p = new(Entity_declarative_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_declarative_item

	return p
}

func (s *Entity_declarative_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_declarative_itemContext) Subprogram_declaration() ISubprogram_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarationContext)
}

func (s *Entity_declarative_itemContext) Subprogram_body() ISubprogram_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_bodyContext)
}

func (s *Entity_declarative_itemContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Entity_declarative_itemContext) Subtype_declaration() ISubtype_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_declarationContext)
}

func (s *Entity_declarative_itemContext) Constant_declaration() IConstant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declarationContext)
}

func (s *Entity_declarative_itemContext) Signal_declaration() ISignal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_declarationContext)
}

func (s *Entity_declarative_itemContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Entity_declarative_itemContext) File_declaration() IFile_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_declarationContext)
}

func (s *Entity_declarative_itemContext) Alias_declaration() IAlias_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_declarationContext)
}

func (s *Entity_declarative_itemContext) Attribute_declaration() IAttribute_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_declarationContext)
}

func (s *Entity_declarative_itemContext) Attribute_specification() IAttribute_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_specificationContext)
}

func (s *Entity_declarative_itemContext) Disconnection_specification() IDisconnection_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisconnection_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisconnection_specificationContext)
}

func (s *Entity_declarative_itemContext) Step_limit_specification() IStep_limit_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStep_limit_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStep_limit_specificationContext)
}

func (s *Entity_declarative_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Entity_declarative_itemContext) Group_template_declaration() IGroup_template_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_template_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_template_declarationContext)
}

func (s *Entity_declarative_itemContext) Group_declaration() IGroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_declarationContext)
}

func (s *Entity_declarative_itemContext) Nature_declaration() INature_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INature_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INature_declarationContext)
}

func (s *Entity_declarative_itemContext) Subnature_declaration() ISubnature_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_declarationContext)
}

func (s *Entity_declarative_itemContext) Quantity_declaration() IQuantity_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantity_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantity_declarationContext)
}

func (s *Entity_declarative_itemContext) Terminal_declaration() ITerminal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminal_declarationContext)
}

func (s *Entity_declarative_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_declarative_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_declarative_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_declarative_item(s)
	}
}

func (s *Entity_declarative_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_declarative_item(s)
	}
}

func (s *Entity_declarative_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitEntity_declarative_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Entity_declarative_item() (localctx IEntity_declarative_itemContext) {
	localctx = NewEntity_declarative_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, vhdlParserRULE_entity_declarative_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1188)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1168)
			p.Subprogram_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1169)
			p.Subprogram_body()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1170)
			p.Type_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1171)
			p.Subtype_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1172)
			p.Constant_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1173)
			p.Signal_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1174)
			p.Variable_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1175)
			p.File_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1176)
			p.Alias_declaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1177)
			p.Attribute_declaration()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1178)
			p.Attribute_specification()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1179)
			p.Disconnection_specification()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1180)
			p.Step_limit_specification()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1181)
			p.Use_clause()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1182)
			p.Group_template_declaration()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1183)
			p.Group_declaration()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1184)
			p.Nature_declaration()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1185)
			p.Subnature_declaration()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1186)
			p.Quantity_declaration()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1187)
			p.Terminal_declaration()
		}

	}

	return localctx
}

// IEntity_declarative_partContext is an interface to support dynamic dispatch.
type IEntity_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_declarative_partContext differentiates from other interfaces.
	IsEntity_declarative_partContext()
}

type Entity_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_declarative_partContext() *Entity_declarative_partContext {
	var p = new(Entity_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_declarative_part
	return p
}

func (*Entity_declarative_partContext) IsEntity_declarative_partContext() {}

func NewEntity_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_declarative_partContext {
	var p = new(Entity_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_declarative_part

	return p
}

func (s *Entity_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_declarative_partContext) AllEntity_declarative_item() []IEntity_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEntity_declarative_itemContext)(nil)).Elem())
	var tst = make([]IEntity_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEntity_declarative_itemContext)
		}
	}

	return tst
}

func (s *Entity_declarative_partContext) Entity_declarative_item(i int) IEntity_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEntity_declarative_itemContext)
}

func (s *Entity_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_declarative_part(s)
	}
}

func (s *Entity_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_declarative_part(s)
	}
}

func (s *Entity_declarative_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitEntity_declarative_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Entity_declarative_part() (localctx IEntity_declarative_partContext) {
	localctx = NewEntity_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, vhdlParserRULE_entity_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1193)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserDISCONNECT)|(1<<vhdlParserFILE)|(1<<vhdlParserFUNCTION))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(vhdlParserGROUP-34))|(1<<(vhdlParserIMPURE-34))|(1<<(vhdlParserLIMIT-34))|(1<<(vhdlParserNATURE-34)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserQUANTITY-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSIGNAL-68))|(1<<(vhdlParserSUBNATURE-68))|(1<<(vhdlParserSUBTYPE-68))|(1<<(vhdlParserTERMINAL-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		{
			p.SetState(1190)
			p.Entity_declarative_item()
		}

		p.SetState(1195)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEntity_designatorContext is an interface to support dynamic dispatch.
type IEntity_designatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_designatorContext differentiates from other interfaces.
	IsEntity_designatorContext()
}

type Entity_designatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_designatorContext() *Entity_designatorContext {
	var p = new(Entity_designatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_designator
	return p
}

func (*Entity_designatorContext) IsEntity_designatorContext() {}

func NewEntity_designatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_designatorContext {
	var p = new(Entity_designatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_designator

	return p
}

func (s *Entity_designatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_designatorContext) Entity_tag() IEntity_tagContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_tagContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_tagContext)
}

func (s *Entity_designatorContext) Signature() ISignatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignatureContext)
}

func (s *Entity_designatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_designatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_designatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_designator(s)
	}
}

func (s *Entity_designatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_designator(s)
	}
}

func (s *Entity_designatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitEntity_designator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Entity_designator() (localctx IEntity_designatorContext) {
	localctx = NewEntity_designatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, vhdlParserRULE_entity_designator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1196)
		p.Entity_tag()
	}
	p.SetState(1198)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserLBRACKET {
		{
			p.SetState(1197)
			p.Signature()
		}

	}

	return localctx
}

// IEntity_headerContext is an interface to support dynamic dispatch.
type IEntity_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_headerContext differentiates from other interfaces.
	IsEntity_headerContext()
}

type Entity_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_headerContext() *Entity_headerContext {
	var p = new(Entity_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_header
	return p
}

func (*Entity_headerContext) IsEntity_headerContext() {}

func NewEntity_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_headerContext {
	var p = new(Entity_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_header

	return p
}

func (s *Entity_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_headerContext) Generic_clause() IGeneric_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneric_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneric_clauseContext)
}

func (s *Entity_headerContext) Port_clause() IPort_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_clauseContext)
}

func (s *Entity_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_header(s)
	}
}

func (s *Entity_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_header(s)
	}
}

func (s *Entity_headerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitEntity_header(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Entity_header() (localctx IEntity_headerContext) {
	localctx = NewEntity_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, vhdlParserRULE_entity_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1201)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserGENERIC {
		{
			p.SetState(1200)
			p.Generic_clause()
		}

	}
	p.SetState(1204)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPORT {
		{
			p.SetState(1203)
			p.Port_clause()
		}

	}

	return localctx
}

// IEntity_name_listContext is an interface to support dynamic dispatch.
type IEntity_name_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_name_listContext differentiates from other interfaces.
	IsEntity_name_listContext()
}

type Entity_name_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_name_listContext() *Entity_name_listContext {
	var p = new(Entity_name_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_name_list
	return p
}

func (*Entity_name_listContext) IsEntity_name_listContext() {}

func NewEntity_name_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_name_listContext {
	var p = new(Entity_name_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_name_list

	return p
}

func (s *Entity_name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_name_listContext) AllEntity_designator() []IEntity_designatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEntity_designatorContext)(nil)).Elem())
	var tst = make([]IEntity_designatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEntity_designatorContext)
		}
	}

	return tst
}

func (s *Entity_name_listContext) Entity_designator(i int) IEntity_designatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_designatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEntity_designatorContext)
}

func (s *Entity_name_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Entity_name_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Entity_name_listContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(vhdlParserOTHERS, 0)
}

func (s *Entity_name_listContext) ALL() antlr.TerminalNode {
	return s.GetToken(vhdlParserALL, 0)
}

func (s *Entity_name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_name_list(s)
	}
}

func (s *Entity_name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_name_list(s)
	}
}

func (s *Entity_name_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitEntity_name_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Entity_name_list() (localctx IEntity_name_listContext) {
	localctx = NewEntity_name_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, vhdlParserRULE_entity_name_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1216)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserCHARACTER_LITERAL, vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1206)
			p.Entity_designator()
		}
		p.SetState(1211)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == vhdlParserCOMMA {
			{
				p.SetState(1207)
				p.Match(vhdlParserCOMMA)
			}
			{
				p.SetState(1208)
				p.Entity_designator()
			}

			p.SetState(1213)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case vhdlParserOTHERS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1214)
			p.Match(vhdlParserOTHERS)
		}

	case vhdlParserALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1215)
			p.Match(vhdlParserALL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEntity_specificationContext is an interface to support dynamic dispatch.
type IEntity_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_specificationContext differentiates from other interfaces.
	IsEntity_specificationContext()
}

type Entity_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_specificationContext() *Entity_specificationContext {
	var p = new(Entity_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_specification
	return p
}

func (*Entity_specificationContext) IsEntity_specificationContext() {}

func NewEntity_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_specificationContext {
	var p = new(Entity_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_specification

	return p
}

func (s *Entity_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_specificationContext) Entity_name_list() IEntity_name_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_name_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_name_listContext)
}

func (s *Entity_specificationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Entity_specificationContext) Entity_class() IEntity_classContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_classContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_classContext)
}

func (s *Entity_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_specification(s)
	}
}

func (s *Entity_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_specification(s)
	}
}

func (s *Entity_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitEntity_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Entity_specification() (localctx IEntity_specificationContext) {
	localctx = NewEntity_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, vhdlParserRULE_entity_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1218)
		p.Entity_name_list()
	}
	{
		p.SetState(1219)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1220)
		p.Entity_class()
	}

	return localctx
}

// IEntity_statementContext is an interface to support dynamic dispatch.
type IEntity_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_statementContext differentiates from other interfaces.
	IsEntity_statementContext()
}

type Entity_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_statementContext() *Entity_statementContext {
	var p = new(Entity_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_statement
	return p
}

func (*Entity_statementContext) IsEntity_statementContext() {}

func NewEntity_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_statementContext {
	var p = new(Entity_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_statement

	return p
}

func (s *Entity_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_statementContext) Concurrent_assertion_statement() IConcurrent_assertion_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcurrent_assertion_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcurrent_assertion_statementContext)
}

func (s *Entity_statementContext) Process_statement() IProcess_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcess_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcess_statementContext)
}

func (s *Entity_statementContext) Concurrent_procedure_call_statement() IConcurrent_procedure_call_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcurrent_procedure_call_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcurrent_procedure_call_statementContext)
}

func (s *Entity_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_statement(s)
	}
}

func (s *Entity_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_statement(s)
	}
}

func (s *Entity_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitEntity_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Entity_statement() (localctx IEntity_statementContext) {
	localctx = NewEntity_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, vhdlParserRULE_entity_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1225)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1222)
			p.Concurrent_assertion_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1223)
			p.Process_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1224)
			p.Concurrent_procedure_call_statement()
		}

	}

	return localctx
}

// IEntity_statement_partContext is an interface to support dynamic dispatch.
type IEntity_statement_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_statement_partContext differentiates from other interfaces.
	IsEntity_statement_partContext()
}

type Entity_statement_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_statement_partContext() *Entity_statement_partContext {
	var p = new(Entity_statement_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_statement_part
	return p
}

func (*Entity_statement_partContext) IsEntity_statement_partContext() {}

func NewEntity_statement_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_statement_partContext {
	var p = new(Entity_statement_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_statement_part

	return p
}

func (s *Entity_statement_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_statement_partContext) AllEntity_statement() []IEntity_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEntity_statementContext)(nil)).Elem())
	var tst = make([]IEntity_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEntity_statementContext)
		}
	}

	return tst
}

func (s *Entity_statement_partContext) Entity_statement(i int) IEntity_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEntity_statementContext)
}

func (s *Entity_statement_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_statement_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_statement_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_statement_part(s)
	}
}

func (s *Entity_statement_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_statement_part(s)
	}
}

func (s *Entity_statement_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitEntity_statement_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Entity_statement_part() (localctx IEntity_statement_partContext) {
	localctx = NewEntity_statement_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, vhdlParserRULE_entity_statement_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1230)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserASSERT || _la == vhdlParserPOSTPONED || _la == vhdlParserPROCESS || _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1227)
			p.Entity_statement()
		}

		p.SetState(1232)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEntity_tagContext is an interface to support dynamic dispatch.
type IEntity_tagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_tagContext differentiates from other interfaces.
	IsEntity_tagContext()
}

type Entity_tagContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_tagContext() *Entity_tagContext {
	var p = new(Entity_tagContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_entity_tag
	return p
}

func (*Entity_tagContext) IsEntity_tagContext() {}

func NewEntity_tagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_tagContext {
	var p = new(Entity_tagContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_entity_tag

	return p
}

func (s *Entity_tagContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_tagContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Entity_tagContext) CHARACTER_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserCHARACTER_LITERAL, 0)
}

func (s *Entity_tagContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSTRING_LITERAL, 0)
}

func (s *Entity_tagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_tagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_tagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEntity_tag(s)
	}
}

func (s *Entity_tagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEntity_tag(s)
	}
}

func (s *Entity_tagContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitEntity_tag(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Entity_tag() (localctx IEntity_tagContext) {
	localctx = NewEntity_tagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, vhdlParserRULE_entity_tag)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1236)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1233)
			p.Identifier()
		}

	case vhdlParserCHARACTER_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1234)
			p.Match(vhdlParserCHARACTER_LITERAL)
		}

	case vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1235)
			p.Match(vhdlParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnumeration_literalContext is an interface to support dynamic dispatch.
type IEnumeration_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeration_literalContext differentiates from other interfaces.
	IsEnumeration_literalContext()
}

type Enumeration_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeration_literalContext() *Enumeration_literalContext {
	var p = new(Enumeration_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_enumeration_literal
	return p
}

func (*Enumeration_literalContext) IsEnumeration_literalContext() {}

func NewEnumeration_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enumeration_literalContext {
	var p = new(Enumeration_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_enumeration_literal

	return p
}

func (s *Enumeration_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Enumeration_literalContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Enumeration_literalContext) CHARACTER_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserCHARACTER_LITERAL, 0)
}

func (s *Enumeration_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enumeration_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enumeration_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEnumeration_literal(s)
	}
}

func (s *Enumeration_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEnumeration_literal(s)
	}
}

func (s *Enumeration_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitEnumeration_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Enumeration_literal() (localctx IEnumeration_literalContext) {
	localctx = NewEnumeration_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, vhdlParserRULE_enumeration_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1240)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1238)
			p.Identifier()
		}

	case vhdlParserCHARACTER_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1239)
			p.Match(vhdlParserCHARACTER_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnumeration_type_definitionContext is an interface to support dynamic dispatch.
type IEnumeration_type_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeration_type_definitionContext differentiates from other interfaces.
	IsEnumeration_type_definitionContext()
}

type Enumeration_type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeration_type_definitionContext() *Enumeration_type_definitionContext {
	var p = new(Enumeration_type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_enumeration_type_definition
	return p
}

func (*Enumeration_type_definitionContext) IsEnumeration_type_definitionContext() {}

func NewEnumeration_type_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enumeration_type_definitionContext {
	var p = new(Enumeration_type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_enumeration_type_definition

	return p
}

func (s *Enumeration_type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Enumeration_type_definitionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Enumeration_type_definitionContext) AllEnumeration_literal() []IEnumeration_literalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumeration_literalContext)(nil)).Elem())
	var tst = make([]IEnumeration_literalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumeration_literalContext)
		}
	}

	return tst
}

func (s *Enumeration_type_definitionContext) Enumeration_literal(i int) IEnumeration_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeration_literalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumeration_literalContext)
}

func (s *Enumeration_type_definitionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Enumeration_type_definitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Enumeration_type_definitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Enumeration_type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enumeration_type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enumeration_type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterEnumeration_type_definition(s)
	}
}

func (s *Enumeration_type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitEnumeration_type_definition(s)
	}
}

func (s *Enumeration_type_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitEnumeration_type_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Enumeration_type_definition() (localctx IEnumeration_type_definitionContext) {
	localctx = NewEnumeration_type_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, vhdlParserRULE_enumeration_type_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1242)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1243)
		p.Enumeration_literal()
	}
	p.SetState(1248)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(1244)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(1245)
			p.Enumeration_literal()
		}

		p.SetState(1250)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1251)
		p.Match(vhdlParserRPAREN)
	}

	return localctx
}

// IExit_statementContext is an interface to support dynamic dispatch.
type IExit_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExit_statementContext differentiates from other interfaces.
	IsExit_statementContext()
}

type Exit_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExit_statementContext() *Exit_statementContext {
	var p = new(Exit_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_exit_statement
	return p
}

func (*Exit_statementContext) IsExit_statementContext() {}

func NewExit_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exit_statementContext {
	var p = new(Exit_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_exit_statement

	return p
}

func (s *Exit_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Exit_statementContext) EXIT() antlr.TerminalNode {
	return s.GetToken(vhdlParserEXIT, 0)
}

func (s *Exit_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Exit_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Exit_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Exit_statementContext) WHEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserWHEN, 0)
}

func (s *Exit_statementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Exit_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exit_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exit_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterExit_statement(s)
	}
}

func (s *Exit_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitExit_statement(s)
	}
}

func (s *Exit_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitExit_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Exit_statement() (localctx IExit_statementContext) {
	localctx = NewExit_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, vhdlParserRULE_exit_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1254)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1253)
			p.Label_colon()
		}

	}
	{
		p.SetState(1256)
		p.Match(vhdlParserEXIT)
	}
	p.SetState(1258)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1257)
			p.Identifier()
		}

	}
	p.SetState(1262)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserWHEN {
		{
			p.SetState(1260)
			p.Match(vhdlParserWHEN)
		}
		{
			p.SetState(1261)
			p.Condition()
		}

	}
	{
		p.SetState(1264)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) AllRelation() []IRelationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationContext)(nil)).Elem())
	var tst = make([]IRelationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Relation(i int) IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *ExpressionContext) AllLogical_operator() []ILogical_operatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILogical_operatorContext)(nil)).Elem())
	var tst = make([]ILogical_operatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILogical_operatorContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Logical_operator(i int) ILogical_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_operatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILogical_operatorContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, vhdlParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1266)
		p.Relation()
	}
	p.SetState(1272)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1267)
				p.Logical_operator()
			}
			{
				p.SetState(1268)
				p.Relation()
			}

		}
		p.SetState(1274)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext())
	}

	return localctx
}

// IFactorContext is an interface to support dynamic dispatch.
type IFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFactorContext differentiates from other interfaces.
	IsFactorContext()
}

type FactorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactorContext() *FactorContext {
	var p = new(FactorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_factor
	return p
}

func (*FactorContext) IsFactorContext() {}

func NewFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FactorContext {
	var p = new(FactorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_factor

	return p
}

func (s *FactorContext) GetParser() antlr.Parser { return s.parser }

func (s *FactorContext) AllPrimary() []IPrimaryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrimaryContext)(nil)).Elem())
	var tst = make([]IPrimaryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrimaryContext)
		}
	}

	return tst
}

func (s *FactorContext) Primary(i int) IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *FactorContext) DOUBLESTAR() antlr.TerminalNode {
	return s.GetToken(vhdlParserDOUBLESTAR, 0)
}

func (s *FactorContext) ABS() antlr.TerminalNode {
	return s.GetToken(vhdlParserABS, 0)
}

func (s *FactorContext) NOT() antlr.TerminalNode {
	return s.GetToken(vhdlParserNOT, 0)
}

func (s *FactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFactor(s)
	}
}

func (s *FactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFactor(s)
	}
}

func (s *FactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Factor() (localctx IFactorContext) {
	localctx = NewFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, vhdlParserRULE_factor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1284)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserNEW, vhdlParserNULL, vhdlParserBASE_LITERAL, vhdlParserBIT_STRING_LITERAL, vhdlParserREAL_LITERAL, vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserCHARACTER_LITERAL, vhdlParserSTRING_LITERAL, vhdlParserLPAREN, vhdlParserINTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1275)
			p.Primary()
		}
		p.SetState(1278)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1276)
				p.Match(vhdlParserDOUBLESTAR)
			}
			{
				p.SetState(1277)
				p.Primary()
			}

		}

	case vhdlParserABS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1280)
			p.Match(vhdlParserABS)
		}
		{
			p.SetState(1281)
			p.Primary()
		}

	case vhdlParserNOT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1282)
			p.Match(vhdlParserNOT)
		}
		{
			p.SetState(1283)
			p.Primary()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFile_declarationContext is an interface to support dynamic dispatch.
type IFile_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_declarationContext differentiates from other interfaces.
	IsFile_declarationContext()
}

type File_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_declarationContext() *File_declarationContext {
	var p = new(File_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_file_declaration
	return p
}

func (*File_declarationContext) IsFile_declarationContext() {}

func NewFile_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_declarationContext {
	var p = new(File_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_file_declaration

	return p
}

func (s *File_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *File_declarationContext) FILE() antlr.TerminalNode {
	return s.GetToken(vhdlParserFILE, 0)
}

func (s *File_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *File_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *File_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *File_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *File_declarationContext) File_open_information() IFile_open_informationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_open_informationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_open_informationContext)
}

func (s *File_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFile_declaration(s)
	}
}

func (s *File_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFile_declaration(s)
	}
}

func (s *File_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitFile_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) File_declaration() (localctx IFile_declarationContext) {
	localctx = NewFile_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, vhdlParserRULE_file_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1286)
		p.Match(vhdlParserFILE)
	}
	{
		p.SetState(1287)
		p.Identifier_list()
	}
	{
		p.SetState(1288)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1289)
		p.Subtype_indication()
	}
	p.SetState(1291)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIS || _la == vhdlParserOPEN {
		{
			p.SetState(1290)
			p.File_open_information()
		}

	}
	{
		p.SetState(1293)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IFile_logical_nameContext is an interface to support dynamic dispatch.
type IFile_logical_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_logical_nameContext differentiates from other interfaces.
	IsFile_logical_nameContext()
}

type File_logical_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_logical_nameContext() *File_logical_nameContext {
	var p = new(File_logical_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_file_logical_name
	return p
}

func (*File_logical_nameContext) IsFile_logical_nameContext() {}

func NewFile_logical_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_logical_nameContext {
	var p = new(File_logical_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_file_logical_name

	return p
}

func (s *File_logical_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *File_logical_nameContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *File_logical_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_logical_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_logical_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFile_logical_name(s)
	}
}

func (s *File_logical_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFile_logical_name(s)
	}
}

func (s *File_logical_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitFile_logical_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) File_logical_name() (localctx IFile_logical_nameContext) {
	localctx = NewFile_logical_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, vhdlParserRULE_file_logical_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1295)
		p.Expression()
	}

	return localctx
}

// IFile_open_informationContext is an interface to support dynamic dispatch.
type IFile_open_informationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_open_informationContext differentiates from other interfaces.
	IsFile_open_informationContext()
}

type File_open_informationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_open_informationContext() *File_open_informationContext {
	var p = new(File_open_informationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_file_open_information
	return p
}

func (*File_open_informationContext) IsFile_open_informationContext() {}

func NewFile_open_informationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_open_informationContext {
	var p = new(File_open_informationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_file_open_information

	return p
}

func (s *File_open_informationContext) GetParser() antlr.Parser { return s.parser }

func (s *File_open_informationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *File_open_informationContext) File_logical_name() IFile_logical_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_logical_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_logical_nameContext)
}

func (s *File_open_informationContext) OPEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserOPEN, 0)
}

func (s *File_open_informationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *File_open_informationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_open_informationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_open_informationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFile_open_information(s)
	}
}

func (s *File_open_informationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFile_open_information(s)
	}
}

func (s *File_open_informationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitFile_open_information(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) File_open_information() (localctx IFile_open_informationContext) {
	localctx = NewFile_open_informationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, vhdlParserRULE_file_open_information)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1299)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserOPEN {
		{
			p.SetState(1297)
			p.Match(vhdlParserOPEN)
		}
		{
			p.SetState(1298)
			p.Expression()
		}

	}
	{
		p.SetState(1301)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(1302)
		p.File_logical_name()
	}

	return localctx
}

// IFile_type_definitionContext is an interface to support dynamic dispatch.
type IFile_type_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_type_definitionContext differentiates from other interfaces.
	IsFile_type_definitionContext()
}

type File_type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_type_definitionContext() *File_type_definitionContext {
	var p = new(File_type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_file_type_definition
	return p
}

func (*File_type_definitionContext) IsFile_type_definitionContext() {}

func NewFile_type_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_type_definitionContext {
	var p = new(File_type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_file_type_definition

	return p
}

func (s *File_type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *File_type_definitionContext) FILE() antlr.TerminalNode {
	return s.GetToken(vhdlParserFILE, 0)
}

func (s *File_type_definitionContext) OF() antlr.TerminalNode {
	return s.GetToken(vhdlParserOF, 0)
}

func (s *File_type_definitionContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *File_type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFile_type_definition(s)
	}
}

func (s *File_type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFile_type_definition(s)
	}
}

func (s *File_type_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitFile_type_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) File_type_definition() (localctx IFile_type_definitionContext) {
	localctx = NewFile_type_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, vhdlParserRULE_file_type_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1304)
		p.Match(vhdlParserFILE)
	}
	{
		p.SetState(1305)
		p.Match(vhdlParserOF)
	}
	{
		p.SetState(1306)
		p.Subtype_indication()
	}

	return localctx
}

// IFormal_parameter_listContext is an interface to support dynamic dispatch.
type IFormal_parameter_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormal_parameter_listContext differentiates from other interfaces.
	IsFormal_parameter_listContext()
}

type Formal_parameter_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormal_parameter_listContext() *Formal_parameter_listContext {
	var p = new(Formal_parameter_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_formal_parameter_list
	return p
}

func (*Formal_parameter_listContext) IsFormal_parameter_listContext() {}

func NewFormal_parameter_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Formal_parameter_listContext {
	var p = new(Formal_parameter_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_formal_parameter_list

	return p
}

func (s *Formal_parameter_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Formal_parameter_listContext) Interface_list() IInterface_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_listContext)
}

func (s *Formal_parameter_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Formal_parameter_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Formal_parameter_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFormal_parameter_list(s)
	}
}

func (s *Formal_parameter_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFormal_parameter_list(s)
	}
}

func (s *Formal_parameter_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitFormal_parameter_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Formal_parameter_list() (localctx IFormal_parameter_listContext) {
	localctx = NewFormal_parameter_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, vhdlParserRULE_formal_parameter_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1308)
		p.Interface_list()
	}

	return localctx
}

// IFormal_partContext is an interface to support dynamic dispatch.
type IFormal_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormal_partContext differentiates from other interfaces.
	IsFormal_partContext()
}

type Formal_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormal_partContext() *Formal_partContext {
	var p = new(Formal_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_formal_part
	return p
}

func (*Formal_partContext) IsFormal_partContext() {}

func NewFormal_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Formal_partContext {
	var p = new(Formal_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_formal_part

	return p
}

func (s *Formal_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Formal_partContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Formal_partContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Formal_partContext) Explicit_range() IExplicit_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicit_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplicit_rangeContext)
}

func (s *Formal_partContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Formal_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Formal_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Formal_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFormal_part(s)
	}
}

func (s *Formal_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFormal_part(s)
	}
}

func (s *Formal_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitFormal_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Formal_part() (localctx IFormal_partContext) {
	localctx = NewFormal_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, vhdlParserRULE_formal_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1316)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1310)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1311)
			p.Identifier()
		}
		{
			p.SetState(1312)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(1313)
			p.Explicit_range()
		}
		{
			p.SetState(1314)
			p.Match(vhdlParserRPAREN)
		}

	}

	return localctx
}

// IFree_quantity_declarationContext is an interface to support dynamic dispatch.
type IFree_quantity_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFree_quantity_declarationContext differentiates from other interfaces.
	IsFree_quantity_declarationContext()
}

type Free_quantity_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFree_quantity_declarationContext() *Free_quantity_declarationContext {
	var p = new(Free_quantity_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_free_quantity_declaration
	return p
}

func (*Free_quantity_declarationContext) IsFree_quantity_declarationContext() {}

func NewFree_quantity_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Free_quantity_declarationContext {
	var p = new(Free_quantity_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_free_quantity_declaration

	return p
}

func (s *Free_quantity_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Free_quantity_declarationContext) QUANTITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserQUANTITY, 0)
}

func (s *Free_quantity_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Free_quantity_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Free_quantity_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Free_quantity_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Free_quantity_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Free_quantity_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Free_quantity_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Free_quantity_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Free_quantity_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFree_quantity_declaration(s)
	}
}

func (s *Free_quantity_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFree_quantity_declaration(s)
	}
}

func (s *Free_quantity_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitFree_quantity_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Free_quantity_declaration() (localctx IFree_quantity_declarationContext) {
	localctx = NewFree_quantity_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, vhdlParserRULE_free_quantity_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1318)
		p.Match(vhdlParserQUANTITY)
	}
	{
		p.SetState(1319)
		p.Identifier_list()
	}
	{
		p.SetState(1320)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1321)
		p.Subtype_indication()
	}
	p.SetState(1324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(1322)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(1323)
			p.Expression()
		}

	}
	{
		p.SetState(1326)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IGenerate_statementContext is an interface to support dynamic dispatch.
type IGenerate_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_statementContext differentiates from other interfaces.
	IsGenerate_statementContext()
}

type Generate_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_statementContext() *Generate_statementContext {
	var p = new(Generate_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_generate_statement
	return p
}

func (*Generate_statementContext) IsGenerate_statementContext() {}

func NewGenerate_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_statementContext {
	var p = new(Generate_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_generate_statement

	return p
}

func (s *Generate_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Generate_statementContext) Generation_scheme() IGeneration_schemeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneration_schemeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneration_schemeContext)
}

func (s *Generate_statementContext) AllGENERATE() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserGENERATE)
}

func (s *Generate_statementContext) GENERATE(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserGENERATE, i)
}

func (s *Generate_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Generate_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Generate_statementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(vhdlParserBEGIN, 0)
}

func (s *Generate_statementContext) AllArchitecture_statement() []IArchitecture_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArchitecture_statementContext)(nil)).Elem())
	var tst = make([]IArchitecture_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArchitecture_statementContext)
		}
	}

	return tst
}

func (s *Generate_statementContext) Architecture_statement(i int) IArchitecture_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArchitecture_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArchitecture_statementContext)
}

func (s *Generate_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Generate_statementContext) AllBlock_declarative_item() []IBlock_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_declarative_itemContext)(nil)).Elem())
	var tst = make([]IBlock_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_declarative_itemContext)
		}
	}

	return tst
}

func (s *Generate_statementContext) Block_declarative_item(i int) IBlock_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_declarative_itemContext)
}

func (s *Generate_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGenerate_statement(s)
	}
}

func (s *Generate_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGenerate_statement(s)
	}
}

func (s *Generate_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitGenerate_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Generate_statement() (localctx IGenerate_statementContext) {
	localctx = NewGenerate_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, vhdlParserRULE_generate_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1328)
		p.Label_colon()
	}
	{
		p.SetState(1329)
		p.Generation_scheme()
	}
	{
		p.SetState(1330)
		p.Match(vhdlParserGENERATE)
	}
	p.SetState(1338)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserBEGIN)|(1<<vhdlParserCOMPONENT)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserDISCONNECT)|(1<<vhdlParserFILE)|(1<<vhdlParserFOR)|(1<<vhdlParserFUNCTION))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(vhdlParserGROUP-34))|(1<<(vhdlParserIMPURE-34))|(1<<(vhdlParserLIMIT-34))|(1<<(vhdlParserNATURE-34)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserQUANTITY-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSIGNAL-68))|(1<<(vhdlParserSUBNATURE-68))|(1<<(vhdlParserSUBTYPE-68))|(1<<(vhdlParserTERMINAL-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		p.SetState(1334)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserCOMPONENT)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserDISCONNECT)|(1<<vhdlParserFILE)|(1<<vhdlParserFOR)|(1<<vhdlParserFUNCTION))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(vhdlParserGROUP-34))|(1<<(vhdlParserIMPURE-34))|(1<<(vhdlParserLIMIT-34))|(1<<(vhdlParserNATURE-34)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserQUANTITY-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSIGNAL-68))|(1<<(vhdlParserSUBNATURE-68))|(1<<(vhdlParserSUBTYPE-68))|(1<<(vhdlParserTERMINAL-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
			{
				p.SetState(1331)
				p.Block_declarative_item()
			}

			p.SetState(1336)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1337)
			p.Match(vhdlParserBEGIN)
		}

	}
	p.SetState(1343)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserABS)|(1<<vhdlParserASSERT)|(1<<vhdlParserBREAK)|(1<<vhdlParserCASE))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(vhdlParserIF-36))|(1<<(vhdlParserNEW-36))|(1<<(vhdlParserNOT-36))|(1<<(vhdlParserNULL-36))|(1<<(vhdlParserPOSTPONED-36))|(1<<(vhdlParserPROCESS-36)))) != 0) || _la == vhdlParserPROCEDURAL || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(vhdlParserWITH-107))|(1<<(vhdlParserBASE_LITERAL-107))|(1<<(vhdlParserBIT_STRING_LITERAL-107))|(1<<(vhdlParserREAL_LITERAL-107))|(1<<(vhdlParserBASIC_IDENTIFIER-107))|(1<<(vhdlParserEXTENDED_IDENTIFIER-107))|(1<<(vhdlParserCHARACTER_LITERAL-107))|(1<<(vhdlParserSTRING_LITERAL-107)))) != 0) || (((_la-141)&-(0x1f+1)) == 0 && ((1<<uint((_la-141)))&((1<<(vhdlParserLPAREN-141))|(1<<(vhdlParserPLUS-141))|(1<<(vhdlParserMINUS-141))|(1<<(vhdlParserINTEGER-141)))) != 0) {
		{
			p.SetState(1340)
			p.Architecture_statement()
		}

		p.SetState(1345)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1346)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(1347)
		p.Match(vhdlParserGENERATE)
	}
	p.SetState(1349)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1348)
			p.Identifier()
		}

	}
	{
		p.SetState(1351)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IGeneration_schemeContext is an interface to support dynamic dispatch.
type IGeneration_schemeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneration_schemeContext differentiates from other interfaces.
	IsGeneration_schemeContext()
}

type Generation_schemeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneration_schemeContext() *Generation_schemeContext {
	var p = new(Generation_schemeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_generation_scheme
	return p
}

func (*Generation_schemeContext) IsGeneration_schemeContext() {}

func NewGeneration_schemeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generation_schemeContext {
	var p = new(Generation_schemeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_generation_scheme

	return p
}

func (s *Generation_schemeContext) GetParser() antlr.Parser { return s.parser }

func (s *Generation_schemeContext) FOR() antlr.TerminalNode {
	return s.GetToken(vhdlParserFOR, 0)
}

func (s *Generation_schemeContext) Parameter_specification() IParameter_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_specificationContext)
}

func (s *Generation_schemeContext) IF() antlr.TerminalNode {
	return s.GetToken(vhdlParserIF, 0)
}

func (s *Generation_schemeContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Generation_schemeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generation_schemeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generation_schemeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGeneration_scheme(s)
	}
}

func (s *Generation_schemeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGeneration_scheme(s)
	}
}

func (s *Generation_schemeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitGeneration_scheme(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Generation_scheme() (localctx IGeneration_schemeContext) {
	localctx = NewGeneration_schemeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, vhdlParserRULE_generation_scheme)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1357)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1353)
			p.Match(vhdlParserFOR)
		}
		{
			p.SetState(1354)
			p.Parameter_specification()
		}

	case vhdlParserIF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1355)
			p.Match(vhdlParserIF)
		}
		{
			p.SetState(1356)
			p.Condition()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGeneric_clauseContext is an interface to support dynamic dispatch.
type IGeneric_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneric_clauseContext differentiates from other interfaces.
	IsGeneric_clauseContext()
}

type Generic_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneric_clauseContext() *Generic_clauseContext {
	var p = new(Generic_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_generic_clause
	return p
}

func (*Generic_clauseContext) IsGeneric_clauseContext() {}

func NewGeneric_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generic_clauseContext {
	var p = new(Generic_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_generic_clause

	return p
}

func (s *Generic_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Generic_clauseContext) GENERIC() antlr.TerminalNode {
	return s.GetToken(vhdlParserGENERIC, 0)
}

func (s *Generic_clauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Generic_clauseContext) Generic_list() IGeneric_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneric_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneric_listContext)
}

func (s *Generic_clauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Generic_clauseContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Generic_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generic_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generic_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGeneric_clause(s)
	}
}

func (s *Generic_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGeneric_clause(s)
	}
}

func (s *Generic_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitGeneric_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Generic_clause() (localctx IGeneric_clauseContext) {
	localctx = NewGeneric_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, vhdlParserRULE_generic_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1359)
		p.Match(vhdlParserGENERIC)
	}
	{
		p.SetState(1360)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1361)
		p.Generic_list()
	}
	{
		p.SetState(1362)
		p.Match(vhdlParserRPAREN)
	}
	{
		p.SetState(1363)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IGeneric_listContext is an interface to support dynamic dispatch.
type IGeneric_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneric_listContext differentiates from other interfaces.
	IsGeneric_listContext()
}

type Generic_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneric_listContext() *Generic_listContext {
	var p = new(Generic_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_generic_list
	return p
}

func (*Generic_listContext) IsGeneric_listContext() {}

func NewGeneric_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generic_listContext {
	var p = new(Generic_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_generic_list

	return p
}

func (s *Generic_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Generic_listContext) AllInterface_constant_declaration() []IInterface_constant_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_constant_declarationContext)(nil)).Elem())
	var tst = make([]IInterface_constant_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_constant_declarationContext)
		}
	}

	return tst
}

func (s *Generic_listContext) Interface_constant_declaration(i int) IInterface_constant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_constant_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_constant_declarationContext)
}

func (s *Generic_listContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserSEMI)
}

func (s *Generic_listContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, i)
}

func (s *Generic_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generic_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generic_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGeneric_list(s)
	}
}

func (s *Generic_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGeneric_list(s)
	}
}

func (s *Generic_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitGeneric_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Generic_list() (localctx IGeneric_listContext) {
	localctx = NewGeneric_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, vhdlParserRULE_generic_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1365)
		p.Interface_constant_declaration()
	}
	p.SetState(1370)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserSEMI {
		{
			p.SetState(1366)
			p.Match(vhdlParserSEMI)
		}
		{
			p.SetState(1367)
			p.Interface_constant_declaration()
		}

		p.SetState(1372)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGeneric_map_aspectContext is an interface to support dynamic dispatch.
type IGeneric_map_aspectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneric_map_aspectContext differentiates from other interfaces.
	IsGeneric_map_aspectContext()
}

type Generic_map_aspectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneric_map_aspectContext() *Generic_map_aspectContext {
	var p = new(Generic_map_aspectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_generic_map_aspect
	return p
}

func (*Generic_map_aspectContext) IsGeneric_map_aspectContext() {}

func NewGeneric_map_aspectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generic_map_aspectContext {
	var p = new(Generic_map_aspectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_generic_map_aspect

	return p
}

func (s *Generic_map_aspectContext) GetParser() antlr.Parser { return s.parser }

func (s *Generic_map_aspectContext) GENERIC() antlr.TerminalNode {
	return s.GetToken(vhdlParserGENERIC, 0)
}

func (s *Generic_map_aspectContext) MAP() antlr.TerminalNode {
	return s.GetToken(vhdlParserMAP, 0)
}

func (s *Generic_map_aspectContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Generic_map_aspectContext) Association_list() IAssociation_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssociation_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssociation_listContext)
}

func (s *Generic_map_aspectContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Generic_map_aspectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generic_map_aspectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generic_map_aspectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGeneric_map_aspect(s)
	}
}

func (s *Generic_map_aspectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGeneric_map_aspect(s)
	}
}

func (s *Generic_map_aspectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitGeneric_map_aspect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Generic_map_aspect() (localctx IGeneric_map_aspectContext) {
	localctx = NewGeneric_map_aspectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, vhdlParserRULE_generic_map_aspect)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1373)
		p.Match(vhdlParserGENERIC)
	}
	{
		p.SetState(1374)
		p.Match(vhdlParserMAP)
	}
	{
		p.SetState(1375)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1376)
		p.Association_list()
	}
	{
		p.SetState(1377)
		p.Match(vhdlParserRPAREN)
	}

	return localctx
}

// IGroup_constituentContext is an interface to support dynamic dispatch.
type IGroup_constituentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroup_constituentContext differentiates from other interfaces.
	IsGroup_constituentContext()
}

type Group_constituentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_constituentContext() *Group_constituentContext {
	var p = new(Group_constituentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_group_constituent
	return p
}

func (*Group_constituentContext) IsGroup_constituentContext() {}

func NewGroup_constituentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_constituentContext {
	var p = new(Group_constituentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_group_constituent

	return p
}

func (s *Group_constituentContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_constituentContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Group_constituentContext) CHARACTER_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserCHARACTER_LITERAL, 0)
}

func (s *Group_constituentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_constituentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_constituentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGroup_constituent(s)
	}
}

func (s *Group_constituentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGroup_constituent(s)
	}
}

func (s *Group_constituentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitGroup_constituent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Group_constituent() (localctx IGroup_constituentContext) {
	localctx = NewGroup_constituentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, vhdlParserRULE_group_constituent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1381)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1379)
			p.Name()
		}

	case vhdlParserCHARACTER_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1380)
			p.Match(vhdlParserCHARACTER_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGroup_constituent_listContext is an interface to support dynamic dispatch.
type IGroup_constituent_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroup_constituent_listContext differentiates from other interfaces.
	IsGroup_constituent_listContext()
}

type Group_constituent_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_constituent_listContext() *Group_constituent_listContext {
	var p = new(Group_constituent_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_group_constituent_list
	return p
}

func (*Group_constituent_listContext) IsGroup_constituent_listContext() {}

func NewGroup_constituent_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_constituent_listContext {
	var p = new(Group_constituent_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_group_constituent_list

	return p
}

func (s *Group_constituent_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_constituent_listContext) AllGroup_constituent() []IGroup_constituentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGroup_constituentContext)(nil)).Elem())
	var tst = make([]IGroup_constituentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGroup_constituentContext)
		}
	}

	return tst
}

func (s *Group_constituent_listContext) Group_constituent(i int) IGroup_constituentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_constituentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGroup_constituentContext)
}

func (s *Group_constituent_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Group_constituent_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Group_constituent_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_constituent_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_constituent_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGroup_constituent_list(s)
	}
}

func (s *Group_constituent_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGroup_constituent_list(s)
	}
}

func (s *Group_constituent_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitGroup_constituent_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Group_constituent_list() (localctx IGroup_constituent_listContext) {
	localctx = NewGroup_constituent_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, vhdlParserRULE_group_constituent_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1383)
		p.Group_constituent()
	}
	p.SetState(1388)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(1384)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(1385)
			p.Group_constituent()
		}

		p.SetState(1390)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGroup_declarationContext is an interface to support dynamic dispatch.
type IGroup_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroup_declarationContext differentiates from other interfaces.
	IsGroup_declarationContext()
}

type Group_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_declarationContext() *Group_declarationContext {
	var p = new(Group_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_group_declaration
	return p
}

func (*Group_declarationContext) IsGroup_declarationContext() {}

func NewGroup_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_declarationContext {
	var p = new(Group_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_group_declaration

	return p
}

func (s *Group_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_declarationContext) GROUP() antlr.TerminalNode {
	return s.GetToken(vhdlParserGROUP, 0)
}

func (s *Group_declarationContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Group_declarationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Group_declarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Group_declarationContext) Group_constituent_list() IGroup_constituent_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_constituent_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_constituent_listContext)
}

func (s *Group_declarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Group_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Group_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGroup_declaration(s)
	}
}

func (s *Group_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGroup_declaration(s)
	}
}

func (s *Group_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitGroup_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Group_declaration() (localctx IGroup_declarationContext) {
	localctx = NewGroup_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, vhdlParserRULE_group_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1391)
		p.Match(vhdlParserGROUP)
	}
	{
		p.SetState(1392)
		p.Label_colon()
	}
	{
		p.SetState(1393)
		p.Name()
	}
	{
		p.SetState(1394)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1395)
		p.Group_constituent_list()
	}
	{
		p.SetState(1396)
		p.Match(vhdlParserRPAREN)
	}
	{
		p.SetState(1397)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IGroup_template_declarationContext is an interface to support dynamic dispatch.
type IGroup_template_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroup_template_declarationContext differentiates from other interfaces.
	IsGroup_template_declarationContext()
}

type Group_template_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_template_declarationContext() *Group_template_declarationContext {
	var p = new(Group_template_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_group_template_declaration
	return p
}

func (*Group_template_declarationContext) IsGroup_template_declarationContext() {}

func NewGroup_template_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_template_declarationContext {
	var p = new(Group_template_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_group_template_declaration

	return p
}

func (s *Group_template_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_template_declarationContext) GROUP() antlr.TerminalNode {
	return s.GetToken(vhdlParserGROUP, 0)
}

func (s *Group_template_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Group_template_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Group_template_declarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Group_template_declarationContext) Entity_class_entry_list() IEntity_class_entry_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_class_entry_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_class_entry_listContext)
}

func (s *Group_template_declarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Group_template_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Group_template_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_template_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_template_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGroup_template_declaration(s)
	}
}

func (s *Group_template_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGroup_template_declaration(s)
	}
}

func (s *Group_template_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitGroup_template_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Group_template_declaration() (localctx IGroup_template_declarationContext) {
	localctx = NewGroup_template_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, vhdlParserRULE_group_template_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1399)
		p.Match(vhdlParserGROUP)
	}
	{
		p.SetState(1400)
		p.Identifier()
	}
	{
		p.SetState(1401)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(1402)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1403)
		p.Entity_class_entry_list()
	}
	{
		p.SetState(1404)
		p.Match(vhdlParserRPAREN)
	}
	{
		p.SetState(1405)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IGuarded_signal_specificationContext is an interface to support dynamic dispatch.
type IGuarded_signal_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGuarded_signal_specificationContext differentiates from other interfaces.
	IsGuarded_signal_specificationContext()
}

type Guarded_signal_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGuarded_signal_specificationContext() *Guarded_signal_specificationContext {
	var p = new(Guarded_signal_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_guarded_signal_specification
	return p
}

func (*Guarded_signal_specificationContext) IsGuarded_signal_specificationContext() {}

func NewGuarded_signal_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Guarded_signal_specificationContext {
	var p = new(Guarded_signal_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_guarded_signal_specification

	return p
}

func (s *Guarded_signal_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Guarded_signal_specificationContext) Signal_list() ISignal_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_listContext)
}

func (s *Guarded_signal_specificationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Guarded_signal_specificationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Guarded_signal_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Guarded_signal_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Guarded_signal_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterGuarded_signal_specification(s)
	}
}

func (s *Guarded_signal_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitGuarded_signal_specification(s)
	}
}

func (s *Guarded_signal_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitGuarded_signal_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Guarded_signal_specification() (localctx IGuarded_signal_specificationContext) {
	localctx = NewGuarded_signal_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, vhdlParserRULE_guarded_signal_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1407)
		p.Signal_list()
	}
	{
		p.SetState(1408)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1409)
		p.Name()
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) BASIC_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(vhdlParserBASIC_IDENTIFIER, 0)
}

func (s *IdentifierContext) EXTENDED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(vhdlParserEXTENDED_IDENTIFIER, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, vhdlParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1411)
	_la = p.GetTokenStream().LA(1)

	if !(_la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IIdentifier_listContext is an interface to support dynamic dispatch.
type IIdentifier_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifier_listContext differentiates from other interfaces.
	IsIdentifier_listContext()
}

type Identifier_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifier_listContext() *Identifier_listContext {
	var p = new(Identifier_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_identifier_list
	return p
}

func (*Identifier_listContext) IsIdentifier_listContext() {}

func NewIdentifier_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Identifier_listContext {
	var p = new(Identifier_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_identifier_list

	return p
}

func (s *Identifier_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Identifier_listContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Identifier_listContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Identifier_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Identifier_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Identifier_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Identifier_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Identifier_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterIdentifier_list(s)
	}
}

func (s *Identifier_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitIdentifier_list(s)
	}
}

func (s *Identifier_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitIdentifier_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Identifier_list() (localctx IIdentifier_listContext) {
	localctx = NewIdentifier_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, vhdlParserRULE_identifier_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1413)
		p.Identifier()
	}
	p.SetState(1418)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(1414)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(1415)
			p.Identifier()
		}

		p.SetState(1420)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIf_statementContext is an interface to support dynamic dispatch.
type IIf_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_statementContext differentiates from other interfaces.
	IsIf_statementContext()
}

type If_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_statementContext() *If_statementContext {
	var p = new(If_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_if_statement
	return p
}

func (*If_statementContext) IsIf_statementContext() {}

func NewIf_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_statementContext {
	var p = new(If_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_if_statement

	return p
}

func (s *If_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *If_statementContext) AllIF() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserIF)
}

func (s *If_statementContext) IF(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserIF, i)
}

func (s *If_statementContext) AllCondition() []IConditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConditionContext)(nil)).Elem())
	var tst = make([]IConditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConditionContext)
		}
	}

	return tst
}

func (s *If_statementContext) Condition(i int) IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *If_statementContext) AllTHEN() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserTHEN)
}

func (s *If_statementContext) THEN(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserTHEN, i)
}

func (s *If_statementContext) AllSequence_of_statements() []ISequence_of_statementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequence_of_statementsContext)(nil)).Elem())
	var tst = make([]ISequence_of_statementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequence_of_statementsContext)
		}
	}

	return tst
}

func (s *If_statementContext) Sequence_of_statements(i int) ISequence_of_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_of_statementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequence_of_statementsContext)
}

func (s *If_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *If_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *If_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *If_statementContext) AllELSIF() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserELSIF)
}

func (s *If_statementContext) ELSIF(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserELSIF, i)
}

func (s *If_statementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(vhdlParserELSE, 0)
}

func (s *If_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *If_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterIf_statement(s)
	}
}

func (s *If_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitIf_statement(s)
	}
}

func (s *If_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitIf_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) If_statement() (localctx IIf_statementContext) {
	localctx = NewIf_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, vhdlParserRULE_if_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1422)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1421)
			p.Label_colon()
		}

	}
	{
		p.SetState(1424)
		p.Match(vhdlParserIF)
	}
	{
		p.SetState(1425)
		p.Condition()
	}
	{
		p.SetState(1426)
		p.Match(vhdlParserTHEN)
	}
	{
		p.SetState(1427)
		p.Sequence_of_statements()
	}
	p.SetState(1435)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserELSIF {
		{
			p.SetState(1428)
			p.Match(vhdlParserELSIF)
		}
		{
			p.SetState(1429)
			p.Condition()
		}
		{
			p.SetState(1430)
			p.Match(vhdlParserTHEN)
		}
		{
			p.SetState(1431)
			p.Sequence_of_statements()
		}

		p.SetState(1437)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1440)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserELSE {
		{
			p.SetState(1438)
			p.Match(vhdlParserELSE)
		}
		{
			p.SetState(1439)
			p.Sequence_of_statements()
		}

	}
	{
		p.SetState(1442)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(1443)
		p.Match(vhdlParserIF)
	}
	p.SetState(1445)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1444)
			p.Identifier()
		}

	}
	{
		p.SetState(1447)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IIndex_constraintContext is an interface to support dynamic dispatch.
type IIndex_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndex_constraintContext differentiates from other interfaces.
	IsIndex_constraintContext()
}

type Index_constraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_constraintContext() *Index_constraintContext {
	var p = new(Index_constraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_index_constraint
	return p
}

func (*Index_constraintContext) IsIndex_constraintContext() {}

func NewIndex_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_constraintContext {
	var p = new(Index_constraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_index_constraint

	return p
}

func (s *Index_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_constraintContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Index_constraintContext) AllDiscrete_range() []IDiscrete_rangeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDiscrete_rangeContext)(nil)).Elem())
	var tst = make([]IDiscrete_rangeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDiscrete_rangeContext)
		}
	}

	return tst
}

func (s *Index_constraintContext) Discrete_range(i int) IDiscrete_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDiscrete_rangeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDiscrete_rangeContext)
}

func (s *Index_constraintContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Index_constraintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Index_constraintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Index_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterIndex_constraint(s)
	}
}

func (s *Index_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitIndex_constraint(s)
	}
}

func (s *Index_constraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitIndex_constraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Index_constraint() (localctx IIndex_constraintContext) {
	localctx = NewIndex_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, vhdlParserRULE_index_constraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1449)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1450)
		p.Discrete_range()
	}
	p.SetState(1455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(1451)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(1452)
			p.Discrete_range()
		}

		p.SetState(1457)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1458)
		p.Match(vhdlParserRPAREN)
	}

	return localctx
}

// IIndex_specificationContext is an interface to support dynamic dispatch.
type IIndex_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndex_specificationContext differentiates from other interfaces.
	IsIndex_specificationContext()
}

type Index_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_specificationContext() *Index_specificationContext {
	var p = new(Index_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_index_specification
	return p
}

func (*Index_specificationContext) IsIndex_specificationContext() {}

func NewIndex_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_specificationContext {
	var p = new(Index_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_index_specification

	return p
}

func (s *Index_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_specificationContext) Discrete_range() IDiscrete_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDiscrete_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDiscrete_rangeContext)
}

func (s *Index_specificationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Index_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterIndex_specification(s)
	}
}

func (s *Index_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitIndex_specification(s)
	}
}

func (s *Index_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitIndex_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Index_specification() (localctx IIndex_specificationContext) {
	localctx = NewIndex_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, vhdlParserRULE_index_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1462)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1460)
			p.Discrete_range()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1461)
			p.Expression()
		}

	}

	return localctx
}

// IIndex_subtype_definitionContext is an interface to support dynamic dispatch.
type IIndex_subtype_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndex_subtype_definitionContext differentiates from other interfaces.
	IsIndex_subtype_definitionContext()
}

type Index_subtype_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_subtype_definitionContext() *Index_subtype_definitionContext {
	var p = new(Index_subtype_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_index_subtype_definition
	return p
}

func (*Index_subtype_definitionContext) IsIndex_subtype_definitionContext() {}

func NewIndex_subtype_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_subtype_definitionContext {
	var p = new(Index_subtype_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_index_subtype_definition

	return p
}

func (s *Index_subtype_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_subtype_definitionContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Index_subtype_definitionContext) RANGE() antlr.TerminalNode {
	return s.GetToken(vhdlParserRANGE, 0)
}

func (s *Index_subtype_definitionContext) BOX() antlr.TerminalNode {
	return s.GetToken(vhdlParserBOX, 0)
}

func (s *Index_subtype_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_subtype_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_subtype_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterIndex_subtype_definition(s)
	}
}

func (s *Index_subtype_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitIndex_subtype_definition(s)
	}
}

func (s *Index_subtype_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitIndex_subtype_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Index_subtype_definition() (localctx IIndex_subtype_definitionContext) {
	localctx = NewIndex_subtype_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, vhdlParserRULE_index_subtype_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1464)
		p.Name()
	}
	{
		p.SetState(1465)
		p.Match(vhdlParserRANGE)
	}
	{
		p.SetState(1466)
		p.Match(vhdlParserBOX)
	}

	return localctx
}

// IInstantiated_unitContext is an interface to support dynamic dispatch.
type IInstantiated_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstantiated_unitContext differentiates from other interfaces.
	IsInstantiated_unitContext()
}

type Instantiated_unitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstantiated_unitContext() *Instantiated_unitContext {
	var p = new(Instantiated_unitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_instantiated_unit
	return p
}

func (*Instantiated_unitContext) IsInstantiated_unitContext() {}

func NewInstantiated_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Instantiated_unitContext {
	var p = new(Instantiated_unitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_instantiated_unit

	return p
}

func (s *Instantiated_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Instantiated_unitContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Instantiated_unitContext) COMPONENT() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMPONENT, 0)
}

func (s *Instantiated_unitContext) ENTITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserENTITY, 0)
}

func (s *Instantiated_unitContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Instantiated_unitContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Instantiated_unitContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Instantiated_unitContext) CONFIGURATION() antlr.TerminalNode {
	return s.GetToken(vhdlParserCONFIGURATION, 0)
}

func (s *Instantiated_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Instantiated_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Instantiated_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInstantiated_unit(s)
	}
}

func (s *Instantiated_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInstantiated_unit(s)
	}
}

func (s *Instantiated_unitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitInstantiated_unit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Instantiated_unit() (localctx IInstantiated_unitContext) {
	localctx = NewInstantiated_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, vhdlParserRULE_instantiated_unit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1482)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserCOMPONENT, vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1469)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserCOMPONENT {
			{
				p.SetState(1468)
				p.Match(vhdlParserCOMPONENT)
			}

		}
		{
			p.SetState(1471)
			p.Name()
		}

	case vhdlParserENTITY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1472)
			p.Match(vhdlParserENTITY)
		}
		{
			p.SetState(1473)
			p.Name()
		}
		p.SetState(1478)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserLPAREN {
			{
				p.SetState(1474)
				p.Match(vhdlParserLPAREN)
			}
			{
				p.SetState(1475)
				p.Identifier()
			}
			{
				p.SetState(1476)
				p.Match(vhdlParserRPAREN)
			}

		}

	case vhdlParserCONFIGURATION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1480)
			p.Match(vhdlParserCONFIGURATION)
		}
		{
			p.SetState(1481)
			p.Name()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInstantiation_listContext is an interface to support dynamic dispatch.
type IInstantiation_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstantiation_listContext differentiates from other interfaces.
	IsInstantiation_listContext()
}

type Instantiation_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstantiation_listContext() *Instantiation_listContext {
	var p = new(Instantiation_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_instantiation_list
	return p
}

func (*Instantiation_listContext) IsInstantiation_listContext() {}

func NewInstantiation_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Instantiation_listContext {
	var p = new(Instantiation_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_instantiation_list

	return p
}

func (s *Instantiation_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Instantiation_listContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Instantiation_listContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Instantiation_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Instantiation_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Instantiation_listContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(vhdlParserOTHERS, 0)
}

func (s *Instantiation_listContext) ALL() antlr.TerminalNode {
	return s.GetToken(vhdlParserALL, 0)
}

func (s *Instantiation_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Instantiation_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Instantiation_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInstantiation_list(s)
	}
}

func (s *Instantiation_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInstantiation_list(s)
	}
}

func (s *Instantiation_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitInstantiation_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Instantiation_list() (localctx IInstantiation_listContext) {
	localctx = NewInstantiation_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, vhdlParserRULE_instantiation_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1494)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1484)
			p.Identifier()
		}
		p.SetState(1489)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == vhdlParserCOMMA {
			{
				p.SetState(1485)
				p.Match(vhdlParserCOMMA)
			}
			{
				p.SetState(1486)
				p.Identifier()
			}

			p.SetState(1491)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case vhdlParserOTHERS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1492)
			p.Match(vhdlParserOTHERS)
		}

	case vhdlParserALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1493)
			p.Match(vhdlParserALL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInterface_constant_declarationContext is an interface to support dynamic dispatch.
type IInterface_constant_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_constant_declarationContext differentiates from other interfaces.
	IsInterface_constant_declarationContext()
}

type Interface_constant_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_constant_declarationContext() *Interface_constant_declarationContext {
	var p = new(Interface_constant_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_constant_declaration
	return p
}

func (*Interface_constant_declarationContext) IsInterface_constant_declarationContext() {}

func NewInterface_constant_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_constant_declarationContext {
	var p = new(Interface_constant_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_constant_declaration

	return p
}

func (s *Interface_constant_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_constant_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Interface_constant_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Interface_constant_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Interface_constant_declarationContext) CONSTANT() antlr.TerminalNode {
	return s.GetToken(vhdlParserCONSTANT, 0)
}

func (s *Interface_constant_declarationContext) IN() antlr.TerminalNode {
	return s.GetToken(vhdlParserIN, 0)
}

func (s *Interface_constant_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Interface_constant_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Interface_constant_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_constant_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_constant_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_constant_declaration(s)
	}
}

func (s *Interface_constant_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_constant_declaration(s)
	}
}

func (s *Interface_constant_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitInterface_constant_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Interface_constant_declaration() (localctx IInterface_constant_declarationContext) {
	localctx = NewInterface_constant_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, vhdlParserRULE_interface_constant_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1497)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserCONSTANT {
		{
			p.SetState(1496)
			p.Match(vhdlParserCONSTANT)
		}

	}
	{
		p.SetState(1499)
		p.Identifier_list()
	}
	{
		p.SetState(1500)
		p.Match(vhdlParserCOLON)
	}
	p.SetState(1502)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIN {
		{
			p.SetState(1501)
			p.Match(vhdlParserIN)
		}

	}
	{
		p.SetState(1504)
		p.Subtype_indication()
	}
	p.SetState(1507)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(1505)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(1506)
			p.Expression()
		}

	}

	return localctx
}

// IInterface_declarationContext is an interface to support dynamic dispatch.
type IInterface_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_declarationContext differentiates from other interfaces.
	IsInterface_declarationContext()
}

type Interface_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_declarationContext() *Interface_declarationContext {
	var p = new(Interface_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_declaration
	return p
}

func (*Interface_declarationContext) IsInterface_declarationContext() {}

func NewInterface_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_declarationContext {
	var p = new(Interface_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_declaration

	return p
}

func (s *Interface_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_declarationContext) Interface_constant_declaration() IInterface_constant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_constant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_constant_declarationContext)
}

func (s *Interface_declarationContext) Interface_signal_declaration() IInterface_signal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_signal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_signal_declarationContext)
}

func (s *Interface_declarationContext) Interface_variable_declaration() IInterface_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_variable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_variable_declarationContext)
}

func (s *Interface_declarationContext) Interface_file_declaration() IInterface_file_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_file_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_file_declarationContext)
}

func (s *Interface_declarationContext) Interface_terminal_declaration() IInterface_terminal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_terminal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_terminal_declarationContext)
}

func (s *Interface_declarationContext) Interface_quantity_declaration() IInterface_quantity_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_quantity_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_quantity_declarationContext)
}

func (s *Interface_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_declaration(s)
	}
}

func (s *Interface_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_declaration(s)
	}
}

func (s *Interface_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitInterface_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Interface_declaration() (localctx IInterface_declarationContext) {
	localctx = NewInterface_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, vhdlParserRULE_interface_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1515)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1509)
			p.Interface_constant_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1510)
			p.Interface_signal_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1511)
			p.Interface_variable_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1512)
			p.Interface_file_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1513)
			p.Interface_terminal_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1514)
			p.Interface_quantity_declaration()
		}

	}

	return localctx
}

// IInterface_elementContext is an interface to support dynamic dispatch.
type IInterface_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_elementContext differentiates from other interfaces.
	IsInterface_elementContext()
}

type Interface_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_elementContext() *Interface_elementContext {
	var p = new(Interface_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_element
	return p
}

func (*Interface_elementContext) IsInterface_elementContext() {}

func NewInterface_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_elementContext {
	var p = new(Interface_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_element

	return p
}

func (s *Interface_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_elementContext) Interface_declaration() IInterface_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_declarationContext)
}

func (s *Interface_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_element(s)
	}
}

func (s *Interface_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_element(s)
	}
}

func (s *Interface_elementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitInterface_element(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Interface_element() (localctx IInterface_elementContext) {
	localctx = NewInterface_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, vhdlParserRULE_interface_element)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1517)
		p.Interface_declaration()
	}

	return localctx
}

// IInterface_file_declarationContext is an interface to support dynamic dispatch.
type IInterface_file_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_file_declarationContext differentiates from other interfaces.
	IsInterface_file_declarationContext()
}

type Interface_file_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_file_declarationContext() *Interface_file_declarationContext {
	var p = new(Interface_file_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_file_declaration
	return p
}

func (*Interface_file_declarationContext) IsInterface_file_declarationContext() {}

func NewInterface_file_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_file_declarationContext {
	var p = new(Interface_file_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_file_declaration

	return p
}

func (s *Interface_file_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_file_declarationContext) FILE() antlr.TerminalNode {
	return s.GetToken(vhdlParserFILE, 0)
}

func (s *Interface_file_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Interface_file_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Interface_file_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Interface_file_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_file_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_file_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_file_declaration(s)
	}
}

func (s *Interface_file_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_file_declaration(s)
	}
}

func (s *Interface_file_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitInterface_file_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Interface_file_declaration() (localctx IInterface_file_declarationContext) {
	localctx = NewInterface_file_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, vhdlParserRULE_interface_file_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1519)
		p.Match(vhdlParserFILE)
	}
	{
		p.SetState(1520)
		p.Identifier_list()
	}
	{
		p.SetState(1521)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1522)
		p.Subtype_indication()
	}

	return localctx
}

// IInterface_signal_listContext is an interface to support dynamic dispatch.
type IInterface_signal_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_signal_listContext differentiates from other interfaces.
	IsInterface_signal_listContext()
}

type Interface_signal_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_signal_listContext() *Interface_signal_listContext {
	var p = new(Interface_signal_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_signal_list
	return p
}

func (*Interface_signal_listContext) IsInterface_signal_listContext() {}

func NewInterface_signal_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_signal_listContext {
	var p = new(Interface_signal_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_signal_list

	return p
}

func (s *Interface_signal_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_signal_listContext) AllInterface_signal_declaration() []IInterface_signal_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_signal_declarationContext)(nil)).Elem())
	var tst = make([]IInterface_signal_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_signal_declarationContext)
		}
	}

	return tst
}

func (s *Interface_signal_listContext) Interface_signal_declaration(i int) IInterface_signal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_signal_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_signal_declarationContext)
}

func (s *Interface_signal_listContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserSEMI)
}

func (s *Interface_signal_listContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, i)
}

func (s *Interface_signal_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_signal_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_signal_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_signal_list(s)
	}
}

func (s *Interface_signal_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_signal_list(s)
	}
}

func (s *Interface_signal_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitInterface_signal_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Interface_signal_list() (localctx IInterface_signal_listContext) {
	localctx = NewInterface_signal_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, vhdlParserRULE_interface_signal_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1524)
		p.Interface_signal_declaration()
	}
	p.SetState(1529)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserSEMI {
		{
			p.SetState(1525)
			p.Match(vhdlParserSEMI)
		}
		{
			p.SetState(1526)
			p.Interface_signal_declaration()
		}

		p.SetState(1531)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInterface_port_listContext is an interface to support dynamic dispatch.
type IInterface_port_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_port_listContext differentiates from other interfaces.
	IsInterface_port_listContext()
}

type Interface_port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_port_listContext() *Interface_port_listContext {
	var p = new(Interface_port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_port_list
	return p
}

func (*Interface_port_listContext) IsInterface_port_listContext() {}

func NewInterface_port_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_port_listContext {
	var p = new(Interface_port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_port_list

	return p
}

func (s *Interface_port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_port_listContext) AllInterface_port_declaration() []IInterface_port_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_port_declarationContext)(nil)).Elem())
	var tst = make([]IInterface_port_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_port_declarationContext)
		}
	}

	return tst
}

func (s *Interface_port_listContext) Interface_port_declaration(i int) IInterface_port_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_port_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_port_declarationContext)
}

func (s *Interface_port_listContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserSEMI)
}

func (s *Interface_port_listContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, i)
}

func (s *Interface_port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_port_list(s)
	}
}

func (s *Interface_port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_port_list(s)
	}
}

func (s *Interface_port_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitInterface_port_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Interface_port_list() (localctx IInterface_port_listContext) {
	localctx = NewInterface_port_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, vhdlParserRULE_interface_port_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1532)
		p.Interface_port_declaration()
	}
	p.SetState(1537)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserSEMI {
		{
			p.SetState(1533)
			p.Match(vhdlParserSEMI)
		}
		{
			p.SetState(1534)
			p.Interface_port_declaration()
		}

		p.SetState(1539)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInterface_listContext is an interface to support dynamic dispatch.
type IInterface_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_listContext differentiates from other interfaces.
	IsInterface_listContext()
}

type Interface_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_listContext() *Interface_listContext {
	var p = new(Interface_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_list
	return p
}

func (*Interface_listContext) IsInterface_listContext() {}

func NewInterface_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_listContext {
	var p = new(Interface_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_list

	return p
}

func (s *Interface_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_listContext) AllInterface_element() []IInterface_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_elementContext)(nil)).Elem())
	var tst = make([]IInterface_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_elementContext)
		}
	}

	return tst
}

func (s *Interface_listContext) Interface_element(i int) IInterface_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_elementContext)
}

func (s *Interface_listContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserSEMI)
}

func (s *Interface_listContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, i)
}

func (s *Interface_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_list(s)
	}
}

func (s *Interface_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_list(s)
	}
}

func (s *Interface_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitInterface_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Interface_list() (localctx IInterface_listContext) {
	localctx = NewInterface_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, vhdlParserRULE_interface_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1540)
		p.Interface_element()
	}
	p.SetState(1545)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserSEMI {
		{
			p.SetState(1541)
			p.Match(vhdlParserSEMI)
		}
		{
			p.SetState(1542)
			p.Interface_element()
		}

		p.SetState(1547)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInterface_quantity_declarationContext is an interface to support dynamic dispatch.
type IInterface_quantity_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_quantity_declarationContext differentiates from other interfaces.
	IsInterface_quantity_declarationContext()
}

type Interface_quantity_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_quantity_declarationContext() *Interface_quantity_declarationContext {
	var p = new(Interface_quantity_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_quantity_declaration
	return p
}

func (*Interface_quantity_declarationContext) IsInterface_quantity_declarationContext() {}

func NewInterface_quantity_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_quantity_declarationContext {
	var p = new(Interface_quantity_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_quantity_declaration

	return p
}

func (s *Interface_quantity_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_quantity_declarationContext) QUANTITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserQUANTITY, 0)
}

func (s *Interface_quantity_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Interface_quantity_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Interface_quantity_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Interface_quantity_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Interface_quantity_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Interface_quantity_declarationContext) IN() antlr.TerminalNode {
	return s.GetToken(vhdlParserIN, 0)
}

func (s *Interface_quantity_declarationContext) OUT() antlr.TerminalNode {
	return s.GetToken(vhdlParserOUT, 0)
}

func (s *Interface_quantity_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_quantity_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_quantity_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_quantity_declaration(s)
	}
}

func (s *Interface_quantity_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_quantity_declaration(s)
	}
}

func (s *Interface_quantity_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitInterface_quantity_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Interface_quantity_declaration() (localctx IInterface_quantity_declarationContext) {
	localctx = NewInterface_quantity_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, vhdlParserRULE_interface_quantity_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1548)
		p.Match(vhdlParserQUANTITY)
	}
	{
		p.SetState(1549)
		p.Identifier_list()
	}
	{
		p.SetState(1550)
		p.Match(vhdlParserCOLON)
	}
	p.SetState(1552)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIN || _la == vhdlParserOUT {
		p.SetState(1551)
		_la = p.GetTokenStream().LA(1)

		if !(_la == vhdlParserIN || _la == vhdlParserOUT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	{
		p.SetState(1554)
		p.Subtype_indication()
	}
	p.SetState(1557)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(1555)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(1556)
			p.Expression()
		}

	}

	return localctx
}

// IInterface_port_declarationContext is an interface to support dynamic dispatch.
type IInterface_port_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_port_declarationContext differentiates from other interfaces.
	IsInterface_port_declarationContext()
}

type Interface_port_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_port_declarationContext() *Interface_port_declarationContext {
	var p = new(Interface_port_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_port_declaration
	return p
}

func (*Interface_port_declarationContext) IsInterface_port_declarationContext() {}

func NewInterface_port_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_port_declarationContext {
	var p = new(Interface_port_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_port_declaration

	return p
}

func (s *Interface_port_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_port_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Interface_port_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Interface_port_declarationContext) Signal_mode() ISignal_modeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_modeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_modeContext)
}

func (s *Interface_port_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Interface_port_declarationContext) BUS() antlr.TerminalNode {
	return s.GetToken(vhdlParserBUS, 0)
}

func (s *Interface_port_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Interface_port_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Interface_port_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_port_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_port_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_port_declaration(s)
	}
}

func (s *Interface_port_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_port_declaration(s)
	}
}

func (s *Interface_port_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitInterface_port_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Interface_port_declaration() (localctx IInterface_port_declarationContext) {
	localctx = NewInterface_port_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, vhdlParserRULE_interface_port_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1559)
		p.Identifier_list()
	}
	{
		p.SetState(1560)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1561)
		p.Signal_mode()
	}
	{
		p.SetState(1562)
		p.Subtype_indication()
	}
	p.SetState(1564)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBUS {
		{
			p.SetState(1563)
			p.Match(vhdlParserBUS)
		}

	}
	p.SetState(1568)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(1566)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(1567)
			p.Expression()
		}

	}

	return localctx
}

// IInterface_signal_declarationContext is an interface to support dynamic dispatch.
type IInterface_signal_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_signal_declarationContext differentiates from other interfaces.
	IsInterface_signal_declarationContext()
}

type Interface_signal_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_signal_declarationContext() *Interface_signal_declarationContext {
	var p = new(Interface_signal_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_signal_declaration
	return p
}

func (*Interface_signal_declarationContext) IsInterface_signal_declarationContext() {}

func NewInterface_signal_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_signal_declarationContext {
	var p = new(Interface_signal_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_signal_declaration

	return p
}

func (s *Interface_signal_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_signal_declarationContext) SIGNAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSIGNAL, 0)
}

func (s *Interface_signal_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Interface_signal_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Interface_signal_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Interface_signal_declarationContext) Signal_mode() ISignal_modeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_modeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_modeContext)
}

func (s *Interface_signal_declarationContext) BUS() antlr.TerminalNode {
	return s.GetToken(vhdlParserBUS, 0)
}

func (s *Interface_signal_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Interface_signal_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Interface_signal_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_signal_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_signal_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_signal_declaration(s)
	}
}

func (s *Interface_signal_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_signal_declaration(s)
	}
}

func (s *Interface_signal_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitInterface_signal_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Interface_signal_declaration() (localctx IInterface_signal_declarationContext) {
	localctx = NewInterface_signal_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, vhdlParserRULE_interface_signal_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1570)
		p.Match(vhdlParserSIGNAL)
	}
	{
		p.SetState(1571)
		p.Identifier_list()
	}
	{
		p.SetState(1572)
		p.Match(vhdlParserCOLON)
	}
	p.SetState(1574)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBUFFER || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(vhdlParserIN-38))|(1<<(vhdlParserINOUT-38))|(1<<(vhdlParserLINKAGE-38))|(1<<(vhdlParserOUT-38)))) != 0) {
		{
			p.SetState(1573)
			p.Signal_mode()
		}

	}
	{
		p.SetState(1576)
		p.Subtype_indication()
	}
	p.SetState(1578)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBUS {
		{
			p.SetState(1577)
			p.Match(vhdlParserBUS)
		}

	}
	p.SetState(1582)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(1580)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(1581)
			p.Expression()
		}

	}

	return localctx
}

// IInterface_terminal_declarationContext is an interface to support dynamic dispatch.
type IInterface_terminal_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_terminal_declarationContext differentiates from other interfaces.
	IsInterface_terminal_declarationContext()
}

type Interface_terminal_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_terminal_declarationContext() *Interface_terminal_declarationContext {
	var p = new(Interface_terminal_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_terminal_declaration
	return p
}

func (*Interface_terminal_declarationContext) IsInterface_terminal_declarationContext() {}

func NewInterface_terminal_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_terminal_declarationContext {
	var p = new(Interface_terminal_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_terminal_declaration

	return p
}

func (s *Interface_terminal_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_terminal_declarationContext) TERMINAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserTERMINAL, 0)
}

func (s *Interface_terminal_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Interface_terminal_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Interface_terminal_declarationContext) Subnature_indication() ISubnature_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_indicationContext)
}

func (s *Interface_terminal_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_terminal_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_terminal_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_terminal_declaration(s)
	}
}

func (s *Interface_terminal_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_terminal_declaration(s)
	}
}

func (s *Interface_terminal_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitInterface_terminal_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Interface_terminal_declaration() (localctx IInterface_terminal_declarationContext) {
	localctx = NewInterface_terminal_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, vhdlParserRULE_interface_terminal_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1584)
		p.Match(vhdlParserTERMINAL)
	}
	{
		p.SetState(1585)
		p.Identifier_list()
	}
	{
		p.SetState(1586)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1587)
		p.Subnature_indication()
	}

	return localctx
}

// IInterface_variable_declarationContext is an interface to support dynamic dispatch.
type IInterface_variable_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_variable_declarationContext differentiates from other interfaces.
	IsInterface_variable_declarationContext()
}

type Interface_variable_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_variable_declarationContext() *Interface_variable_declarationContext {
	var p = new(Interface_variable_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_interface_variable_declaration
	return p
}

func (*Interface_variable_declarationContext) IsInterface_variable_declarationContext() {}

func NewInterface_variable_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_variable_declarationContext {
	var p = new(Interface_variable_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_interface_variable_declaration

	return p
}

func (s *Interface_variable_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_variable_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Interface_variable_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Interface_variable_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Interface_variable_declarationContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARIABLE, 0)
}

func (s *Interface_variable_declarationContext) Signal_mode() ISignal_modeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_modeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_modeContext)
}

func (s *Interface_variable_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Interface_variable_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Interface_variable_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_variable_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_variable_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterInterface_variable_declaration(s)
	}
}

func (s *Interface_variable_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitInterface_variable_declaration(s)
	}
}

func (s *Interface_variable_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitInterface_variable_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Interface_variable_declaration() (localctx IInterface_variable_declarationContext) {
	localctx = NewInterface_variable_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, vhdlParserRULE_interface_variable_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1590)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARIABLE {
		{
			p.SetState(1589)
			p.Match(vhdlParserVARIABLE)
		}

	}
	{
		p.SetState(1592)
		p.Identifier_list()
	}
	{
		p.SetState(1593)
		p.Match(vhdlParserCOLON)
	}
	p.SetState(1595)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBUFFER || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(vhdlParserIN-38))|(1<<(vhdlParserINOUT-38))|(1<<(vhdlParserLINKAGE-38))|(1<<(vhdlParserOUT-38)))) != 0) {
		{
			p.SetState(1594)
			p.Signal_mode()
		}

	}
	{
		p.SetState(1597)
		p.Subtype_indication()
	}
	p.SetState(1600)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(1598)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(1599)
			p.Expression()
		}

	}

	return localctx
}

// IIteration_schemeContext is an interface to support dynamic dispatch.
type IIteration_schemeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIteration_schemeContext differentiates from other interfaces.
	IsIteration_schemeContext()
}

type Iteration_schemeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIteration_schemeContext() *Iteration_schemeContext {
	var p = new(Iteration_schemeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_iteration_scheme
	return p
}

func (*Iteration_schemeContext) IsIteration_schemeContext() {}

func NewIteration_schemeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Iteration_schemeContext {
	var p = new(Iteration_schemeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_iteration_scheme

	return p
}

func (s *Iteration_schemeContext) GetParser() antlr.Parser { return s.parser }

func (s *Iteration_schemeContext) WHILE() antlr.TerminalNode {
	return s.GetToken(vhdlParserWHILE, 0)
}

func (s *Iteration_schemeContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Iteration_schemeContext) FOR() antlr.TerminalNode {
	return s.GetToken(vhdlParserFOR, 0)
}

func (s *Iteration_schemeContext) Parameter_specification() IParameter_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_specificationContext)
}

func (s *Iteration_schemeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Iteration_schemeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Iteration_schemeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterIteration_scheme(s)
	}
}

func (s *Iteration_schemeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitIteration_scheme(s)
	}
}

func (s *Iteration_schemeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitIteration_scheme(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Iteration_scheme() (localctx IIteration_schemeContext) {
	localctx = NewIteration_schemeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, vhdlParserRULE_iteration_scheme)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1606)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserWHILE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1602)
			p.Match(vhdlParserWHILE)
		}
		{
			p.SetState(1603)
			p.Condition()
		}

	case vhdlParserFOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1604)
			p.Match(vhdlParserFOR)
		}
		{
			p.SetState(1605)
			p.Parameter_specification()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILabel_colonContext is an interface to support dynamic dispatch.
type ILabel_colonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabel_colonContext differentiates from other interfaces.
	IsLabel_colonContext()
}

type Label_colonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabel_colonContext() *Label_colonContext {
	var p = new(Label_colonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_label_colon
	return p
}

func (*Label_colonContext) IsLabel_colonContext() {}

func NewLabel_colonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Label_colonContext {
	var p = new(Label_colonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_label_colon

	return p
}

func (s *Label_colonContext) GetParser() antlr.Parser { return s.parser }

func (s *Label_colonContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Label_colonContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Label_colonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Label_colonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Label_colonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterLabel_colon(s)
	}
}

func (s *Label_colonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitLabel_colon(s)
	}
}

func (s *Label_colonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitLabel_colon(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Label_colon() (localctx ILabel_colonContext) {
	localctx = NewLabel_colonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, vhdlParserRULE_label_colon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1608)
		p.Identifier()
	}
	{
		p.SetState(1609)
		p.Match(vhdlParserCOLON)
	}

	return localctx
}

// ILibrary_clauseContext is an interface to support dynamic dispatch.
type ILibrary_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibrary_clauseContext differentiates from other interfaces.
	IsLibrary_clauseContext()
}

type Library_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibrary_clauseContext() *Library_clauseContext {
	var p = new(Library_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_library_clause
	return p
}

func (*Library_clauseContext) IsLibrary_clauseContext() {}

func NewLibrary_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Library_clauseContext {
	var p = new(Library_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_library_clause

	return p
}

func (s *Library_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Library_clauseContext) LIBRARY() antlr.TerminalNode {
	return s.GetToken(vhdlParserLIBRARY, 0)
}

func (s *Library_clauseContext) Logical_name_list() ILogical_name_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_name_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_name_listContext)
}

func (s *Library_clauseContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Library_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Library_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Library_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterLibrary_clause(s)
	}
}

func (s *Library_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitLibrary_clause(s)
	}
}

func (s *Library_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitLibrary_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Library_clause() (localctx ILibrary_clauseContext) {
	localctx = NewLibrary_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, vhdlParserRULE_library_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1611)
		p.Match(vhdlParserLIBRARY)
	}
	{
		p.SetState(1612)
		p.Logical_name_list()
	}
	{
		p.SetState(1613)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ILibrary_unitContext is an interface to support dynamic dispatch.
type ILibrary_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibrary_unitContext differentiates from other interfaces.
	IsLibrary_unitContext()
}

type Library_unitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibrary_unitContext() *Library_unitContext {
	var p = new(Library_unitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_library_unit
	return p
}

func (*Library_unitContext) IsLibrary_unitContext() {}

func NewLibrary_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Library_unitContext {
	var p = new(Library_unitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_library_unit

	return p
}

func (s *Library_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Library_unitContext) Secondary_unit() ISecondary_unitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISecondary_unitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISecondary_unitContext)
}

func (s *Library_unitContext) Primary_unit() IPrimary_unitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_unitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_unitContext)
}

func (s *Library_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Library_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Library_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterLibrary_unit(s)
	}
}

func (s *Library_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitLibrary_unit(s)
	}
}

func (s *Library_unitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitLibrary_unit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Library_unit() (localctx ILibrary_unitContext) {
	localctx = NewLibrary_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, vhdlParserRULE_library_unit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1617)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1615)
			p.Secondary_unit()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1616)
			p.Primary_unit()
		}

	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(vhdlParserNULL, 0)
}

func (s *LiteralContext) BIT_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserBIT_STRING_LITERAL, 0)
}

func (s *LiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSTRING_LITERAL, 0)
}

func (s *LiteralContext) Enumeration_literal() IEnumeration_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeration_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumeration_literalContext)
}

func (s *LiteralContext) Numeric_literal() INumeric_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeric_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeric_literalContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, vhdlParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1624)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserNULL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1619)
			p.Match(vhdlParserNULL)
		}

	case vhdlParserBIT_STRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1620)
			p.Match(vhdlParserBIT_STRING_LITERAL)
		}

	case vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1621)
			p.Match(vhdlParserSTRING_LITERAL)
		}

	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserCHARACTER_LITERAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1622)
			p.Enumeration_literal()
		}

	case vhdlParserBASE_LITERAL, vhdlParserREAL_LITERAL, vhdlParserINTEGER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1623)
			p.Numeric_literal()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILogical_nameContext is an interface to support dynamic dispatch.
type ILogical_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogical_nameContext differentiates from other interfaces.
	IsLogical_nameContext()
}

type Logical_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_nameContext() *Logical_nameContext {
	var p = new(Logical_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_logical_name
	return p
}

func (*Logical_nameContext) IsLogical_nameContext() {}

func NewLogical_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_nameContext {
	var p = new(Logical_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_logical_name

	return p
}

func (s *Logical_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Logical_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logical_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterLogical_name(s)
	}
}

func (s *Logical_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitLogical_name(s)
	}
}

func (s *Logical_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitLogical_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Logical_name() (localctx ILogical_nameContext) {
	localctx = NewLogical_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, vhdlParserRULE_logical_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1626)
		p.Identifier()
	}

	return localctx
}

// ILogical_name_listContext is an interface to support dynamic dispatch.
type ILogical_name_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogical_name_listContext differentiates from other interfaces.
	IsLogical_name_listContext()
}

type Logical_name_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_name_listContext() *Logical_name_listContext {
	var p = new(Logical_name_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_logical_name_list
	return p
}

func (*Logical_name_listContext) IsLogical_name_listContext() {}

func NewLogical_name_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_name_listContext {
	var p = new(Logical_name_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_logical_name_list

	return p
}

func (s *Logical_name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_name_listContext) AllLogical_name() []ILogical_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILogical_nameContext)(nil)).Elem())
	var tst = make([]ILogical_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILogical_nameContext)
		}
	}

	return tst
}

func (s *Logical_name_listContext) Logical_name(i int) ILogical_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILogical_nameContext)
}

func (s *Logical_name_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Logical_name_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Logical_name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logical_name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterLogical_name_list(s)
	}
}

func (s *Logical_name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitLogical_name_list(s)
	}
}

func (s *Logical_name_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitLogical_name_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Logical_name_list() (localctx ILogical_name_listContext) {
	localctx = NewLogical_name_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, vhdlParserRULE_logical_name_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1628)
		p.Logical_name()
	}
	p.SetState(1633)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(1629)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(1630)
			p.Logical_name()
		}

		p.SetState(1635)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILogical_operatorContext is an interface to support dynamic dispatch.
type ILogical_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogical_operatorContext differentiates from other interfaces.
	IsLogical_operatorContext()
}

type Logical_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_operatorContext() *Logical_operatorContext {
	var p = new(Logical_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_logical_operator
	return p
}

func (*Logical_operatorContext) IsLogical_operatorContext() {}

func NewLogical_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_operatorContext {
	var p = new(Logical_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_logical_operator

	return p
}

func (s *Logical_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_operatorContext) AND() antlr.TerminalNode {
	return s.GetToken(vhdlParserAND, 0)
}

func (s *Logical_operatorContext) OR() antlr.TerminalNode {
	return s.GetToken(vhdlParserOR, 0)
}

func (s *Logical_operatorContext) NAND() antlr.TerminalNode {
	return s.GetToken(vhdlParserNAND, 0)
}

func (s *Logical_operatorContext) NOR() antlr.TerminalNode {
	return s.GetToken(vhdlParserNOR, 0)
}

func (s *Logical_operatorContext) XOR() antlr.TerminalNode {
	return s.GetToken(vhdlParserXOR, 0)
}

func (s *Logical_operatorContext) XNOR() antlr.TerminalNode {
	return s.GetToken(vhdlParserXNOR, 0)
}

func (s *Logical_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logical_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterLogical_operator(s)
	}
}

func (s *Logical_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitLogical_operator(s)
	}
}

func (s *Logical_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitLogical_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Logical_operator() (localctx ILogical_operatorContext) {
	localctx = NewLogical_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, vhdlParserRULE_logical_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1636)
	_la = p.GetTokenStream().LA(1)

	if !(_la == vhdlParserAND || (((_la-50)&-(0x1f+1)) == 0 && ((1<<uint((_la-50)))&((1<<(vhdlParserNAND-50))|(1<<(vhdlParserNOR-50))|(1<<(vhdlParserOR-50)))) != 0) || _la == vhdlParserXNOR || _la == vhdlParserXOR) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// ILoop_statementContext is an interface to support dynamic dispatch.
type ILoop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoop_statementContext differentiates from other interfaces.
	IsLoop_statementContext()
}

type Loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoop_statementContext() *Loop_statementContext {
	var p = new(Loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_loop_statement
	return p
}

func (*Loop_statementContext) IsLoop_statementContext() {}

func NewLoop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_statementContext {
	var p = new(Loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_loop_statement

	return p
}

func (s *Loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_statementContext) AllLOOP() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserLOOP)
}

func (s *Loop_statementContext) LOOP(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserLOOP, i)
}

func (s *Loop_statementContext) Sequence_of_statements() ISequence_of_statementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_of_statementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_of_statementsContext)
}

func (s *Loop_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Loop_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Loop_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Loop_statementContext) Iteration_scheme() IIteration_schemeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIteration_schemeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIteration_schemeContext)
}

func (s *Loop_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterLoop_statement(s)
	}
}

func (s *Loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitLoop_statement(s)
	}
}

func (s *Loop_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitLoop_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Loop_statement() (localctx ILoop_statementContext) {
	localctx = NewLoop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, vhdlParserRULE_loop_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1639)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1638)
			p.Label_colon()
		}

	}
	p.SetState(1642)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserFOR || _la == vhdlParserWHILE {
		{
			p.SetState(1641)
			p.Iteration_scheme()
		}

	}
	{
		p.SetState(1644)
		p.Match(vhdlParserLOOP)
	}
	{
		p.SetState(1645)
		p.Sequence_of_statements()
	}
	{
		p.SetState(1646)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(1647)
		p.Match(vhdlParserLOOP)
	}
	p.SetState(1649)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1648)
			p.Identifier()
		}

	}
	{
		p.SetState(1651)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISignal_modeContext is an interface to support dynamic dispatch.
type ISignal_modeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignal_modeContext differentiates from other interfaces.
	IsSignal_modeContext()
}

type Signal_modeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignal_modeContext() *Signal_modeContext {
	var p = new(Signal_modeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_signal_mode
	return p
}

func (*Signal_modeContext) IsSignal_modeContext() {}

func NewSignal_modeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signal_modeContext {
	var p = new(Signal_modeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_signal_mode

	return p
}

func (s *Signal_modeContext) GetParser() antlr.Parser { return s.parser }

func (s *Signal_modeContext) IN() antlr.TerminalNode {
	return s.GetToken(vhdlParserIN, 0)
}

func (s *Signal_modeContext) OUT() antlr.TerminalNode {
	return s.GetToken(vhdlParserOUT, 0)
}

func (s *Signal_modeContext) INOUT() antlr.TerminalNode {
	return s.GetToken(vhdlParserINOUT, 0)
}

func (s *Signal_modeContext) BUFFER() antlr.TerminalNode {
	return s.GetToken(vhdlParserBUFFER, 0)
}

func (s *Signal_modeContext) LINKAGE() antlr.TerminalNode {
	return s.GetToken(vhdlParserLINKAGE, 0)
}

func (s *Signal_modeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signal_modeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signal_modeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSignal_mode(s)
	}
}

func (s *Signal_modeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSignal_mode(s)
	}
}

func (s *Signal_modeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSignal_mode(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Signal_mode() (localctx ISignal_modeContext) {
	localctx = NewSignal_modeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, vhdlParserRULE_signal_mode)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1653)
	_la = p.GetTokenStream().LA(1)

	if !(_la == vhdlParserBUFFER || (((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(vhdlParserIN-38))|(1<<(vhdlParserINOUT-38))|(1<<(vhdlParserLINKAGE-38))|(1<<(vhdlParserOUT-38)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IMultiplying_operatorContext is an interface to support dynamic dispatch.
type IMultiplying_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplying_operatorContext differentiates from other interfaces.
	IsMultiplying_operatorContext()
}

type Multiplying_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplying_operatorContext() *Multiplying_operatorContext {
	var p = new(Multiplying_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_multiplying_operator
	return p
}

func (*Multiplying_operatorContext) IsMultiplying_operatorContext() {}

func NewMultiplying_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multiplying_operatorContext {
	var p = new(Multiplying_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_multiplying_operator

	return p
}

func (s *Multiplying_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Multiplying_operatorContext) MUL() antlr.TerminalNode {
	return s.GetToken(vhdlParserMUL, 0)
}

func (s *Multiplying_operatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(vhdlParserDIV, 0)
}

func (s *Multiplying_operatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(vhdlParserMOD, 0)
}

func (s *Multiplying_operatorContext) REM() antlr.TerminalNode {
	return s.GetToken(vhdlParserREM, 0)
}

func (s *Multiplying_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multiplying_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multiplying_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterMultiplying_operator(s)
	}
}

func (s *Multiplying_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitMultiplying_operator(s)
	}
}

func (s *Multiplying_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitMultiplying_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Multiplying_operator() (localctx IMultiplying_operatorContext) {
	localctx = NewMultiplying_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, vhdlParserRULE_multiplying_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1655)
	_la = p.GetTokenStream().LA(1)

	if !(_la == vhdlParserMOD || _la == vhdlParserREM || _la == vhdlParserMUL || _la == vhdlParserDIV) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_name
	return p
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) Selected_name() ISelected_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelected_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelected_nameContext)
}

func (s *NameContext) AllName_part() []IName_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IName_partContext)(nil)).Elem())
	var tst = make([]IName_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IName_partContext)
		}
	}

	return tst
}

func (s *NameContext) Name_part(i int) IName_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IName_partContext)
}

func (s *NameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserDOT)
}

func (s *NameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserDOT, i)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitName(s)
	}
}

func (s *NameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Name() (localctx INameContext) {
	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, vhdlParserRULE_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1666)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1657)
			p.Selected_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1658)
			p.Name_part()
		}
		p.SetState(1663)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 167, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1659)
					p.Match(vhdlParserDOT)
				}
				{
					p.SetState(1660)
					p.Name_part()
				}

			}
			p.SetState(1665)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 167, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IName_partContext is an interface to support dynamic dispatch.
type IName_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_partContext differentiates from other interfaces.
	IsName_partContext()
}

type Name_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_partContext() *Name_partContext {
	var p = new(Name_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_name_part
	return p
}

func (*Name_partContext) IsName_partContext() {}

func NewName_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_partContext {
	var p = new(Name_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_name_part

	return p
}

func (s *Name_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_partContext) Selected_name() ISelected_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelected_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelected_nameContext)
}

func (s *Name_partContext) Name_attribute_part() IName_attribute_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_attribute_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_attribute_partContext)
}

func (s *Name_partContext) Name_function_call_or_indexed_part() IName_function_call_or_indexed_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_function_call_or_indexed_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_function_call_or_indexed_partContext)
}

func (s *Name_partContext) Name_slice_part() IName_slice_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_slice_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_slice_partContext)
}

func (s *Name_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterName_part(s)
	}
}

func (s *Name_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitName_part(s)
	}
}

func (s *Name_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitName_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Name_part() (localctx IName_partContext) {
	localctx = NewName_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, vhdlParserRULE_name_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1668)
		p.Selected_name()
	}
	p.SetState(1672)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1669)
			p.Name_attribute_part()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1670)
			p.Name_function_call_or_indexed_part()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(1671)
			p.Name_slice_part()
		}

	}

	return localctx
}

// IName_attribute_partContext is an interface to support dynamic dispatch.
type IName_attribute_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_attribute_partContext differentiates from other interfaces.
	IsName_attribute_partContext()
}

type Name_attribute_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_attribute_partContext() *Name_attribute_partContext {
	var p = new(Name_attribute_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_name_attribute_part
	return p
}

func (*Name_attribute_partContext) IsName_attribute_partContext() {}

func NewName_attribute_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_attribute_partContext {
	var p = new(Name_attribute_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_name_attribute_part

	return p
}

func (s *Name_attribute_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_attribute_partContext) APOSTROPHE() antlr.TerminalNode {
	return s.GetToken(vhdlParserAPOSTROPHE, 0)
}

func (s *Name_attribute_partContext) Attribute_designator() IAttribute_designatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_designatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_designatorContext)
}

func (s *Name_attribute_partContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Name_attribute_partContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Name_attribute_partContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Name_attribute_partContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Name_attribute_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_attribute_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_attribute_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterName_attribute_part(s)
	}
}

func (s *Name_attribute_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitName_attribute_part(s)
	}
}

func (s *Name_attribute_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitName_attribute_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Name_attribute_part() (localctx IName_attribute_partContext) {
	localctx = NewName_attribute_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, vhdlParserRULE_name_attribute_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1674)
		p.Match(vhdlParserAPOSTROPHE)
	}
	{
		p.SetState(1675)
		p.Attribute_designator()
	}
	p.SetState(1684)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1676)
			p.Expression()
		}
		p.SetState(1681)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1677)
					p.Match(vhdlParserCOMMA)
				}
				{
					p.SetState(1678)
					p.Expression()
				}

			}
			p.SetState(1683)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IName_function_call_or_indexed_partContext is an interface to support dynamic dispatch.
type IName_function_call_or_indexed_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_function_call_or_indexed_partContext differentiates from other interfaces.
	IsName_function_call_or_indexed_partContext()
}

type Name_function_call_or_indexed_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_function_call_or_indexed_partContext() *Name_function_call_or_indexed_partContext {
	var p = new(Name_function_call_or_indexed_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_name_function_call_or_indexed_part
	return p
}

func (*Name_function_call_or_indexed_partContext) IsName_function_call_or_indexed_partContext() {}

func NewName_function_call_or_indexed_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_function_call_or_indexed_partContext {
	var p = new(Name_function_call_or_indexed_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_name_function_call_or_indexed_part

	return p
}

func (s *Name_function_call_or_indexed_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_function_call_or_indexed_partContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Name_function_call_or_indexed_partContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Name_function_call_or_indexed_partContext) Actual_parameter_part() IActual_parameter_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActual_parameter_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActual_parameter_partContext)
}

func (s *Name_function_call_or_indexed_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_function_call_or_indexed_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_function_call_or_indexed_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterName_function_call_or_indexed_part(s)
	}
}

func (s *Name_function_call_or_indexed_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitName_function_call_or_indexed_part(s)
	}
}

func (s *Name_function_call_or_indexed_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitName_function_call_or_indexed_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Name_function_call_or_indexed_part() (localctx IName_function_call_or_indexed_partContext) {
	localctx = NewName_function_call_or_indexed_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, vhdlParserRULE_name_function_call_or_indexed_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1686)
		p.Match(vhdlParserLPAREN)
	}
	p.SetState(1688)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserABS || (((_la-52)&-(0x1f+1)) == 0 && ((1<<uint((_la-52)))&((1<<(vhdlParserNEW-52))|(1<<(vhdlParserNOT-52))|(1<<(vhdlParserNULL-52))|(1<<(vhdlParserOPEN-52)))) != 0) || (((_la-112)&-(0x1f+1)) == 0 && ((1<<uint((_la-112)))&((1<<(vhdlParserBASE_LITERAL-112))|(1<<(vhdlParserBIT_STRING_LITERAL-112))|(1<<(vhdlParserREAL_LITERAL-112))|(1<<(vhdlParserBASIC_IDENTIFIER-112))|(1<<(vhdlParserEXTENDED_IDENTIFIER-112))|(1<<(vhdlParserCHARACTER_LITERAL-112))|(1<<(vhdlParserSTRING_LITERAL-112))|(1<<(vhdlParserLPAREN-112)))) != 0) || (((_la-148)&-(0x1f+1)) == 0 && ((1<<uint((_la-148)))&((1<<(vhdlParserPLUS-148))|(1<<(vhdlParserMINUS-148))|(1<<(vhdlParserINTEGER-148)))) != 0) {
		{
			p.SetState(1687)
			p.Actual_parameter_part()
		}

	}
	{
		p.SetState(1690)
		p.Match(vhdlParserRPAREN)
	}

	return localctx
}

// IName_slice_partContext is an interface to support dynamic dispatch.
type IName_slice_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_slice_partContext differentiates from other interfaces.
	IsName_slice_partContext()
}

type Name_slice_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_slice_partContext() *Name_slice_partContext {
	var p = new(Name_slice_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_name_slice_part
	return p
}

func (*Name_slice_partContext) IsName_slice_partContext() {}

func NewName_slice_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_slice_partContext {
	var p = new(Name_slice_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_name_slice_part

	return p
}

func (s *Name_slice_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_slice_partContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserLPAREN)
}

func (s *Name_slice_partContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, i)
}

func (s *Name_slice_partContext) AllExplicit_range() []IExplicit_rangeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExplicit_rangeContext)(nil)).Elem())
	var tst = make([]IExplicit_rangeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExplicit_rangeContext)
		}
	}

	return tst
}

func (s *Name_slice_partContext) Explicit_range(i int) IExplicit_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicit_rangeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExplicit_rangeContext)
}

func (s *Name_slice_partContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserRPAREN)
}

func (s *Name_slice_partContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, i)
}

func (s *Name_slice_partContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Name_slice_partContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Name_slice_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_slice_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_slice_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterName_slice_part(s)
	}
}

func (s *Name_slice_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitName_slice_part(s)
	}
}

func (s *Name_slice_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitName_slice_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Name_slice_part() (localctx IName_slice_partContext) {
	localctx = NewName_slice_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, vhdlParserRULE_name_slice_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1703)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1692)
				p.Match(vhdlParserLPAREN)
			}
			{
				p.SetState(1693)
				p.Explicit_range()
			}
			p.SetState(1698)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == vhdlParserCOMMA {
				{
					p.SetState(1694)
					p.Match(vhdlParserCOMMA)
				}
				{
					p.SetState(1695)
					p.Explicit_range()
				}

				p.SetState(1700)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1701)
				p.Match(vhdlParserRPAREN)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1705)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 174, p.GetParserRuleContext())
	}

	return localctx
}

// ISelected_nameContext is an interface to support dynamic dispatch.
type ISelected_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelected_nameContext differentiates from other interfaces.
	IsSelected_nameContext()
}

type Selected_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelected_nameContext() *Selected_nameContext {
	var p = new(Selected_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_selected_name
	return p
}

func (*Selected_nameContext) IsSelected_nameContext() {}

func NewSelected_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selected_nameContext {
	var p = new(Selected_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_selected_name

	return p
}

func (s *Selected_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Selected_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Selected_nameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserDOT)
}

func (s *Selected_nameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserDOT, i)
}

func (s *Selected_nameContext) AllSuffix() []ISuffixContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuffixContext)(nil)).Elem())
	var tst = make([]ISuffixContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuffixContext)
		}
	}

	return tst
}

func (s *Selected_nameContext) Suffix(i int) ISuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuffixContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuffixContext)
}

func (s *Selected_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selected_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Selected_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSelected_name(s)
	}
}

func (s *Selected_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSelected_name(s)
	}
}

func (s *Selected_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSelected_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Selected_name() (localctx ISelected_nameContext) {
	localctx = NewSelected_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, vhdlParserRULE_selected_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1707)
		p.Identifier()
	}
	p.SetState(1712)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 175, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1708)
				p.Match(vhdlParserDOT)
			}
			{
				p.SetState(1709)
				p.Suffix()
			}

		}
		p.SetState(1714)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 175, p.GetParserRuleContext())
	}

	return localctx
}

// INature_declarationContext is an interface to support dynamic dispatch.
type INature_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNature_declarationContext differentiates from other interfaces.
	IsNature_declarationContext()
}

type Nature_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNature_declarationContext() *Nature_declarationContext {
	var p = new(Nature_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_nature_declaration
	return p
}

func (*Nature_declarationContext) IsNature_declarationContext() {}

func NewNature_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nature_declarationContext {
	var p = new(Nature_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_nature_declaration

	return p
}

func (s *Nature_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Nature_declarationContext) NATURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserNATURE, 0)
}

func (s *Nature_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Nature_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Nature_declarationContext) Nature_definition() INature_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INature_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INature_definitionContext)
}

func (s *Nature_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Nature_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nature_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nature_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterNature_declaration(s)
	}
}

func (s *Nature_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitNature_declaration(s)
	}
}

func (s *Nature_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitNature_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Nature_declaration() (localctx INature_declarationContext) {
	localctx = NewNature_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, vhdlParserRULE_nature_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1715)
		p.Match(vhdlParserNATURE)
	}
	{
		p.SetState(1716)
		p.Identifier()
	}
	{
		p.SetState(1717)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(1718)
		p.Nature_definition()
	}
	{
		p.SetState(1719)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// INature_definitionContext is an interface to support dynamic dispatch.
type INature_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNature_definitionContext differentiates from other interfaces.
	IsNature_definitionContext()
}

type Nature_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNature_definitionContext() *Nature_definitionContext {
	var p = new(Nature_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_nature_definition
	return p
}

func (*Nature_definitionContext) IsNature_definitionContext() {}

func NewNature_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nature_definitionContext {
	var p = new(Nature_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_nature_definition

	return p
}

func (s *Nature_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Nature_definitionContext) Scalar_nature_definition() IScalar_nature_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScalar_nature_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScalar_nature_definitionContext)
}

func (s *Nature_definitionContext) Composite_nature_definition() IComposite_nature_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComposite_nature_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComposite_nature_definitionContext)
}

func (s *Nature_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nature_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nature_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterNature_definition(s)
	}
}

func (s *Nature_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitNature_definition(s)
	}
}

func (s *Nature_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitNature_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Nature_definition() (localctx INature_definitionContext) {
	localctx = NewNature_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, vhdlParserRULE_nature_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1723)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1721)
			p.Scalar_nature_definition()
		}

	case vhdlParserARRAY, vhdlParserRECORD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1722)
			p.Composite_nature_definition()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INature_element_declarationContext is an interface to support dynamic dispatch.
type INature_element_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNature_element_declarationContext differentiates from other interfaces.
	IsNature_element_declarationContext()
}

type Nature_element_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNature_element_declarationContext() *Nature_element_declarationContext {
	var p = new(Nature_element_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_nature_element_declaration
	return p
}

func (*Nature_element_declarationContext) IsNature_element_declarationContext() {}

func NewNature_element_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nature_element_declarationContext {
	var p = new(Nature_element_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_nature_element_declaration

	return p
}

func (s *Nature_element_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Nature_element_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Nature_element_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Nature_element_declarationContext) Element_subnature_definition() IElement_subnature_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElement_subnature_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElement_subnature_definitionContext)
}

func (s *Nature_element_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nature_element_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nature_element_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterNature_element_declaration(s)
	}
}

func (s *Nature_element_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitNature_element_declaration(s)
	}
}

func (s *Nature_element_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitNature_element_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Nature_element_declaration() (localctx INature_element_declarationContext) {
	localctx = NewNature_element_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, vhdlParserRULE_nature_element_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1725)
		p.Identifier_list()
	}
	{
		p.SetState(1726)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(1727)
		p.Element_subnature_definition()
	}

	return localctx
}

// INext_statementContext is an interface to support dynamic dispatch.
type INext_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNext_statementContext differentiates from other interfaces.
	IsNext_statementContext()
}

type Next_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNext_statementContext() *Next_statementContext {
	var p = new(Next_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_next_statement
	return p
}

func (*Next_statementContext) IsNext_statementContext() {}

func NewNext_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Next_statementContext {
	var p = new(Next_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_next_statement

	return p
}

func (s *Next_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Next_statementContext) NEXT() antlr.TerminalNode {
	return s.GetToken(vhdlParserNEXT, 0)
}

func (s *Next_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Next_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Next_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Next_statementContext) WHEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserWHEN, 0)
}

func (s *Next_statementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Next_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Next_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Next_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterNext_statement(s)
	}
}

func (s *Next_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitNext_statement(s)
	}
}

func (s *Next_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitNext_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Next_statement() (localctx INext_statementContext) {
	localctx = NewNext_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, vhdlParserRULE_next_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1730)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1729)
			p.Label_colon()
		}

	}
	{
		p.SetState(1732)
		p.Match(vhdlParserNEXT)
	}
	p.SetState(1734)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1733)
			p.Identifier()
		}

	}
	p.SetState(1738)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserWHEN {
		{
			p.SetState(1736)
			p.Match(vhdlParserWHEN)
		}
		{
			p.SetState(1737)
			p.Condition()
		}

	}
	{
		p.SetState(1740)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// INumeric_literalContext is an interface to support dynamic dispatch.
type INumeric_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumeric_literalContext differentiates from other interfaces.
	IsNumeric_literalContext()
}

type Numeric_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumeric_literalContext() *Numeric_literalContext {
	var p = new(Numeric_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_numeric_literal
	return p
}

func (*Numeric_literalContext) IsNumeric_literalContext() {}

func NewNumeric_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Numeric_literalContext {
	var p = new(Numeric_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_numeric_literal

	return p
}

func (s *Numeric_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Numeric_literalContext) Abstract_literal() IAbstract_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_literalContext)
}

func (s *Numeric_literalContext) Physical_literal() IPhysical_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPhysical_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPhysical_literalContext)
}

func (s *Numeric_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Numeric_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Numeric_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterNumeric_literal(s)
	}
}

func (s *Numeric_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitNumeric_literal(s)
	}
}

func (s *Numeric_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitNumeric_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Numeric_literal() (localctx INumeric_literalContext) {
	localctx = NewNumeric_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, vhdlParserRULE_numeric_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1744)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1742)
			p.Abstract_literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1743)
			p.Physical_literal()
		}

	}

	return localctx
}

// IObject_declarationContext is an interface to support dynamic dispatch.
type IObject_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObject_declarationContext differentiates from other interfaces.
	IsObject_declarationContext()
}

type Object_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_declarationContext() *Object_declarationContext {
	var p = new(Object_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_object_declaration
	return p
}

func (*Object_declarationContext) IsObject_declarationContext() {}

func NewObject_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_declarationContext {
	var p = new(Object_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_object_declaration

	return p
}

func (s *Object_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_declarationContext) Constant_declaration() IConstant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declarationContext)
}

func (s *Object_declarationContext) Signal_declaration() ISignal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_declarationContext)
}

func (s *Object_declarationContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Object_declarationContext) File_declaration() IFile_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_declarationContext)
}

func (s *Object_declarationContext) Terminal_declaration() ITerminal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminal_declarationContext)
}

func (s *Object_declarationContext) Quantity_declaration() IQuantity_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantity_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantity_declarationContext)
}

func (s *Object_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterObject_declaration(s)
	}
}

func (s *Object_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitObject_declaration(s)
	}
}

func (s *Object_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitObject_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Object_declaration() (localctx IObject_declarationContext) {
	localctx = NewObject_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, vhdlParserRULE_object_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1752)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserCONSTANT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1746)
			p.Constant_declaration()
		}

	case vhdlParserSIGNAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1747)
			p.Signal_declaration()
		}

	case vhdlParserSHARED, vhdlParserVARIABLE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1748)
			p.Variable_declaration()
		}

	case vhdlParserFILE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1749)
			p.File_declaration()
		}

	case vhdlParserTERMINAL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1750)
			p.Terminal_declaration()
		}

	case vhdlParserQUANTITY:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1751)
			p.Quantity_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOptsContext is an interface to support dynamic dispatch.
type IOptsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptsContext differentiates from other interfaces.
	IsOptsContext()
}

type OptsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptsContext() *OptsContext {
	var p = new(OptsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_opts
	return p
}

func (*OptsContext) IsOptsContext() {}

func NewOptsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptsContext {
	var p = new(OptsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_opts

	return p
}

func (s *OptsContext) GetParser() antlr.Parser { return s.parser }

func (s *OptsContext) GUARDED() antlr.TerminalNode {
	return s.GetToken(vhdlParserGUARDED, 0)
}

func (s *OptsContext) Delay_mechanism() IDelay_mechanismContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_mechanismContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_mechanismContext)
}

func (s *OptsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterOpts(s)
	}
}

func (s *OptsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitOpts(s)
	}
}

func (s *OptsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitOpts(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Opts() (localctx IOptsContext) {
	localctx = NewOptsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, vhdlParserRULE_opts)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1755)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserGUARDED {
		{
			p.SetState(1754)
			p.Match(vhdlParserGUARDED)
		}

	}
	p.SetState(1758)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserINERTIAL || _la == vhdlParserREJECT || _la == vhdlParserTRANSPORT {
		{
			p.SetState(1757)
			p.Delay_mechanism()
		}

	}

	return localctx
}

// IPackage_bodyContext is an interface to support dynamic dispatch.
type IPackage_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_bodyContext differentiates from other interfaces.
	IsPackage_bodyContext()
}

type Package_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_bodyContext() *Package_bodyContext {
	var p = new(Package_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_package_body
	return p
}

func (*Package_bodyContext) IsPackage_bodyContext() {}

func NewPackage_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_bodyContext {
	var p = new(Package_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_package_body

	return p
}

func (s *Package_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_bodyContext) AllPACKAGE() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserPACKAGE)
}

func (s *Package_bodyContext) PACKAGE(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserPACKAGE, i)
}

func (s *Package_bodyContext) AllBODY() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserBODY)
}

func (s *Package_bodyContext) BODY(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserBODY, i)
}

func (s *Package_bodyContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Package_bodyContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Package_bodyContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Package_bodyContext) Package_body_declarative_part() IPackage_body_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_body_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_body_declarative_partContext)
}

func (s *Package_bodyContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Package_bodyContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Package_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPackage_body(s)
	}
}

func (s *Package_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPackage_body(s)
	}
}

func (s *Package_bodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitPackage_body(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Package_body() (localctx IPackage_bodyContext) {
	localctx = NewPackage_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, vhdlParserRULE_package_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1760)
		p.Match(vhdlParserPACKAGE)
	}
	{
		p.SetState(1761)
		p.Match(vhdlParserBODY)
	}
	{
		p.SetState(1762)
		p.Identifier()
	}
	{
		p.SetState(1763)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(1764)
		p.Package_body_declarative_part()
	}
	{
		p.SetState(1765)
		p.Match(vhdlParserEND)
	}
	p.SetState(1768)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPACKAGE {
		{
			p.SetState(1766)
			p.Match(vhdlParserPACKAGE)
		}
		{
			p.SetState(1767)
			p.Match(vhdlParserBODY)
		}

	}
	p.SetState(1771)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1770)
			p.Identifier()
		}

	}
	{
		p.SetState(1773)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IPackage_body_declarative_itemContext is an interface to support dynamic dispatch.
type IPackage_body_declarative_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_body_declarative_itemContext differentiates from other interfaces.
	IsPackage_body_declarative_itemContext()
}

type Package_body_declarative_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_body_declarative_itemContext() *Package_body_declarative_itemContext {
	var p = new(Package_body_declarative_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_package_body_declarative_item
	return p
}

func (*Package_body_declarative_itemContext) IsPackage_body_declarative_itemContext() {}

func NewPackage_body_declarative_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_body_declarative_itemContext {
	var p = new(Package_body_declarative_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_package_body_declarative_item

	return p
}

func (s *Package_body_declarative_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_body_declarative_itemContext) Subprogram_declaration() ISubprogram_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarationContext)
}

func (s *Package_body_declarative_itemContext) Subprogram_body() ISubprogram_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_bodyContext)
}

func (s *Package_body_declarative_itemContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Package_body_declarative_itemContext) Subtype_declaration() ISubtype_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_declarationContext)
}

func (s *Package_body_declarative_itemContext) Constant_declaration() IConstant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declarationContext)
}

func (s *Package_body_declarative_itemContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Package_body_declarative_itemContext) File_declaration() IFile_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_declarationContext)
}

func (s *Package_body_declarative_itemContext) Alias_declaration() IAlias_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_declarationContext)
}

func (s *Package_body_declarative_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Package_body_declarative_itemContext) Group_template_declaration() IGroup_template_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_template_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_template_declarationContext)
}

func (s *Package_body_declarative_itemContext) Group_declaration() IGroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_declarationContext)
}

func (s *Package_body_declarative_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_body_declarative_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_body_declarative_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPackage_body_declarative_item(s)
	}
}

func (s *Package_body_declarative_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPackage_body_declarative_item(s)
	}
}

func (s *Package_body_declarative_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitPackage_body_declarative_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Package_body_declarative_item() (localctx IPackage_body_declarative_itemContext) {
	localctx = NewPackage_body_declarative_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, vhdlParserRULE_package_body_declarative_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1786)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1775)
			p.Subprogram_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1776)
			p.Subprogram_body()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1777)
			p.Type_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1778)
			p.Subtype_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1779)
			p.Constant_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1780)
			p.Variable_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1781)
			p.File_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1782)
			p.Alias_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1783)
			p.Use_clause()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1784)
			p.Group_template_declaration()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1785)
			p.Group_declaration()
		}

	}

	return localctx
}

// IPackage_body_declarative_partContext is an interface to support dynamic dispatch.
type IPackage_body_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_body_declarative_partContext differentiates from other interfaces.
	IsPackage_body_declarative_partContext()
}

type Package_body_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_body_declarative_partContext() *Package_body_declarative_partContext {
	var p = new(Package_body_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_package_body_declarative_part
	return p
}

func (*Package_body_declarative_partContext) IsPackage_body_declarative_partContext() {}

func NewPackage_body_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_body_declarative_partContext {
	var p = new(Package_body_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_package_body_declarative_part

	return p
}

func (s *Package_body_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_body_declarative_partContext) AllPackage_body_declarative_item() []IPackage_body_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_body_declarative_itemContext)(nil)).Elem())
	var tst = make([]IPackage_body_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_body_declarative_itemContext)
		}
	}

	return tst
}

func (s *Package_body_declarative_partContext) Package_body_declarative_item(i int) IPackage_body_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_body_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_body_declarative_itemContext)
}

func (s *Package_body_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_body_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_body_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPackage_body_declarative_part(s)
	}
}

func (s *Package_body_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPackage_body_declarative_part(s)
	}
}

func (s *Package_body_declarative_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitPackage_body_declarative_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Package_body_declarative_part() (localctx IPackage_body_declarative_partContext) {
	localctx = NewPackage_body_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, vhdlParserRULE_package_body_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1791)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserFILE)|(1<<vhdlParserFUNCTION))) != 0) || _la == vhdlParserGROUP || _la == vhdlParserIMPURE || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSUBTYPE-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		{
			p.SetState(1788)
			p.Package_body_declarative_item()
		}

		p.SetState(1793)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPackage_declarationContext is an interface to support dynamic dispatch.
type IPackage_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_declarationContext differentiates from other interfaces.
	IsPackage_declarationContext()
}

type Package_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_declarationContext() *Package_declarationContext {
	var p = new(Package_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_package_declaration
	return p
}

func (*Package_declarationContext) IsPackage_declarationContext() {}

func NewPackage_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_declarationContext {
	var p = new(Package_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_package_declaration

	return p
}

func (s *Package_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_declarationContext) AllPACKAGE() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserPACKAGE)
}

func (s *Package_declarationContext) PACKAGE(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserPACKAGE, i)
}

func (s *Package_declarationContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Package_declarationContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Package_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Package_declarationContext) Package_declarative_part() IPackage_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_declarative_partContext)
}

func (s *Package_declarationContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Package_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Package_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPackage_declaration(s)
	}
}

func (s *Package_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPackage_declaration(s)
	}
}

func (s *Package_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitPackage_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Package_declaration() (localctx IPackage_declarationContext) {
	localctx = NewPackage_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, vhdlParserRULE_package_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1794)
		p.Match(vhdlParserPACKAGE)
	}
	{
		p.SetState(1795)
		p.Identifier()
	}
	{
		p.SetState(1796)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(1797)
		p.Package_declarative_part()
	}
	{
		p.SetState(1798)
		p.Match(vhdlParserEND)
	}
	p.SetState(1800)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPACKAGE {
		{
			p.SetState(1799)
			p.Match(vhdlParserPACKAGE)
		}

	}
	p.SetState(1803)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1802)
			p.Identifier()
		}

	}
	{
		p.SetState(1805)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IPackage_declarative_itemContext is an interface to support dynamic dispatch.
type IPackage_declarative_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_declarative_itemContext differentiates from other interfaces.
	IsPackage_declarative_itemContext()
}

type Package_declarative_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_declarative_itemContext() *Package_declarative_itemContext {
	var p = new(Package_declarative_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_package_declarative_item
	return p
}

func (*Package_declarative_itemContext) IsPackage_declarative_itemContext() {}

func NewPackage_declarative_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_declarative_itemContext {
	var p = new(Package_declarative_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_package_declarative_item

	return p
}

func (s *Package_declarative_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_declarative_itemContext) Subprogram_declaration() ISubprogram_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarationContext)
}

func (s *Package_declarative_itemContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Package_declarative_itemContext) Subtype_declaration() ISubtype_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_declarationContext)
}

func (s *Package_declarative_itemContext) Constant_declaration() IConstant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declarationContext)
}

func (s *Package_declarative_itemContext) Signal_declaration() ISignal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_declarationContext)
}

func (s *Package_declarative_itemContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Package_declarative_itemContext) File_declaration() IFile_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_declarationContext)
}

func (s *Package_declarative_itemContext) Alias_declaration() IAlias_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_declarationContext)
}

func (s *Package_declarative_itemContext) Component_declaration() IComponent_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_declarationContext)
}

func (s *Package_declarative_itemContext) Attribute_declaration() IAttribute_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_declarationContext)
}

func (s *Package_declarative_itemContext) Attribute_specification() IAttribute_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_specificationContext)
}

func (s *Package_declarative_itemContext) Disconnection_specification() IDisconnection_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisconnection_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisconnection_specificationContext)
}

func (s *Package_declarative_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Package_declarative_itemContext) Group_template_declaration() IGroup_template_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_template_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_template_declarationContext)
}

func (s *Package_declarative_itemContext) Group_declaration() IGroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_declarationContext)
}

func (s *Package_declarative_itemContext) Nature_declaration() INature_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INature_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INature_declarationContext)
}

func (s *Package_declarative_itemContext) Subnature_declaration() ISubnature_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_declarationContext)
}

func (s *Package_declarative_itemContext) Terminal_declaration() ITerminal_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminal_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminal_declarationContext)
}

func (s *Package_declarative_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_declarative_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_declarative_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPackage_declarative_item(s)
	}
}

func (s *Package_declarative_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPackage_declarative_item(s)
	}
}

func (s *Package_declarative_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitPackage_declarative_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Package_declarative_item() (localctx IPackage_declarative_itemContext) {
	localctx = NewPackage_declarative_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, vhdlParserRULE_package_declarative_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1825)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 190, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1807)
			p.Subprogram_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1808)
			p.Type_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1809)
			p.Subtype_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1810)
			p.Constant_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1811)
			p.Signal_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1812)
			p.Variable_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1813)
			p.File_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1814)
			p.Alias_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1815)
			p.Component_declaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1816)
			p.Attribute_declaration()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1817)
			p.Attribute_specification()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1818)
			p.Disconnection_specification()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1819)
			p.Use_clause()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1820)
			p.Group_template_declaration()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1821)
			p.Group_declaration()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1822)
			p.Nature_declaration()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1823)
			p.Subnature_declaration()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1824)
			p.Terminal_declaration()
		}

	}

	return localctx
}

// IPackage_declarative_partContext is an interface to support dynamic dispatch.
type IPackage_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_declarative_partContext differentiates from other interfaces.
	IsPackage_declarative_partContext()
}

type Package_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_declarative_partContext() *Package_declarative_partContext {
	var p = new(Package_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_package_declarative_part
	return p
}

func (*Package_declarative_partContext) IsPackage_declarative_partContext() {}

func NewPackage_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_declarative_partContext {
	var p = new(Package_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_package_declarative_part

	return p
}

func (s *Package_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_declarative_partContext) AllPackage_declarative_item() []IPackage_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_declarative_itemContext)(nil)).Elem())
	var tst = make([]IPackage_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_declarative_itemContext)
		}
	}

	return tst
}

func (s *Package_declarative_partContext) Package_declarative_item(i int) IPackage_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_declarative_itemContext)
}

func (s *Package_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPackage_declarative_part(s)
	}
}

func (s *Package_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPackage_declarative_part(s)
	}
}

func (s *Package_declarative_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitPackage_declarative_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Package_declarative_part() (localctx IPackage_declarative_partContext) {
	localctx = NewPackage_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, vhdlParserRULE_package_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1830)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserCOMPONENT)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserDISCONNECT)|(1<<vhdlParserFILE)|(1<<vhdlParserFUNCTION))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(vhdlParserGROUP-34))|(1<<(vhdlParserIMPURE-34))|(1<<(vhdlParserNATURE-34)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSIGNAL-68))|(1<<(vhdlParserSUBNATURE-68))|(1<<(vhdlParserSUBTYPE-68))|(1<<(vhdlParserTERMINAL-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		{
			p.SetState(1827)
			p.Package_declarative_item()
		}

		p.SetState(1832)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParameter_specificationContext is an interface to support dynamic dispatch.
type IParameter_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_specificationContext differentiates from other interfaces.
	IsParameter_specificationContext()
}

type Parameter_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_specificationContext() *Parameter_specificationContext {
	var p = new(Parameter_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_parameter_specification
	return p
}

func (*Parameter_specificationContext) IsParameter_specificationContext() {}

func NewParameter_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_specificationContext {
	var p = new(Parameter_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_parameter_specification

	return p
}

func (s *Parameter_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_specificationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Parameter_specificationContext) IN() antlr.TerminalNode {
	return s.GetToken(vhdlParserIN, 0)
}

func (s *Parameter_specificationContext) Discrete_range() IDiscrete_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDiscrete_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDiscrete_rangeContext)
}

func (s *Parameter_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterParameter_specification(s)
	}
}

func (s *Parameter_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitParameter_specification(s)
	}
}

func (s *Parameter_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitParameter_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Parameter_specification() (localctx IParameter_specificationContext) {
	localctx = NewParameter_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, vhdlParserRULE_parameter_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1833)
		p.Identifier()
	}
	{
		p.SetState(1834)
		p.Match(vhdlParserIN)
	}
	{
		p.SetState(1835)
		p.Discrete_range()
	}

	return localctx
}

// IPhysical_literalContext is an interface to support dynamic dispatch.
type IPhysical_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPhysical_literalContext differentiates from other interfaces.
	IsPhysical_literalContext()
}

type Physical_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPhysical_literalContext() *Physical_literalContext {
	var p = new(Physical_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_physical_literal
	return p
}

func (*Physical_literalContext) IsPhysical_literalContext() {}

func NewPhysical_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Physical_literalContext {
	var p = new(Physical_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_physical_literal

	return p
}

func (s *Physical_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Physical_literalContext) Abstract_literal() IAbstract_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_literalContext)
}

func (s *Physical_literalContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Physical_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Physical_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Physical_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPhysical_literal(s)
	}
}

func (s *Physical_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPhysical_literal(s)
	}
}

func (s *Physical_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitPhysical_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Physical_literal() (localctx IPhysical_literalContext) {
	localctx = NewPhysical_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, vhdlParserRULE_physical_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1837)
		p.Abstract_literal()
	}

	{
		p.SetState(1838)
		p.Identifier()
	}

	return localctx
}

// IPhysical_type_definitionContext is an interface to support dynamic dispatch.
type IPhysical_type_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPhysical_type_definitionContext differentiates from other interfaces.
	IsPhysical_type_definitionContext()
}

type Physical_type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPhysical_type_definitionContext() *Physical_type_definitionContext {
	var p = new(Physical_type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_physical_type_definition
	return p
}

func (*Physical_type_definitionContext) IsPhysical_type_definitionContext() {}

func NewPhysical_type_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Physical_type_definitionContext {
	var p = new(Physical_type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_physical_type_definition

	return p
}

func (s *Physical_type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Physical_type_definitionContext) Range_constraint() IRange_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_constraintContext)
}

func (s *Physical_type_definitionContext) AllUNITS() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserUNITS)
}

func (s *Physical_type_definitionContext) UNITS(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserUNITS, i)
}

func (s *Physical_type_definitionContext) Base_unit_declaration() IBase_unit_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_unit_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_unit_declarationContext)
}

func (s *Physical_type_definitionContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Physical_type_definitionContext) AllSecondary_unit_declaration() []ISecondary_unit_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISecondary_unit_declarationContext)(nil)).Elem())
	var tst = make([]ISecondary_unit_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISecondary_unit_declarationContext)
		}
	}

	return tst
}

func (s *Physical_type_definitionContext) Secondary_unit_declaration(i int) ISecondary_unit_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISecondary_unit_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISecondary_unit_declarationContext)
}

func (s *Physical_type_definitionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Physical_type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Physical_type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Physical_type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPhysical_type_definition(s)
	}
}

func (s *Physical_type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPhysical_type_definition(s)
	}
}

func (s *Physical_type_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitPhysical_type_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Physical_type_definition() (localctx IPhysical_type_definitionContext) {
	localctx = NewPhysical_type_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, vhdlParserRULE_physical_type_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1840)
		p.Range_constraint()
	}
	{
		p.SetState(1841)
		p.Match(vhdlParserUNITS)
	}
	{
		p.SetState(1842)
		p.Base_unit_declaration()
	}
	p.SetState(1846)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1843)
			p.Secondary_unit_declaration()
		}

		p.SetState(1848)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1849)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(1850)
		p.Match(vhdlParserUNITS)
	}
	p.SetState(1852)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1851)
			p.Identifier()
		}

	}

	return localctx
}

// IPort_clauseContext is an interface to support dynamic dispatch.
type IPort_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_clauseContext differentiates from other interfaces.
	IsPort_clauseContext()
}

type Port_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_clauseContext() *Port_clauseContext {
	var p = new(Port_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_port_clause
	return p
}

func (*Port_clauseContext) IsPort_clauseContext() {}

func NewPort_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_clauseContext {
	var p = new(Port_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_port_clause

	return p
}

func (s *Port_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_clauseContext) PORT() antlr.TerminalNode {
	return s.GetToken(vhdlParserPORT, 0)
}

func (s *Port_clauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Port_clauseContext) Port_list() IPort_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_listContext)
}

func (s *Port_clauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Port_clauseContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Port_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPort_clause(s)
	}
}

func (s *Port_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPort_clause(s)
	}
}

func (s *Port_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitPort_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Port_clause() (localctx IPort_clauseContext) {
	localctx = NewPort_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, vhdlParserRULE_port_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1854)
		p.Match(vhdlParserPORT)
	}
	{
		p.SetState(1855)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1856)
		p.Port_list()
	}
	{
		p.SetState(1857)
		p.Match(vhdlParserRPAREN)
	}
	{
		p.SetState(1858)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IPort_listContext is an interface to support dynamic dispatch.
type IPort_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_listContext differentiates from other interfaces.
	IsPort_listContext()
}

type Port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_listContext() *Port_listContext {
	var p = new(Port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_port_list
	return p
}

func (*Port_listContext) IsPort_listContext() {}

func NewPort_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_listContext {
	var p = new(Port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_port_list

	return p
}

func (s *Port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_listContext) Interface_port_list() IInterface_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_port_listContext)
}

func (s *Port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPort_list(s)
	}
}

func (s *Port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPort_list(s)
	}
}

func (s *Port_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitPort_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Port_list() (localctx IPort_listContext) {
	localctx = NewPort_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, vhdlParserRULE_port_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1860)
		p.Interface_port_list()
	}

	return localctx
}

// IPort_map_aspectContext is an interface to support dynamic dispatch.
type IPort_map_aspectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_map_aspectContext differentiates from other interfaces.
	IsPort_map_aspectContext()
}

type Port_map_aspectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_map_aspectContext() *Port_map_aspectContext {
	var p = new(Port_map_aspectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_port_map_aspect
	return p
}

func (*Port_map_aspectContext) IsPort_map_aspectContext() {}

func NewPort_map_aspectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_map_aspectContext {
	var p = new(Port_map_aspectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_port_map_aspect

	return p
}

func (s *Port_map_aspectContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_map_aspectContext) PORT() antlr.TerminalNode {
	return s.GetToken(vhdlParserPORT, 0)
}

func (s *Port_map_aspectContext) MAP() antlr.TerminalNode {
	return s.GetToken(vhdlParserMAP, 0)
}

func (s *Port_map_aspectContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Port_map_aspectContext) Association_list() IAssociation_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssociation_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssociation_listContext)
}

func (s *Port_map_aspectContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Port_map_aspectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_map_aspectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_map_aspectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPort_map_aspect(s)
	}
}

func (s *Port_map_aspectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPort_map_aspect(s)
	}
}

func (s *Port_map_aspectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitPort_map_aspect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Port_map_aspect() (localctx IPort_map_aspectContext) {
	localctx = NewPort_map_aspectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, vhdlParserRULE_port_map_aspect)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1862)
		p.Match(vhdlParserPORT)
	}
	{
		p.SetState(1863)
		p.Match(vhdlParserMAP)
	}
	{
		p.SetState(1864)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(1865)
		p.Association_list()
	}
	{
		p.SetState(1866)
		p.Match(vhdlParserRPAREN)
	}

	return localctx
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_primary
	return p
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryContext) Qualified_expression() IQualified_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualified_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualified_expressionContext)
}

func (s *PrimaryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *PrimaryContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *PrimaryContext) Allocator() IAllocatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAllocatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAllocatorContext)
}

func (s *PrimaryContext) Aggregate() IAggregateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregateContext)
}

func (s *PrimaryContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (s *PrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Primary() (localctx IPrimaryContext) {
	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, vhdlParserRULE_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1877)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 194, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1868)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1869)
			p.Qualified_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1870)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(1871)
			p.Expression()
		}
		{
			p.SetState(1872)
			p.Match(vhdlParserRPAREN)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1874)
			p.Allocator()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1875)
			p.Aggregate()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1876)
			p.Name()
		}

	}

	return localctx
}

// IPrimary_unitContext is an interface to support dynamic dispatch.
type IPrimary_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimary_unitContext differentiates from other interfaces.
	IsPrimary_unitContext()
}

type Primary_unitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_unitContext() *Primary_unitContext {
	var p = new(Primary_unitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_primary_unit
	return p
}

func (*Primary_unitContext) IsPrimary_unitContext() {}

func NewPrimary_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_unitContext {
	var p = new(Primary_unitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_primary_unit

	return p
}

func (s *Primary_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_unitContext) Entity_declaration() IEntity_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_declarationContext)
}

func (s *Primary_unitContext) Configuration_declaration() IConfiguration_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfiguration_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConfiguration_declarationContext)
}

func (s *Primary_unitContext) Package_declaration() IPackage_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_declarationContext)
}

func (s *Primary_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Primary_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterPrimary_unit(s)
	}
}

func (s *Primary_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitPrimary_unit(s)
	}
}

func (s *Primary_unitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitPrimary_unit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Primary_unit() (localctx IPrimary_unitContext) {
	localctx = NewPrimary_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, vhdlParserRULE_primary_unit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1882)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserENTITY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1879)
			p.Entity_declaration()
		}

	case vhdlParserCONFIGURATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1880)
			p.Configuration_declaration()
		}

	case vhdlParserPACKAGE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1881)
			p.Package_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProcedural_declarative_itemContext is an interface to support dynamic dispatch.
type IProcedural_declarative_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_declarative_itemContext differentiates from other interfaces.
	IsProcedural_declarative_itemContext()
}

type Procedural_declarative_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_declarative_itemContext() *Procedural_declarative_itemContext {
	var p = new(Procedural_declarative_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_procedural_declarative_item
	return p
}

func (*Procedural_declarative_itemContext) IsProcedural_declarative_itemContext() {}

func NewProcedural_declarative_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_declarative_itemContext {
	var p = new(Procedural_declarative_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_procedural_declarative_item

	return p
}

func (s *Procedural_declarative_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_declarative_itemContext) Subprogram_declaration() ISubprogram_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarationContext)
}

func (s *Procedural_declarative_itemContext) Subprogram_body() ISubprogram_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_bodyContext)
}

func (s *Procedural_declarative_itemContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Procedural_declarative_itemContext) Subtype_declaration() ISubtype_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_declarationContext)
}

func (s *Procedural_declarative_itemContext) Constant_declaration() IConstant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declarationContext)
}

func (s *Procedural_declarative_itemContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Procedural_declarative_itemContext) Alias_declaration() IAlias_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_declarationContext)
}

func (s *Procedural_declarative_itemContext) Attribute_declaration() IAttribute_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_declarationContext)
}

func (s *Procedural_declarative_itemContext) Attribute_specification() IAttribute_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_specificationContext)
}

func (s *Procedural_declarative_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Procedural_declarative_itemContext) Group_template_declaration() IGroup_template_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_template_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_template_declarationContext)
}

func (s *Procedural_declarative_itemContext) Group_declaration() IGroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_declarationContext)
}

func (s *Procedural_declarative_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_declarative_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_declarative_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcedural_declarative_item(s)
	}
}

func (s *Procedural_declarative_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcedural_declarative_item(s)
	}
}

func (s *Procedural_declarative_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitProcedural_declarative_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Procedural_declarative_item() (localctx IProcedural_declarative_itemContext) {
	localctx = NewProcedural_declarative_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, vhdlParserRULE_procedural_declarative_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1896)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 196, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1884)
			p.Subprogram_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1885)
			p.Subprogram_body()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1886)
			p.Type_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1887)
			p.Subtype_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1888)
			p.Constant_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1889)
			p.Variable_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1890)
			p.Alias_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1891)
			p.Attribute_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1892)
			p.Attribute_specification()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1893)
			p.Use_clause()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1894)
			p.Group_template_declaration()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1895)
			p.Group_declaration()
		}

	}

	return localctx
}

// IProcedural_declarative_partContext is an interface to support dynamic dispatch.
type IProcedural_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_declarative_partContext differentiates from other interfaces.
	IsProcedural_declarative_partContext()
}

type Procedural_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_declarative_partContext() *Procedural_declarative_partContext {
	var p = new(Procedural_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_procedural_declarative_part
	return p
}

func (*Procedural_declarative_partContext) IsProcedural_declarative_partContext() {}

func NewProcedural_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_declarative_partContext {
	var p = new(Procedural_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_procedural_declarative_part

	return p
}

func (s *Procedural_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_declarative_partContext) AllProcedural_declarative_item() []IProcedural_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcedural_declarative_itemContext)(nil)).Elem())
	var tst = make([]IProcedural_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcedural_declarative_itemContext)
		}
	}

	return tst
}

func (s *Procedural_declarative_partContext) Procedural_declarative_item(i int) IProcedural_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcedural_declarative_itemContext)
}

func (s *Procedural_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcedural_declarative_part(s)
	}
}

func (s *Procedural_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcedural_declarative_part(s)
	}
}

func (s *Procedural_declarative_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitProcedural_declarative_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Procedural_declarative_part() (localctx IProcedural_declarative_partContext) {
	localctx = NewProcedural_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, vhdlParserRULE_procedural_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1901)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserFUNCTION))) != 0) || _la == vhdlParserGROUP || _la == vhdlParserIMPURE || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSUBTYPE-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		{
			p.SetState(1898)
			p.Procedural_declarative_item()
		}

		p.SetState(1903)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProcedural_statement_partContext is an interface to support dynamic dispatch.
type IProcedural_statement_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_statement_partContext differentiates from other interfaces.
	IsProcedural_statement_partContext()
}

type Procedural_statement_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_statement_partContext() *Procedural_statement_partContext {
	var p = new(Procedural_statement_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_procedural_statement_part
	return p
}

func (*Procedural_statement_partContext) IsProcedural_statement_partContext() {}

func NewProcedural_statement_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_statement_partContext {
	var p = new(Procedural_statement_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_procedural_statement_part

	return p
}

func (s *Procedural_statement_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_statement_partContext) AllSequential_statement() []ISequential_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequential_statementContext)(nil)).Elem())
	var tst = make([]ISequential_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequential_statementContext)
		}
	}

	return tst
}

func (s *Procedural_statement_partContext) Sequential_statement(i int) ISequential_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequential_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequential_statementContext)
}

func (s *Procedural_statement_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_statement_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_statement_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcedural_statement_part(s)
	}
}

func (s *Procedural_statement_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcedural_statement_part(s)
	}
}

func (s *Procedural_statement_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitProcedural_statement_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Procedural_statement_part() (localctx IProcedural_statement_partContext) {
	localctx = NewProcedural_statement_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, vhdlParserRULE_procedural_statement_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1907)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserASSERT)|(1<<vhdlParserBREAK)|(1<<vhdlParserCASE)|(1<<vhdlParserEXIT)|(1<<vhdlParserFOR))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(vhdlParserIF-36))|(1<<(vhdlParserLOOP-36))|(1<<(vhdlParserNEXT-36))|(1<<(vhdlParserNULL-36)))) != 0) || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(vhdlParserREPORT-79))|(1<<(vhdlParserRETURN-79))|(1<<(vhdlParserWAIT-79))|(1<<(vhdlParserWHILE-79)))) != 0) || (((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(vhdlParserBASIC_IDENTIFIER-118))|(1<<(vhdlParserEXTENDED_IDENTIFIER-118))|(1<<(vhdlParserLPAREN-118)))) != 0) {
		{
			p.SetState(1904)
			p.Sequential_statement()
		}

		p.SetState(1909)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProcedure_callContext is an interface to support dynamic dispatch.
type IProcedure_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedure_callContext differentiates from other interfaces.
	IsProcedure_callContext()
}

type Procedure_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedure_callContext() *Procedure_callContext {
	var p = new(Procedure_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_procedure_call
	return p
}

func (*Procedure_callContext) IsProcedure_callContext() {}

func NewProcedure_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedure_callContext {
	var p = new(Procedure_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_procedure_call

	return p
}

func (s *Procedure_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedure_callContext) Selected_name() ISelected_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelected_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelected_nameContext)
}

func (s *Procedure_callContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Procedure_callContext) Actual_parameter_part() IActual_parameter_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActual_parameter_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActual_parameter_partContext)
}

func (s *Procedure_callContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Procedure_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedure_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedure_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcedure_call(s)
	}
}

func (s *Procedure_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcedure_call(s)
	}
}

func (s *Procedure_callContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitProcedure_call(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Procedure_call() (localctx IProcedure_callContext) {
	localctx = NewProcedure_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, vhdlParserRULE_procedure_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1910)
		p.Selected_name()
	}
	p.SetState(1915)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserLPAREN {
		{
			p.SetState(1911)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(1912)
			p.Actual_parameter_part()
		}
		{
			p.SetState(1913)
			p.Match(vhdlParserRPAREN)
		}

	}

	return localctx
}

// IProcedure_call_statementContext is an interface to support dynamic dispatch.
type IProcedure_call_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedure_call_statementContext differentiates from other interfaces.
	IsProcedure_call_statementContext()
}

type Procedure_call_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedure_call_statementContext() *Procedure_call_statementContext {
	var p = new(Procedure_call_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_procedure_call_statement
	return p
}

func (*Procedure_call_statementContext) IsProcedure_call_statementContext() {}

func NewProcedure_call_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedure_call_statementContext {
	var p = new(Procedure_call_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_procedure_call_statement

	return p
}

func (s *Procedure_call_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedure_call_statementContext) Procedure_call() IProcedure_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_callContext)
}

func (s *Procedure_call_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Procedure_call_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Procedure_call_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedure_call_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedure_call_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcedure_call_statement(s)
	}
}

func (s *Procedure_call_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcedure_call_statement(s)
	}
}

func (s *Procedure_call_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitProcedure_call_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Procedure_call_statement() (localctx IProcedure_call_statementContext) {
	localctx = NewProcedure_call_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, vhdlParserRULE_procedure_call_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1918)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 200, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1917)
			p.Label_colon()
		}

	}
	{
		p.SetState(1920)
		p.Procedure_call()
	}
	{
		p.SetState(1921)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IProcess_declarative_itemContext is an interface to support dynamic dispatch.
type IProcess_declarative_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcess_declarative_itemContext differentiates from other interfaces.
	IsProcess_declarative_itemContext()
}

type Process_declarative_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcess_declarative_itemContext() *Process_declarative_itemContext {
	var p = new(Process_declarative_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_process_declarative_item
	return p
}

func (*Process_declarative_itemContext) IsProcess_declarative_itemContext() {}

func NewProcess_declarative_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Process_declarative_itemContext {
	var p = new(Process_declarative_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_process_declarative_item

	return p
}

func (s *Process_declarative_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Process_declarative_itemContext) Subprogram_declaration() ISubprogram_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarationContext)
}

func (s *Process_declarative_itemContext) Subprogram_body() ISubprogram_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_bodyContext)
}

func (s *Process_declarative_itemContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Process_declarative_itemContext) Subtype_declaration() ISubtype_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_declarationContext)
}

func (s *Process_declarative_itemContext) Constant_declaration() IConstant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declarationContext)
}

func (s *Process_declarative_itemContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Process_declarative_itemContext) File_declaration() IFile_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_declarationContext)
}

func (s *Process_declarative_itemContext) Alias_declaration() IAlias_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_declarationContext)
}

func (s *Process_declarative_itemContext) Attribute_declaration() IAttribute_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_declarationContext)
}

func (s *Process_declarative_itemContext) Attribute_specification() IAttribute_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_specificationContext)
}

func (s *Process_declarative_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Process_declarative_itemContext) Group_template_declaration() IGroup_template_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_template_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_template_declarationContext)
}

func (s *Process_declarative_itemContext) Group_declaration() IGroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_declarationContext)
}

func (s *Process_declarative_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Process_declarative_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Process_declarative_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcess_declarative_item(s)
	}
}

func (s *Process_declarative_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcess_declarative_item(s)
	}
}

func (s *Process_declarative_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitProcess_declarative_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Process_declarative_item() (localctx IProcess_declarative_itemContext) {
	localctx = NewProcess_declarative_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, vhdlParserRULE_process_declarative_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1936)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 201, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1923)
			p.Subprogram_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1924)
			p.Subprogram_body()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1925)
			p.Type_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1926)
			p.Subtype_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1927)
			p.Constant_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1928)
			p.Variable_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1929)
			p.File_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1930)
			p.Alias_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1931)
			p.Attribute_declaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1932)
			p.Attribute_specification()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1933)
			p.Use_clause()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1934)
			p.Group_template_declaration()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1935)
			p.Group_declaration()
		}

	}

	return localctx
}

// IProcess_declarative_partContext is an interface to support dynamic dispatch.
type IProcess_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcess_declarative_partContext differentiates from other interfaces.
	IsProcess_declarative_partContext()
}

type Process_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcess_declarative_partContext() *Process_declarative_partContext {
	var p = new(Process_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_process_declarative_part
	return p
}

func (*Process_declarative_partContext) IsProcess_declarative_partContext() {}

func NewProcess_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Process_declarative_partContext {
	var p = new(Process_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_process_declarative_part

	return p
}

func (s *Process_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Process_declarative_partContext) AllProcess_declarative_item() []IProcess_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcess_declarative_itemContext)(nil)).Elem())
	var tst = make([]IProcess_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcess_declarative_itemContext)
		}
	}

	return tst
}

func (s *Process_declarative_partContext) Process_declarative_item(i int) IProcess_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcess_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcess_declarative_itemContext)
}

func (s *Process_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Process_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Process_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcess_declarative_part(s)
	}
}

func (s *Process_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcess_declarative_part(s)
	}
}

func (s *Process_declarative_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitProcess_declarative_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Process_declarative_part() (localctx IProcess_declarative_partContext) {
	localctx = NewProcess_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, vhdlParserRULE_process_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1941)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserFILE)|(1<<vhdlParserFUNCTION))) != 0) || _la == vhdlParserGROUP || _la == vhdlParserIMPURE || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSUBTYPE-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		{
			p.SetState(1938)
			p.Process_declarative_item()
		}

		p.SetState(1943)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProcess_statementContext is an interface to support dynamic dispatch.
type IProcess_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcess_statementContext differentiates from other interfaces.
	IsProcess_statementContext()
}

type Process_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcess_statementContext() *Process_statementContext {
	var p = new(Process_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_process_statement
	return p
}

func (*Process_statementContext) IsProcess_statementContext() {}

func NewProcess_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Process_statementContext {
	var p = new(Process_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_process_statement

	return p
}

func (s *Process_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Process_statementContext) AllPROCESS() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserPROCESS)
}

func (s *Process_statementContext) PROCESS(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserPROCESS, i)
}

func (s *Process_statementContext) Process_declarative_part() IProcess_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcess_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcess_declarative_partContext)
}

func (s *Process_statementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(vhdlParserBEGIN, 0)
}

func (s *Process_statementContext) Process_statement_part() IProcess_statement_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcess_statement_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcess_statement_partContext)
}

func (s *Process_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Process_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Process_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Process_statementContext) AllPOSTPONED() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserPOSTPONED)
}

func (s *Process_statementContext) POSTPONED(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserPOSTPONED, i)
}

func (s *Process_statementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Process_statementContext) Sensitivity_list() ISensitivity_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISensitivity_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISensitivity_listContext)
}

func (s *Process_statementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Process_statementContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Process_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Process_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Process_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Process_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcess_statement(s)
	}
}

func (s *Process_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcess_statement(s)
	}
}

func (s *Process_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitProcess_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Process_statement() (localctx IProcess_statementContext) {
	localctx = NewProcess_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, vhdlParserRULE_process_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1945)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1944)
			p.Label_colon()
		}

	}
	p.SetState(1948)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPOSTPONED {
		{
			p.SetState(1947)
			p.Match(vhdlParserPOSTPONED)
		}

	}
	{
		p.SetState(1950)
		p.Match(vhdlParserPROCESS)
	}
	p.SetState(1955)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserLPAREN {
		{
			p.SetState(1951)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(1952)
			p.Sensitivity_list()
		}
		{
			p.SetState(1953)
			p.Match(vhdlParserRPAREN)
		}

	}
	p.SetState(1958)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIS {
		{
			p.SetState(1957)
			p.Match(vhdlParserIS)
		}

	}
	{
		p.SetState(1960)
		p.Process_declarative_part()
	}
	{
		p.SetState(1961)
		p.Match(vhdlParserBEGIN)
	}
	{
		p.SetState(1962)
		p.Process_statement_part()
	}
	{
		p.SetState(1963)
		p.Match(vhdlParserEND)
	}
	p.SetState(1965)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPOSTPONED {
		{
			p.SetState(1964)
			p.Match(vhdlParserPOSTPONED)
		}

	}
	{
		p.SetState(1967)
		p.Match(vhdlParserPROCESS)
	}
	p.SetState(1969)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(1968)
			p.Identifier()
		}

	}
	{
		p.SetState(1971)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IProcess_statement_partContext is an interface to support dynamic dispatch.
type IProcess_statement_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcess_statement_partContext differentiates from other interfaces.
	IsProcess_statement_partContext()
}

type Process_statement_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcess_statement_partContext() *Process_statement_partContext {
	var p = new(Process_statement_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_process_statement_part
	return p
}

func (*Process_statement_partContext) IsProcess_statement_partContext() {}

func NewProcess_statement_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Process_statement_partContext {
	var p = new(Process_statement_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_process_statement_part

	return p
}

func (s *Process_statement_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Process_statement_partContext) AllSequential_statement() []ISequential_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequential_statementContext)(nil)).Elem())
	var tst = make([]ISequential_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequential_statementContext)
		}
	}

	return tst
}

func (s *Process_statement_partContext) Sequential_statement(i int) ISequential_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequential_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequential_statementContext)
}

func (s *Process_statement_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Process_statement_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Process_statement_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcess_statement_part(s)
	}
}

func (s *Process_statement_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcess_statement_part(s)
	}
}

func (s *Process_statement_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitProcess_statement_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Process_statement_part() (localctx IProcess_statement_partContext) {
	localctx = NewProcess_statement_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, vhdlParserRULE_process_statement_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1976)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserASSERT)|(1<<vhdlParserBREAK)|(1<<vhdlParserCASE)|(1<<vhdlParserEXIT)|(1<<vhdlParserFOR))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(vhdlParserIF-36))|(1<<(vhdlParserLOOP-36))|(1<<(vhdlParserNEXT-36))|(1<<(vhdlParserNULL-36)))) != 0) || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(vhdlParserREPORT-79))|(1<<(vhdlParserRETURN-79))|(1<<(vhdlParserWAIT-79))|(1<<(vhdlParserWHILE-79)))) != 0) || (((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(vhdlParserBASIC_IDENTIFIER-118))|(1<<(vhdlParserEXTENDED_IDENTIFIER-118))|(1<<(vhdlParserLPAREN-118)))) != 0) {
		{
			p.SetState(1973)
			p.Sequential_statement()
		}

		p.SetState(1978)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IQualified_expressionContext is an interface to support dynamic dispatch.
type IQualified_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualified_expressionContext differentiates from other interfaces.
	IsQualified_expressionContext()
}

type Qualified_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualified_expressionContext() *Qualified_expressionContext {
	var p = new(Qualified_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_qualified_expression
	return p
}

func (*Qualified_expressionContext) IsQualified_expressionContext() {}

func NewQualified_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Qualified_expressionContext {
	var p = new(Qualified_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_qualified_expression

	return p
}

func (s *Qualified_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Qualified_expressionContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Qualified_expressionContext) APOSTROPHE() antlr.TerminalNode {
	return s.GetToken(vhdlParserAPOSTROPHE, 0)
}

func (s *Qualified_expressionContext) Aggregate() IAggregateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregateContext)
}

func (s *Qualified_expressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Qualified_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Qualified_expressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Qualified_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Qualified_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Qualified_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterQualified_expression(s)
	}
}

func (s *Qualified_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitQualified_expression(s)
	}
}

func (s *Qualified_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitQualified_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Qualified_expression() (localctx IQualified_expressionContext) {
	localctx = NewQualified_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, vhdlParserRULE_qualified_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1979)
		p.Subtype_indication()
	}
	{
		p.SetState(1980)
		p.Match(vhdlParserAPOSTROPHE)
	}
	p.SetState(1986)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 210, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1981)
			p.Aggregate()
		}

	case 2:
		{
			p.SetState(1982)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(1983)
			p.Expression()
		}
		{
			p.SetState(1984)
			p.Match(vhdlParserRPAREN)
		}

	}

	return localctx
}

// IQuantity_declarationContext is an interface to support dynamic dispatch.
type IQuantity_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuantity_declarationContext differentiates from other interfaces.
	IsQuantity_declarationContext()
}

type Quantity_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantity_declarationContext() *Quantity_declarationContext {
	var p = new(Quantity_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_quantity_declaration
	return p
}

func (*Quantity_declarationContext) IsQuantity_declarationContext() {}

func NewQuantity_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quantity_declarationContext {
	var p = new(Quantity_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_quantity_declaration

	return p
}

func (s *Quantity_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Quantity_declarationContext) Free_quantity_declaration() IFree_quantity_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFree_quantity_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFree_quantity_declarationContext)
}

func (s *Quantity_declarationContext) Branch_quantity_declaration() IBranch_quantity_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBranch_quantity_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBranch_quantity_declarationContext)
}

func (s *Quantity_declarationContext) Source_quantity_declaration() ISource_quantity_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISource_quantity_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISource_quantity_declarationContext)
}

func (s *Quantity_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quantity_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quantity_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterQuantity_declaration(s)
	}
}

func (s *Quantity_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitQuantity_declaration(s)
	}
}

func (s *Quantity_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitQuantity_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Quantity_declaration() (localctx IQuantity_declarationContext) {
	localctx = NewQuantity_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, vhdlParserRULE_quantity_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1991)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 211, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1988)
			p.Free_quantity_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1989)
			p.Branch_quantity_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1990)
			p.Source_quantity_declaration()
		}

	}

	return localctx
}

// IQuantity_listContext is an interface to support dynamic dispatch.
type IQuantity_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuantity_listContext differentiates from other interfaces.
	IsQuantity_listContext()
}

type Quantity_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantity_listContext() *Quantity_listContext {
	var p = new(Quantity_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_quantity_list
	return p
}

func (*Quantity_listContext) IsQuantity_listContext() {}

func NewQuantity_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quantity_listContext {
	var p = new(Quantity_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_quantity_list

	return p
}

func (s *Quantity_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Quantity_listContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *Quantity_listContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Quantity_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Quantity_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Quantity_listContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(vhdlParserOTHERS, 0)
}

func (s *Quantity_listContext) ALL() antlr.TerminalNode {
	return s.GetToken(vhdlParserALL, 0)
}

func (s *Quantity_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quantity_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quantity_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterQuantity_list(s)
	}
}

func (s *Quantity_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitQuantity_list(s)
	}
}

func (s *Quantity_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitQuantity_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Quantity_list() (localctx IQuantity_listContext) {
	localctx = NewQuantity_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, vhdlParserRULE_quantity_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2003)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1993)
			p.Name()
		}
		p.SetState(1998)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == vhdlParserCOMMA {
			{
				p.SetState(1994)
				p.Match(vhdlParserCOMMA)
			}
			{
				p.SetState(1995)
				p.Name()
			}

			p.SetState(2000)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case vhdlParserOTHERS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2001)
			p.Match(vhdlParserOTHERS)
		}

	case vhdlParserALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2002)
			p.Match(vhdlParserALL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQuantity_specificationContext is an interface to support dynamic dispatch.
type IQuantity_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuantity_specificationContext differentiates from other interfaces.
	IsQuantity_specificationContext()
}

type Quantity_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantity_specificationContext() *Quantity_specificationContext {
	var p = new(Quantity_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_quantity_specification
	return p
}

func (*Quantity_specificationContext) IsQuantity_specificationContext() {}

func NewQuantity_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quantity_specificationContext {
	var p = new(Quantity_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_quantity_specification

	return p
}

func (s *Quantity_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Quantity_specificationContext) Quantity_list() IQuantity_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantity_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantity_listContext)
}

func (s *Quantity_specificationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Quantity_specificationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Quantity_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quantity_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quantity_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterQuantity_specification(s)
	}
}

func (s *Quantity_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitQuantity_specification(s)
	}
}

func (s *Quantity_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitQuantity_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Quantity_specification() (localctx IQuantity_specificationContext) {
	localctx = NewQuantity_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, vhdlParserRULE_quantity_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2005)
		p.Quantity_list()
	}
	{
		p.SetState(2006)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(2007)
		p.Name()
	}

	return localctx
}

// IRange_declContext is an interface to support dynamic dispatch.
type IRange_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRange_declContext differentiates from other interfaces.
	IsRange_declContext()
}

type Range_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_declContext() *Range_declContext {
	var p = new(Range_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_range_decl
	return p
}

func (*Range_declContext) IsRange_declContext() {}

func NewRange_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_declContext {
	var p = new(Range_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_range_decl

	return p
}

func (s *Range_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_declContext) Explicit_range() IExplicit_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicit_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplicit_rangeContext)
}

func (s *Range_declContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Range_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterRange_decl(s)
	}
}

func (s *Range_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitRange_decl(s)
	}
}

func (s *Range_declContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitRange_decl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Range_decl() (localctx IRange_declContext) {
	localctx = NewRange_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, vhdlParserRULE_range_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2011)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 214, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2009)
			p.Explicit_range()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2010)
			p.Name()
		}

	}

	return localctx
}

// IExplicit_rangeContext is an interface to support dynamic dispatch.
type IExplicit_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplicit_rangeContext differentiates from other interfaces.
	IsExplicit_rangeContext()
}

type Explicit_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicit_rangeContext() *Explicit_rangeContext {
	var p = new(Explicit_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_explicit_range
	return p
}

func (*Explicit_rangeContext) IsExplicit_rangeContext() {}

func NewExplicit_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Explicit_rangeContext {
	var p = new(Explicit_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_explicit_range

	return p
}

func (s *Explicit_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Explicit_rangeContext) AllSimple_expression() []ISimple_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem())
	var tst = make([]ISimple_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_expressionContext)
		}
	}

	return tst
}

func (s *Explicit_rangeContext) Simple_expression(i int) ISimple_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_expressionContext)
}

func (s *Explicit_rangeContext) Direction() IDirectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDirectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDirectionContext)
}

func (s *Explicit_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Explicit_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Explicit_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterExplicit_range(s)
	}
}

func (s *Explicit_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitExplicit_range(s)
	}
}

func (s *Explicit_rangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitExplicit_range(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Explicit_range() (localctx IExplicit_rangeContext) {
	localctx = NewExplicit_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, vhdlParserRULE_explicit_range)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2013)
		p.Simple_expression()
	}
	p.SetState(2017)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 215, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2014)
			p.Direction()
		}
		{
			p.SetState(2015)
			p.Simple_expression()
		}

	}

	return localctx
}

// IRange_constraintContext is an interface to support dynamic dispatch.
type IRange_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRange_constraintContext differentiates from other interfaces.
	IsRange_constraintContext()
}

type Range_constraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_constraintContext() *Range_constraintContext {
	var p = new(Range_constraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_range_constraint
	return p
}

func (*Range_constraintContext) IsRange_constraintContext() {}

func NewRange_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_constraintContext {
	var p = new(Range_constraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_range_constraint

	return p
}

func (s *Range_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_constraintContext) RANGE() antlr.TerminalNode {
	return s.GetToken(vhdlParserRANGE, 0)
}

func (s *Range_constraintContext) Range_decl() IRange_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_declContext)
}

func (s *Range_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterRange_constraint(s)
	}
}

func (s *Range_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitRange_constraint(s)
	}
}

func (s *Range_constraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitRange_constraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Range_constraint() (localctx IRange_constraintContext) {
	localctx = NewRange_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, vhdlParserRULE_range_constraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2019)
		p.Match(vhdlParserRANGE)
	}
	{
		p.SetState(2020)
		p.Range_decl()
	}

	return localctx
}

// IRecord_nature_definitionContext is an interface to support dynamic dispatch.
type IRecord_nature_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecord_nature_definitionContext differentiates from other interfaces.
	IsRecord_nature_definitionContext()
}

type Record_nature_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecord_nature_definitionContext() *Record_nature_definitionContext {
	var p = new(Record_nature_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_record_nature_definition
	return p
}

func (*Record_nature_definitionContext) IsRecord_nature_definitionContext() {}

func NewRecord_nature_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Record_nature_definitionContext {
	var p = new(Record_nature_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_record_nature_definition

	return p
}

func (s *Record_nature_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Record_nature_definitionContext) AllRECORD() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserRECORD)
}

func (s *Record_nature_definitionContext) RECORD(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserRECORD, i)
}

func (s *Record_nature_definitionContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Record_nature_definitionContext) AllNature_element_declaration() []INature_element_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INature_element_declarationContext)(nil)).Elem())
	var tst = make([]INature_element_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INature_element_declarationContext)
		}
	}

	return tst
}

func (s *Record_nature_definitionContext) Nature_element_declaration(i int) INature_element_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INature_element_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INature_element_declarationContext)
}

func (s *Record_nature_definitionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Record_nature_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Record_nature_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Record_nature_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterRecord_nature_definition(s)
	}
}

func (s *Record_nature_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitRecord_nature_definition(s)
	}
}

func (s *Record_nature_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitRecord_nature_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Record_nature_definition() (localctx IRecord_nature_definitionContext) {
	localctx = NewRecord_nature_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, vhdlParserRULE_record_nature_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2022)
		p.Match(vhdlParserRECORD)
	}
	p.SetState(2024)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2023)
			p.Nature_element_declaration()
		}

		p.SetState(2026)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2028)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(2029)
		p.Match(vhdlParserRECORD)
	}
	p.SetState(2031)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2030)
			p.Identifier()
		}

	}

	return localctx
}

// IRecord_type_definitionContext is an interface to support dynamic dispatch.
type IRecord_type_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecord_type_definitionContext differentiates from other interfaces.
	IsRecord_type_definitionContext()
}

type Record_type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecord_type_definitionContext() *Record_type_definitionContext {
	var p = new(Record_type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_record_type_definition
	return p
}

func (*Record_type_definitionContext) IsRecord_type_definitionContext() {}

func NewRecord_type_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Record_type_definitionContext {
	var p = new(Record_type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_record_type_definition

	return p
}

func (s *Record_type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Record_type_definitionContext) AllRECORD() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserRECORD)
}

func (s *Record_type_definitionContext) RECORD(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserRECORD, i)
}

func (s *Record_type_definitionContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Record_type_definitionContext) AllElement_declaration() []IElement_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElement_declarationContext)(nil)).Elem())
	var tst = make([]IElement_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElement_declarationContext)
		}
	}

	return tst
}

func (s *Record_type_definitionContext) Element_declaration(i int) IElement_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElement_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElement_declarationContext)
}

func (s *Record_type_definitionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Record_type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Record_type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Record_type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterRecord_type_definition(s)
	}
}

func (s *Record_type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitRecord_type_definition(s)
	}
}

func (s *Record_type_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitRecord_type_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Record_type_definition() (localctx IRecord_type_definitionContext) {
	localctx = NewRecord_type_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, vhdlParserRULE_record_type_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2033)
		p.Match(vhdlParserRECORD)
	}
	p.SetState(2035)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2034)
			p.Element_declaration()
		}

		p.SetState(2037)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2039)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(2040)
		p.Match(vhdlParserRECORD)
	}
	p.SetState(2042)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2041)
			p.Identifier()
		}

	}

	return localctx
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_relation
	return p
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) AllShift_expression() []IShift_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IShift_expressionContext)(nil)).Elem())
	var tst = make([]IShift_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IShift_expressionContext)
		}
	}

	return tst
}

func (s *RelationContext) Shift_expression(i int) IShift_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IShift_expressionContext)
}

func (s *RelationContext) Relational_operator() IRelational_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelational_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelational_operatorContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterRelation(s)
	}
}

func (s *RelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitRelation(s)
	}
}

func (s *RelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Relation() (localctx IRelationContext) {
	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, vhdlParserRULE_relation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2044)
		p.Shift_expression()
	}
	p.SetState(2048)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 220, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2045)
			p.Relational_operator()
		}
		{
			p.SetState(2046)
			p.Shift_expression()
		}

	}

	return localctx
}

// IRelational_operatorContext is an interface to support dynamic dispatch.
type IRelational_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelational_operatorContext differentiates from other interfaces.
	IsRelational_operatorContext()
}

type Relational_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelational_operatorContext() *Relational_operatorContext {
	var p = new(Relational_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_relational_operator
	return p
}

func (*Relational_operatorContext) IsRelational_operatorContext() {}

func NewRelational_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relational_operatorContext {
	var p = new(Relational_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_relational_operator

	return p
}

func (s *Relational_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Relational_operatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(vhdlParserEQ, 0)
}

func (s *Relational_operatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(vhdlParserNEQ, 0)
}

func (s *Relational_operatorContext) LOWERTHAN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLOWERTHAN, 0)
}

func (s *Relational_operatorContext) LE() antlr.TerminalNode {
	return s.GetToken(vhdlParserLE, 0)
}

func (s *Relational_operatorContext) GREATERTHAN() antlr.TerminalNode {
	return s.GetToken(vhdlParserGREATERTHAN, 0)
}

func (s *Relational_operatorContext) GE() antlr.TerminalNode {
	return s.GetToken(vhdlParserGE, 0)
}

func (s *Relational_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relational_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relational_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterRelational_operator(s)
	}
}

func (s *Relational_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitRelational_operator(s)
	}
}

func (s *Relational_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitRelational_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Relational_operator() (localctx IRelational_operatorContext) {
	localctx = NewRelational_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, vhdlParserRULE_relational_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2050)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-131)&-(0x1f+1)) == 0 && ((1<<uint((_la-131)))&((1<<(vhdlParserLE-131))|(1<<(vhdlParserGE-131))|(1<<(vhdlParserNEQ-131))|(1<<(vhdlParserLOWERTHAN-131))|(1<<(vhdlParserGREATERTHAN-131))|(1<<(vhdlParserEQ-131)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IReport_statementContext is an interface to support dynamic dispatch.
type IReport_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReport_statementContext differentiates from other interfaces.
	IsReport_statementContext()
}

type Report_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReport_statementContext() *Report_statementContext {
	var p = new(Report_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_report_statement
	return p
}

func (*Report_statementContext) IsReport_statementContext() {}

func NewReport_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Report_statementContext {
	var p = new(Report_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_report_statement

	return p
}

func (s *Report_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Report_statementContext) REPORT() antlr.TerminalNode {
	return s.GetToken(vhdlParserREPORT, 0)
}

func (s *Report_statementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Report_statementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Report_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Report_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Report_statementContext) SEVERITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEVERITY, 0)
}

func (s *Report_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Report_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Report_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterReport_statement(s)
	}
}

func (s *Report_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitReport_statement(s)
	}
}

func (s *Report_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitReport_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Report_statement() (localctx IReport_statementContext) {
	localctx = NewReport_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, vhdlParserRULE_report_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2053)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2052)
			p.Label_colon()
		}

	}
	{
		p.SetState(2055)
		p.Match(vhdlParserREPORT)
	}
	{
		p.SetState(2056)
		p.Expression()
	}
	p.SetState(2059)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserSEVERITY {
		{
			p.SetState(2057)
			p.Match(vhdlParserSEVERITY)
		}
		{
			p.SetState(2058)
			p.Expression()
		}

	}
	{
		p.SetState(2061)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IReturn_statementContext is an interface to support dynamic dispatch.
type IReturn_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturn_statementContext differentiates from other interfaces.
	IsReturn_statementContext()
}

type Return_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_statementContext() *Return_statementContext {
	var p = new(Return_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_return_statement
	return p
}

func (*Return_statementContext) IsReturn_statementContext() {}

func NewReturn_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_statementContext {
	var p = new(Return_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_return_statement

	return p
}

func (s *Return_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_statementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRETURN, 0)
}

func (s *Return_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Return_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Return_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Return_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Return_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterReturn_statement(s)
	}
}

func (s *Return_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitReturn_statement(s)
	}
}

func (s *Return_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitReturn_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Return_statement() (localctx IReturn_statementContext) {
	localctx = NewReturn_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, vhdlParserRULE_return_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2064)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2063)
			p.Label_colon()
		}

	}
	{
		p.SetState(2066)
		p.Match(vhdlParserRETURN)
	}
	p.SetState(2068)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserABS || (((_la-52)&-(0x1f+1)) == 0 && ((1<<uint((_la-52)))&((1<<(vhdlParserNEW-52))|(1<<(vhdlParserNOT-52))|(1<<(vhdlParserNULL-52)))) != 0) || (((_la-112)&-(0x1f+1)) == 0 && ((1<<uint((_la-112)))&((1<<(vhdlParserBASE_LITERAL-112))|(1<<(vhdlParserBIT_STRING_LITERAL-112))|(1<<(vhdlParserREAL_LITERAL-112))|(1<<(vhdlParserBASIC_IDENTIFIER-112))|(1<<(vhdlParserEXTENDED_IDENTIFIER-112))|(1<<(vhdlParserCHARACTER_LITERAL-112))|(1<<(vhdlParserSTRING_LITERAL-112))|(1<<(vhdlParserLPAREN-112)))) != 0) || (((_la-148)&-(0x1f+1)) == 0 && ((1<<uint((_la-148)))&((1<<(vhdlParserPLUS-148))|(1<<(vhdlParserMINUS-148))|(1<<(vhdlParserINTEGER-148)))) != 0) {
		{
			p.SetState(2067)
			p.Expression()
		}

	}
	{
		p.SetState(2070)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IScalar_nature_definitionContext is an interface to support dynamic dispatch.
type IScalar_nature_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScalar_nature_definitionContext differentiates from other interfaces.
	IsScalar_nature_definitionContext()
}

type Scalar_nature_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalar_nature_definitionContext() *Scalar_nature_definitionContext {
	var p = new(Scalar_nature_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_scalar_nature_definition
	return p
}

func (*Scalar_nature_definitionContext) IsScalar_nature_definitionContext() {}

func NewScalar_nature_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Scalar_nature_definitionContext {
	var p = new(Scalar_nature_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_scalar_nature_definition

	return p
}

func (s *Scalar_nature_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Scalar_nature_definitionContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *Scalar_nature_definitionContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Scalar_nature_definitionContext) ACROSS() antlr.TerminalNode {
	return s.GetToken(vhdlParserACROSS, 0)
}

func (s *Scalar_nature_definitionContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(vhdlParserTHROUGH, 0)
}

func (s *Scalar_nature_definitionContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(vhdlParserREFERENCE, 0)
}

func (s *Scalar_nature_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Scalar_nature_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Scalar_nature_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterScalar_nature_definition(s)
	}
}

func (s *Scalar_nature_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitScalar_nature_definition(s)
	}
}

func (s *Scalar_nature_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitScalar_nature_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Scalar_nature_definition() (localctx IScalar_nature_definitionContext) {
	localctx = NewScalar_nature_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, vhdlParserRULE_scalar_nature_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2072)
		p.Name()
	}
	{
		p.SetState(2073)
		p.Match(vhdlParserACROSS)
	}
	{
		p.SetState(2074)
		p.Name()
	}
	{
		p.SetState(2075)
		p.Match(vhdlParserTHROUGH)
	}
	{
		p.SetState(2076)
		p.Name()
	}
	{
		p.SetState(2077)
		p.Match(vhdlParserREFERENCE)
	}

	return localctx
}

// IScalar_type_definitionContext is an interface to support dynamic dispatch.
type IScalar_type_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScalar_type_definitionContext differentiates from other interfaces.
	IsScalar_type_definitionContext()
}

type Scalar_type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalar_type_definitionContext() *Scalar_type_definitionContext {
	var p = new(Scalar_type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_scalar_type_definition
	return p
}

func (*Scalar_type_definitionContext) IsScalar_type_definitionContext() {}

func NewScalar_type_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Scalar_type_definitionContext {
	var p = new(Scalar_type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_scalar_type_definition

	return p
}

func (s *Scalar_type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Scalar_type_definitionContext) Physical_type_definition() IPhysical_type_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPhysical_type_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPhysical_type_definitionContext)
}

func (s *Scalar_type_definitionContext) Enumeration_type_definition() IEnumeration_type_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeration_type_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumeration_type_definitionContext)
}

func (s *Scalar_type_definitionContext) Range_constraint() IRange_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_constraintContext)
}

func (s *Scalar_type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Scalar_type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Scalar_type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterScalar_type_definition(s)
	}
}

func (s *Scalar_type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitScalar_type_definition(s)
	}
}

func (s *Scalar_type_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitScalar_type_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Scalar_type_definition() (localctx IScalar_type_definitionContext) {
	localctx = NewScalar_type_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, vhdlParserRULE_scalar_type_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2082)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 225, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2079)
			p.Physical_type_definition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2080)
			p.Enumeration_type_definition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2081)
			p.Range_constraint()
		}

	}

	return localctx
}

// ISecondary_unitContext is an interface to support dynamic dispatch.
type ISecondary_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSecondary_unitContext differentiates from other interfaces.
	IsSecondary_unitContext()
}

type Secondary_unitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySecondary_unitContext() *Secondary_unitContext {
	var p = new(Secondary_unitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_secondary_unit
	return p
}

func (*Secondary_unitContext) IsSecondary_unitContext() {}

func NewSecondary_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Secondary_unitContext {
	var p = new(Secondary_unitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_secondary_unit

	return p
}

func (s *Secondary_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Secondary_unitContext) Architecture_body() IArchitecture_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArchitecture_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArchitecture_bodyContext)
}

func (s *Secondary_unitContext) Package_body() IPackage_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_bodyContext)
}

func (s *Secondary_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Secondary_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Secondary_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSecondary_unit(s)
	}
}

func (s *Secondary_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSecondary_unit(s)
	}
}

func (s *Secondary_unitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSecondary_unit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Secondary_unit() (localctx ISecondary_unitContext) {
	localctx = NewSecondary_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, vhdlParserRULE_secondary_unit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2086)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserARCHITECTURE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2084)
			p.Architecture_body()
		}

	case vhdlParserPACKAGE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2085)
			p.Package_body()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISecondary_unit_declarationContext is an interface to support dynamic dispatch.
type ISecondary_unit_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSecondary_unit_declarationContext differentiates from other interfaces.
	IsSecondary_unit_declarationContext()
}

type Secondary_unit_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySecondary_unit_declarationContext() *Secondary_unit_declarationContext {
	var p = new(Secondary_unit_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_secondary_unit_declaration
	return p
}

func (*Secondary_unit_declarationContext) IsSecondary_unit_declarationContext() {}

func NewSecondary_unit_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Secondary_unit_declarationContext {
	var p = new(Secondary_unit_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_secondary_unit_declaration

	return p
}

func (s *Secondary_unit_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Secondary_unit_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Secondary_unit_declarationContext) EQ() antlr.TerminalNode {
	return s.GetToken(vhdlParserEQ, 0)
}

func (s *Secondary_unit_declarationContext) Physical_literal() IPhysical_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPhysical_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPhysical_literalContext)
}

func (s *Secondary_unit_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Secondary_unit_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Secondary_unit_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Secondary_unit_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSecondary_unit_declaration(s)
	}
}

func (s *Secondary_unit_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSecondary_unit_declaration(s)
	}
}

func (s *Secondary_unit_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSecondary_unit_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Secondary_unit_declaration() (localctx ISecondary_unit_declarationContext) {
	localctx = NewSecondary_unit_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, vhdlParserRULE_secondary_unit_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2088)
		p.Identifier()
	}
	{
		p.SetState(2089)
		p.Match(vhdlParserEQ)
	}
	{
		p.SetState(2090)
		p.Physical_literal()
	}
	{
		p.SetState(2091)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISelected_signal_assignmentContext is an interface to support dynamic dispatch.
type ISelected_signal_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelected_signal_assignmentContext differentiates from other interfaces.
	IsSelected_signal_assignmentContext()
}

type Selected_signal_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelected_signal_assignmentContext() *Selected_signal_assignmentContext {
	var p = new(Selected_signal_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_selected_signal_assignment
	return p
}

func (*Selected_signal_assignmentContext) IsSelected_signal_assignmentContext() {}

func NewSelected_signal_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selected_signal_assignmentContext {
	var p = new(Selected_signal_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_selected_signal_assignment

	return p
}

func (s *Selected_signal_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Selected_signal_assignmentContext) WITH() antlr.TerminalNode {
	return s.GetToken(vhdlParserWITH, 0)
}

func (s *Selected_signal_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Selected_signal_assignmentContext) SELECT() antlr.TerminalNode {
	return s.GetToken(vhdlParserSELECT, 0)
}

func (s *Selected_signal_assignmentContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Selected_signal_assignmentContext) LE() antlr.TerminalNode {
	return s.GetToken(vhdlParserLE, 0)
}

func (s *Selected_signal_assignmentContext) Opts() IOptsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptsContext)
}

func (s *Selected_signal_assignmentContext) Selected_waveforms() ISelected_waveformsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelected_waveformsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelected_waveformsContext)
}

func (s *Selected_signal_assignmentContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Selected_signal_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selected_signal_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Selected_signal_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSelected_signal_assignment(s)
	}
}

func (s *Selected_signal_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSelected_signal_assignment(s)
	}
}

func (s *Selected_signal_assignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSelected_signal_assignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Selected_signal_assignment() (localctx ISelected_signal_assignmentContext) {
	localctx = NewSelected_signal_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, vhdlParserRULE_selected_signal_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2093)
		p.Match(vhdlParserWITH)
	}
	{
		p.SetState(2094)
		p.Expression()
	}
	{
		p.SetState(2095)
		p.Match(vhdlParserSELECT)
	}
	{
		p.SetState(2096)
		p.Target()
	}
	{
		p.SetState(2097)
		p.Match(vhdlParserLE)
	}
	{
		p.SetState(2098)
		p.Opts()
	}
	{
		p.SetState(2099)
		p.Selected_waveforms()
	}
	{
		p.SetState(2100)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISelected_waveformsContext is an interface to support dynamic dispatch.
type ISelected_waveformsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelected_waveformsContext differentiates from other interfaces.
	IsSelected_waveformsContext()
}

type Selected_waveformsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelected_waveformsContext() *Selected_waveformsContext {
	var p = new(Selected_waveformsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_selected_waveforms
	return p
}

func (*Selected_waveformsContext) IsSelected_waveformsContext() {}

func NewSelected_waveformsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selected_waveformsContext {
	var p = new(Selected_waveformsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_selected_waveforms

	return p
}

func (s *Selected_waveformsContext) GetParser() antlr.Parser { return s.parser }

func (s *Selected_waveformsContext) AllWaveform() []IWaveformContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWaveformContext)(nil)).Elem())
	var tst = make([]IWaveformContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWaveformContext)
		}
	}

	return tst
}

func (s *Selected_waveformsContext) Waveform(i int) IWaveformContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWaveformContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWaveformContext)
}

func (s *Selected_waveformsContext) AllWHEN() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserWHEN)
}

func (s *Selected_waveformsContext) WHEN(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserWHEN, i)
}

func (s *Selected_waveformsContext) AllChoices() []IChoicesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IChoicesContext)(nil)).Elem())
	var tst = make([]IChoicesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IChoicesContext)
		}
	}

	return tst
}

func (s *Selected_waveformsContext) Choices(i int) IChoicesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoicesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IChoicesContext)
}

func (s *Selected_waveformsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Selected_waveformsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Selected_waveformsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selected_waveformsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Selected_waveformsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSelected_waveforms(s)
	}
}

func (s *Selected_waveformsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSelected_waveforms(s)
	}
}

func (s *Selected_waveformsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSelected_waveforms(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Selected_waveforms() (localctx ISelected_waveformsContext) {
	localctx = NewSelected_waveformsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, vhdlParserRULE_selected_waveforms)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2102)
		p.Waveform()
	}
	{
		p.SetState(2103)
		p.Match(vhdlParserWHEN)
	}
	{
		p.SetState(2104)
		p.Choices()
	}
	p.SetState(2112)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(2105)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(2106)
			p.Waveform()
		}
		{
			p.SetState(2107)
			p.Match(vhdlParserWHEN)
		}
		{
			p.SetState(2108)
			p.Choices()
		}

		p.SetState(2114)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISensitivity_clauseContext is an interface to support dynamic dispatch.
type ISensitivity_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSensitivity_clauseContext differentiates from other interfaces.
	IsSensitivity_clauseContext()
}

type Sensitivity_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySensitivity_clauseContext() *Sensitivity_clauseContext {
	var p = new(Sensitivity_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_sensitivity_clause
	return p
}

func (*Sensitivity_clauseContext) IsSensitivity_clauseContext() {}

func NewSensitivity_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sensitivity_clauseContext {
	var p = new(Sensitivity_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_sensitivity_clause

	return p
}

func (s *Sensitivity_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Sensitivity_clauseContext) ON() antlr.TerminalNode {
	return s.GetToken(vhdlParserON, 0)
}

func (s *Sensitivity_clauseContext) Sensitivity_list() ISensitivity_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISensitivity_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISensitivity_listContext)
}

func (s *Sensitivity_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sensitivity_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sensitivity_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSensitivity_clause(s)
	}
}

func (s *Sensitivity_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSensitivity_clause(s)
	}
}

func (s *Sensitivity_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSensitivity_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Sensitivity_clause() (localctx ISensitivity_clauseContext) {
	localctx = NewSensitivity_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, vhdlParserRULE_sensitivity_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2115)
		p.Match(vhdlParserON)
	}
	{
		p.SetState(2116)
		p.Sensitivity_list()
	}

	return localctx
}

// ISensitivity_listContext is an interface to support dynamic dispatch.
type ISensitivity_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSensitivity_listContext differentiates from other interfaces.
	IsSensitivity_listContext()
}

type Sensitivity_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySensitivity_listContext() *Sensitivity_listContext {
	var p = new(Sensitivity_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_sensitivity_list
	return p
}

func (*Sensitivity_listContext) IsSensitivity_listContext() {}

func NewSensitivity_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sensitivity_listContext {
	var p = new(Sensitivity_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_sensitivity_list

	return p
}

func (s *Sensitivity_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Sensitivity_listContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *Sensitivity_listContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Sensitivity_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Sensitivity_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Sensitivity_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sensitivity_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sensitivity_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSensitivity_list(s)
	}
}

func (s *Sensitivity_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSensitivity_list(s)
	}
}

func (s *Sensitivity_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSensitivity_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Sensitivity_list() (localctx ISensitivity_listContext) {
	localctx = NewSensitivity_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, vhdlParserRULE_sensitivity_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2118)
		p.Name()
	}
	p.SetState(2123)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(2119)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(2120)
			p.Name()
		}

		p.SetState(2125)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISequence_of_statementsContext is an interface to support dynamic dispatch.
type ISequence_of_statementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_of_statementsContext differentiates from other interfaces.
	IsSequence_of_statementsContext()
}

type Sequence_of_statementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_of_statementsContext() *Sequence_of_statementsContext {
	var p = new(Sequence_of_statementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_sequence_of_statements
	return p
}

func (*Sequence_of_statementsContext) IsSequence_of_statementsContext() {}

func NewSequence_of_statementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_of_statementsContext {
	var p = new(Sequence_of_statementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_sequence_of_statements

	return p
}

func (s *Sequence_of_statementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_of_statementsContext) AllSequential_statement() []ISequential_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequential_statementContext)(nil)).Elem())
	var tst = make([]ISequential_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequential_statementContext)
		}
	}

	return tst
}

func (s *Sequence_of_statementsContext) Sequential_statement(i int) ISequential_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequential_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequential_statementContext)
}

func (s *Sequence_of_statementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_of_statementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_of_statementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSequence_of_statements(s)
	}
}

func (s *Sequence_of_statementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSequence_of_statements(s)
	}
}

func (s *Sequence_of_statementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSequence_of_statements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Sequence_of_statements() (localctx ISequence_of_statementsContext) {
	localctx = NewSequence_of_statementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, vhdlParserRULE_sequence_of_statements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2129)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserASSERT)|(1<<vhdlParserBREAK)|(1<<vhdlParserCASE)|(1<<vhdlParserEXIT)|(1<<vhdlParserFOR))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(vhdlParserIF-36))|(1<<(vhdlParserLOOP-36))|(1<<(vhdlParserNEXT-36))|(1<<(vhdlParserNULL-36)))) != 0) || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(vhdlParserREPORT-79))|(1<<(vhdlParserRETURN-79))|(1<<(vhdlParserWAIT-79))|(1<<(vhdlParserWHILE-79)))) != 0) || (((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(vhdlParserBASIC_IDENTIFIER-118))|(1<<(vhdlParserEXTENDED_IDENTIFIER-118))|(1<<(vhdlParserLPAREN-118)))) != 0) {
		{
			p.SetState(2126)
			p.Sequential_statement()
		}

		p.SetState(2131)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISequential_statementContext is an interface to support dynamic dispatch.
type ISequential_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequential_statementContext differentiates from other interfaces.
	IsSequential_statementContext()
}

type Sequential_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequential_statementContext() *Sequential_statementContext {
	var p = new(Sequential_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_sequential_statement
	return p
}

func (*Sequential_statementContext) IsSequential_statementContext() {}

func NewSequential_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequential_statementContext {
	var p = new(Sequential_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_sequential_statement

	return p
}

func (s *Sequential_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequential_statementContext) Wait_statement() IWait_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWait_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWait_statementContext)
}

func (s *Sequential_statementContext) Assertion_statement() IAssertion_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertion_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertion_statementContext)
}

func (s *Sequential_statementContext) Report_statement() IReport_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReport_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReport_statementContext)
}

func (s *Sequential_statementContext) Signal_assignment_statement() ISignal_assignment_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_assignment_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_assignment_statementContext)
}

func (s *Sequential_statementContext) Variable_assignment_statement() IVariable_assignment_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_assignment_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_assignment_statementContext)
}

func (s *Sequential_statementContext) If_statement() IIf_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_statementContext)
}

func (s *Sequential_statementContext) Case_statement() ICase_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_statementContext)
}

func (s *Sequential_statementContext) Loop_statement() ILoop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_statementContext)
}

func (s *Sequential_statementContext) Next_statement() INext_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INext_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INext_statementContext)
}

func (s *Sequential_statementContext) Exit_statement() IExit_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExit_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExit_statementContext)
}

func (s *Sequential_statementContext) Return_statement() IReturn_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturn_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturn_statementContext)
}

func (s *Sequential_statementContext) NULL() antlr.TerminalNode {
	return s.GetToken(vhdlParserNULL, 0)
}

func (s *Sequential_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Sequential_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Sequential_statementContext) Break_statement() IBreak_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreak_statementContext)
}

func (s *Sequential_statementContext) Procedure_call_statement() IProcedure_call_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_call_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_call_statementContext)
}

func (s *Sequential_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequential_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequential_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSequential_statement(s)
	}
}

func (s *Sequential_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSequential_statement(s)
	}
}

func (s *Sequential_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSequential_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Sequential_statement() (localctx ISequential_statementContext) {
	localctx = NewSequential_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, vhdlParserRULE_sequential_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2150)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 231, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2132)
			p.Wait_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2133)
			p.Assertion_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2134)
			p.Report_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2135)
			p.Signal_assignment_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2136)
			p.Variable_assignment_statement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2137)
			p.If_statement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2138)
			p.Case_statement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2139)
			p.Loop_statement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2140)
			p.Next_statement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2141)
			p.Exit_statement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2142)
			p.Return_statement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		p.SetState(2144)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
			{
				p.SetState(2143)
				p.Label_colon()
			}

		}
		{
			p.SetState(2146)
			p.Match(vhdlParserNULL)
		}
		{
			p.SetState(2147)
			p.Match(vhdlParserSEMI)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2148)
			p.Break_statement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2149)
			p.Procedure_call_statement()
		}

	}

	return localctx
}

// IShift_expressionContext is an interface to support dynamic dispatch.
type IShift_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShift_expressionContext differentiates from other interfaces.
	IsShift_expressionContext()
}

type Shift_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_expressionContext() *Shift_expressionContext {
	var p = new(Shift_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_shift_expression
	return p
}

func (*Shift_expressionContext) IsShift_expressionContext() {}

func NewShift_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_expressionContext {
	var p = new(Shift_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_shift_expression

	return p
}

func (s *Shift_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_expressionContext) AllSimple_expression() []ISimple_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem())
	var tst = make([]ISimple_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_expressionContext)
		}
	}

	return tst
}

func (s *Shift_expressionContext) Simple_expression(i int) ISimple_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_expressionContext)
}

func (s *Shift_expressionContext) Shift_operator() IShift_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShift_operatorContext)
}

func (s *Shift_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shift_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterShift_expression(s)
	}
}

func (s *Shift_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitShift_expression(s)
	}
}

func (s *Shift_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitShift_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Shift_expression() (localctx IShift_expressionContext) {
	localctx = NewShift_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, vhdlParserRULE_shift_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2152)
		p.Simple_expression()
	}
	p.SetState(2156)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 232, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2153)
			p.Shift_operator()
		}
		{
			p.SetState(2154)
			p.Simple_expression()
		}

	}

	return localctx
}

// IShift_operatorContext is an interface to support dynamic dispatch.
type IShift_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShift_operatorContext differentiates from other interfaces.
	IsShift_operatorContext()
}

type Shift_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_operatorContext() *Shift_operatorContext {
	var p = new(Shift_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_shift_operator
	return p
}

func (*Shift_operatorContext) IsShift_operatorContext() {}

func NewShift_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_operatorContext {
	var p = new(Shift_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_shift_operator

	return p
}

func (s *Shift_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_operatorContext) SLL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSLL, 0)
}

func (s *Shift_operatorContext) SRL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSRL, 0)
}

func (s *Shift_operatorContext) SLA() antlr.TerminalNode {
	return s.GetToken(vhdlParserSLA, 0)
}

func (s *Shift_operatorContext) SRA() antlr.TerminalNode {
	return s.GetToken(vhdlParserSRA, 0)
}

func (s *Shift_operatorContext) ROL() antlr.TerminalNode {
	return s.GetToken(vhdlParserROL, 0)
}

func (s *Shift_operatorContext) ROR() antlr.TerminalNode {
	return s.GetToken(vhdlParserROR, 0)
}

func (s *Shift_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shift_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterShift_operator(s)
	}
}

func (s *Shift_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitShift_operator(s)
	}
}

func (s *Shift_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitShift_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Shift_operator() (localctx IShift_operatorContext) {
	localctx = NewShift_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, vhdlParserRULE_shift_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2158)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(vhdlParserROL-81))|(1<<(vhdlParserROR-81))|(1<<(vhdlParserSLA-81))|(1<<(vhdlParserSLL-81))|(1<<(vhdlParserSRA-81))|(1<<(vhdlParserSRL-81)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// ISignal_assignment_statementContext is an interface to support dynamic dispatch.
type ISignal_assignment_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignal_assignment_statementContext differentiates from other interfaces.
	IsSignal_assignment_statementContext()
}

type Signal_assignment_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignal_assignment_statementContext() *Signal_assignment_statementContext {
	var p = new(Signal_assignment_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_signal_assignment_statement
	return p
}

func (*Signal_assignment_statementContext) IsSignal_assignment_statementContext() {}

func NewSignal_assignment_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signal_assignment_statementContext {
	var p = new(Signal_assignment_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_signal_assignment_statement

	return p
}

func (s *Signal_assignment_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Signal_assignment_statementContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Signal_assignment_statementContext) LE() antlr.TerminalNode {
	return s.GetToken(vhdlParserLE, 0)
}

func (s *Signal_assignment_statementContext) Waveform() IWaveformContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWaveformContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWaveformContext)
}

func (s *Signal_assignment_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Signal_assignment_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Signal_assignment_statementContext) Delay_mechanism() IDelay_mechanismContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_mechanismContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_mechanismContext)
}

func (s *Signal_assignment_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signal_assignment_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signal_assignment_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSignal_assignment_statement(s)
	}
}

func (s *Signal_assignment_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSignal_assignment_statement(s)
	}
}

func (s *Signal_assignment_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSignal_assignment_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Signal_assignment_statement() (localctx ISignal_assignment_statementContext) {
	localctx = NewSignal_assignment_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, vhdlParserRULE_signal_assignment_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2161)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 233, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2160)
			p.Label_colon()
		}

	}
	{
		p.SetState(2163)
		p.Target()
	}
	{
		p.SetState(2164)
		p.Match(vhdlParserLE)
	}
	p.SetState(2166)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserINERTIAL || _la == vhdlParserREJECT || _la == vhdlParserTRANSPORT {
		{
			p.SetState(2165)
			p.Delay_mechanism()
		}

	}
	{
		p.SetState(2168)
		p.Waveform()
	}
	{
		p.SetState(2169)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISignal_declarationContext is an interface to support dynamic dispatch.
type ISignal_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignal_declarationContext differentiates from other interfaces.
	IsSignal_declarationContext()
}

type Signal_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignal_declarationContext() *Signal_declarationContext {
	var p = new(Signal_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_signal_declaration
	return p
}

func (*Signal_declarationContext) IsSignal_declarationContext() {}

func NewSignal_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signal_declarationContext {
	var p = new(Signal_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_signal_declaration

	return p
}

func (s *Signal_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Signal_declarationContext) SIGNAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSIGNAL, 0)
}

func (s *Signal_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Signal_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Signal_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Signal_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Signal_declarationContext) Signal_kind() ISignal_kindContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_kindContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_kindContext)
}

func (s *Signal_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Signal_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Signal_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signal_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signal_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSignal_declaration(s)
	}
}

func (s *Signal_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSignal_declaration(s)
	}
}

func (s *Signal_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSignal_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Signal_declaration() (localctx ISignal_declarationContext) {
	localctx = NewSignal_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, vhdlParserRULE_signal_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2171)
		p.Match(vhdlParserSIGNAL)
	}
	{
		p.SetState(2172)
		p.Identifier_list()
	}
	{
		p.SetState(2173)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(2174)
		p.Subtype_indication()
	}
	p.SetState(2176)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBUS || _la == vhdlParserREGISTER {
		{
			p.SetState(2175)
			p.Signal_kind()
		}

	}
	p.SetState(2180)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(2178)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(2179)
			p.Expression()
		}

	}
	{
		p.SetState(2182)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISignal_kindContext is an interface to support dynamic dispatch.
type ISignal_kindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignal_kindContext differentiates from other interfaces.
	IsSignal_kindContext()
}

type Signal_kindContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignal_kindContext() *Signal_kindContext {
	var p = new(Signal_kindContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_signal_kind
	return p
}

func (*Signal_kindContext) IsSignal_kindContext() {}

func NewSignal_kindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signal_kindContext {
	var p = new(Signal_kindContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_signal_kind

	return p
}

func (s *Signal_kindContext) GetParser() antlr.Parser { return s.parser }

func (s *Signal_kindContext) REGISTER() antlr.TerminalNode {
	return s.GetToken(vhdlParserREGISTER, 0)
}

func (s *Signal_kindContext) BUS() antlr.TerminalNode {
	return s.GetToken(vhdlParserBUS, 0)
}

func (s *Signal_kindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signal_kindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signal_kindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSignal_kind(s)
	}
}

func (s *Signal_kindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSignal_kind(s)
	}
}

func (s *Signal_kindContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSignal_kind(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Signal_kind() (localctx ISignal_kindContext) {
	localctx = NewSignal_kindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, vhdlParserRULE_signal_kind)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2184)
	_la = p.GetTokenStream().LA(1)

	if !(_la == vhdlParserBUS || _la == vhdlParserREGISTER) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// ISignal_listContext is an interface to support dynamic dispatch.
type ISignal_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignal_listContext differentiates from other interfaces.
	IsSignal_listContext()
}

type Signal_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignal_listContext() *Signal_listContext {
	var p = new(Signal_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_signal_list
	return p
}

func (*Signal_listContext) IsSignal_listContext() {}

func NewSignal_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signal_listContext {
	var p = new(Signal_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_signal_list

	return p
}

func (s *Signal_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Signal_listContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *Signal_listContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Signal_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Signal_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Signal_listContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(vhdlParserOTHERS, 0)
}

func (s *Signal_listContext) ALL() antlr.TerminalNode {
	return s.GetToken(vhdlParserALL, 0)
}

func (s *Signal_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signal_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signal_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSignal_list(s)
	}
}

func (s *Signal_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSignal_list(s)
	}
}

func (s *Signal_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSignal_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Signal_list() (localctx ISignal_listContext) {
	localctx = NewSignal_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, vhdlParserRULE_signal_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2196)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2186)
			p.Name()
		}
		p.SetState(2191)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == vhdlParserCOMMA {
			{
				p.SetState(2187)
				p.Match(vhdlParserCOMMA)
			}
			{
				p.SetState(2188)
				p.Name()
			}

			p.SetState(2193)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case vhdlParserOTHERS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2194)
			p.Match(vhdlParserOTHERS)
		}

	case vhdlParserALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2195)
			p.Match(vhdlParserALL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISignatureContext is an interface to support dynamic dispatch.
type ISignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignatureContext differentiates from other interfaces.
	IsSignatureContext()
}

type SignatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignatureContext() *SignatureContext {
	var p = new(SignatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_signature
	return p
}

func (*SignatureContext) IsSignatureContext() {}

func NewSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignatureContext {
	var p = new(SignatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_signature

	return p
}

func (s *SignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *SignatureContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(vhdlParserLBRACKET, 0)
}

func (s *SignatureContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(vhdlParserRBRACKET, 0)
}

func (s *SignatureContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *SignatureContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *SignatureContext) RETURN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRETURN, 0)
}

func (s *SignatureContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *SignatureContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *SignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSignature(s)
	}
}

func (s *SignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSignature(s)
	}
}

func (s *SignatureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSignature(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Signature() (localctx ISignatureContext) {
	localctx = NewSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, vhdlParserRULE_signature)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2198)
		p.Match(vhdlParserLBRACKET)
	}
	p.SetState(2207)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2199)
			p.Name()
		}
		p.SetState(2204)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == vhdlParserCOMMA {
			{
				p.SetState(2200)
				p.Match(vhdlParserCOMMA)
			}
			{
				p.SetState(2201)
				p.Name()
			}

			p.SetState(2206)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(2211)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserRETURN {
		{
			p.SetState(2209)
			p.Match(vhdlParserRETURN)
		}
		{
			p.SetState(2210)
			p.Name()
		}

	}
	{
		p.SetState(2213)
		p.Match(vhdlParserRBRACKET)
	}

	return localctx
}

// ISimple_expressionContext is an interface to support dynamic dispatch.
type ISimple_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_expressionContext differentiates from other interfaces.
	IsSimple_expressionContext()
}

type Simple_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_expressionContext() *Simple_expressionContext {
	var p = new(Simple_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_simple_expression
	return p
}

func (*Simple_expressionContext) IsSimple_expressionContext() {}

func NewSimple_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_expressionContext {
	var p = new(Simple_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_simple_expression

	return p
}

func (s *Simple_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_expressionContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *Simple_expressionContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Simple_expressionContext) AllAdding_operator() []IAdding_operatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdding_operatorContext)(nil)).Elem())
	var tst = make([]IAdding_operatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdding_operatorContext)
		}
	}

	return tst
}

func (s *Simple_expressionContext) Adding_operator(i int) IAdding_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdding_operatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdding_operatorContext)
}

func (s *Simple_expressionContext) PLUS() antlr.TerminalNode {
	return s.GetToken(vhdlParserPLUS, 0)
}

func (s *Simple_expressionContext) MINUS() antlr.TerminalNode {
	return s.GetToken(vhdlParserMINUS, 0)
}

func (s *Simple_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSimple_expression(s)
	}
}

func (s *Simple_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSimple_expression(s)
	}
}

func (s *Simple_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSimple_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Simple_expression() (localctx ISimple_expressionContext) {
	localctx = NewSimple_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, vhdlParserRULE_simple_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2216)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserPLUS || _la == vhdlParserMINUS {
		p.SetState(2215)
		_la = p.GetTokenStream().LA(1)

		if !(_la == vhdlParserPLUS || _la == vhdlParserMINUS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	{
		p.SetState(2218)
		p.Term()
	}
	p.SetState(2224)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 243, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2219)
				p.Adding_operator()
			}
			{
				p.SetState(2220)
				p.Term()
			}

		}
		p.SetState(2226)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 243, p.GetParserRuleContext())
	}

	return localctx
}

// ISimple_simultaneous_statementContext is an interface to support dynamic dispatch.
type ISimple_simultaneous_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_simultaneous_statementContext differentiates from other interfaces.
	IsSimple_simultaneous_statementContext()
}

type Simple_simultaneous_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_simultaneous_statementContext() *Simple_simultaneous_statementContext {
	var p = new(Simple_simultaneous_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_simple_simultaneous_statement
	return p
}

func (*Simple_simultaneous_statementContext) IsSimple_simultaneous_statementContext() {}

func NewSimple_simultaneous_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_simultaneous_statementContext {
	var p = new(Simple_simultaneous_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_simple_simultaneous_statement

	return p
}

func (s *Simple_simultaneous_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_simultaneous_statementContext) AllSimple_expression() []ISimple_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem())
	var tst = make([]ISimple_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_expressionContext)
		}
	}

	return tst
}

func (s *Simple_simultaneous_statementContext) Simple_expression(i int) ISimple_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_expressionContext)
}

func (s *Simple_simultaneous_statementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserASSIGN, 0)
}

func (s *Simple_simultaneous_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Simple_simultaneous_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Simple_simultaneous_statementContext) Tolerance_aspect() ITolerance_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITolerance_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITolerance_aspectContext)
}

func (s *Simple_simultaneous_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_simultaneous_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_simultaneous_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSimple_simultaneous_statement(s)
	}
}

func (s *Simple_simultaneous_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSimple_simultaneous_statement(s)
	}
}

func (s *Simple_simultaneous_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSimple_simultaneous_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Simple_simultaneous_statement() (localctx ISimple_simultaneous_statementContext) {
	localctx = NewSimple_simultaneous_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, vhdlParserRULE_simple_simultaneous_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2228)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 244, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2227)
			p.Label_colon()
		}

	}
	{
		p.SetState(2230)
		p.Simple_expression()
	}
	{
		p.SetState(2231)
		p.Match(vhdlParserASSIGN)
	}
	{
		p.SetState(2232)
		p.Simple_expression()
	}
	p.SetState(2234)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserTOLERANCE {
		{
			p.SetState(2233)
			p.Tolerance_aspect()
		}

	}
	{
		p.SetState(2236)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISimultaneous_alternativeContext is an interface to support dynamic dispatch.
type ISimultaneous_alternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimultaneous_alternativeContext differentiates from other interfaces.
	IsSimultaneous_alternativeContext()
}

type Simultaneous_alternativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimultaneous_alternativeContext() *Simultaneous_alternativeContext {
	var p = new(Simultaneous_alternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_simultaneous_alternative
	return p
}

func (*Simultaneous_alternativeContext) IsSimultaneous_alternativeContext() {}

func NewSimultaneous_alternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simultaneous_alternativeContext {
	var p = new(Simultaneous_alternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_simultaneous_alternative

	return p
}

func (s *Simultaneous_alternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *Simultaneous_alternativeContext) WHEN() antlr.TerminalNode {
	return s.GetToken(vhdlParserWHEN, 0)
}

func (s *Simultaneous_alternativeContext) Choices() IChoicesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoicesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChoicesContext)
}

func (s *Simultaneous_alternativeContext) ARROW() antlr.TerminalNode {
	return s.GetToken(vhdlParserARROW, 0)
}

func (s *Simultaneous_alternativeContext) Simultaneous_statement_part() ISimultaneous_statement_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimultaneous_statement_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimultaneous_statement_partContext)
}

func (s *Simultaneous_alternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simultaneous_alternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simultaneous_alternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSimultaneous_alternative(s)
	}
}

func (s *Simultaneous_alternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSimultaneous_alternative(s)
	}
}

func (s *Simultaneous_alternativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSimultaneous_alternative(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Simultaneous_alternative() (localctx ISimultaneous_alternativeContext) {
	localctx = NewSimultaneous_alternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, vhdlParserRULE_simultaneous_alternative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2238)
		p.Match(vhdlParserWHEN)
	}
	{
		p.SetState(2239)
		p.Choices()
	}
	{
		p.SetState(2240)
		p.Match(vhdlParserARROW)
	}
	{
		p.SetState(2241)
		p.Simultaneous_statement_part()
	}

	return localctx
}

// ISimultaneous_case_statementContext is an interface to support dynamic dispatch.
type ISimultaneous_case_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimultaneous_case_statementContext differentiates from other interfaces.
	IsSimultaneous_case_statementContext()
}

type Simultaneous_case_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimultaneous_case_statementContext() *Simultaneous_case_statementContext {
	var p = new(Simultaneous_case_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_simultaneous_case_statement
	return p
}

func (*Simultaneous_case_statementContext) IsSimultaneous_case_statementContext() {}

func NewSimultaneous_case_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simultaneous_case_statementContext {
	var p = new(Simultaneous_case_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_simultaneous_case_statement

	return p
}

func (s *Simultaneous_case_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Simultaneous_case_statementContext) AllCASE() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCASE)
}

func (s *Simultaneous_case_statementContext) CASE(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCASE, i)
}

func (s *Simultaneous_case_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Simultaneous_case_statementContext) USE() antlr.TerminalNode {
	return s.GetToken(vhdlParserUSE, 0)
}

func (s *Simultaneous_case_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Simultaneous_case_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Simultaneous_case_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Simultaneous_case_statementContext) AllSimultaneous_alternative() []ISimultaneous_alternativeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimultaneous_alternativeContext)(nil)).Elem())
	var tst = make([]ISimultaneous_alternativeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimultaneous_alternativeContext)
		}
	}

	return tst
}

func (s *Simultaneous_case_statementContext) Simultaneous_alternative(i int) ISimultaneous_alternativeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimultaneous_alternativeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimultaneous_alternativeContext)
}

func (s *Simultaneous_case_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Simultaneous_case_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simultaneous_case_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simultaneous_case_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSimultaneous_case_statement(s)
	}
}

func (s *Simultaneous_case_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSimultaneous_case_statement(s)
	}
}

func (s *Simultaneous_case_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSimultaneous_case_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Simultaneous_case_statement() (localctx ISimultaneous_case_statementContext) {
	localctx = NewSimultaneous_case_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, vhdlParserRULE_simultaneous_case_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2244)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2243)
			p.Label_colon()
		}

	}
	{
		p.SetState(2246)
		p.Match(vhdlParserCASE)
	}
	{
		p.SetState(2247)
		p.Expression()
	}
	{
		p.SetState(2248)
		p.Match(vhdlParserUSE)
	}
	p.SetState(2250)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == vhdlParserWHEN {
		{
			p.SetState(2249)
			p.Simultaneous_alternative()
		}

		p.SetState(2252)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2254)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(2255)
		p.Match(vhdlParserCASE)
	}
	p.SetState(2257)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2256)
			p.Identifier()
		}

	}
	{
		p.SetState(2259)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISimultaneous_if_statementContext is an interface to support dynamic dispatch.
type ISimultaneous_if_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimultaneous_if_statementContext differentiates from other interfaces.
	IsSimultaneous_if_statementContext()
}

type Simultaneous_if_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimultaneous_if_statementContext() *Simultaneous_if_statementContext {
	var p = new(Simultaneous_if_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_simultaneous_if_statement
	return p
}

func (*Simultaneous_if_statementContext) IsSimultaneous_if_statementContext() {}

func NewSimultaneous_if_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simultaneous_if_statementContext {
	var p = new(Simultaneous_if_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_simultaneous_if_statement

	return p
}

func (s *Simultaneous_if_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Simultaneous_if_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(vhdlParserIF, 0)
}

func (s *Simultaneous_if_statementContext) AllCondition() []IConditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConditionContext)(nil)).Elem())
	var tst = make([]IConditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConditionContext)
		}
	}

	return tst
}

func (s *Simultaneous_if_statementContext) Condition(i int) IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Simultaneous_if_statementContext) AllUSE() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserUSE)
}

func (s *Simultaneous_if_statementContext) USE(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserUSE, i)
}

func (s *Simultaneous_if_statementContext) AllSimultaneous_statement_part() []ISimultaneous_statement_partContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimultaneous_statement_partContext)(nil)).Elem())
	var tst = make([]ISimultaneous_statement_partContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimultaneous_statement_partContext)
		}
	}

	return tst
}

func (s *Simultaneous_if_statementContext) Simultaneous_statement_part(i int) ISimultaneous_statement_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimultaneous_statement_partContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimultaneous_statement_partContext)
}

func (s *Simultaneous_if_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Simultaneous_if_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Simultaneous_if_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Simultaneous_if_statementContext) AllELSIF() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserELSIF)
}

func (s *Simultaneous_if_statementContext) ELSIF(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserELSIF, i)
}

func (s *Simultaneous_if_statementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(vhdlParserELSE, 0)
}

func (s *Simultaneous_if_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Simultaneous_if_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simultaneous_if_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simultaneous_if_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSimultaneous_if_statement(s)
	}
}

func (s *Simultaneous_if_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSimultaneous_if_statement(s)
	}
}

func (s *Simultaneous_if_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSimultaneous_if_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Simultaneous_if_statement() (localctx ISimultaneous_if_statementContext) {
	localctx = NewSimultaneous_if_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, vhdlParserRULE_simultaneous_if_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2262)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2261)
			p.Label_colon()
		}

	}
	{
		p.SetState(2264)
		p.Match(vhdlParserIF)
	}
	{
		p.SetState(2265)
		p.Condition()
	}
	{
		p.SetState(2266)
		p.Match(vhdlParserUSE)
	}
	{
		p.SetState(2267)
		p.Simultaneous_statement_part()
	}
	p.SetState(2275)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserELSIF {
		{
			p.SetState(2268)
			p.Match(vhdlParserELSIF)
		}
		{
			p.SetState(2269)
			p.Condition()
		}
		{
			p.SetState(2270)
			p.Match(vhdlParserUSE)
		}
		{
			p.SetState(2271)
			p.Simultaneous_statement_part()
		}

		p.SetState(2277)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2280)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserELSE {
		{
			p.SetState(2278)
			p.Match(vhdlParserELSE)
		}
		{
			p.SetState(2279)
			p.Simultaneous_statement_part()
		}

	}
	{
		p.SetState(2282)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(2283)
		p.Match(vhdlParserUSE)
	}
	p.SetState(2285)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2284)
			p.Identifier()
		}

	}
	{
		p.SetState(2287)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISimultaneous_procedural_statementContext is an interface to support dynamic dispatch.
type ISimultaneous_procedural_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimultaneous_procedural_statementContext differentiates from other interfaces.
	IsSimultaneous_procedural_statementContext()
}

type Simultaneous_procedural_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimultaneous_procedural_statementContext() *Simultaneous_procedural_statementContext {
	var p = new(Simultaneous_procedural_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_simultaneous_procedural_statement
	return p
}

func (*Simultaneous_procedural_statementContext) IsSimultaneous_procedural_statementContext() {}

func NewSimultaneous_procedural_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simultaneous_procedural_statementContext {
	var p = new(Simultaneous_procedural_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_simultaneous_procedural_statement

	return p
}

func (s *Simultaneous_procedural_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Simultaneous_procedural_statementContext) AllPROCEDURAL() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserPROCEDURAL)
}

func (s *Simultaneous_procedural_statementContext) PROCEDURAL(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserPROCEDURAL, i)
}

func (s *Simultaneous_procedural_statementContext) Procedural_declarative_part() IProcedural_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_declarative_partContext)
}

func (s *Simultaneous_procedural_statementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(vhdlParserBEGIN, 0)
}

func (s *Simultaneous_procedural_statementContext) Procedural_statement_part() IProcedural_statement_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_statement_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_statement_partContext)
}

func (s *Simultaneous_procedural_statementContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Simultaneous_procedural_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Simultaneous_procedural_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Simultaneous_procedural_statementContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Simultaneous_procedural_statementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Simultaneous_procedural_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simultaneous_procedural_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simultaneous_procedural_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSimultaneous_procedural_statement(s)
	}
}

func (s *Simultaneous_procedural_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSimultaneous_procedural_statement(s)
	}
}

func (s *Simultaneous_procedural_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSimultaneous_procedural_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Simultaneous_procedural_statement() (localctx ISimultaneous_procedural_statementContext) {
	localctx = NewSimultaneous_procedural_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, vhdlParserRULE_simultaneous_procedural_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2290)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2289)
			p.Label_colon()
		}

	}
	{
		p.SetState(2292)
		p.Match(vhdlParserPROCEDURAL)
	}
	p.SetState(2294)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIS {
		{
			p.SetState(2293)
			p.Match(vhdlParserIS)
		}

	}
	{
		p.SetState(2296)
		p.Procedural_declarative_part()
	}
	{
		p.SetState(2297)
		p.Match(vhdlParserBEGIN)
	}
	{
		p.SetState(2298)
		p.Procedural_statement_part()
	}
	{
		p.SetState(2299)
		p.Match(vhdlParserEND)
	}
	{
		p.SetState(2300)
		p.Match(vhdlParserPROCEDURAL)
	}
	p.SetState(2302)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2301)
			p.Identifier()
		}

	}
	{
		p.SetState(2304)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISimultaneous_statementContext is an interface to support dynamic dispatch.
type ISimultaneous_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimultaneous_statementContext differentiates from other interfaces.
	IsSimultaneous_statementContext()
}

type Simultaneous_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimultaneous_statementContext() *Simultaneous_statementContext {
	var p = new(Simultaneous_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_simultaneous_statement
	return p
}

func (*Simultaneous_statementContext) IsSimultaneous_statementContext() {}

func NewSimultaneous_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simultaneous_statementContext {
	var p = new(Simultaneous_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_simultaneous_statement

	return p
}

func (s *Simultaneous_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Simultaneous_statementContext) Simple_simultaneous_statement() ISimple_simultaneous_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_simultaneous_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_simultaneous_statementContext)
}

func (s *Simultaneous_statementContext) Simultaneous_if_statement() ISimultaneous_if_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimultaneous_if_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimultaneous_if_statementContext)
}

func (s *Simultaneous_statementContext) Simultaneous_case_statement() ISimultaneous_case_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimultaneous_case_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimultaneous_case_statementContext)
}

func (s *Simultaneous_statementContext) Simultaneous_procedural_statement() ISimultaneous_procedural_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimultaneous_procedural_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimultaneous_procedural_statementContext)
}

func (s *Simultaneous_statementContext) NULL() antlr.TerminalNode {
	return s.GetToken(vhdlParserNULL, 0)
}

func (s *Simultaneous_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Simultaneous_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Simultaneous_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simultaneous_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simultaneous_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSimultaneous_statement(s)
	}
}

func (s *Simultaneous_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSimultaneous_statement(s)
	}
}

func (s *Simultaneous_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSimultaneous_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Simultaneous_statement() (localctx ISimultaneous_statementContext) {
	localctx = NewSimultaneous_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, vhdlParserRULE_simultaneous_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2315)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 257, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2306)
			p.Simple_simultaneous_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2307)
			p.Simultaneous_if_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2308)
			p.Simultaneous_case_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2309)
			p.Simultaneous_procedural_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(2311)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
			{
				p.SetState(2310)
				p.Label_colon()
			}

		}
		{
			p.SetState(2313)
			p.Match(vhdlParserNULL)
		}
		{
			p.SetState(2314)
			p.Match(vhdlParserSEMI)
		}

	}

	return localctx
}

// ISimultaneous_statement_partContext is an interface to support dynamic dispatch.
type ISimultaneous_statement_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimultaneous_statement_partContext differentiates from other interfaces.
	IsSimultaneous_statement_partContext()
}

type Simultaneous_statement_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimultaneous_statement_partContext() *Simultaneous_statement_partContext {
	var p = new(Simultaneous_statement_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_simultaneous_statement_part
	return p
}

func (*Simultaneous_statement_partContext) IsSimultaneous_statement_partContext() {}

func NewSimultaneous_statement_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simultaneous_statement_partContext {
	var p = new(Simultaneous_statement_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_simultaneous_statement_part

	return p
}

func (s *Simultaneous_statement_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Simultaneous_statement_partContext) AllSimultaneous_statement() []ISimultaneous_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimultaneous_statementContext)(nil)).Elem())
	var tst = make([]ISimultaneous_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimultaneous_statementContext)
		}
	}

	return tst
}

func (s *Simultaneous_statement_partContext) Simultaneous_statement(i int) ISimultaneous_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimultaneous_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimultaneous_statementContext)
}

func (s *Simultaneous_statement_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simultaneous_statement_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simultaneous_statement_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSimultaneous_statement_part(s)
	}
}

func (s *Simultaneous_statement_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSimultaneous_statement_part(s)
	}
}

func (s *Simultaneous_statement_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSimultaneous_statement_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Simultaneous_statement_part() (localctx ISimultaneous_statement_partContext) {
	localctx = NewSimultaneous_statement_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, vhdlParserRULE_simultaneous_statement_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2320)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserABS || _la == vhdlParserCASE || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(vhdlParserIF-36))|(1<<(vhdlParserNEW-36))|(1<<(vhdlParserNOT-36))|(1<<(vhdlParserNULL-36)))) != 0) || _la == vhdlParserPROCEDURAL || (((_la-112)&-(0x1f+1)) == 0 && ((1<<uint((_la-112)))&((1<<(vhdlParserBASE_LITERAL-112))|(1<<(vhdlParserBIT_STRING_LITERAL-112))|(1<<(vhdlParserREAL_LITERAL-112))|(1<<(vhdlParserBASIC_IDENTIFIER-112))|(1<<(vhdlParserEXTENDED_IDENTIFIER-112))|(1<<(vhdlParserCHARACTER_LITERAL-112))|(1<<(vhdlParserSTRING_LITERAL-112))|(1<<(vhdlParserLPAREN-112)))) != 0) || (((_la-148)&-(0x1f+1)) == 0 && ((1<<uint((_la-148)))&((1<<(vhdlParserPLUS-148))|(1<<(vhdlParserMINUS-148))|(1<<(vhdlParserINTEGER-148)))) != 0) {
		{
			p.SetState(2317)
			p.Simultaneous_statement()
		}

		p.SetState(2322)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISource_aspectContext is an interface to support dynamic dispatch.
type ISource_aspectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSource_aspectContext differentiates from other interfaces.
	IsSource_aspectContext()
}

type Source_aspectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySource_aspectContext() *Source_aspectContext {
	var p = new(Source_aspectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_source_aspect
	return p
}

func (*Source_aspectContext) IsSource_aspectContext() {}

func NewSource_aspectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Source_aspectContext {
	var p = new(Source_aspectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_source_aspect

	return p
}

func (s *Source_aspectContext) GetParser() antlr.Parser { return s.parser }

func (s *Source_aspectContext) SPECTRUM() antlr.TerminalNode {
	return s.GetToken(vhdlParserSPECTRUM, 0)
}

func (s *Source_aspectContext) AllSimple_expression() []ISimple_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem())
	var tst = make([]ISimple_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_expressionContext)
		}
	}

	return tst
}

func (s *Source_aspectContext) Simple_expression(i int) ISimple_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_expressionContext)
}

func (s *Source_aspectContext) COMMA() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, 0)
}

func (s *Source_aspectContext) NOISE() antlr.TerminalNode {
	return s.GetToken(vhdlParserNOISE, 0)
}

func (s *Source_aspectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Source_aspectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Source_aspectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSource_aspect(s)
	}
}

func (s *Source_aspectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSource_aspect(s)
	}
}

func (s *Source_aspectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSource_aspect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Source_aspect() (localctx ISource_aspectContext) {
	localctx = NewSource_aspectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, vhdlParserRULE_source_aspect)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2330)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserSPECTRUM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2323)
			p.Match(vhdlParserSPECTRUM)
		}
		{
			p.SetState(2324)
			p.Simple_expression()
		}
		{
			p.SetState(2325)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(2326)
			p.Simple_expression()
		}

	case vhdlParserNOISE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2328)
			p.Match(vhdlParserNOISE)
		}
		{
			p.SetState(2329)
			p.Simple_expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISource_quantity_declarationContext is an interface to support dynamic dispatch.
type ISource_quantity_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSource_quantity_declarationContext differentiates from other interfaces.
	IsSource_quantity_declarationContext()
}

type Source_quantity_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySource_quantity_declarationContext() *Source_quantity_declarationContext {
	var p = new(Source_quantity_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_source_quantity_declaration
	return p
}

func (*Source_quantity_declarationContext) IsSource_quantity_declarationContext() {}

func NewSource_quantity_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Source_quantity_declarationContext {
	var p = new(Source_quantity_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_source_quantity_declaration

	return p
}

func (s *Source_quantity_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Source_quantity_declarationContext) QUANTITY() antlr.TerminalNode {
	return s.GetToken(vhdlParserQUANTITY, 0)
}

func (s *Source_quantity_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Source_quantity_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Source_quantity_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Source_quantity_declarationContext) Source_aspect() ISource_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISource_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISource_aspectContext)
}

func (s *Source_quantity_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Source_quantity_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Source_quantity_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Source_quantity_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSource_quantity_declaration(s)
	}
}

func (s *Source_quantity_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSource_quantity_declaration(s)
	}
}

func (s *Source_quantity_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSource_quantity_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Source_quantity_declaration() (localctx ISource_quantity_declarationContext) {
	localctx = NewSource_quantity_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, vhdlParserRULE_source_quantity_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2332)
		p.Match(vhdlParserQUANTITY)
	}
	{
		p.SetState(2333)
		p.Identifier_list()
	}
	{
		p.SetState(2334)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(2335)
		p.Subtype_indication()
	}
	{
		p.SetState(2336)
		p.Source_aspect()
	}
	{
		p.SetState(2337)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IStep_limit_specificationContext is an interface to support dynamic dispatch.
type IStep_limit_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStep_limit_specificationContext differentiates from other interfaces.
	IsStep_limit_specificationContext()
}

type Step_limit_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStep_limit_specificationContext() *Step_limit_specificationContext {
	var p = new(Step_limit_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_step_limit_specification
	return p
}

func (*Step_limit_specificationContext) IsStep_limit_specificationContext() {}

func NewStep_limit_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Step_limit_specificationContext {
	var p = new(Step_limit_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_step_limit_specification

	return p
}

func (s *Step_limit_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Step_limit_specificationContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(vhdlParserLIMIT, 0)
}

func (s *Step_limit_specificationContext) Quantity_specification() IQuantity_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantity_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantity_specificationContext)
}

func (s *Step_limit_specificationContext) WITH() antlr.TerminalNode {
	return s.GetToken(vhdlParserWITH, 0)
}

func (s *Step_limit_specificationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Step_limit_specificationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Step_limit_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Step_limit_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Step_limit_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterStep_limit_specification(s)
	}
}

func (s *Step_limit_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitStep_limit_specification(s)
	}
}

func (s *Step_limit_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitStep_limit_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Step_limit_specification() (localctx IStep_limit_specificationContext) {
	localctx = NewStep_limit_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, vhdlParserRULE_step_limit_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2339)
		p.Match(vhdlParserLIMIT)
	}
	{
		p.SetState(2340)
		p.Quantity_specification()
	}
	{
		p.SetState(2341)
		p.Match(vhdlParserWITH)
	}
	{
		p.SetState(2342)
		p.Expression()
	}
	{
		p.SetState(2343)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISubnature_declarationContext is an interface to support dynamic dispatch.
type ISubnature_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubnature_declarationContext differentiates from other interfaces.
	IsSubnature_declarationContext()
}

type Subnature_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubnature_declarationContext() *Subnature_declarationContext {
	var p = new(Subnature_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subnature_declaration
	return p
}

func (*Subnature_declarationContext) IsSubnature_declarationContext() {}

func NewSubnature_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subnature_declarationContext {
	var p = new(Subnature_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subnature_declaration

	return p
}

func (s *Subnature_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Subnature_declarationContext) SUBNATURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserSUBNATURE, 0)
}

func (s *Subnature_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Subnature_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Subnature_declarationContext) Subnature_indication() ISubnature_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_indicationContext)
}

func (s *Subnature_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Subnature_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subnature_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subnature_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubnature_declaration(s)
	}
}

func (s *Subnature_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubnature_declaration(s)
	}
}

func (s *Subnature_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSubnature_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Subnature_declaration() (localctx ISubnature_declarationContext) {
	localctx = NewSubnature_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, vhdlParserRULE_subnature_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2345)
		p.Match(vhdlParserSUBNATURE)
	}
	{
		p.SetState(2346)
		p.Identifier()
	}
	{
		p.SetState(2347)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(2348)
		p.Subnature_indication()
	}
	{
		p.SetState(2349)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISubnature_indicationContext is an interface to support dynamic dispatch.
type ISubnature_indicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubnature_indicationContext differentiates from other interfaces.
	IsSubnature_indicationContext()
}

type Subnature_indicationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubnature_indicationContext() *Subnature_indicationContext {
	var p = new(Subnature_indicationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subnature_indication
	return p
}

func (*Subnature_indicationContext) IsSubnature_indicationContext() {}

func NewSubnature_indicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subnature_indicationContext {
	var p = new(Subnature_indicationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subnature_indication

	return p
}

func (s *Subnature_indicationContext) GetParser() antlr.Parser { return s.parser }

func (s *Subnature_indicationContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Subnature_indicationContext) Index_constraint() IIndex_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndex_constraintContext)
}

func (s *Subnature_indicationContext) TOLERANCE() antlr.TerminalNode {
	return s.GetToken(vhdlParserTOLERANCE, 0)
}

func (s *Subnature_indicationContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Subnature_indicationContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Subnature_indicationContext) ACROSS() antlr.TerminalNode {
	return s.GetToken(vhdlParserACROSS, 0)
}

func (s *Subnature_indicationContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(vhdlParserTHROUGH, 0)
}

func (s *Subnature_indicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subnature_indicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subnature_indicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubnature_indication(s)
	}
}

func (s *Subnature_indicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubnature_indication(s)
	}
}

func (s *Subnature_indicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSubnature_indication(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Subnature_indication() (localctx ISubnature_indicationContext) {
	localctx = NewSubnature_indicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, vhdlParserRULE_subnature_indication)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2351)
		p.Name()
	}
	p.SetState(2353)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserLPAREN {
		{
			p.SetState(2352)
			p.Index_constraint()
		}

	}
	p.SetState(2361)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserTOLERANCE {
		{
			p.SetState(2355)
			p.Match(vhdlParserTOLERANCE)
		}
		{
			p.SetState(2356)
			p.Expression()
		}
		{
			p.SetState(2357)
			p.Match(vhdlParserACROSS)
		}
		{
			p.SetState(2358)
			p.Expression()
		}
		{
			p.SetState(2359)
			p.Match(vhdlParserTHROUGH)
		}

	}

	return localctx
}

// ISubprogram_bodyContext is an interface to support dynamic dispatch.
type ISubprogram_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubprogram_bodyContext differentiates from other interfaces.
	IsSubprogram_bodyContext()
}

type Subprogram_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubprogram_bodyContext() *Subprogram_bodyContext {
	var p = new(Subprogram_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subprogram_body
	return p
}

func (*Subprogram_bodyContext) IsSubprogram_bodyContext() {}

func NewSubprogram_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subprogram_bodyContext {
	var p = new(Subprogram_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subprogram_body

	return p
}

func (s *Subprogram_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Subprogram_bodyContext) Subprogram_specification() ISubprogram_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_specificationContext)
}

func (s *Subprogram_bodyContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Subprogram_bodyContext) Subprogram_declarative_part() ISubprogram_declarative_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarative_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarative_partContext)
}

func (s *Subprogram_bodyContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(vhdlParserBEGIN, 0)
}

func (s *Subprogram_bodyContext) Subprogram_statement_part() ISubprogram_statement_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_statement_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_statement_partContext)
}

func (s *Subprogram_bodyContext) END() antlr.TerminalNode {
	return s.GetToken(vhdlParserEND, 0)
}

func (s *Subprogram_bodyContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Subprogram_bodyContext) Subprogram_kind() ISubprogram_kindContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_kindContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_kindContext)
}

func (s *Subprogram_bodyContext) Designator() IDesignatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *Subprogram_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subprogram_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subprogram_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubprogram_body(s)
	}
}

func (s *Subprogram_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubprogram_body(s)
	}
}

func (s *Subprogram_bodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSubprogram_body(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Subprogram_body() (localctx ISubprogram_bodyContext) {
	localctx = NewSubprogram_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, vhdlParserRULE_subprogram_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2363)
		p.Subprogram_specification()
	}
	{
		p.SetState(2364)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(2365)
		p.Subprogram_declarative_part()
	}
	{
		p.SetState(2366)
		p.Match(vhdlParserBEGIN)
	}
	{
		p.SetState(2367)
		p.Subprogram_statement_part()
	}
	{
		p.SetState(2368)
		p.Match(vhdlParserEND)
	}
	p.SetState(2370)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserFUNCTION || _la == vhdlParserPROCEDURE {
		{
			p.SetState(2369)
			p.Subprogram_kind()
		}

	}
	p.SetState(2373)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(vhdlParserBASIC_IDENTIFIER-118))|(1<<(vhdlParserEXTENDED_IDENTIFIER-118))|(1<<(vhdlParserSTRING_LITERAL-118)))) != 0 {
		{
			p.SetState(2372)
			p.Designator()
		}

	}
	{
		p.SetState(2375)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISubprogram_declarationContext is an interface to support dynamic dispatch.
type ISubprogram_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubprogram_declarationContext differentiates from other interfaces.
	IsSubprogram_declarationContext()
}

type Subprogram_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubprogram_declarationContext() *Subprogram_declarationContext {
	var p = new(Subprogram_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subprogram_declaration
	return p
}

func (*Subprogram_declarationContext) IsSubprogram_declarationContext() {}

func NewSubprogram_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subprogram_declarationContext {
	var p = new(Subprogram_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subprogram_declaration

	return p
}

func (s *Subprogram_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Subprogram_declarationContext) Subprogram_specification() ISubprogram_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_specificationContext)
}

func (s *Subprogram_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Subprogram_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subprogram_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subprogram_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubprogram_declaration(s)
	}
}

func (s *Subprogram_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubprogram_declaration(s)
	}
}

func (s *Subprogram_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSubprogram_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Subprogram_declaration() (localctx ISubprogram_declarationContext) {
	localctx = NewSubprogram_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, vhdlParserRULE_subprogram_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2377)
		p.Subprogram_specification()
	}
	{
		p.SetState(2378)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISubprogram_declarative_itemContext is an interface to support dynamic dispatch.
type ISubprogram_declarative_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubprogram_declarative_itemContext differentiates from other interfaces.
	IsSubprogram_declarative_itemContext()
}

type Subprogram_declarative_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubprogram_declarative_itemContext() *Subprogram_declarative_itemContext {
	var p = new(Subprogram_declarative_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subprogram_declarative_item
	return p
}

func (*Subprogram_declarative_itemContext) IsSubprogram_declarative_itemContext() {}

func NewSubprogram_declarative_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subprogram_declarative_itemContext {
	var p = new(Subprogram_declarative_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subprogram_declarative_item

	return p
}

func (s *Subprogram_declarative_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Subprogram_declarative_itemContext) Subprogram_declaration() ISubprogram_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarationContext)
}

func (s *Subprogram_declarative_itemContext) Subprogram_body() ISubprogram_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_bodyContext)
}

func (s *Subprogram_declarative_itemContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Subprogram_declarative_itemContext) Subtype_declaration() ISubtype_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_declarationContext)
}

func (s *Subprogram_declarative_itemContext) Constant_declaration() IConstant_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declarationContext)
}

func (s *Subprogram_declarative_itemContext) Variable_declaration() IVariable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Subprogram_declarative_itemContext) File_declaration() IFile_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_declarationContext)
}

func (s *Subprogram_declarative_itemContext) Alias_declaration() IAlias_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlias_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlias_declarationContext)
}

func (s *Subprogram_declarative_itemContext) Attribute_declaration() IAttribute_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_declarationContext)
}

func (s *Subprogram_declarative_itemContext) Attribute_specification() IAttribute_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_specificationContext)
}

func (s *Subprogram_declarative_itemContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Subprogram_declarative_itemContext) Group_template_declaration() IGroup_template_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_template_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_template_declarationContext)
}

func (s *Subprogram_declarative_itemContext) Group_declaration() IGroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_declarationContext)
}

func (s *Subprogram_declarative_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subprogram_declarative_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subprogram_declarative_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubprogram_declarative_item(s)
	}
}

func (s *Subprogram_declarative_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubprogram_declarative_item(s)
	}
}

func (s *Subprogram_declarative_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSubprogram_declarative_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Subprogram_declarative_item() (localctx ISubprogram_declarative_itemContext) {
	localctx = NewSubprogram_declarative_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, vhdlParserRULE_subprogram_declarative_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2393)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 264, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2380)
			p.Subprogram_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2381)
			p.Subprogram_body()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2382)
			p.Type_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2383)
			p.Subtype_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2384)
			p.Constant_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2385)
			p.Variable_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2386)
			p.File_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2387)
			p.Alias_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2388)
			p.Attribute_declaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2389)
			p.Attribute_specification()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2390)
			p.Use_clause()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2391)
			p.Group_template_declaration()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2392)
			p.Group_declaration()
		}

	}

	return localctx
}

// ISubprogram_declarative_partContext is an interface to support dynamic dispatch.
type ISubprogram_declarative_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubprogram_declarative_partContext differentiates from other interfaces.
	IsSubprogram_declarative_partContext()
}

type Subprogram_declarative_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubprogram_declarative_partContext() *Subprogram_declarative_partContext {
	var p = new(Subprogram_declarative_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subprogram_declarative_part
	return p
}

func (*Subprogram_declarative_partContext) IsSubprogram_declarative_partContext() {}

func NewSubprogram_declarative_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subprogram_declarative_partContext {
	var p = new(Subprogram_declarative_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subprogram_declarative_part

	return p
}

func (s *Subprogram_declarative_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Subprogram_declarative_partContext) AllSubprogram_declarative_item() []ISubprogram_declarative_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubprogram_declarative_itemContext)(nil)).Elem())
	var tst = make([]ISubprogram_declarative_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubprogram_declarative_itemContext)
		}
	}

	return tst
}

func (s *Subprogram_declarative_partContext) Subprogram_declarative_item(i int) ISubprogram_declarative_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubprogram_declarative_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubprogram_declarative_itemContext)
}

func (s *Subprogram_declarative_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subprogram_declarative_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subprogram_declarative_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubprogram_declarative_part(s)
	}
}

func (s *Subprogram_declarative_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubprogram_declarative_part(s)
	}
}

func (s *Subprogram_declarative_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSubprogram_declarative_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Subprogram_declarative_part() (localctx ISubprogram_declarative_partContext) {
	localctx = NewSubprogram_declarative_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, vhdlParserRULE_subprogram_declarative_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2398)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserALIAS)|(1<<vhdlParserATTRIBUTE)|(1<<vhdlParserCONSTANT)|(1<<vhdlParserFILE)|(1<<vhdlParserFUNCTION))) != 0) || _la == vhdlParserGROUP || _la == vhdlParserIMPURE || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(vhdlParserPROCEDURE-68))|(1<<(vhdlParserPURE-68))|(1<<(vhdlParserSHARED-68))|(1<<(vhdlParserSUBTYPE-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(vhdlParserTYPE-100))|(1<<(vhdlParserUSE-100))|(1<<(vhdlParserVARIABLE-100)))) != 0) {
		{
			p.SetState(2395)
			p.Subprogram_declarative_item()
		}

		p.SetState(2400)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISubprogram_kindContext is an interface to support dynamic dispatch.
type ISubprogram_kindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubprogram_kindContext differentiates from other interfaces.
	IsSubprogram_kindContext()
}

type Subprogram_kindContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubprogram_kindContext() *Subprogram_kindContext {
	var p = new(Subprogram_kindContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subprogram_kind
	return p
}

func (*Subprogram_kindContext) IsSubprogram_kindContext() {}

func NewSubprogram_kindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subprogram_kindContext {
	var p = new(Subprogram_kindContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subprogram_kind

	return p
}

func (s *Subprogram_kindContext) GetParser() antlr.Parser { return s.parser }

func (s *Subprogram_kindContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserPROCEDURE, 0)
}

func (s *Subprogram_kindContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(vhdlParserFUNCTION, 0)
}

func (s *Subprogram_kindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subprogram_kindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subprogram_kindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubprogram_kind(s)
	}
}

func (s *Subprogram_kindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubprogram_kind(s)
	}
}

func (s *Subprogram_kindContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSubprogram_kind(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Subprogram_kind() (localctx ISubprogram_kindContext) {
	localctx = NewSubprogram_kindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, vhdlParserRULE_subprogram_kind)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2401)
	_la = p.GetTokenStream().LA(1)

	if !(_la == vhdlParserFUNCTION || _la == vhdlParserPROCEDURE) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// ISubprogram_specificationContext is an interface to support dynamic dispatch.
type ISubprogram_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubprogram_specificationContext differentiates from other interfaces.
	IsSubprogram_specificationContext()
}

type Subprogram_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubprogram_specificationContext() *Subprogram_specificationContext {
	var p = new(Subprogram_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subprogram_specification
	return p
}

func (*Subprogram_specificationContext) IsSubprogram_specificationContext() {}

func NewSubprogram_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subprogram_specificationContext {
	var p = new(Subprogram_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subprogram_specification

	return p
}

func (s *Subprogram_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Subprogram_specificationContext) Procedure_specification() IProcedure_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedure_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedure_specificationContext)
}

func (s *Subprogram_specificationContext) Function_specification() IFunction_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_specificationContext)
}

func (s *Subprogram_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subprogram_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subprogram_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubprogram_specification(s)
	}
}

func (s *Subprogram_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubprogram_specification(s)
	}
}

func (s *Subprogram_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSubprogram_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Subprogram_specification() (localctx ISubprogram_specificationContext) {
	localctx = NewSubprogram_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, vhdlParserRULE_subprogram_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2405)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserPROCEDURE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2403)
			p.Procedure_specification()
		}

	case vhdlParserFUNCTION, vhdlParserIMPURE, vhdlParserPURE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2404)
			p.Function_specification()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProcedure_specificationContext is an interface to support dynamic dispatch.
type IProcedure_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedure_specificationContext differentiates from other interfaces.
	IsProcedure_specificationContext()
}

type Procedure_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedure_specificationContext() *Procedure_specificationContext {
	var p = new(Procedure_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_procedure_specification
	return p
}

func (*Procedure_specificationContext) IsProcedure_specificationContext() {}

func NewProcedure_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedure_specificationContext {
	var p = new(Procedure_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_procedure_specification

	return p
}

func (s *Procedure_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedure_specificationContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserPROCEDURE, 0)
}

func (s *Procedure_specificationContext) Designator() IDesignatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *Procedure_specificationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Procedure_specificationContext) Formal_parameter_list() IFormal_parameter_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormal_parameter_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormal_parameter_listContext)
}

func (s *Procedure_specificationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Procedure_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedure_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedure_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterProcedure_specification(s)
	}
}

func (s *Procedure_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitProcedure_specification(s)
	}
}

func (s *Procedure_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitProcedure_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Procedure_specification() (localctx IProcedure_specificationContext) {
	localctx = NewProcedure_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, vhdlParserRULE_procedure_specification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2407)
		p.Match(vhdlParserPROCEDURE)
	}
	{
		p.SetState(2408)
		p.Designator()
	}
	p.SetState(2413)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserLPAREN {
		{
			p.SetState(2409)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(2410)
			p.Formal_parameter_list()
		}
		{
			p.SetState(2411)
			p.Match(vhdlParserRPAREN)
		}

	}

	return localctx
}

// IFunction_specificationContext is an interface to support dynamic dispatch.
type IFunction_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_specificationContext differentiates from other interfaces.
	IsFunction_specificationContext()
}

type Function_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_specificationContext() *Function_specificationContext {
	var p = new(Function_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_function_specification
	return p
}

func (*Function_specificationContext) IsFunction_specificationContext() {}

func NewFunction_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_specificationContext {
	var p = new(Function_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_function_specification

	return p
}

func (s *Function_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_specificationContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(vhdlParserFUNCTION, 0)
}

func (s *Function_specificationContext) Designator() IDesignatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesignatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *Function_specificationContext) RETURN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRETURN, 0)
}

func (s *Function_specificationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Function_specificationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Function_specificationContext) Formal_parameter_list() IFormal_parameter_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormal_parameter_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormal_parameter_listContext)
}

func (s *Function_specificationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Function_specificationContext) PURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserPURE, 0)
}

func (s *Function_specificationContext) IMPURE() antlr.TerminalNode {
	return s.GetToken(vhdlParserIMPURE, 0)
}

func (s *Function_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterFunction_specification(s)
	}
}

func (s *Function_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitFunction_specification(s)
	}
}

func (s *Function_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitFunction_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Function_specification() (localctx IFunction_specificationContext) {
	localctx = NewFunction_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, vhdlParserRULE_function_specification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2416)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIMPURE || _la == vhdlParserPURE {
		p.SetState(2415)
		_la = p.GetTokenStream().LA(1)

		if !(_la == vhdlParserIMPURE || _la == vhdlParserPURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	{
		p.SetState(2418)
		p.Match(vhdlParserFUNCTION)
	}
	{
		p.SetState(2419)
		p.Designator()
	}
	p.SetState(2424)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserLPAREN {
		{
			p.SetState(2420)
			p.Match(vhdlParserLPAREN)
		}
		{
			p.SetState(2421)
			p.Formal_parameter_list()
		}
		{
			p.SetState(2422)
			p.Match(vhdlParserRPAREN)
		}

	}
	{
		p.SetState(2426)
		p.Match(vhdlParserRETURN)
	}
	{
		p.SetState(2427)
		p.Subtype_indication()
	}

	return localctx
}

// ISubprogram_statement_partContext is an interface to support dynamic dispatch.
type ISubprogram_statement_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubprogram_statement_partContext differentiates from other interfaces.
	IsSubprogram_statement_partContext()
}

type Subprogram_statement_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubprogram_statement_partContext() *Subprogram_statement_partContext {
	var p = new(Subprogram_statement_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subprogram_statement_part
	return p
}

func (*Subprogram_statement_partContext) IsSubprogram_statement_partContext() {}

func NewSubprogram_statement_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subprogram_statement_partContext {
	var p = new(Subprogram_statement_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subprogram_statement_part

	return p
}

func (s *Subprogram_statement_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Subprogram_statement_partContext) AllSequential_statement() []ISequential_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequential_statementContext)(nil)).Elem())
	var tst = make([]ISequential_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequential_statementContext)
		}
	}

	return tst
}

func (s *Subprogram_statement_partContext) Sequential_statement(i int) ISequential_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequential_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequential_statementContext)
}

func (s *Subprogram_statement_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subprogram_statement_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subprogram_statement_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubprogram_statement_part(s)
	}
}

func (s *Subprogram_statement_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubprogram_statement_part(s)
	}
}

func (s *Subprogram_statement_partContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSubprogram_statement_part(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Subprogram_statement_part() (localctx ISubprogram_statement_partContext) {
	localctx = NewSubprogram_statement_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, vhdlParserRULE_subprogram_statement_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2432)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<vhdlParserASSERT)|(1<<vhdlParserBREAK)|(1<<vhdlParserCASE)|(1<<vhdlParserEXIT)|(1<<vhdlParserFOR))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(vhdlParserIF-36))|(1<<(vhdlParserLOOP-36))|(1<<(vhdlParserNEXT-36))|(1<<(vhdlParserNULL-36)))) != 0) || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(vhdlParserREPORT-79))|(1<<(vhdlParserRETURN-79))|(1<<(vhdlParserWAIT-79))|(1<<(vhdlParserWHILE-79)))) != 0) || (((_la-118)&-(0x1f+1)) == 0 && ((1<<uint((_la-118)))&((1<<(vhdlParserBASIC_IDENTIFIER-118))|(1<<(vhdlParserEXTENDED_IDENTIFIER-118))|(1<<(vhdlParserLPAREN-118)))) != 0) {
		{
			p.SetState(2429)
			p.Sequential_statement()
		}

		p.SetState(2434)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISubtype_declarationContext is an interface to support dynamic dispatch.
type ISubtype_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtype_declarationContext differentiates from other interfaces.
	IsSubtype_declarationContext()
}

type Subtype_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtype_declarationContext() *Subtype_declarationContext {
	var p = new(Subtype_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subtype_declaration
	return p
}

func (*Subtype_declarationContext) IsSubtype_declarationContext() {}

func NewSubtype_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subtype_declarationContext {
	var p = new(Subtype_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subtype_declaration

	return p
}

func (s *Subtype_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Subtype_declarationContext) SUBTYPE() antlr.TerminalNode {
	return s.GetToken(vhdlParserSUBTYPE, 0)
}

func (s *Subtype_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Subtype_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Subtype_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Subtype_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Subtype_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subtype_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subtype_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubtype_declaration(s)
	}
}

func (s *Subtype_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubtype_declaration(s)
	}
}

func (s *Subtype_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSubtype_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Subtype_declaration() (localctx ISubtype_declarationContext) {
	localctx = NewSubtype_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, vhdlParserRULE_subtype_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2435)
		p.Match(vhdlParserSUBTYPE)
	}
	{
		p.SetState(2436)
		p.Identifier()
	}
	{
		p.SetState(2437)
		p.Match(vhdlParserIS)
	}
	{
		p.SetState(2438)
		p.Subtype_indication()
	}
	{
		p.SetState(2439)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// ISubtype_indicationContext is an interface to support dynamic dispatch.
type ISubtype_indicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtype_indicationContext differentiates from other interfaces.
	IsSubtype_indicationContext()
}

type Subtype_indicationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtype_indicationContext() *Subtype_indicationContext {
	var p = new(Subtype_indicationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_subtype_indication
	return p
}

func (*Subtype_indicationContext) IsSubtype_indicationContext() {}

func NewSubtype_indicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subtype_indicationContext {
	var p = new(Subtype_indicationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_subtype_indication

	return p
}

func (s *Subtype_indicationContext) GetParser() antlr.Parser { return s.parser }

func (s *Subtype_indicationContext) AllSelected_name() []ISelected_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelected_nameContext)(nil)).Elem())
	var tst = make([]ISelected_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelected_nameContext)
		}
	}

	return tst
}

func (s *Subtype_indicationContext) Selected_name(i int) ISelected_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelected_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelected_nameContext)
}

func (s *Subtype_indicationContext) Constraint() IConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *Subtype_indicationContext) Tolerance_aspect() ITolerance_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITolerance_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITolerance_aspectContext)
}

func (s *Subtype_indicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subtype_indicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subtype_indicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSubtype_indication(s)
	}
}

func (s *Subtype_indicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSubtype_indication(s)
	}
}

func (s *Subtype_indicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSubtype_indication(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Subtype_indication() (localctx ISubtype_indicationContext) {
	localctx = NewSubtype_indicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, vhdlParserRULE_subtype_indication)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2441)
		p.Selected_name()
	}
	p.SetState(2443)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 271, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2442)
			p.Selected_name()
		}

	}
	p.SetState(2446)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 272, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2445)
			p.Constraint()
		}

	}
	p.SetState(2449)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 273, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2448)
			p.Tolerance_aspect()
		}

	}

	return localctx
}

// ISuffixContext is an interface to support dynamic dispatch.
type ISuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuffixContext differentiates from other interfaces.
	IsSuffixContext()
}

type SuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuffixContext() *SuffixContext {
	var p = new(SuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_suffix
	return p
}

func (*SuffixContext) IsSuffixContext() {}

func NewSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuffixContext {
	var p = new(SuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_suffix

	return p
}

func (s *SuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *SuffixContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SuffixContext) CHARACTER_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserCHARACTER_LITERAL, 0)
}

func (s *SuffixContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserSTRING_LITERAL, 0)
}

func (s *SuffixContext) ALL() antlr.TerminalNode {
	return s.GetToken(vhdlParserALL, 0)
}

func (s *SuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterSuffix(s)
	}
}

func (s *SuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitSuffix(s)
	}
}

func (s *SuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Suffix() (localctx ISuffixContext) {
	localctx = NewSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, vhdlParserRULE_suffix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2455)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2451)
			p.Identifier()
		}

	case vhdlParserCHARACTER_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2452)
			p.Match(vhdlParserCHARACTER_LITERAL)
		}

	case vhdlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2453)
			p.Match(vhdlParserSTRING_LITERAL)
		}

	case vhdlParserALL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2454)
			p.Match(vhdlParserALL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITargetContext is an interface to support dynamic dispatch.
type ITargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTargetContext differentiates from other interfaces.
	IsTargetContext()
}

type TargetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetContext() *TargetContext {
	var p = new(TargetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_target
	return p
}

func (*TargetContext) IsTargetContext() {}

func NewTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetContext {
	var p = new(TargetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_target

	return p
}

func (s *TargetContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *TargetContext) Aggregate() IAggregateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregateContext)
}

func (s *TargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterTarget(s)
	}
}

func (s *TargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitTarget(s)
	}
}

func (s *TargetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitTarget(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Target() (localctx ITargetContext) {
	localctx = NewTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, vhdlParserRULE_target)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2459)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2457)
			p.Name()
		}

	case vhdlParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2458)
			p.Aggregate()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) AllFactor() []IFactorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFactorContext)(nil)).Elem())
	var tst = make([]IFactorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFactorContext)
		}
	}

	return tst
}

func (s *TermContext) Factor(i int) IFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *TermContext) AllMultiplying_operator() []IMultiplying_operatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplying_operatorContext)(nil)).Elem())
	var tst = make([]IMultiplying_operatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplying_operatorContext)
		}
	}

	return tst
}

func (s *TermContext) Multiplying_operator(i int) IMultiplying_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplying_operatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplying_operatorContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (s *TermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, vhdlParserRULE_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2461)
		p.Factor()
	}
	p.SetState(2467)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 276, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2462)
				p.Multiplying_operator()
			}
			{
				p.SetState(2463)
				p.Factor()
			}

		}
		p.SetState(2469)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 276, p.GetParserRuleContext())
	}

	return localctx
}

// ITerminal_aspectContext is an interface to support dynamic dispatch.
type ITerminal_aspectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTerminal_aspectContext differentiates from other interfaces.
	IsTerminal_aspectContext()
}

type Terminal_aspectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerminal_aspectContext() *Terminal_aspectContext {
	var p = new(Terminal_aspectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_terminal_aspect
	return p
}

func (*Terminal_aspectContext) IsTerminal_aspectContext() {}

func NewTerminal_aspectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Terminal_aspectContext {
	var p = new(Terminal_aspectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_terminal_aspect

	return p
}

func (s *Terminal_aspectContext) GetParser() antlr.Parser { return s.parser }

func (s *Terminal_aspectContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *Terminal_aspectContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Terminal_aspectContext) TO() antlr.TerminalNode {
	return s.GetToken(vhdlParserTO, 0)
}

func (s *Terminal_aspectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Terminal_aspectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Terminal_aspectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterTerminal_aspect(s)
	}
}

func (s *Terminal_aspectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitTerminal_aspect(s)
	}
}

func (s *Terminal_aspectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitTerminal_aspect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Terminal_aspect() (localctx ITerminal_aspectContext) {
	localctx = NewTerminal_aspectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, vhdlParserRULE_terminal_aspect)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2470)
		p.Name()
	}
	p.SetState(2473)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserTO {
		{
			p.SetState(2471)
			p.Match(vhdlParserTO)
		}
		{
			p.SetState(2472)
			p.Name()
		}

	}

	return localctx
}

// ITerminal_declarationContext is an interface to support dynamic dispatch.
type ITerminal_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTerminal_declarationContext differentiates from other interfaces.
	IsTerminal_declarationContext()
}

type Terminal_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerminal_declarationContext() *Terminal_declarationContext {
	var p = new(Terminal_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_terminal_declaration
	return p
}

func (*Terminal_declarationContext) IsTerminal_declarationContext() {}

func NewTerminal_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Terminal_declarationContext {
	var p = new(Terminal_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_terminal_declaration

	return p
}

func (s *Terminal_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Terminal_declarationContext) TERMINAL() antlr.TerminalNode {
	return s.GetToken(vhdlParserTERMINAL, 0)
}

func (s *Terminal_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Terminal_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Terminal_declarationContext) Subnature_indication() ISubnature_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_indicationContext)
}

func (s *Terminal_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Terminal_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Terminal_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Terminal_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterTerminal_declaration(s)
	}
}

func (s *Terminal_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitTerminal_declaration(s)
	}
}

func (s *Terminal_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitTerminal_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Terminal_declaration() (localctx ITerminal_declarationContext) {
	localctx = NewTerminal_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, vhdlParserRULE_terminal_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2475)
		p.Match(vhdlParserTERMINAL)
	}
	{
		p.SetState(2476)
		p.Identifier_list()
	}
	{
		p.SetState(2477)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(2478)
		p.Subnature_indication()
	}
	{
		p.SetState(2479)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IThrough_aspectContext is an interface to support dynamic dispatch.
type IThrough_aspectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrough_aspectContext differentiates from other interfaces.
	IsThrough_aspectContext()
}

type Through_aspectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrough_aspectContext() *Through_aspectContext {
	var p = new(Through_aspectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_through_aspect
	return p
}

func (*Through_aspectContext) IsThrough_aspectContext() {}

func NewThrough_aspectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Through_aspectContext {
	var p = new(Through_aspectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_through_aspect

	return p
}

func (s *Through_aspectContext) GetParser() antlr.Parser { return s.parser }

func (s *Through_aspectContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Through_aspectContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(vhdlParserTHROUGH, 0)
}

func (s *Through_aspectContext) Tolerance_aspect() ITolerance_aspectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITolerance_aspectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITolerance_aspectContext)
}

func (s *Through_aspectContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Through_aspectContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Through_aspectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Through_aspectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Through_aspectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterThrough_aspect(s)
	}
}

func (s *Through_aspectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitThrough_aspect(s)
	}
}

func (s *Through_aspectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitThrough_aspect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Through_aspect() (localctx IThrough_aspectContext) {
	localctx = NewThrough_aspectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, vhdlParserRULE_through_aspect)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2481)
		p.Identifier_list()
	}
	p.SetState(2483)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserTOLERANCE {
		{
			p.SetState(2482)
			p.Tolerance_aspect()
		}

	}
	p.SetState(2487)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(2485)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(2486)
			p.Expression()
		}

	}
	{
		p.SetState(2489)
		p.Match(vhdlParserTHROUGH)
	}

	return localctx
}

// ITimeout_clauseContext is an interface to support dynamic dispatch.
type ITimeout_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimeout_clauseContext differentiates from other interfaces.
	IsTimeout_clauseContext()
}

type Timeout_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeout_clauseContext() *Timeout_clauseContext {
	var p = new(Timeout_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_timeout_clause
	return p
}

func (*Timeout_clauseContext) IsTimeout_clauseContext() {}

func NewTimeout_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timeout_clauseContext {
	var p = new(Timeout_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_timeout_clause

	return p
}

func (s *Timeout_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Timeout_clauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(vhdlParserFOR, 0)
}

func (s *Timeout_clauseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Timeout_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timeout_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timeout_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterTimeout_clause(s)
	}
}

func (s *Timeout_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitTimeout_clause(s)
	}
}

func (s *Timeout_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitTimeout_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Timeout_clause() (localctx ITimeout_clauseContext) {
	localctx = NewTimeout_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, vhdlParserRULE_timeout_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2491)
		p.Match(vhdlParserFOR)
	}
	{
		p.SetState(2492)
		p.Expression()
	}

	return localctx
}

// ITolerance_aspectContext is an interface to support dynamic dispatch.
type ITolerance_aspectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTolerance_aspectContext differentiates from other interfaces.
	IsTolerance_aspectContext()
}

type Tolerance_aspectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTolerance_aspectContext() *Tolerance_aspectContext {
	var p = new(Tolerance_aspectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_tolerance_aspect
	return p
}

func (*Tolerance_aspectContext) IsTolerance_aspectContext() {}

func NewTolerance_aspectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tolerance_aspectContext {
	var p = new(Tolerance_aspectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_tolerance_aspect

	return p
}

func (s *Tolerance_aspectContext) GetParser() antlr.Parser { return s.parser }

func (s *Tolerance_aspectContext) TOLERANCE() antlr.TerminalNode {
	return s.GetToken(vhdlParserTOLERANCE, 0)
}

func (s *Tolerance_aspectContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Tolerance_aspectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tolerance_aspectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tolerance_aspectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterTolerance_aspect(s)
	}
}

func (s *Tolerance_aspectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitTolerance_aspect(s)
	}
}

func (s *Tolerance_aspectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitTolerance_aspect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Tolerance_aspect() (localctx ITolerance_aspectContext) {
	localctx = NewTolerance_aspectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, vhdlParserRULE_tolerance_aspect)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2494)
		p.Match(vhdlParserTOLERANCE)
	}
	{
		p.SetState(2495)
		p.Expression()
	}

	return localctx
}

// IType_declarationContext is an interface to support dynamic dispatch.
type IType_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_declarationContext differentiates from other interfaces.
	IsType_declarationContext()
}

type Type_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_declarationContext() *Type_declarationContext {
	var p = new(Type_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_type_declaration
	return p
}

func (*Type_declarationContext) IsType_declarationContext() {}

func NewType_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_declarationContext {
	var p = new(Type_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_type_declaration

	return p
}

func (s *Type_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_declarationContext) TYPE() antlr.TerminalNode {
	return s.GetToken(vhdlParserTYPE, 0)
}

func (s *Type_declarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Type_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Type_declarationContext) IS() antlr.TerminalNode {
	return s.GetToken(vhdlParserIS, 0)
}

func (s *Type_declarationContext) Type_definition() IType_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_definitionContext)
}

func (s *Type_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterType_declaration(s)
	}
}

func (s *Type_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitType_declaration(s)
	}
}

func (s *Type_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitType_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Type_declaration() (localctx IType_declarationContext) {
	localctx = NewType_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, vhdlParserRULE_type_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2497)
		p.Match(vhdlParserTYPE)
	}
	{
		p.SetState(2498)
		p.Identifier()
	}
	p.SetState(2501)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserIS {
		{
			p.SetState(2499)
			p.Match(vhdlParserIS)
		}
		{
			p.SetState(2500)
			p.Type_definition()
		}

	}
	{
		p.SetState(2503)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IType_definitionContext is an interface to support dynamic dispatch.
type IType_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_definitionContext differentiates from other interfaces.
	IsType_definitionContext()
}

type Type_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_definitionContext() *Type_definitionContext {
	var p = new(Type_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_type_definition
	return p
}

func (*Type_definitionContext) IsType_definitionContext() {}

func NewType_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_definitionContext {
	var p = new(Type_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_type_definition

	return p
}

func (s *Type_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_definitionContext) Scalar_type_definition() IScalar_type_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScalar_type_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScalar_type_definitionContext)
}

func (s *Type_definitionContext) Composite_type_definition() IComposite_type_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComposite_type_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComposite_type_definitionContext)
}

func (s *Type_definitionContext) Access_type_definition() IAccess_type_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccess_type_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccess_type_definitionContext)
}

func (s *Type_definitionContext) File_type_definition() IFile_type_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFile_type_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFile_type_definitionContext)
}

func (s *Type_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterType_definition(s)
	}
}

func (s *Type_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitType_definition(s)
	}
}

func (s *Type_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitType_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Type_definition() (localctx IType_definitionContext) {
	localctx = NewType_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, vhdlParserRULE_type_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2509)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserRANGE, vhdlParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2505)
			p.Scalar_type_definition()
		}

	case vhdlParserARRAY, vhdlParserRECORD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2506)
			p.Composite_type_definition()
		}

	case vhdlParserACCESS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2507)
			p.Access_type_definition()
		}

	case vhdlParserFILE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2508)
			p.File_type_definition()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnconstrained_array_definitionContext is an interface to support dynamic dispatch.
type IUnconstrained_array_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnconstrained_array_definitionContext differentiates from other interfaces.
	IsUnconstrained_array_definitionContext()
}

type Unconstrained_array_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnconstrained_array_definitionContext() *Unconstrained_array_definitionContext {
	var p = new(Unconstrained_array_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_unconstrained_array_definition
	return p
}

func (*Unconstrained_array_definitionContext) IsUnconstrained_array_definitionContext() {}

func NewUnconstrained_array_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unconstrained_array_definitionContext {
	var p = new(Unconstrained_array_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_unconstrained_array_definition

	return p
}

func (s *Unconstrained_array_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Unconstrained_array_definitionContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(vhdlParserARRAY, 0)
}

func (s *Unconstrained_array_definitionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Unconstrained_array_definitionContext) AllIndex_subtype_definition() []IIndex_subtype_definitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIndex_subtype_definitionContext)(nil)).Elem())
	var tst = make([]IIndex_subtype_definitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIndex_subtype_definitionContext)
		}
	}

	return tst
}

func (s *Unconstrained_array_definitionContext) Index_subtype_definition(i int) IIndex_subtype_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_subtype_definitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIndex_subtype_definitionContext)
}

func (s *Unconstrained_array_definitionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Unconstrained_array_definitionContext) OF() antlr.TerminalNode {
	return s.GetToken(vhdlParserOF, 0)
}

func (s *Unconstrained_array_definitionContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Unconstrained_array_definitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Unconstrained_array_definitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Unconstrained_array_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unconstrained_array_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unconstrained_array_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterUnconstrained_array_definition(s)
	}
}

func (s *Unconstrained_array_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitUnconstrained_array_definition(s)
	}
}

func (s *Unconstrained_array_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitUnconstrained_array_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Unconstrained_array_definition() (localctx IUnconstrained_array_definitionContext) {
	localctx = NewUnconstrained_array_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, vhdlParserRULE_unconstrained_array_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2511)
		p.Match(vhdlParserARRAY)
	}
	{
		p.SetState(2512)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(2513)
		p.Index_subtype_definition()
	}
	p.SetState(2518)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(2514)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(2515)
			p.Index_subtype_definition()
		}

		p.SetState(2520)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2521)
		p.Match(vhdlParserRPAREN)
	}
	{
		p.SetState(2522)
		p.Match(vhdlParserOF)
	}
	{
		p.SetState(2523)
		p.Subtype_indication()
	}

	return localctx
}

// IUnconstrained_nature_definitionContext is an interface to support dynamic dispatch.
type IUnconstrained_nature_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnconstrained_nature_definitionContext differentiates from other interfaces.
	IsUnconstrained_nature_definitionContext()
}

type Unconstrained_nature_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnconstrained_nature_definitionContext() *Unconstrained_nature_definitionContext {
	var p = new(Unconstrained_nature_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_unconstrained_nature_definition
	return p
}

func (*Unconstrained_nature_definitionContext) IsUnconstrained_nature_definitionContext() {}

func NewUnconstrained_nature_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unconstrained_nature_definitionContext {
	var p = new(Unconstrained_nature_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_unconstrained_nature_definition

	return p
}

func (s *Unconstrained_nature_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Unconstrained_nature_definitionContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(vhdlParserARRAY, 0)
}

func (s *Unconstrained_nature_definitionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserLPAREN, 0)
}

func (s *Unconstrained_nature_definitionContext) AllIndex_subtype_definition() []IIndex_subtype_definitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIndex_subtype_definitionContext)(nil)).Elem())
	var tst = make([]IIndex_subtype_definitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIndex_subtype_definitionContext)
		}
	}

	return tst
}

func (s *Unconstrained_nature_definitionContext) Index_subtype_definition(i int) IIndex_subtype_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_subtype_definitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIndex_subtype_definitionContext)
}

func (s *Unconstrained_nature_definitionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(vhdlParserRPAREN, 0)
}

func (s *Unconstrained_nature_definitionContext) OF() antlr.TerminalNode {
	return s.GetToken(vhdlParserOF, 0)
}

func (s *Unconstrained_nature_definitionContext) Subnature_indication() ISubnature_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubnature_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubnature_indicationContext)
}

func (s *Unconstrained_nature_definitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Unconstrained_nature_definitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Unconstrained_nature_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unconstrained_nature_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unconstrained_nature_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterUnconstrained_nature_definition(s)
	}
}

func (s *Unconstrained_nature_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitUnconstrained_nature_definition(s)
	}
}

func (s *Unconstrained_nature_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitUnconstrained_nature_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Unconstrained_nature_definition() (localctx IUnconstrained_nature_definitionContext) {
	localctx = NewUnconstrained_nature_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, vhdlParserRULE_unconstrained_nature_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2525)
		p.Match(vhdlParserARRAY)
	}
	{
		p.SetState(2526)
		p.Match(vhdlParserLPAREN)
	}
	{
		p.SetState(2527)
		p.Index_subtype_definition()
	}
	p.SetState(2532)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(2528)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(2529)
			p.Index_subtype_definition()
		}

		p.SetState(2534)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2535)
		p.Match(vhdlParserRPAREN)
	}
	{
		p.SetState(2536)
		p.Match(vhdlParserOF)
	}
	{
		p.SetState(2537)
		p.Subnature_indication()
	}

	return localctx
}

// IUse_clauseContext is an interface to support dynamic dispatch.
type IUse_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUse_clauseContext differentiates from other interfaces.
	IsUse_clauseContext()
}

type Use_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_clauseContext() *Use_clauseContext {
	var p = new(Use_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_use_clause
	return p
}

func (*Use_clauseContext) IsUse_clauseContext() {}

func NewUse_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_clauseContext {
	var p = new(Use_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_use_clause

	return p
}

func (s *Use_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_clauseContext) USE() antlr.TerminalNode {
	return s.GetToken(vhdlParserUSE, 0)
}

func (s *Use_clauseContext) AllSelected_name() []ISelected_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelected_nameContext)(nil)).Elem())
	var tst = make([]ISelected_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelected_nameContext)
		}
	}

	return tst
}

func (s *Use_clauseContext) Selected_name(i int) ISelected_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelected_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelected_nameContext)
}

func (s *Use_clauseContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Use_clauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *Use_clauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *Use_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Use_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterUse_clause(s)
	}
}

func (s *Use_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitUse_clause(s)
	}
}

func (s *Use_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitUse_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Use_clause() (localctx IUse_clauseContext) {
	localctx = NewUse_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, vhdlParserRULE_use_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2539)
		p.Match(vhdlParserUSE)
	}
	{
		p.SetState(2540)
		p.Selected_name()
	}
	p.SetState(2545)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == vhdlParserCOMMA {
		{
			p.SetState(2541)
			p.Match(vhdlParserCOMMA)
		}
		{
			p.SetState(2542)
			p.Selected_name()
		}

		p.SetState(2547)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2548)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IVariable_assignment_statementContext is an interface to support dynamic dispatch.
type IVariable_assignment_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_assignment_statementContext differentiates from other interfaces.
	IsVariable_assignment_statementContext()
}

type Variable_assignment_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_assignment_statementContext() *Variable_assignment_statementContext {
	var p = new(Variable_assignment_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_variable_assignment_statement
	return p
}

func (*Variable_assignment_statementContext) IsVariable_assignment_statementContext() {}

func NewVariable_assignment_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_assignment_statementContext {
	var p = new(Variable_assignment_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_variable_assignment_statement

	return p
}

func (s *Variable_assignment_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_assignment_statementContext) Target() ITargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetContext)
}

func (s *Variable_assignment_statementContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Variable_assignment_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_assignment_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Variable_assignment_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Variable_assignment_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_assignment_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_assignment_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterVariable_assignment_statement(s)
	}
}

func (s *Variable_assignment_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitVariable_assignment_statement(s)
	}
}

func (s *Variable_assignment_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitVariable_assignment_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Variable_assignment_statement() (localctx IVariable_assignment_statementContext) {
	localctx = NewVariable_assignment_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, vhdlParserRULE_variable_assignment_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2551)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 285, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2550)
			p.Label_colon()
		}

	}
	{
		p.SetState(2553)
		p.Target()
	}
	{
		p.SetState(2554)
		p.Match(vhdlParserVARASGN)
	}
	{
		p.SetState(2555)
		p.Expression()
	}
	{
		p.SetState(2556)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IVariable_declarationContext is an interface to support dynamic dispatch.
type IVariable_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_declarationContext differentiates from other interfaces.
	IsVariable_declarationContext()
}

type Variable_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_declarationContext() *Variable_declarationContext {
	var p = new(Variable_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_variable_declaration
	return p
}

func (*Variable_declarationContext) IsVariable_declarationContext() {}

func NewVariable_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_declarationContext {
	var p = new(Variable_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_variable_declaration

	return p
}

func (s *Variable_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_declarationContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARIABLE, 0)
}

func (s *Variable_declarationContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Variable_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(vhdlParserCOLON, 0)
}

func (s *Variable_declarationContext) Subtype_indication() ISubtype_indicationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtype_indicationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtype_indicationContext)
}

func (s *Variable_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Variable_declarationContext) SHARED() antlr.TerminalNode {
	return s.GetToken(vhdlParserSHARED, 0)
}

func (s *Variable_declarationContext) VARASGN() antlr.TerminalNode {
	return s.GetToken(vhdlParserVARASGN, 0)
}

func (s *Variable_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterVariable_declaration(s)
	}
}

func (s *Variable_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitVariable_declaration(s)
	}
}

func (s *Variable_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitVariable_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Variable_declaration() (localctx IVariable_declarationContext) {
	localctx = NewVariable_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, vhdlParserRULE_variable_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserSHARED {
		{
			p.SetState(2558)
			p.Match(vhdlParserSHARED)
		}

	}
	{
		p.SetState(2561)
		p.Match(vhdlParserVARIABLE)
	}
	{
		p.SetState(2562)
		p.Identifier_list()
	}
	{
		p.SetState(2563)
		p.Match(vhdlParserCOLON)
	}
	{
		p.SetState(2564)
		p.Subtype_indication()
	}
	p.SetState(2567)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserVARASGN {
		{
			p.SetState(2565)
			p.Match(vhdlParserVARASGN)
		}
		{
			p.SetState(2566)
			p.Expression()
		}

	}
	{
		p.SetState(2569)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IWait_statementContext is an interface to support dynamic dispatch.
type IWait_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWait_statementContext differentiates from other interfaces.
	IsWait_statementContext()
}

type Wait_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWait_statementContext() *Wait_statementContext {
	var p = new(Wait_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_wait_statement
	return p
}

func (*Wait_statementContext) IsWait_statementContext() {}

func NewWait_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Wait_statementContext {
	var p = new(Wait_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_wait_statement

	return p
}

func (s *Wait_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Wait_statementContext) WAIT() antlr.TerminalNode {
	return s.GetToken(vhdlParserWAIT, 0)
}

func (s *Wait_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(vhdlParserSEMI, 0)
}

func (s *Wait_statementContext) Label_colon() ILabel_colonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_colonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_colonContext)
}

func (s *Wait_statementContext) Sensitivity_clause() ISensitivity_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISensitivity_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISensitivity_clauseContext)
}

func (s *Wait_statementContext) Condition_clause() ICondition_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICondition_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICondition_clauseContext)
}

func (s *Wait_statementContext) Timeout_clause() ITimeout_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeout_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeout_clauseContext)
}

func (s *Wait_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Wait_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Wait_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterWait_statement(s)
	}
}

func (s *Wait_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitWait_statement(s)
	}
}

func (s *Wait_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitWait_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Wait_statement() (localctx IWait_statementContext) {
	localctx = NewWait_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, vhdlParserRULE_wait_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2572)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserBASIC_IDENTIFIER || _la == vhdlParserEXTENDED_IDENTIFIER {
		{
			p.SetState(2571)
			p.Label_colon()
		}

	}
	{
		p.SetState(2574)
		p.Match(vhdlParserWAIT)
	}
	p.SetState(2576)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserON {
		{
			p.SetState(2575)
			p.Sensitivity_clause()
		}

	}
	p.SetState(2579)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserUNTIL {
		{
			p.SetState(2578)
			p.Condition_clause()
		}

	}
	p.SetState(2582)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserFOR {
		{
			p.SetState(2581)
			p.Timeout_clause()
		}

	}
	{
		p.SetState(2584)
		p.Match(vhdlParserSEMI)
	}

	return localctx
}

// IWaveformContext is an interface to support dynamic dispatch.
type IWaveformContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWaveformContext differentiates from other interfaces.
	IsWaveformContext()
}

type WaveformContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWaveformContext() *WaveformContext {
	var p = new(WaveformContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_waveform
	return p
}

func (*WaveformContext) IsWaveformContext() {}

func NewWaveformContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WaveformContext {
	var p = new(WaveformContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_waveform

	return p
}

func (s *WaveformContext) GetParser() antlr.Parser { return s.parser }

func (s *WaveformContext) AllWaveform_element() []IWaveform_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWaveform_elementContext)(nil)).Elem())
	var tst = make([]IWaveform_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWaveform_elementContext)
		}
	}

	return tst
}

func (s *WaveformContext) Waveform_element(i int) IWaveform_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWaveform_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWaveform_elementContext)
}

func (s *WaveformContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(vhdlParserCOMMA)
}

func (s *WaveformContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(vhdlParserCOMMA, i)
}

func (s *WaveformContext) UNAFFECTED() antlr.TerminalNode {
	return s.GetToken(vhdlParserUNAFFECTED, 0)
}

func (s *WaveformContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WaveformContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WaveformContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterWaveform(s)
	}
}

func (s *WaveformContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitWaveform(s)
	}
}

func (s *WaveformContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitWaveform(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Waveform() (localctx IWaveformContext) {
	localctx = NewWaveformContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, vhdlParserRULE_waveform)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2595)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case vhdlParserABS, vhdlParserNEW, vhdlParserNOT, vhdlParserNULL, vhdlParserBASE_LITERAL, vhdlParserBIT_STRING_LITERAL, vhdlParserREAL_LITERAL, vhdlParserBASIC_IDENTIFIER, vhdlParserEXTENDED_IDENTIFIER, vhdlParserCHARACTER_LITERAL, vhdlParserSTRING_LITERAL, vhdlParserLPAREN, vhdlParserPLUS, vhdlParserMINUS, vhdlParserINTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2586)
			p.Waveform_element()
		}
		p.SetState(2591)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == vhdlParserCOMMA {
			{
				p.SetState(2587)
				p.Match(vhdlParserCOMMA)
			}
			{
				p.SetState(2588)
				p.Waveform_element()
			}

			p.SetState(2593)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case vhdlParserUNAFFECTED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2594)
			p.Match(vhdlParserUNAFFECTED)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWaveform_elementContext is an interface to support dynamic dispatch.
type IWaveform_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWaveform_elementContext differentiates from other interfaces.
	IsWaveform_elementContext()
}

type Waveform_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWaveform_elementContext() *Waveform_elementContext {
	var p = new(Waveform_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = vhdlParserRULE_waveform_element
	return p
}

func (*Waveform_elementContext) IsWaveform_elementContext() {}

func NewWaveform_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Waveform_elementContext {
	var p = new(Waveform_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = vhdlParserRULE_waveform_element

	return p
}

func (s *Waveform_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Waveform_elementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Waveform_elementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Waveform_elementContext) AFTER() antlr.TerminalNode {
	return s.GetToken(vhdlParserAFTER, 0)
}

func (s *Waveform_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Waveform_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Waveform_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.EnterWaveform_element(s)
	}
}

func (s *Waveform_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(vhdlListener); ok {
		listenerT.ExitWaveform_element(s)
	}
}

func (s *Waveform_elementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case vhdlVisitor:
		return t.VisitWaveform_element(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *vhdlParser) Waveform_element() (localctx IWaveform_elementContext) {
	localctx = NewWaveform_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, vhdlParserRULE_waveform_element)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2597)
		p.Expression()
	}
	p.SetState(2600)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == vhdlParserAFTER {
		{
			p.SetState(2598)
			p.Match(vhdlParserAFTER)
		}
		{
			p.SetState(2599)
			p.Expression()
		}

	}

	return localctx
}
